contract main {




// =====================  Runtime code  =====================


#
#  - claimRewardsForPools(address[] arg1)
#  - withdraw(address arg1, uint256 arg2)
#
address owner;
uint256 stor1;
uint8 paused;
array of struct stor3;
array of struct stor4;
array of struct stor5;
mapping of struct stor7;
mapping of uint8 stor8;

function paused() payable {
    return bool(paused)
}

function owner() payable {
    return owner
}

function _fallback() payable {
    revert
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function getPoolList() payable {
    if stor4.length:
        mem[128] = address(stor4.field_0)
        if (32 * stor4.length) + 32 > 64:
            mem[160] = address(stor4.field_256)
            idx = 160
            s = 1
            while (32 * stor4.length) + 96 > idx:
                mem[idx + 32] = address(stor4[s].field_256)
                idx = idx + 32
                s = s + 1
                continue 
    mem[(32 * stor4.length) + 128] = 32
    mem[(32 * stor4.length) + 160] = stor4.length
    idx = 0
    s = (32 * stor4.length) + 192
    t = 128
    while idx < stor4.length:
        mem[s] = mem[t + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    return memory
      from (32 * stor4.length) + 128
       len (96 * stor4.length) + 64
}

function setPaused(bool arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor3.length:
        mem[128] = address(stor3.field_0)
        idx = 128
        s = 0
        while (32 * stor3.length) + 96 > idx:
            mem[idx + 32] = address(stor3[s].field_256)
            idx = idx + 32
            s = s + 1
            continue 
    if owner != msg.sender:
        idx = 0
        while idx < stor3.length:
            if idx >= stor3.length:
                revert with 0, 50
            if mem[(32 * idx) + 140 len 20] != msg.sender:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            paused = uint8(arg1)
        revert with 0, 'BonusRewards: caller not responder'
    paused = uint8(arg1)
}

function sub_664c0bf9(?) payable {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor3.length = ('cd', 4).length
    if not ('cd', 4).length:
        idx = 0
        while stor3.length > idx:
            uint256(stor3[idx].field_0) = 0
            idx = idx + 1
            continue 
    else:
        s = 0
        idx = cd[4] + 36
        while cd[4] + (32 * ('cd', 4).length) + 36 > idx:
            address(stor3[s].field_0) = address(cd[idx])
            s = s + 1
            idx = idx + 32
            continue 
        idx = Mask(251, 0, (32 * ('cd', 4).length) + 31) >> 5
        while stor3.length > idx:
            uint256(stor3[idx].field_0) = 0
            idx = idx + 1
            continue 
}

function getResponders() payable {
    mem[64] = (32 * stor3.length) + 128
    mem[96] = stor3.length
    if not stor3.length:
        mem[(32 * stor3.length) + 128] = 32
        mem[(32 * stor3.length) + 160] = stor3.length
        idx = 0
        s = (32 * stor3.length) + 192
        t = 128
        while idx < stor3.length:
            mem[s] = mem[t + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        return memory
          from (32 * stor3.length) + 128
           len (96 * stor3.length) + 64
    mem[128] = address(stor3.field_0)
    idx = 128
    s = 0
    while (32 * stor3.length) + 96 > idx:
        mem[idx + 32] = address(stor3[s].field_256)
        idx = idx + 32
        s = s + 1
        continue 
    mem[(32 * stor3.length) + 128] = 32
    mem[(32 * stor3.length) + 160] = stor3.length
    idx = 0
    s = mem[64] + 64
    t = 128
    while idx < stor3.length:
        mem[s] = mem[t + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    return memory
      from mem[64]
       len (64 * stor3.length) + -mem[64] + 192
}

function getPool(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[96] = 96
    mem[128] = 0
    mem[0] = arg1
    mem[32] = 5
    mem[64] = (32 * uint256(stor5[address(arg1)].field_0)) + 256
    mem[224] = uint256(stor5[address(arg1)].field_0)
    s = 256
    idx = 0
    while idx < uint256(stor5[address(arg1)].field_0):
        mem[0] = sha3(address(arg1), 5)
        _19 = mem[64]
        mem[64] = mem[64] + 192
        mem[_19] = address(stor5[address(arg1)][idx].field_0)
        mem[_19 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
        mem[_19 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
        mem[_19 + 96] = uint256(stor5[address(arg1)][idx].field_256)
        mem[_19 + 128] = uint256(stor5[address(arg1)][idx].field_512)
        mem[_19 + 160] = uint256(stor5[address(arg1)][idx].field_768)
        mem[s] = _19
        s = s + 32
        idx = idx + 1
        continue 
    mem[160] = 224
    mem[192] = uint256(stor5[address(arg1)].field_256)
    _20 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = 64
    _22 = mem[224]
    mem[mem[64] + 96] = mem[224]
    idx = 0
    s = mem[64] + 128
    t = 256
    while idx < _22:
        _33 = mem[t]
        mem[s] = mem[mem[t] + 12 len 20]
        mem[s + 32] = mem[_33 + 58 len 6]
        mem[s + 64] = mem[_33 + 90 len 6]
        mem[s + 96] = mem[_33 + 96]
        mem[s + 128] = mem[_33 + 128]
        mem[s + 160] = mem[_33 + 160]
        idx = idx + 1
        s = s + 192
        t = t + 32
        continue 
    mem[_20 + 64] = mem[192]
    return memory
      from mem[64]
       len _20 + (192 * _22) + -mem[64] + 128
}

function getAuthorizers(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    mem[64] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 128
    mem[96] = uint256(stor7[address(arg1)][address(arg2)].field_0)
    if not uint256(stor7[address(arg1)][address(arg2)].field_0):
        mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 128] = 32
        mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 160] = uint256(stor7[address(arg1)][address(arg2)].field_0)
        idx = 0
        s = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192
        t = 128
        while idx < uint256(stor7[address(arg1)][address(arg2)].field_0):
            mem[s] = mem[t + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        return memory
          from (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 128
           len (96 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 64
    mem[128] = address(stor7[address(arg1)][address(arg2)].field_0)
    idx = 128
    s = 0
    while (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 96 > idx:
        mem[idx + 32] = address(stor7[address(arg1)][address(arg2)][s].field_256)
        idx = idx + 32
        s = s + 1
        continue 
    mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 128] = 32
    mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 160] = uint256(stor7[address(arg1)][address(arg2)].field_0)
    idx = 0
    s = mem[64] + 64
    t = 128
    while idx < uint256(stor7[address(arg1)][address(arg2)].field_0):
        mem[s] = mem[t + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    return memory
      from mem[64]
       len (64 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + -mem[64] + 192
}

function collectDust(address arg1, address arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if uint256(stor5[address(arg1)].field_256):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BonusRewards: lpToken, not allowed'
    if not arg1:
        call owner with:
           value eth.balance(this.address) wei
             gas 2300 * is_zero(value) wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
    else:
        require ext_code.size(arg1)
        staticcall arg1.balanceOf(address rg1) with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if stor8[address(arg1)] != 1:
            require ext_code.size(arg1)
            call arg1.transfer(address rg1, uint256 rg2) with:
                 gas gas_remaining wei
                args owner, ext_call.return_data[0]
        else:
            if arg3 >= uint256(stor5[address(arg2)].field_0):
                revert with 0, 50
            if arg1 != address(stor5[address(arg2)][arg3].field_0):
                revert with 0, 'BonusRewards: wrong pool'
            if stor5[address(arg2)][arg3].field_208 % 281474976710656 > -604801:
                revert with 0, 17
            if stor5[address(arg2)][arg3].field_208 % 281474976710656 + (168 * 24 * 3600) >= block.timestamp:
                revert with 0, 'BonusRewards: not ready'
            if arg3 >= uint256(stor5[address(arg2)].field_0):
                revert with 0, 50
            uint256(stor5[address(arg2)][arg3].field_768) = 0
            require ext_code.size(arg1)
            call arg1.transfer(address rg1, uint256 rg2) with:
                 gas gas_remaining wei
                args owner, uint256(stor5[address(arg2)][arg3].field_768)
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
}

function sub_8c880e02(?) payable {
    mem[64] = 96
    require calldata.size - 4 >= 96
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    require ('cd', 36).length <= test266151307()
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    require ('cd', 68).length <= test266151307()
    require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if paused:
        revert with 0, 'BonusRewards: paused'
    idx = 0
    while idx < ('cd', 4).length:
        require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
        require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
        staticcall address(cd[((32 * idx) + cd[4] + 36)]).decimals() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _31 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_31] == mem[_31 + 31 len 1]
        if mem[_31 + 31 len 1] > 18:
            revert with 0, 'BonusRewards: lptoken decimals > 18'
        mem[0] = address(cd[((32 * idx) + cd[4] + 36)])
        mem[32] = 5
        if not uint256(stor5[address(cd[((32 * idx) + cd[4] + 36)])].field_256):
            mem[32] = 5
            uint256(stor5[address(cd[((32 * idx) + cd[4] + 36)])].field_256) = block.timestamp
            stor4.length++
            mem[0] = 4
            address(stor4[stor4.length].field_0) = address(cd[((32 * idx) + cd[4] + 36)])
        s = 0
        while s < ('cd', 36).length:
            require cd[((32 * s) + cd[36] + 36)] == address(cd[((32 * s) + cd[36] + 36)])
            if uint256(stor5[address(cd[((32 * s) + cd[36] + 36)])].field_256):
                revert with 0, 'BonusRewards: lpToken, not allowed'
            uint256(stor7[address(cd[((32 * idx) + cd[4] + 36)])][address(cd[((32 * s) + cd[36] + 36)])].field_0) = ('cd', 68).length
            if not ('cd', 68).length:
                t = sha3(sha3(address(cd[((32 * s) + cd[36] + 36)]), sha3(address(cd[((32 * idx) + cd[4] + 36)]), 7)))
                while sha3(sha3(address(cd[((32 * s) + cd[36] + 36)]), sha3(address(cd[((32 * idx) + cd[4] + 36)]), 7))) + uint256(stor7[address(cd[((32 * idx) + cd[4] + 36)])][address(cd[((32 * s) + cd[36] + 36)])].field_0) > t:
                    uint256(stor[t]) = 0
                    t = t + 1
                    continue 
            else:
                u = sha3(sha3(address(cd[((32 * s) + cd[36] + 36)]), sha3(address(cd[((32 * idx) + cd[4] + 36)]), 7)))
                t = cd[68] + 36
                while cd[68] + (32 * ('cd', 68).length) + 36 > t:
                    address(stor[u]) = address(cd[t])
                    u = u + 1
                    t = t + 32
                    continue 
                t = sha3(sha3(address(cd[((32 * s) + cd[36] + 36)]), sha3(address(cd[((32 * idx) + cd[4] + 36)]), 7))) + (Mask(251, 0, (32 * ('cd', 68).length) + 31) >> 5)
                while sha3(sha3(address(cd[((32 * s) + cd[36] + 36)]), sha3(address(cd[((32 * idx) + cd[4] + 36)]), 7))) + uint256(stor7[address(cd[((32 * idx) + cd[4] + 36)])][address(cd[((32 * s) + cd[36] + 36)])].field_0) > t:
                    uint256(stor[t]) = 0
                    t = t + 1
                    continue 
            mem[0] = address(cd[((32 * s) + cd[36] + 36)])
            mem[32] = 8
            stor8[address(cd[((32 * s) + cd[36] + 36)])] = 1
            if s == -1:
                revert with 0, 17
            s = s + 1
            continue 
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function sub_01c1dfba(?) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    if stor1 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor1 = 2
    idx = 0
    while idx < ('cd', 4).length:
        require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
        mem[0] = msg.sender
        mem[32] = sha3(address(cd[((32 * idx) + cd[4] + 36)]), 6)
        uint256(stor6[address(cd[((32 * idx) + cd[4] + 36)])][msg.sender].field_0) = 0
        if idx >= ('cd', 4).length:
            revert with 0, 50
        require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
        staticcall address(cd[((32 * idx) + cd[4] + 36)]).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _173 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _174 = mem[_173]
        if mem[_173] > uint256(stor6[address(cd[((32 * idx) + cd[4] + 36)])][msg.sender].field_0):
            _175 = mem[64]
            mem[mem[64] + 36] = msg.sender
            mem[mem[64] + 68] = uint256(stor6[address(cd[((32 * idx) + cd[4] + 36)])][msg.sender].field_0)
            _177 = mem[64]
            mem[mem[64]] = 68
            mem[64] = mem[64] + 100
            mem[_177 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_177 + 36 len 28]
            mem[64] = _175 + 164
            mem[_175 + 100] = 32
            mem[_175 + 132] = 'SafeERC20: low-level call failed'
            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(cd[((32 * idx) + cd[4] + 36)])):
                revert with 0, 'Address: call to non-contract'
            if not ext_code.hash(address(cd[((32 * idx) + cd[4] + 36)])):
                revert with 0, 'Address: call to non-contract'
            _191 = mem[_177]
            s = 0
            while s < _191:
                mem[s + _175 + 164] = mem[s + _177 + 32]
                s = s + 32
                continue 
            if ceil32(_191) > _191:
                mem[_191 + _175 + 164] = 0
            call address(cd[((32 * idx) + cd[4] + 36)]).mem[_175 + 164 len 4] with:
                 gas gas_remaining wei
                args mem[_175 + 168 len _191 - 4]
            if not return_data.size:
                if not ext_call.success:
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    mem[_175 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_175 + 168] = 32
                    idx = 0
                    while idx < 32:
                        mem[idx + _175 + 232] = mem[idx + _175 + 132]
                        idx = idx + 32
                        continue 
                    revert with 0, 32, 32, mem[_175 + 232]
                if mem[96]:
                    require mem[96] >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if idx >= ('cd', 4).length:
                    revert with 0, 50
                require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
                mem[_175 + 164] = uint256(stor6[address(cd[((32 * idx) + cd[4] + 36)])][msg.sender].field_0)
            else:
                mem[64] = _175 + ceil32(return_data.size) + 165
                mem[_175 + 164] = return_data.size
                mem[_175 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_175 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_175 + ceil32(return_data.size) + 169] = 32
                    idx = 0
                    while idx < 32:
                        mem[idx + _175 + ceil32(return_data.size) + 233] = mem[idx + _175 + 132]
                        idx = idx + 32
                        continue 
                    revert with 0, 32, 32, mem[_175 + ceil32(return_data.size) + 233]
                if return_data.size:
                    require return_data.size >= 32
                    require mem[_175 + 196] == bool(mem[_175 + 196])
                    if not mem[_175 + 196]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if idx >= ('cd', 4).length:
                    revert with 0, 50
                require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
                mem[_175 + ceil32(return_data.size) + 165] = uint256(stor6[address(cd[((32 * idx) + cd[4] + 36)])][msg.sender].field_0)
        else:
            if not mem[_173]:
                if idx >= ('cd', 4).length:
                    revert with 0, 50
                require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
                mem[mem[64]] = uint256(stor6[address(cd[((32 * idx) + cd[4] + 36)])][msg.sender].field_0)
            else:
                _176 = mem[64]
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = _174
                _179 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_179 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_179 + 36 len 28]
                mem[64] = _176 + 164
                mem[_176 + 100] = 32
                mem[_176 + 132] = 'SafeERC20: low-level call failed'
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(cd[((32 * idx) + cd[4] + 36)])):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(address(cd[((32 * idx) + cd[4] + 36)])):
                    revert with 0, 'Address: call to non-contract'
                _192 = mem[_179]
                s = 0
                while s < _192:
                    mem[s + _176 + 164] = mem[s + _179 + 32]
                    s = s + 32
                    continue 
                if ceil32(_192) > _192:
                    mem[_192 + _176 + 164] = 0
                call address(cd[((32 * idx) + cd[4] + 36)]).mem[_176 + 164 len 4] with:
                     gas gas_remaining wei
                    args mem[_176 + 168 len _192 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        mem[_176 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_176 + 168] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + _176 + 232] = mem[idx + _176 + 132]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_176 + 232]
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if idx >= ('cd', 4).length:
                        revert with 0, 50
                    require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
                    mem[_176 + 164] = uint256(stor6[address(cd[((32 * idx) + cd[4] + 36)])][msg.sender].field_0)
                else:
                    mem[64] = _176 + ceil32(return_data.size) + 165
                    mem[_176 + 164] = return_data.size
                    mem[_176 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_176 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_176 + ceil32(return_data.size) + 169] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + _176 + ceil32(return_data.size) + 233] = mem[idx + _176 + 132]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_176 + ceil32(return_data.size) + 233]
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_176 + 196] == bool(mem[_176 + 196])
                        if not mem[_176 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if idx >= ('cd', 4).length:
                        revert with 0, 50
                    require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
                    mem[_176 + ceil32(return_data.size) + 165] = uint256(stor6[address(cd[((32 * idx) + cd[4] + 36)])][msg.sender].field_0)
        emit Withdraw(uint256(stor6[address(cd[((32 * idx) + cd[4] + 36)])][msg.sender].field_0), msg.sender, address(cd[((32 * idx) + cd[4] + 36)]));
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    stor1 = 1
}

function extendBonus(address arg1, uint256 arg2, address arg3, uint256 arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg3 == arg3
    if stor1 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor1 = 2
    if paused:
        revert with 0, 'BonusRewards: paused'
    if not uint256(stor7[address(arg1)][address(arg3)].field_0):
        if owner != msg.sender:
            idx = 0
            while idx < uint256(stor7[address(arg1)][address(arg3)].field_0):
                if idx >= uint256(stor7[address(arg1)][address(arg3)].field_0):
                    revert with 0, 50
                if mem[(32 * idx) + 140 len 20] != msg.sender:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if arg2 >= uint256(stor5[address(arg1)].field_0):
                    revert with 0, 50
                mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + 128] = address(stor5[address(arg1)][arg2].field_0)
                if arg3 != address(stor5[address(arg1)][arg2].field_0):
                    revert with 0, 'BonusRewards: bonus and id dont match'
                if stor5[address(arg1)][arg2].field_208 % 281474976710656 <= block.timestamp:
                    revert with 0, 'BonusRewards: bonus program ended, please start a new one'
                require ext_code.size(arg3)
                staticcall arg3.balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 356] = msg.sender
                mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 388] = this.address
                mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 420] = arg4
                mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 352] = 0x23b872dd00000000000000000000000000000000000000000000000000000000 or Mask(224, 32, msg.sender) >> 32
                mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 452] = 32
                mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 484] = 'SafeERC20: low-level call failed'
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg3):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(arg3):
                    revert with 0, 'Address: call to non-contract'
                idx = 0
                while idx < 100:
                    mem[idx + (32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 516] = mem[idx + (32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 352]
                    idx = idx + 32
                    continue 
                mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 616] = 0
                call arg3.mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 516 len 4] with:
                     gas gas_remaining wei
                    args mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 520 len 96]
                if not return_data.size:
                    if not ext_call.success:
                        if uint256(stor7[address(arg1)][address(arg3)].field_0):
                            revert with memory
                              from 128
                               len uint256(stor7[address(arg1)][address(arg3)].field_0)
                        mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 516] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 520] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + (32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 584] = mem[idx + (32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 484]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 584]
                    if uint256(stor7[address(arg1)][address(arg3)].field_0):
                        require uint256(stor7[address(arg1)][address(arg3)].field_0) >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 516] = return_data.size
                    mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + ceil32(return_data.size) + 521] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + (32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + ceil32(return_data.size) + 585] = mem[idx + (32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 484]
                            idx = idx + 32
                            continue 
                        revert with 0, 
                                    32,
                                    32,
                                    mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + ceil32(return_data.size) + 585]
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 548] == bool(mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 548])
                        if not mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 548]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                require ext_code.size(arg3)
                staticcall arg3.balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 17
                if not uint256(stor5[address(arg1)][arg2].field_256):
                    revert with 0, 18
                if 0 / uint256(stor5[address(arg1)][arg2].field_256) > !stor5[address(arg1)][arg2].field_0 % 281474976710656:
                    revert with 0, 17
                if arg2 >= uint256(stor5[address(arg1)].field_0):
                    revert with 0, 50
                stor5[address(arg1)][arg2].field_208 % 281474976710656 = (0 / uint256(stor5[address(arg1)][arg2].field_256)) + stor5[address(arg1)][arg2].field_0 % 281474976710656 % 281474976710656
                if uint256(stor5[address(arg1)][arg2].field_768) > !0:
                    revert with 0, 17
                if arg2 >= uint256(stor5[address(arg1)].field_0):
                    revert with 0, 50
                uint256(stor5[address(arg1)][arg2].field_768) = uint256(stor5[address(arg1)][arg2].field_768)
                stor1 = 1
            revert with 0, 'BonusRewards: not authorized caller'
        if arg2 >= uint256(stor5[address(arg1)].field_0):
            revert with 0, 50
        mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + 128] = address(stor5[address(arg1)][arg2].field_0)
        if arg3 != address(stor5[address(arg1)][arg2].field_0):
            revert with 0, 'BonusRewards: bonus and id dont match'
        if stor5[address(arg1)][arg2].field_208 % 281474976710656 <= block.timestamp:
            revert with 0, 'BonusRewards: bonus program ended, please start a new one'
        require ext_code.size(arg3)
        staticcall arg3.balanceOf(address rg1) with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg3):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(arg3):
            revert with 0, 'Address: call to non-contract'
        mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 516 len 128] = transferFrom(address rg1, address rg2, uint256 rg3), msg.sender, address(this.address), arg4, 0
        call arg3 with:
           funct Mask(32, 224, transferFrom(address rg1, address rg2, uint256 rg3), msg.sender, address(this.address), arg4, 0) >> 224
             gas gas_remaining wei
            args (Mask(768, -544, transferFrom(address rg1, address rg2, uint256 rg3), msg.sender, address(this.address), arg4, 0) << 544)
        if not return_data.size:
            if not ext_call.success:
                if uint256(stor7[address(arg1)][address(arg3)].field_0):
                    revert with memory
                      from 128
                       len uint256(stor7[address(arg1)][address(arg3)].field_0)
                revert with 0, 'SafeERC20: low-level call failed'
            if uint256(stor7[address(arg1)][address(arg3)].field_0):
                require uint256(stor7[address(arg1)][address(arg3)].field_0) >= 32
                require mem[128] == bool(mem[128])
                if not mem[128]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        else:
            mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                require mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 548] == bool(mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 548])
                if not mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 548]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    else:
        mem[128] = address(stor7[address(arg1)][address(arg3)].field_0)
        if (32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + 32 > 64:
            mem[160] = address(stor7[address(arg1)][address(arg3)].field_256)
            idx = 160
            s = 1
            while (32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + 96 > idx:
                mem[idx + 32] = address(stor7[address(arg1)][address(arg3)][s].field_256)
                idx = idx + 32
                s = s + 1
                continue 
        if owner != msg.sender:
            idx = 0
            while idx < uint256(stor7[address(arg1)][address(arg3)].field_0):
                if idx >= uint256(stor7[address(arg1)][address(arg3)].field_0):
                    revert with 0, 50
                if mem[(32 * idx) + 140 len 20] != msg.sender:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if arg2 >= uint256(stor5[address(arg1)].field_0):
                    revert with 0, 50
                if arg3 != address(stor5[address(arg1)][arg2].field_0):
                    revert with 0, 'BonusRewards: bonus and id dont match'
                if stor5[address(arg1)][arg2].field_208 % 281474976710656 <= block.timestamp:
                    revert with 0, 'BonusRewards: bonus program ended, please start a new one'
                require ext_code.size(arg3)
                staticcall arg3.balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 356] = msg.sender
                mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 388] = this.address
                mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 420] = arg4
                mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 352] = 0x23b872dd00000000000000000000000000000000000000000000000000000000 or Mask(224, 32, msg.sender) >> 32
                mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 452] = 32
                mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 484] = 'SafeERC20: low-level call failed'
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg3):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(arg3):
                    revert with 0, 'Address: call to non-contract'
                idx = 0
                while idx < 100:
                    mem[idx + (32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 516] = mem[idx + (32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 352]
                    idx = idx + 32
                    continue 
                mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 616] = 0
                call arg3.mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 516 len 4] with:
                     gas gas_remaining wei
                    args mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 520 len 96]
                if not return_data.size:
                    if not ext_call.success:
                        if uint256(stor7[address(arg1)][address(arg3)].field_0):
                            revert with memory
                              from 128
                               len uint256(stor7[address(arg1)][address(arg3)].field_0)
                        mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 516] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 520] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + (32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 584] = mem[idx + (32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 484]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 584]
                    if uint256(stor7[address(arg1)][address(arg3)].field_0):
                        require uint256(stor7[address(arg1)][address(arg3)].field_0) >= 32
                        require address(stor7[address(arg1)][address(arg3)].field_0) == bool(address(stor7[address(arg1)][address(arg3)].field_0))
                        if not address(stor7[address(arg1)][address(arg3)].field_0):
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 516] = return_data.size
                    mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + ceil32(return_data.size) + 517] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + ceil32(return_data.size) + 521] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + (32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + ceil32(return_data.size) + 585] = mem[idx + (32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 484]
                            idx = idx + 32
                            continue 
                        revert with 0, 
                                    32,
                                    32,
                                    mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + ceil32(return_data.size) + 585]
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 548] == bool(mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 548])
                        if not mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 548]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                require ext_code.size(arg3)
                staticcall arg3.balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 17
                if not uint256(stor5[address(arg1)][arg2].field_256):
                    revert with 0, 18
                if 0 / uint256(stor5[address(arg1)][arg2].field_256) > !stor5[address(arg1)][arg2].field_0 % 281474976710656:
                    revert with 0, 17
                if arg2 >= uint256(stor5[address(arg1)].field_0):
                    revert with 0, 50
                stor5[address(arg1)][arg2].field_208 % 281474976710656 = (0 / uint256(stor5[address(arg1)][arg2].field_256)) + stor5[address(arg1)][arg2].field_0 % 281474976710656 % 281474976710656
                if uint256(stor5[address(arg1)][arg2].field_768) > !0:
                    revert with 0, 17
                if arg2 >= uint256(stor5[address(arg1)].field_0):
                    revert with 0, 50
                uint256(stor5[address(arg1)][arg2].field_768) = uint256(stor5[address(arg1)][arg2].field_768)
                stor1 = 1
            revert with 0, 'BonusRewards: not authorized caller'
        if arg2 >= uint256(stor5[address(arg1)].field_0):
            revert with 0, 50
        if arg3 != address(stor5[address(arg1)][arg2].field_0):
            revert with 0, 'BonusRewards: bonus and id dont match'
        if stor5[address(arg1)][arg2].field_208 % 281474976710656 <= block.timestamp:
            revert with 0, 'BonusRewards: bonus program ended, please start a new one'
        require ext_code.size(arg3)
        staticcall arg3.balanceOf(address rg1) with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg3):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(arg3):
            revert with 0, 'Address: call to non-contract'
        mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 516 len 128] = transferFrom(address rg1, address rg2, uint256 rg3), msg.sender, address(this.address), arg4, 0
        call arg3 with:
           funct Mask(32, 224, transferFrom(address rg1, address rg2, uint256 rg3), msg.sender, address(this.address), arg4, 0) >> 224
             gas gas_remaining wei
            args (Mask(768, -544, transferFrom(address rg1, address rg2, uint256 rg3), msg.sender, address(this.address), arg4, 0) << 544)
        if not return_data.size:
            if not ext_call.success:
                if uint256(stor7[address(arg1)][address(arg3)].field_0):
                    revert with memory
                      from 128
                       len uint256(stor7[address(arg1)][address(arg3)].field_0)
                revert with 0, 'SafeERC20: low-level call failed'
            if uint256(stor7[address(arg1)][address(arg3)].field_0):
                require uint256(stor7[address(arg1)][address(arg3)].field_0) >= 32
                require address(stor7[address(arg1)][address(arg3)].field_0) == bool(address(stor7[address(arg1)][address(arg3)].field_0))
                if not address(stor7[address(arg1)][address(arg3)].field_0):
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        else:
            mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                require mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 548] == bool(mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 548])
                if not mem[(32 * uint256(stor7[address(arg1)][address(arg3)].field_0)) + ceil32(return_data.size) + 548]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    require ext_code.size(arg3)
    staticcall arg3.balanceOf(address rg1) with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] < ext_call.return_data[0]:
        revert with 0, 17
    if not uint256(stor5[address(arg1)][arg2].field_256):
        revert with 0, 18
    if 0 / uint256(stor5[address(arg1)][arg2].field_256) > !stor5[address(arg1)][arg2].field_0 % 281474976710656:
        revert with 0, 17
    if arg2 >= uint256(stor5[address(arg1)].field_0):
        revert with 0, 50
    stor5[address(arg1)][arg2].field_208 % 281474976710656 = (0 / uint256(stor5[address(arg1)][arg2].field_256)) + stor5[address(arg1)][arg2].field_0 % 281474976710656 % 281474976710656
    if uint256(stor5[address(arg1)][arg2].field_768) > !0:
        revert with 0, 17
    if arg2 >= uint256(stor5[address(arg1)].field_0):
        revert with 0, 50
    uint256(stor5[address(arg1)][arg2].field_768) = uint256(stor5[address(arg1)][arg2].field_768)
    stor1 = 1
}

function addBonus(address arg1, address arg2, uint48 arg3, uint256 arg4, uint256 arg5) payable {
    require calldata.size - 4 >= 160
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3 % 281474976710656
    if stor1 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor1 = 2
    if paused:
        revert with 0, 'BonusRewards: paused'
    mem[0] = arg2
    mem[32] = sha3(address(arg1), 7)
    mem[64] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 128
    mem[96] = uint256(stor7[address(arg1)][address(arg2)].field_0)
    if not uint256(stor7[address(arg1)][address(arg2)].field_0):
        if owner != msg.sender:
            idx = 0
            while idx < uint256(stor7[address(arg1)][address(arg2)].field_0):
                if idx >= uint256(stor7[address(arg1)][address(arg2)].field_0):
                    revert with 0, 50
                if mem[(32 * idx) + 140 len 20] != msg.sender:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if arg3 % 281474976710656 < block.timestamp:
                    revert with 0, 'BonusRewards: startTime in the past'
                mem[0] = arg1
                mem[32] = 5
                mem[64] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + (32 * uint256(stor5[address(arg1)].field_0)) + 224
                mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192] = uint256(stor5[address(arg1)].field_0)
                s = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224
                idx = 0
                while idx < uint256(stor5[address(arg1)].field_0):
                    mem[0] = sha3(address(arg1), 5)
                    _1585 = mem[64]
                    mem[64] = mem[64] + 192
                    mem[_1585] = address(stor5[address(arg1)][idx].field_0)
                    mem[_1585 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                    mem[_1585 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                    mem[_1585 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                    mem[_1585 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                    mem[_1585 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                    mem[s] = _1585
                    s = s + 32
                    idx = idx + 1
                    continue 
                mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 128] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192
                mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 160] = uint256(stor5[address(arg1)].field_256)
                if uint256(stor5[address(arg1)].field_256) <= 0:
                    revert with 0, 'BonusRewards: pool does not exist'
                idx = 0
                while idx < mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                    if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                        revert with 0, 50
                    if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 12 len 20] == arg2:
                        if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                            revert with 0, 50
                        if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 90 len 6] > -604801:
                            revert with 0, 17
                        if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 90 len 6] + (168 * 24 * 3600) >= block.timestamp:
                            revert with 0, 'BonusRewards: last bonus period hasn't ended'
                        if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                            revert with 0, 50
                        if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 160] != 0:
                            revert with 0, 'BonusRewards: last bonus not all claimed'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(arg2)
                staticcall arg2.balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2765 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2776 = mem[_2765]
                _2812 = mem[64]
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = this.address
                mem[mem[64] + 100] = arg5
                _2845 = mem[64]
                mem[mem[64]] = 100
                mem[64] = mem[64] + 132
                mem[_2845 + 32] = 0x23b872dd00000000000000000000000000000000000000000000000000000000 or mem[_2845 + 36 len 28]
                mem[64] = _2812 + 196
                mem[_2812 + 132] = 32
                mem[_2812 + 164] = 'SafeERC20: low-level call failed'
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg2):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(arg2):
                    revert with 0, 'Address: call to non-contract'
                _2954 = mem[_2845]
                idx = 0
                while idx < _2954:
                    mem[idx + _2812 + 196] = mem[idx + _2845 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_2954) > _2954:
                    mem[_2954 + _2812 + 196] = 0
                call arg2.mem[_2812 + 196 len 4] with:
                     gas gas_remaining wei
                    args mem[_2812 + 200 len _2954 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        mem[_2812 + 196] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_2812 + 200] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + _2812 + 264] = mem[idx + _2812 + 164]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_2812 + 264]
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[_2812 + 196] = return_data.size
                    mem[_2812 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2812 + ceil32(return_data.size) + 197] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_2812 + ceil32(return_data.size) + 201] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + _2812 + ceil32(return_data.size) + 265] = mem[idx + _2812 + 164]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_2812 + ceil32(return_data.size) + 265]
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_2812 + 228] == bool(mem[_2812 + 228])
                        if not mem[_2812 + 228]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                require ext_code.size(arg2)
                staticcall arg2.balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] < _2776:
                    revert with 0, 17
                if ext_call.return_data[0] - _2776 and 168 * 24 * 3600 > -1 / ext_call.return_data[0] - _2776:
                    revert with 0, 17
                if not arg4:
                    revert with 0, 18
                if (168 * 24 * 3600 * ext_call.return_data[0]) - (168 * 24 * 3600 * _2776) / arg4 > !(arg3 % 281474976710656):
                    revert with 0, 17
                uint256(stor5[address(arg1)].field_0)++
                address(stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_0) = arg2
                stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_160 % 281474976710656 = arg3 % 281474976710656
                stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_208 % 281474976710656 = ((168 * 24 * 3600 * ext_call.return_data[0]) - (168 * 24 * 3600 * _2776) / arg4) + (arg3 % 281474976710656) % 281474976710656
                uint256(stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_256) = arg4
                uint256(stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_512) = 0
                uint256(stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_768) = ext_call.return_data[0] - _2776
                stor1 = 1
            revert with 0, 'BonusRewards: not authorized caller'
        if arg3 % 281474976710656 < block.timestamp:
            revert with 0, 'BonusRewards: startTime in the past'
        mem[0] = arg1
        mem[32] = 5
        mem[64] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + (32 * uint256(stor5[address(arg1)].field_0)) + 224
        mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192] = uint256(stor5[address(arg1)].field_0)
        s = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224
        idx = 0
        while idx < uint256(stor5[address(arg1)].field_0):
            mem[0] = sha3(address(arg1), 5)
            _804 = mem[64]
            mem[64] = mem[64] + 192
            mem[_804] = address(stor5[address(arg1)][idx].field_0)
            mem[_804 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
            mem[_804 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
            mem[_804 + 96] = uint256(stor5[address(arg1)][idx].field_256)
            mem[_804 + 128] = uint256(stor5[address(arg1)][idx].field_512)
            mem[_804 + 160] = uint256(stor5[address(arg1)][idx].field_768)
            mem[s] = _804
            s = s + 32
            idx = idx + 1
            continue 
        mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 128] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192
        mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 160] = uint256(stor5[address(arg1)].field_256)
        if uint256(stor5[address(arg1)].field_256) <= 0:
            revert with 0, 'BonusRewards: pool does not exist'
        idx = 0
        while idx < mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
            if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                revert with 0, 50
            if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 12 len 20] == arg2:
                if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                    revert with 0, 50
                if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 90 len 6] > -604801:
                    revert with 0, 17
                if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 90 len 6] + (168 * 24 * 3600) >= block.timestamp:
                    revert with 0, 'BonusRewards: last bonus period hasn't ended'
                if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                    revert with 0, 50
                if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 160] != 0:
                    revert with 0, 'BonusRewards: last bonus not all claimed'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(arg2)
        staticcall arg2.balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1619 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1631 = mem[_1619]
        _1646 = mem[64]
        mem[mem[64] + 36] = msg.sender
        mem[mem[64] + 68] = this.address
        mem[mem[64] + 100] = arg5
        _1665 = mem[64]
        mem[mem[64]] = 100
        mem[mem[64] + 32 len 4] = transferFrom(address rg1, address rg2, uint256 rg3)
        mem[64] = mem[64] + 196
        mem[_1646 + 132] = 32
        mem[_1646 + 164] = 'SafeERC20: low-level call failed'
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg2):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(arg2):
            revert with 0, 'Address: call to non-contract'
        _1727 = mem[_1665]
        mem[_1646 + 196 len ceil32(mem[_1665])] = mem[_1665 + 32 len ceil32(mem[_1665])]
        if ceil32(_1727) > _1727:
            mem[_1727 + _1646 + 196] = 0
        call arg2 with:
             gas gas_remaining wei
            args mem[_1646 + 200 len _1727 - 4]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96]:
                require mem[96] >= 32
                require mem[128] == bool(mem[128])
                if not mem[128]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        else:
            mem[_1646 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                require mem[_1646 + 228] == bool(mem[_1646 + 228])
                if not mem[_1646 + 228]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        require ext_code.size(arg2)
        staticcall arg2.balanceOf(address rg1) with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] < _1631:
            revert with 0, 17
        if ext_call.return_data[0] - _1631 and 168 * 24 * 3600 > -1 / ext_call.return_data[0] - _1631:
            revert with 0, 17
        if not arg4:
            revert with 0, 18
        if (168 * 24 * 3600 * ext_call.return_data[0]) - (168 * 24 * 3600 * _1631) / arg4 > !(arg3 % 281474976710656):
            revert with 0, 17
        uint256(stor5[address(arg1)].field_0)++
        address(stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_0) = arg2
        stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_160 % 281474976710656 = arg3 % 281474976710656
        stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_208 % 281474976710656 = ((168 * 24 * 3600 * ext_call.return_data[0]) - (168 * 24 * 3600 * _1631) / arg4) + (arg3 % 281474976710656) % 281474976710656
        uint256(stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_256) = arg4
        uint256(stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_512) = 0
        uint256(stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_768) = ext_call.return_data[0] - _1631
    else:
        mem[0] = sha3(address(arg2), sha3(address(arg1), 7))
        mem[128] = address(stor7[address(arg1)][address(arg2)].field_0)
        if (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 32 <= 64:
            if owner != msg.sender:
                idx = 0
                while idx < uint256(stor7[address(arg1)][address(arg2)].field_0):
                    if idx >= uint256(stor7[address(arg1)][address(arg2)].field_0):
                        revert with 0, 50
                    if mem[(32 * idx) + 140 len 20] != msg.sender:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if arg3 % 281474976710656 < block.timestamp:
                        revert with 0, 'BonusRewards: startTime in the past'
                    mem[0] = arg1
                    mem[32] = 5
                    mem[64] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + (32 * uint256(stor5[address(arg1)].field_0)) + 224
                    mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192] = uint256(stor5[address(arg1)].field_0)
                    s = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224
                    idx = 0
                    while idx < uint256(stor5[address(arg1)].field_0):
                        mem[0] = sha3(address(arg1), 5)
                        _1590 = mem[64]
                        mem[64] = mem[64] + 192
                        mem[_1590] = address(stor5[address(arg1)][idx].field_0)
                        mem[_1590 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                        mem[_1590 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                        mem[_1590 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                        mem[_1590 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                        mem[_1590 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                        mem[s] = _1590
                        s = s + 32
                        idx = idx + 1
                        continue 
                    mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 128] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192
                    mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 160] = uint256(stor5[address(arg1)].field_256)
                    if uint256(stor5[address(arg1)].field_256) <= 0:
                        revert with 0, 'BonusRewards: pool does not exist'
                    idx = 0
                    while idx < mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                        if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                            revert with 0, 50
                        if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 12 len 20] == arg2:
                            if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                                revert with 0, 50
                            if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 90 len 6] > -604801:
                                revert with 0, 17
                            if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 90 len 6] + (168 * 24 * 3600) >= block.timestamp:
                                revert with 0, 'BonusRewards: last bonus period hasn't ended'
                            if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                                revert with 0, 50
                            if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 160] != 0:
                                revert with 0, 'BonusRewards: last bonus not all claimed'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(arg2)
                    staticcall arg2.balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2771 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2786 = mem[_2771]
                    _2823 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = this.address
                    mem[mem[64] + 100] = arg5
                    _2854 = mem[64]
                    mem[mem[64]] = 100
                    mem[64] = mem[64] + 132
                    mem[_2854 + 32] = 0x23b872dd00000000000000000000000000000000000000000000000000000000 or mem[_2854 + 36 len 28]
                    mem[64] = _2823 + 196
                    mem[_2823 + 132] = 32
                    mem[_2823 + 164] = 'SafeERC20: low-level call failed'
                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg2):
                        revert with 0, 'Address: call to non-contract'
                    if not ext_code.hash(arg2):
                        revert with 0, 'Address: call to non-contract'
                    _2961 = mem[_2854]
                    idx = 0
                    while idx < _2961:
                        mem[idx + _2823 + 196] = mem[idx + _2854 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_2961) > _2961:
                        mem[_2961 + _2823 + 196] = 0
                    call arg2.mem[_2823 + 196 len 4] with:
                         gas gas_remaining wei
                        args mem[_2823 + 200 len _2961 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_2823 + 196] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_2823 + 200] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _2823 + 264] = mem[idx + _2823 + 164]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_2823 + 264]
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_2823 + 196] = return_data.size
                        mem[_2823 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_2823 + ceil32(return_data.size) + 197] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_2823 + ceil32(return_data.size) + 201] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _2823 + ceil32(return_data.size) + 265] = mem[idx + _2823 + 164]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_2823 + ceil32(return_data.size) + 265]
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_2823 + 228] == bool(mem[_2823 + 228])
                            if not mem[_2823 + 228]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    require ext_code.size(arg2)
                    staticcall arg2.balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] < _2786:
                        revert with 0, 17
                    if ext_call.return_data[0] - _2786 and 168 * 24 * 3600 > -1 / ext_call.return_data[0] - _2786:
                        revert with 0, 17
                    if not arg4:
                        revert with 0, 18
                    if (168 * 24 * 3600 * ext_call.return_data[0]) - (168 * 24 * 3600 * _2786) / arg4 > !(arg3 % 281474976710656):
                        revert with 0, 17
                    uint256(stor5[address(arg1)].field_0)++
                    address(stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_0) = arg2
                    stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_160 % 281474976710656 = arg3 % 281474976710656
                    stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_208 % 281474976710656 = ((168 * 24 * 3600 * ext_call.return_data[0]) - (168 * 24 * 3600 * _2786) / arg4) + (arg3 % 281474976710656) % 281474976710656
                    uint256(stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_256) = arg4
                    uint256(stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_512) = 0
                    uint256(stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_768) = ext_call.return_data[0] - _2786
                    stor1 = 1
                revert with 0, 'BonusRewards: not authorized caller'
            if arg3 % 281474976710656 < block.timestamp:
                revert with 0, 'BonusRewards: startTime in the past'
            mem[0] = arg1
            mem[32] = 5
            mem[64] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + (32 * uint256(stor5[address(arg1)].field_0)) + 224
            mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192] = uint256(stor5[address(arg1)].field_0)
            s = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224
            idx = 0
            while idx < uint256(stor5[address(arg1)].field_0):
                mem[0] = sha3(address(arg1), 5)
                _808 = mem[64]
                mem[64] = mem[64] + 192
                mem[_808] = address(stor5[address(arg1)][idx].field_0)
                mem[_808 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                mem[_808 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                mem[_808 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                mem[_808 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                mem[_808 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                mem[s] = _808
                s = s + 32
                idx = idx + 1
                continue 
            mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 128] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192
            mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 160] = uint256(stor5[address(arg1)].field_256)
            if uint256(stor5[address(arg1)].field_256) <= 0:
                revert with 0, 'BonusRewards: pool does not exist'
            idx = 0
            while idx < mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                    revert with 0, 50
                if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 12 len 20] == arg2:
                    if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                        revert with 0, 50
                    if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 90 len 6] > -604801:
                        revert with 0, 17
                    if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 90 len 6] + (168 * 24 * 3600) >= block.timestamp:
                        revert with 0, 'BonusRewards: last bonus period hasn't ended'
                    if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                        revert with 0, 50
                    if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 160] != 0:
                        revert with 0, 'BonusRewards: last bonus not all claimed'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(arg2)
            staticcall arg2.balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1623 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1635 = mem[_1623]
            _1649 = mem[64]
            mem[mem[64] + 36] = msg.sender
            mem[mem[64] + 68] = this.address
            mem[mem[64] + 100] = arg5
            _1671 = mem[64]
            mem[mem[64]] = 100
            mem[mem[64] + 32 len 4] = transferFrom(address rg1, address rg2, uint256 rg3)
            mem[64] = mem[64] + 196
            mem[_1649 + 132] = 32
            mem[_1649 + 164] = 'SafeERC20: low-level call failed'
            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg2):
                revert with 0, 'Address: call to non-contract'
            if not ext_code.hash(arg2):
                revert with 0, 'Address: call to non-contract'
            _1731 = mem[_1671]
            mem[_1649 + 196 len ceil32(mem[_1671])] = mem[_1671 + 32 len ceil32(mem[_1671])]
            if ceil32(_1731) > _1731:
                mem[_1731 + _1649 + 196] = 0
            call arg2 with:
                 gas gas_remaining wei
                args mem[_1649 + 200 len _1731 - 4]
            if not return_data.size:
                if not ext_call.success:
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    revert with 0, 'SafeERC20: low-level call failed'
                if mem[96]:
                    require mem[96] >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                mem[_1649 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size:
                    require return_data.size >= 32
                    require mem[_1649 + 228] == bool(mem[_1649 + 228])
                    if not mem[_1649 + 228]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            require ext_code.size(arg2)
            staticcall arg2.balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] < _1635:
                revert with 0, 17
            if ext_call.return_data[0] - _1635 and 168 * 24 * 3600 > -1 / ext_call.return_data[0] - _1635:
                revert with 0, 17
            if not arg4:
                revert with 0, 18
            if (168 * 24 * 3600 * ext_call.return_data[0]) - (168 * 24 * 3600 * _1635) / arg4 > !(arg3 % 281474976710656):
                revert with 0, 17
            uint256(stor5[address(arg1)].field_0)++
            address(stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_0) = arg2
            stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_160 % 281474976710656 = arg3 % 281474976710656
            stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_208 % 281474976710656 = ((168 * 24 * 3600 * ext_call.return_data[0]) - (168 * 24 * 3600 * _1635) / arg4) + (arg3 % 281474976710656) % 281474976710656
            uint256(stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_256) = arg4
            uint256(stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_512) = 0
            uint256(stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_768) = ext_call.return_data[0] - _1635
        else:
            mem[160] = address(stor7[address(arg1)][address(arg2)].field_256)
            idx = 160
            s = 1
            while (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 96 > idx:
                mem[idx + 32] = address(stor7[address(arg1)][address(arg2)][s].field_256)
                idx = idx + 32
                s = s + 1
                continue 
            if owner != msg.sender:
                idx = 0
                while idx < uint256(stor7[address(arg1)][address(arg2)].field_0):
                    if idx >= uint256(stor7[address(arg1)][address(arg2)].field_0):
                        revert with 0, 50
                    if mem[(32 * idx) + 140 len 20] != msg.sender:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if arg3 % 281474976710656 < block.timestamp:
                        revert with 0, 'BonusRewards: startTime in the past'
                    mem[0] = arg1
                    mem[32] = 5
                    mem[64] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + (32 * uint256(stor5[address(arg1)].field_0)) + 224
                    mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192] = uint256(stor5[address(arg1)].field_0)
                    s = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224
                    idx = 0
                    while idx < uint256(stor5[address(arg1)].field_0):
                        mem[0] = sha3(address(arg1), 5)
                        _3811 = mem[64]
                        mem[64] = mem[64] + 192
                        mem[_3811] = address(stor5[address(arg1)][idx].field_0)
                        mem[_3811 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                        mem[_3811 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                        mem[_3811 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                        mem[_3811 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                        mem[_3811 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                        mem[s] = _3811
                        s = s + 32
                        idx = idx + 1
                        continue 
                    mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 128] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192
                    mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 160] = uint256(stor5[address(arg1)].field_256)
                    if uint256(stor5[address(arg1)].field_256) <= 0:
                        revert with 0, 'BonusRewards: pool does not exist'
                    idx = 0
                    while idx < mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                        if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                            revert with 0, 50
                        if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 12 len 20] == arg2:
                            if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                                revert with 0, 50
                            if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 90 len 6] > -604801:
                                revert with 0, 17
                            if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 90 len 6] + (168 * 24 * 3600) >= block.timestamp:
                                revert with 0, 'BonusRewards: last bonus period hasn't ended'
                            if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                                revert with 0, 50
                            if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 160] != 0:
                                revert with 0, 'BonusRewards: last bonus not all claimed'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(arg2)
                    staticcall arg2.balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4553 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _4556 = mem[_4553]
                    _4571 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = this.address
                    mem[mem[64] + 100] = arg5
                    _4584 = mem[64]
                    mem[mem[64]] = 100
                    mem[64] = mem[64] + 132
                    mem[_4584 + 32] = 0x23b872dd00000000000000000000000000000000000000000000000000000000 or mem[_4584 + 36 len 28]
                    mem[64] = _4571 + 196
                    mem[_4571 + 132] = 32
                    mem[_4571 + 164] = 'SafeERC20: low-level call failed'
                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg2):
                        revert with 0, 'Address: call to non-contract'
                    if not ext_code.hash(arg2):
                        revert with 0, 'Address: call to non-contract'
                    _4627 = mem[_4584]
                    idx = 0
                    while idx < _4627:
                        mem[idx + _4571 + 196] = mem[idx + _4584 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_4627) > _4627:
                        mem[_4627 + _4571 + 196] = 0
                    call arg2.mem[_4571 + 196 len 4] with:
                         gas gas_remaining wei
                        args mem[_4571 + 200 len _4627 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_4571 + 196] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4571 + 200] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4571 + 264] = mem[idx + _4571 + 164]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4571 + 264]
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_4571 + 196] = return_data.size
                        mem[_4571 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_4571 + ceil32(return_data.size) + 197] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4571 + ceil32(return_data.size) + 201] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4571 + ceil32(return_data.size) + 265] = mem[idx + _4571 + 164]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4571 + ceil32(return_data.size) + 265]
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_4571 + 228] == bool(mem[_4571 + 228])
                            if not mem[_4571 + 228]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    require ext_code.size(arg2)
                    staticcall arg2.balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] < _4556:
                        revert with 0, 17
                    if ext_call.return_data[0] - _4556 and 168 * 24 * 3600 > -1 / ext_call.return_data[0] - _4556:
                        revert with 0, 17
                    if not arg4:
                        revert with 0, 18
                    if (168 * 24 * 3600 * ext_call.return_data[0]) - (168 * 24 * 3600 * _4556) / arg4 > !(arg3 % 281474976710656):
                        revert with 0, 17
                    uint256(stor5[address(arg1)].field_0)++
                    address(stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_0) = arg2
                    stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_160 % 281474976710656 = arg3 % 281474976710656
                    stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_208 % 281474976710656 = ((168 * 24 * 3600 * ext_call.return_data[0]) - (168 * 24 * 3600 * _4556) / arg4) + (arg3 % 281474976710656) % 281474976710656
                    uint256(stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_256) = arg4
                    uint256(stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_512) = 0
                    uint256(stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_768) = ext_call.return_data[0] - _4556
                    stor1 = 1
                revert with 0, 'BonusRewards: not authorized caller'
            if arg3 % 281474976710656 < block.timestamp:
                revert with 0, 'BonusRewards: startTime in the past'
            mem[0] = arg1
            mem[32] = 5
            mem[64] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + (32 * uint256(stor5[address(arg1)].field_0)) + 224
            mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192] = uint256(stor5[address(arg1)].field_0)
            s = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224
            idx = 0
            while idx < uint256(stor5[address(arg1)].field_0):
                mem[0] = sha3(address(arg1), 5)
                _2737 = mem[64]
                mem[64] = mem[64] + 192
                mem[_2737] = address(stor5[address(arg1)][idx].field_0)
                mem[_2737 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                mem[_2737 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                mem[_2737 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                mem[_2737 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                mem[_2737 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                mem[s] = _2737
                s = s + 32
                idx = idx + 1
                continue 
            mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 128] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192
            mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 160] = uint256(stor5[address(arg1)].field_256)
            if uint256(stor5[address(arg1)].field_256) <= 0:
                revert with 0, 'BonusRewards: pool does not exist'
            idx = 0
            while idx < mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                    revert with 0, 50
                if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 12 len 20] == arg2:
                    if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                        revert with 0, 50
                    if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 90 len 6] > -604801:
                        revert with 0, 17
                    if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 90 len 6] + (168 * 24 * 3600) >= block.timestamp:
                        revert with 0, 'BonusRewards: last bonus period hasn't ended'
                    if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                        revert with 0, 50
                    if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 160] != 0:
                        revert with 0, 'BonusRewards: last bonus not all claimed'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(arg2)
            staticcall arg2.balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3855 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3866 = mem[_3855]
            _3894 = mem[64]
            mem[mem[64] + 36] = msg.sender
            mem[mem[64] + 68] = this.address
            mem[mem[64] + 100] = arg5
            _3918 = mem[64]
            mem[mem[64]] = 100
            mem[mem[64] + 32 len 4] = transferFrom(address rg1, address rg2, uint256 rg3)
            mem[64] = mem[64] + 196
            mem[_3894 + 132] = 32
            mem[_3894 + 164] = 'SafeERC20: low-level call failed'
            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg2):
                revert with 0, 'Address: call to non-contract'
            if not ext_code.hash(arg2):
                revert with 0, 'Address: call to non-contract'
            _4006 = mem[_3918]
            mem[_3894 + 196 len ceil32(mem[_3918])] = mem[_3918 + 32 len ceil32(mem[_3918])]
            if ceil32(_4006) > _4006:
                mem[_4006 + _3894 + 196] = 0
            call arg2 with:
                 gas gas_remaining wei
                args mem[_3894 + 200 len _4006 - 4]
            if not return_data.size:
                if not ext_call.success:
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    revert with 0, 'SafeERC20: low-level call failed'
                if mem[96]:
                    require mem[96] >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                mem[_3894 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size:
                    require return_data.size >= 32
                    require mem[_3894 + 228] == bool(mem[_3894 + 228])
                    if not mem[_3894 + 228]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            require ext_code.size(arg2)
            staticcall arg2.balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] < _3866:
                revert with 0, 17
            if ext_call.return_data[0] - _3866 and 168 * 24 * 3600 > -1 / ext_call.return_data[0] - _3866:
                revert with 0, 17
            if not arg4:
                revert with 0, 18
            if (168 * 24 * 3600 * ext_call.return_data[0]) - (168 * 24 * 3600 * _3866) / arg4 > !(arg3 % 281474976710656):
                revert with 0, 17
            uint256(stor5[address(arg1)].field_0)++
            address(stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_0) = arg2
            stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_160 % 281474976710656 = arg3 % 281474976710656
            stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_208 % 281474976710656 = ((168 * 24 * 3600 * ext_call.return_data[0]) - (168 * 24 * 3600 * _3866) / arg4) + (arg3 % 281474976710656) % 281474976710656
            uint256(stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_256) = arg4
            uint256(stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_512) = 0
            uint256(stor5[address(arg1)][uint256(stor5[address(arg1)].field_0)].field_768) = ext_call.return_data[0] - _3866
    stor1 = 1
}

function viewRewards(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    mem[64] = (32 * uint256(stor5[address(arg1)].field_0)) + 192
    mem[160] = uint256(stor5[address(arg1)].field_0)
    s = 192
    idx = 0
    while idx < uint256(stor5[address(arg1)].field_0):
        mem[0] = sha3(address(arg1), 5)
        _224 = mem[64]
        mem[64] = mem[64] + 192
        mem[_224] = address(stor5[address(arg1)][idx].field_0)
        mem[_224 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
        mem[_224 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
        mem[_224 + 96] = uint256(stor5[address(arg1)][idx].field_256)
        mem[_224 + 128] = uint256(stor5[address(arg1)][idx].field_512)
        mem[_224 + 160] = uint256(stor5[address(arg1)][idx].field_768)
        mem[s] = _224
        s = s + 32
        idx = idx + 1
        continue 
    mem[96] = 160
    mem[128] = uint256(stor5[address(arg1)].field_256)
    mem[0] = arg2
    mem[32] = sha3(address(arg1), 6)
    _221 = mem[64]
    mem[64] = mem[64] + 64
    mem[_221] = uint256(stor6[address(arg1)][address(arg2)].field_0)
    _222 = mem[64]
    mem[64] = mem[64] + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 32
    mem[_222] = uint256(stor6[address(arg1)][address(arg2)].field_256)
    if not uint256(stor6[address(arg1)][address(arg2)].field_256):
        mem[_221 + 32] = _222
        _226 = mem[160]
        if mem[160] > test266151307():
            revert with 0, 65
        _228 = mem[64]
        mem[mem[64]] = mem[160]
        mem[64] = mem[64] + (32 * _226) + 32
        if not _226:
            if not uint256(stor6[address(arg1)][address(arg2)].field_0):
                mem[_228 + (32 * _226) + 32] = 32
                mem[_228 + (32 * _226) + 64] = mem[_228]
                mem[_228 + (32 * _226) + 96 len 32 * mem[_228]] = mem[_228 + 32 len 32 * mem[_228]]
                return memory
                  from mem[64]
                   len _228 + (32 * _226) + (32 * mem[_228]) + -mem[64] + 96
            _435 = mem[_228]
            idx = 0
            while idx < _435:
                if idx >= mem[mem[96]]:
                    revert with 0, 50
                _443 = mem[(32 * idx) + mem[96] + 32]
                if mem[mem[(32 * idx) + mem[96] + 32] + 58 len 6] < block.timestamp:
                    if mem[mem[(32 * idx) + mem[96] + 32] + 160] > 0:
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(arg1)
                        staticcall arg1.balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _462 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_443 + 90 len 6] <= mem[128]:
                            if not mem[_462]:
                                revert with 0, 18
                            if mem[_443 + 128] > !(0 / mem[_462]):
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                if mem[_221] and mem[_443 + 128] + (0 / mem[_462]) > -1 / mem[_221]:
                                    revert with 0, 17
                                if (mem[_443 + 128] * mem[_221]) + (0 / mem[_462] * mem[_221]) / 1000000000000 * 10^18 < 0:
                                    revert with 0, 17
                                if idx >= mem[_228]:
                                    revert with 0, 50
                                if (mem[_443 + 128] * mem[_221]) + (0 / mem[_462] * mem[_221]) / 1000000000000 * 10^18 < mem[_443 + 160]:
                                    mem[(32 * idx) + _228 + 32] = (mem[_443 + 128] * mem[_221]) + (0 / mem[_462] * mem[_221]) / 1000000000000 * 10^18
                                else:
                                    mem[(32 * idx) + _228 + 32] = mem[_443 + 160]
                            else:
                                if idx >= mem[mem[_221 + 32]]:
                                    revert with 0, 50
                                if mem[_221] and mem[_443 + 128] + (0 / mem[_462]) > -1 / mem[_221]:
                                    revert with 0, 17
                                if (mem[_443 + 128] * mem[_221]) + (0 / mem[_462] * mem[_221]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_221 + 32] + 32]:
                                    revert with 0, 17
                                if idx >= mem[_228]:
                                    revert with 0, 50
                                if ((mem[_443 + 128] * mem[_221]) + (0 / mem[_462] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32] < mem[_443 + 160]:
                                    mem[(32 * idx) + _228 + 32] = ((mem[_443 + 128] * mem[_221]) + (0 / mem[_462] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32]
                                else:
                                    mem[(32 * idx) + _228 + 32] = mem[_443 + 160]
                        else:
                            if block.timestamp > mem[_443 + 90 len 6]:
                                if mem[128] > mem[_443 + 58 len 6]:
                                    if mem[_443 + 90 len 6] < mem[128]:
                                        revert with 0, 17
                                    if mem[_443 + 96] and 1000000000000 * 10^18 > -1 / mem[_443 + 96]:
                                        revert with 0, 17
                                    if 1000000000000 * 10^18 * mem[_443 + 96] and mem[_443 + 90 len 6] - mem[128] > -1 / 1000000000000 * 10^18 * mem[_443 + 96]:
                                        revert with 0, 17
                                    if not mem[_462]:
                                        revert with 0, 18
                                    if mem[_443 + 128] > !((1000000000000 * 10^18 * mem[_443 + 90 len 6] * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462]):
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                        if mem[_221] and mem[_443 + 128] + ((1000000000000 * 10^18 * mem[_443 + 90 len 6] * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462]) > -1 / mem[_221]:
                                            revert with 0, 17
                                        if (mem[_443 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_443 + 90 len 6] * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462] * mem[_221]) / 1000000000000 * 10^18 < 0:
                                            revert with 0, 17
                                        if idx >= mem[_228]:
                                            revert with 0, 50
                                        if (mem[_443 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_443 + 90 len 6] * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462] * mem[_221]) / 1000000000000 * 10^18 < mem[_443 + 160]:
                                            mem[(32 * idx) + _228 + 32] = (mem[_443 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_443 + 90 len 6] * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462] * mem[_221]) / 1000000000000 * 10^18
                                        else:
                                            mem[(32 * idx) + _228 + 32] = mem[_443 + 160]
                                    else:
                                        if idx >= mem[mem[_221 + 32]]:
                                            revert with 0, 50
                                        if mem[_221] and mem[_443 + 128] + ((1000000000000 * 10^18 * mem[_443 + 90 len 6] * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462]) > -1 / mem[_221]:
                                            revert with 0, 17
                                        if (mem[_443 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_443 + 90 len 6] * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462] * mem[_221]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_221 + 32] + 32]:
                                            revert with 0, 17
                                        if idx >= mem[_228]:
                                            revert with 0, 50
                                        if ((mem[_443 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_443 + 90 len 6] * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32] < mem[_443 + 160]:
                                            mem[(32 * idx) + _228 + 32] = ((mem[_443 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_443 + 90 len 6] * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32]
                                        else:
                                            mem[(32 * idx) + _228 + 32] = mem[_443 + 160]
                                else:
                                    if mem[_443 + 90 len 6] < mem[_443 + 58 len 6]:
                                        revert with 0, 17
                                    if mem[_443 + 96] and 1000000000000 * 10^18 > -1 / mem[_443 + 96]:
                                        revert with 0, 17
                                    if 1000000000000 * 10^18 * mem[_443 + 96] and mem[_443 + 90 len 6] - mem[_443 + 58 len 6] > -1 / 1000000000000 * 10^18 * mem[_443 + 96]:
                                        revert with 0, 17
                                    if not mem[_462]:
                                        revert with 0, 18
                                    if mem[_443 + 128] > !((1000000000000 * 10^18 * mem[_443 + 90 len 6] * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[_443 + 58 len 6] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462]):
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                        if mem[_221] and mem[_443 + 128] + ((1000000000000 * 10^18 * mem[_443 + 90 len 6] * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[_443 + 58 len 6] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462]) > -1 / mem[_221]:
                                            revert with 0, 17
                                        if (mem[_443 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_443 + 90 len 6] * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[_443 + 58 len 6] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462] * mem[_221]) / 1000000000000 * 10^18 < 0:
                                            revert with 0, 17
                                        if idx >= mem[_228]:
                                            revert with 0, 50
                                        if (mem[_443 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_443 + 90 len 6] * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[_443 + 58 len 6] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462] * mem[_221]) / 1000000000000 * 10^18 < mem[_443 + 160]:
                                            mem[(32 * idx) + _228 + 32] = (mem[_443 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_443 + 90 len 6] * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[_443 + 58 len 6] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462] * mem[_221]) / 1000000000000 * 10^18
                                        else:
                                            mem[(32 * idx) + _228 + 32] = mem[_443 + 160]
                                    else:
                                        if idx >= mem[mem[_221 + 32]]:
                                            revert with 0, 50
                                        if mem[_221] and mem[_443 + 128] + ((1000000000000 * 10^18 * mem[_443 + 90 len 6] * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[_443 + 58 len 6] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462]) > -1 / mem[_221]:
                                            revert with 0, 17
                                        if (mem[_443 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_443 + 90 len 6] * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[_443 + 58 len 6] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462] * mem[_221]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_221 + 32] + 32]:
                                            revert with 0, 17
                                        if idx >= mem[_228]:
                                            revert with 0, 50
                                        if ((mem[_443 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_443 + 90 len 6] * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[_443 + 58 len 6] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32] < mem[_443 + 160]:
                                            mem[(32 * idx) + _228 + 32] = ((mem[_443 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_443 + 90 len 6] * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[_443 + 58 len 6] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32]
                                        else:
                                            mem[(32 * idx) + _228 + 32] = mem[_443 + 160]
                            else:
                                if mem[128] > mem[_443 + 58 len 6]:
                                    if block.timestamp < mem[128]:
                                        revert with 0, 17
                                    if mem[_443 + 96] and 1000000000000 * 10^18 > -1 / mem[_443 + 96]:
                                        revert with 0, 17
                                    if 1000000000000 * 10^18 * mem[_443 + 96] and block.timestamp - mem[128] > -1 / 1000000000000 * 10^18 * mem[_443 + 96]:
                                        revert with 0, 17
                                    if not mem[_462]:
                                        revert with 0, 18
                                    if mem[_443 + 128] > !((1000000000000 * 10^18 * block.timestamp * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462]):
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                        if mem[_221] and mem[_443 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462]) > -1 / mem[_221]:
                                            revert with 0, 17
                                        if (mem[_443 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462] * mem[_221]) / 1000000000000 * 10^18 < 0:
                                            revert with 0, 17
                                        if idx >= mem[_228]:
                                            revert with 0, 50
                                        if (mem[_443 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462] * mem[_221]) / 1000000000000 * 10^18 < mem[_443 + 160]:
                                            mem[(32 * idx) + _228 + 32] = (mem[_443 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462] * mem[_221]) / 1000000000000 * 10^18
                                        else:
                                            mem[(32 * idx) + _228 + 32] = mem[_443 + 160]
                                    else:
                                        if idx >= mem[mem[_221 + 32]]:
                                            revert with 0, 50
                                        if mem[_221] and mem[_443 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462]) > -1 / mem[_221]:
                                            revert with 0, 17
                                        if (mem[_443 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462] * mem[_221]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_221 + 32] + 32]:
                                            revert with 0, 17
                                        if idx >= mem[_228]:
                                            revert with 0, 50
                                        if ((mem[_443 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32] < mem[_443 + 160]:
                                            mem[(32 * idx) + _228 + 32] = ((mem[_443 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32]
                                        else:
                                            mem[(32 * idx) + _228 + 32] = mem[_443 + 160]
                                else:
                                    if block.timestamp < mem[_443 + 58 len 6]:
                                        revert with 0, 17
                                    if mem[_443 + 96] and 1000000000000 * 10^18 > -1 / mem[_443 + 96]:
                                        revert with 0, 17
                                    if 1000000000000 * 10^18 * mem[_443 + 96] and block.timestamp - mem[_443 + 58 len 6] > -1 / 1000000000000 * 10^18 * mem[_443 + 96]:
                                        revert with 0, 17
                                    if not mem[_462]:
                                        revert with 0, 18
                                    if mem[_443 + 128] > !((1000000000000 * 10^18 * block.timestamp * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[_443 + 58 len 6] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462]):
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                        if mem[_221] and mem[_443 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[_443 + 58 len 6] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462]) > -1 / mem[_221]:
                                            revert with 0, 17
                                        if (mem[_443 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[_443 + 58 len 6] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462] * mem[_221]) / 1000000000000 * 10^18 < 0:
                                            revert with 0, 17
                                        if idx >= mem[_228]:
                                            revert with 0, 50
                                        if (mem[_443 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[_443 + 58 len 6] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462] * mem[_221]) / 1000000000000 * 10^18 < mem[_443 + 160]:
                                            mem[(32 * idx) + _228 + 32] = (mem[_443 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[_443 + 58 len 6] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462] * mem[_221]) / 1000000000000 * 10^18
                                        else:
                                            mem[(32 * idx) + _228 + 32] = mem[_443 + 160]
                                    else:
                                        if idx >= mem[mem[_221 + 32]]:
                                            revert with 0, 50
                                        if mem[_221] and mem[_443 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[_443 + 58 len 6] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462]) > -1 / mem[_221]:
                                            revert with 0, 17
                                        if (mem[_443 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[_443 + 58 len 6] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462] * mem[_221]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_221 + 32] + 32]:
                                            revert with 0, 17
                                        if idx >= mem[_228]:
                                            revert with 0, 50
                                        if ((mem[_443 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[_443 + 58 len 6] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32] < mem[_443 + 160]:
                                            mem[(32 * idx) + _228 + 32] = ((mem[_443 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_443 + 96]) - (1000000000000 * 10^18 * mem[_443 + 58 len 6] * mem[_443 + 96]) / 168 * 24 * 3600 / mem[_462] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32]
                                        else:
                                            mem[(32 * idx) + _228 + 32] = mem[_443 + 160]
                if idx == -1:
                    revert with 0, 17
                _435 = mem[_228]
                idx = idx + 1
                continue 
            mem[mem[64]] = 32
            _453 = mem[_228]
            mem[mem[64] + 32] = mem[_228]
            mem[mem[64] + 64 len 32 * _453] = mem[_228 + 32 len 32 * _453]
            return 32, mem[mem[64] + 32 len (32 * _453) + 32]
        mem[_228 + 32 len 32 * _226] = call.data[calldata.size len 32 * _226]
        if not uint256(stor6[address(arg1)][address(arg2)].field_0):
            mem[_228 + (32 * _226) + 32] = 32
            mem[_228 + (32 * _226) + 64] = mem[_228]
            mem[_228 + (32 * _226) + 96 len 32 * mem[_228]] = mem[_228 + 32 len 32 * mem[_228]]
            return memory
              from mem[64]
               len _228 + (32 * _226) + (32 * mem[_228]) + -mem[64] + 96
        _436 = mem[_228]
        idx = 0
        while idx < _436:
            if idx >= mem[mem[96]]:
                revert with 0, 50
            _445 = mem[(32 * idx) + mem[96] + 32]
            if mem[mem[(32 * idx) + mem[96] + 32] + 58 len 6] < block.timestamp:
                if mem[mem[(32 * idx) + mem[96] + 32] + 160] > 0:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(arg1)
                    staticcall arg1.balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _464 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_445 + 90 len 6] <= mem[128]:
                        if not mem[_464]:
                            revert with 0, 18
                        if mem[_445 + 128] > !(0 / mem[_464]):
                            revert with 0, 17
                        if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                            if mem[_221] and mem[_445 + 128] + (0 / mem[_464]) > -1 / mem[_221]:
                                revert with 0, 17
                            if (mem[_445 + 128] * mem[_221]) + (0 / mem[_464] * mem[_221]) / 1000000000000 * 10^18 < 0:
                                revert with 0, 17
                            if idx >= mem[_228]:
                                revert with 0, 50
                            if (mem[_445 + 128] * mem[_221]) + (0 / mem[_464] * mem[_221]) / 1000000000000 * 10^18 < mem[_445 + 160]:
                                mem[(32 * idx) + _228 + 32] = (mem[_445 + 128] * mem[_221]) + (0 / mem[_464] * mem[_221]) / 1000000000000 * 10^18
                            else:
                                mem[(32 * idx) + _228 + 32] = mem[_445 + 160]
                        else:
                            if idx >= mem[mem[_221 + 32]]:
                                revert with 0, 50
                            if mem[_221] and mem[_445 + 128] + (0 / mem[_464]) > -1 / mem[_221]:
                                revert with 0, 17
                            if (mem[_445 + 128] * mem[_221]) + (0 / mem[_464] * mem[_221]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_221 + 32] + 32]:
                                revert with 0, 17
                            if idx >= mem[_228]:
                                revert with 0, 50
                            if ((mem[_445 + 128] * mem[_221]) + (0 / mem[_464] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32] < mem[_445 + 160]:
                                mem[(32 * idx) + _228 + 32] = ((mem[_445 + 128] * mem[_221]) + (0 / mem[_464] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32]
                            else:
                                mem[(32 * idx) + _228 + 32] = mem[_445 + 160]
                    else:
                        if block.timestamp > mem[_445 + 90 len 6]:
                            if mem[128] > mem[_445 + 58 len 6]:
                                if mem[_445 + 90 len 6] < mem[128]:
                                    revert with 0, 17
                                if mem[_445 + 96] and 1000000000000 * 10^18 > -1 / mem[_445 + 96]:
                                    revert with 0, 17
                                if 1000000000000 * 10^18 * mem[_445 + 96] and mem[_445 + 90 len 6] - mem[128] > -1 / 1000000000000 * 10^18 * mem[_445 + 96]:
                                    revert with 0, 17
                                if not mem[_464]:
                                    revert with 0, 18
                                if mem[_445 + 128] > !((1000000000000 * 10^18 * mem[_445 + 90 len 6] * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464]):
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                    if mem[_221] and mem[_445 + 128] + ((1000000000000 * 10^18 * mem[_445 + 90 len 6] * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464]) > -1 / mem[_221]:
                                        revert with 0, 17
                                    if (mem[_445 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_445 + 90 len 6] * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464] * mem[_221]) / 1000000000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if idx >= mem[_228]:
                                        revert with 0, 50
                                    if (mem[_445 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_445 + 90 len 6] * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464] * mem[_221]) / 1000000000000 * 10^18 < mem[_445 + 160]:
                                        mem[(32 * idx) + _228 + 32] = (mem[_445 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_445 + 90 len 6] * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464] * mem[_221]) / 1000000000000 * 10^18
                                    else:
                                        mem[(32 * idx) + _228 + 32] = mem[_445 + 160]
                                else:
                                    if idx >= mem[mem[_221 + 32]]:
                                        revert with 0, 50
                                    if mem[_221] and mem[_445 + 128] + ((1000000000000 * 10^18 * mem[_445 + 90 len 6] * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464]) > -1 / mem[_221]:
                                        revert with 0, 17
                                    if (mem[_445 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_445 + 90 len 6] * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464] * mem[_221]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_221 + 32] + 32]:
                                        revert with 0, 17
                                    if idx >= mem[_228]:
                                        revert with 0, 50
                                    if ((mem[_445 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_445 + 90 len 6] * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32] < mem[_445 + 160]:
                                        mem[(32 * idx) + _228 + 32] = ((mem[_445 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_445 + 90 len 6] * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32]
                                    else:
                                        mem[(32 * idx) + _228 + 32] = mem[_445 + 160]
                            else:
                                if mem[_445 + 90 len 6] < mem[_445 + 58 len 6]:
                                    revert with 0, 17
                                if mem[_445 + 96] and 1000000000000 * 10^18 > -1 / mem[_445 + 96]:
                                    revert with 0, 17
                                if 1000000000000 * 10^18 * mem[_445 + 96] and mem[_445 + 90 len 6] - mem[_445 + 58 len 6] > -1 / 1000000000000 * 10^18 * mem[_445 + 96]:
                                    revert with 0, 17
                                if not mem[_464]:
                                    revert with 0, 18
                                if mem[_445 + 128] > !((1000000000000 * 10^18 * mem[_445 + 90 len 6] * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[_445 + 58 len 6] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464]):
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                    if mem[_221] and mem[_445 + 128] + ((1000000000000 * 10^18 * mem[_445 + 90 len 6] * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[_445 + 58 len 6] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464]) > -1 / mem[_221]:
                                        revert with 0, 17
                                    if (mem[_445 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_445 + 90 len 6] * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[_445 + 58 len 6] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464] * mem[_221]) / 1000000000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if idx >= mem[_228]:
                                        revert with 0, 50
                                    if (mem[_445 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_445 + 90 len 6] * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[_445 + 58 len 6] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464] * mem[_221]) / 1000000000000 * 10^18 < mem[_445 + 160]:
                                        mem[(32 * idx) + _228 + 32] = (mem[_445 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_445 + 90 len 6] * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[_445 + 58 len 6] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464] * mem[_221]) / 1000000000000 * 10^18
                                    else:
                                        mem[(32 * idx) + _228 + 32] = mem[_445 + 160]
                                else:
                                    if idx >= mem[mem[_221 + 32]]:
                                        revert with 0, 50
                                    if mem[_221] and mem[_445 + 128] + ((1000000000000 * 10^18 * mem[_445 + 90 len 6] * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[_445 + 58 len 6] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464]) > -1 / mem[_221]:
                                        revert with 0, 17
                                    if (mem[_445 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_445 + 90 len 6] * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[_445 + 58 len 6] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464] * mem[_221]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_221 + 32] + 32]:
                                        revert with 0, 17
                                    if idx >= mem[_228]:
                                        revert with 0, 50
                                    if ((mem[_445 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_445 + 90 len 6] * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[_445 + 58 len 6] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32] < mem[_445 + 160]:
                                        mem[(32 * idx) + _228 + 32] = ((mem[_445 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_445 + 90 len 6] * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[_445 + 58 len 6] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32]
                                    else:
                                        mem[(32 * idx) + _228 + 32] = mem[_445 + 160]
                        else:
                            if mem[128] > mem[_445 + 58 len 6]:
                                if block.timestamp < mem[128]:
                                    revert with 0, 17
                                if mem[_445 + 96] and 1000000000000 * 10^18 > -1 / mem[_445 + 96]:
                                    revert with 0, 17
                                if 1000000000000 * 10^18 * mem[_445 + 96] and block.timestamp - mem[128] > -1 / 1000000000000 * 10^18 * mem[_445 + 96]:
                                    revert with 0, 17
                                if not mem[_464]:
                                    revert with 0, 18
                                if mem[_445 + 128] > !((1000000000000 * 10^18 * block.timestamp * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464]):
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                    if mem[_221] and mem[_445 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464]) > -1 / mem[_221]:
                                        revert with 0, 17
                                    if (mem[_445 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464] * mem[_221]) / 1000000000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if idx >= mem[_228]:
                                        revert with 0, 50
                                    if (mem[_445 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464] * mem[_221]) / 1000000000000 * 10^18 < mem[_445 + 160]:
                                        mem[(32 * idx) + _228 + 32] = (mem[_445 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464] * mem[_221]) / 1000000000000 * 10^18
                                    else:
                                        mem[(32 * idx) + _228 + 32] = mem[_445 + 160]
                                else:
                                    if idx >= mem[mem[_221 + 32]]:
                                        revert with 0, 50
                                    if mem[_221] and mem[_445 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464]) > -1 / mem[_221]:
                                        revert with 0, 17
                                    if (mem[_445 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464] * mem[_221]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_221 + 32] + 32]:
                                        revert with 0, 17
                                    if idx >= mem[_228]:
                                        revert with 0, 50
                                    if ((mem[_445 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32] < mem[_445 + 160]:
                                        mem[(32 * idx) + _228 + 32] = ((mem[_445 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32]
                                    else:
                                        mem[(32 * idx) + _228 + 32] = mem[_445 + 160]
                            else:
                                if block.timestamp < mem[_445 + 58 len 6]:
                                    revert with 0, 17
                                if mem[_445 + 96] and 1000000000000 * 10^18 > -1 / mem[_445 + 96]:
                                    revert with 0, 17
                                if 1000000000000 * 10^18 * mem[_445 + 96] and block.timestamp - mem[_445 + 58 len 6] > -1 / 1000000000000 * 10^18 * mem[_445 + 96]:
                                    revert with 0, 17
                                if not mem[_464]:
                                    revert with 0, 18
                                if mem[_445 + 128] > !((1000000000000 * 10^18 * block.timestamp * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[_445 + 58 len 6] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464]):
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                    if mem[_221] and mem[_445 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[_445 + 58 len 6] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464]) > -1 / mem[_221]:
                                        revert with 0, 17
                                    if (mem[_445 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[_445 + 58 len 6] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464] * mem[_221]) / 1000000000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if idx >= mem[_228]:
                                        revert with 0, 50
                                    if (mem[_445 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[_445 + 58 len 6] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464] * mem[_221]) / 1000000000000 * 10^18 < mem[_445 + 160]:
                                        mem[(32 * idx) + _228 + 32] = (mem[_445 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[_445 + 58 len 6] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464] * mem[_221]) / 1000000000000 * 10^18
                                    else:
                                        mem[(32 * idx) + _228 + 32] = mem[_445 + 160]
                                else:
                                    if idx >= mem[mem[_221 + 32]]:
                                        revert with 0, 50
                                    if mem[_221] and mem[_445 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[_445 + 58 len 6] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464]) > -1 / mem[_221]:
                                        revert with 0, 17
                                    if (mem[_445 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[_445 + 58 len 6] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464] * mem[_221]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_221 + 32] + 32]:
                                        revert with 0, 17
                                    if idx >= mem[_228]:
                                        revert with 0, 50
                                    if ((mem[_445 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[_445 + 58 len 6] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32] < mem[_445 + 160]:
                                        mem[(32 * idx) + _228 + 32] = ((mem[_445 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_445 + 96]) - (1000000000000 * 10^18 * mem[_445 + 58 len 6] * mem[_445 + 96]) / 168 * 24 * 3600 / mem[_464] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32]
                                    else:
                                        mem[(32 * idx) + _228 + 32] = mem[_445 + 160]
            if idx == -1:
                revert with 0, 17
            _436 = mem[_228]
            idx = idx + 1
            continue 
        mem[mem[64]] = 32
        _455 = mem[_228]
        mem[mem[64] + 32] = mem[_228]
        mem[mem[64] + 64 len 32 * _455] = mem[_228 + 32 len 32 * _455]
        return 32, mem[mem[64] + 32 len (32 * _455) + 32]
    mem[0] = sha3(address(arg2), sha3(address(arg1), 6)) + 1
    mem[_222 + 32] = uint256(stor6[address(arg1)][address(arg2)][1].field_0)
    idx = _222 + 32
    s = 0
    while _222 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) > idx:
        mem[idx + 32] = uint256(stor6[address(arg1)][address(arg2)][s + 1].field_256)
        idx = idx + 32
        s = s + 1
        continue 
    mem[_221 + 32] = _222
    _632 = mem[mem[96]]
    if mem[mem[96]] > test266151307():
        revert with 0, 65
    _635 = mem[64]
    mem[mem[64]] = mem[mem[96]]
    mem[64] = mem[64] + (32 * _632) + 32
    if not _632:
        if not mem[_221]:
            mem[_635 + (32 * _632) + 32] = 32
            mem[_635 + (32 * _632) + 64] = mem[_635]
            mem[_635 + (32 * _632) + 96 len 32 * mem[_635]] = mem[_635 + 32 len 32 * mem[_635]]
            return memory
              from mem[64]
               len _635 + (32 * _632) + (32 * mem[_635]) + -mem[64] + 96
        _844 = mem[_635]
        idx = 0
        while idx < _844:
            if idx >= mem[mem[96]]:
                revert with 0, 50
            _852 = mem[(32 * idx) + mem[96] + 32]
            if mem[mem[(32 * idx) + mem[96] + 32] + 58 len 6] < block.timestamp:
                if mem[mem[(32 * idx) + mem[96] + 32] + 160] > 0:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(arg1)
                    staticcall arg1.balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _871 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_852 + 90 len 6] <= mem[128]:
                        if not mem[_871]:
                            revert with 0, 18
                        if mem[_852 + 128] > !(0 / mem[_871]):
                            revert with 0, 17
                        if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                            if mem[_221] and mem[_852 + 128] + (0 / mem[_871]) > -1 / mem[_221]:
                                revert with 0, 17
                            if (mem[_852 + 128] * mem[_221]) + (0 / mem[_871] * mem[_221]) / 1000000000000 * 10^18 < 0:
                                revert with 0, 17
                            if idx >= mem[_635]:
                                revert with 0, 50
                            if (mem[_852 + 128] * mem[_221]) + (0 / mem[_871] * mem[_221]) / 1000000000000 * 10^18 < mem[_852 + 160]:
                                mem[(32 * idx) + _635 + 32] = (mem[_852 + 128] * mem[_221]) + (0 / mem[_871] * mem[_221]) / 1000000000000 * 10^18
                            else:
                                mem[(32 * idx) + _635 + 32] = mem[_852 + 160]
                        else:
                            if idx >= mem[mem[_221 + 32]]:
                                revert with 0, 50
                            if mem[_221] and mem[_852 + 128] + (0 / mem[_871]) > -1 / mem[_221]:
                                revert with 0, 17
                            if (mem[_852 + 128] * mem[_221]) + (0 / mem[_871] * mem[_221]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_221 + 32] + 32]:
                                revert with 0, 17
                            if idx >= mem[_635]:
                                revert with 0, 50
                            if ((mem[_852 + 128] * mem[_221]) + (0 / mem[_871] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32] < mem[_852 + 160]:
                                mem[(32 * idx) + _635 + 32] = ((mem[_852 + 128] * mem[_221]) + (0 / mem[_871] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32]
                            else:
                                mem[(32 * idx) + _635 + 32] = mem[_852 + 160]
                    else:
                        if block.timestamp > mem[_852 + 90 len 6]:
                            if mem[128] > mem[_852 + 58 len 6]:
                                if mem[_852 + 90 len 6] < mem[128]:
                                    revert with 0, 17
                                if mem[_852 + 96] and 1000000000000 * 10^18 > -1 / mem[_852 + 96]:
                                    revert with 0, 17
                                if 1000000000000 * 10^18 * mem[_852 + 96] and mem[_852 + 90 len 6] - mem[128] > -1 / 1000000000000 * 10^18 * mem[_852 + 96]:
                                    revert with 0, 17
                                if not mem[_871]:
                                    revert with 0, 18
                                if mem[_852 + 128] > !((1000000000000 * 10^18 * mem[_852 + 90 len 6] * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871]):
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                    if mem[_221] and mem[_852 + 128] + ((1000000000000 * 10^18 * mem[_852 + 90 len 6] * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871]) > -1 / mem[_221]:
                                        revert with 0, 17
                                    if (mem[_852 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_852 + 90 len 6] * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871] * mem[_221]) / 1000000000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if idx >= mem[_635]:
                                        revert with 0, 50
                                    if (mem[_852 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_852 + 90 len 6] * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871] * mem[_221]) / 1000000000000 * 10^18 < mem[_852 + 160]:
                                        mem[(32 * idx) + _635 + 32] = (mem[_852 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_852 + 90 len 6] * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871] * mem[_221]) / 1000000000000 * 10^18
                                    else:
                                        mem[(32 * idx) + _635 + 32] = mem[_852 + 160]
                                else:
                                    if idx >= mem[mem[_221 + 32]]:
                                        revert with 0, 50
                                    if mem[_221] and mem[_852 + 128] + ((1000000000000 * 10^18 * mem[_852 + 90 len 6] * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871]) > -1 / mem[_221]:
                                        revert with 0, 17
                                    if (mem[_852 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_852 + 90 len 6] * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871] * mem[_221]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_221 + 32] + 32]:
                                        revert with 0, 17
                                    if idx >= mem[_635]:
                                        revert with 0, 50
                                    if ((mem[_852 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_852 + 90 len 6] * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32] < mem[_852 + 160]:
                                        mem[(32 * idx) + _635 + 32] = ((mem[_852 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_852 + 90 len 6] * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32]
                                    else:
                                        mem[(32 * idx) + _635 + 32] = mem[_852 + 160]
                            else:
                                if mem[_852 + 90 len 6] < mem[_852 + 58 len 6]:
                                    revert with 0, 17
                                if mem[_852 + 96] and 1000000000000 * 10^18 > -1 / mem[_852 + 96]:
                                    revert with 0, 17
                                if 1000000000000 * 10^18 * mem[_852 + 96] and mem[_852 + 90 len 6] - mem[_852 + 58 len 6] > -1 / 1000000000000 * 10^18 * mem[_852 + 96]:
                                    revert with 0, 17
                                if not mem[_871]:
                                    revert with 0, 18
                                if mem[_852 + 128] > !((1000000000000 * 10^18 * mem[_852 + 90 len 6] * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[_852 + 58 len 6] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871]):
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                    if mem[_221] and mem[_852 + 128] + ((1000000000000 * 10^18 * mem[_852 + 90 len 6] * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[_852 + 58 len 6] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871]) > -1 / mem[_221]:
                                        revert with 0, 17
                                    if (mem[_852 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_852 + 90 len 6] * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[_852 + 58 len 6] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871] * mem[_221]) / 1000000000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if idx >= mem[_635]:
                                        revert with 0, 50
                                    if (mem[_852 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_852 + 90 len 6] * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[_852 + 58 len 6] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871] * mem[_221]) / 1000000000000 * 10^18 < mem[_852 + 160]:
                                        mem[(32 * idx) + _635 + 32] = (mem[_852 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_852 + 90 len 6] * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[_852 + 58 len 6] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871] * mem[_221]) / 1000000000000 * 10^18
                                    else:
                                        mem[(32 * idx) + _635 + 32] = mem[_852 + 160]
                                else:
                                    if idx >= mem[mem[_221 + 32]]:
                                        revert with 0, 50
                                    if mem[_221] and mem[_852 + 128] + ((1000000000000 * 10^18 * mem[_852 + 90 len 6] * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[_852 + 58 len 6] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871]) > -1 / mem[_221]:
                                        revert with 0, 17
                                    if (mem[_852 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_852 + 90 len 6] * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[_852 + 58 len 6] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871] * mem[_221]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_221 + 32] + 32]:
                                        revert with 0, 17
                                    if idx >= mem[_635]:
                                        revert with 0, 50
                                    if ((mem[_852 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_852 + 90 len 6] * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[_852 + 58 len 6] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32] < mem[_852 + 160]:
                                        mem[(32 * idx) + _635 + 32] = ((mem[_852 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_852 + 90 len 6] * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[_852 + 58 len 6] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32]
                                    else:
                                        mem[(32 * idx) + _635 + 32] = mem[_852 + 160]
                        else:
                            if mem[128] > mem[_852 + 58 len 6]:
                                if block.timestamp < mem[128]:
                                    revert with 0, 17
                                if mem[_852 + 96] and 1000000000000 * 10^18 > -1 / mem[_852 + 96]:
                                    revert with 0, 17
                                if 1000000000000 * 10^18 * mem[_852 + 96] and block.timestamp - mem[128] > -1 / 1000000000000 * 10^18 * mem[_852 + 96]:
                                    revert with 0, 17
                                if not mem[_871]:
                                    revert with 0, 18
                                if mem[_852 + 128] > !((1000000000000 * 10^18 * block.timestamp * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871]):
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                    if mem[_221] and mem[_852 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871]) > -1 / mem[_221]:
                                        revert with 0, 17
                                    if (mem[_852 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871] * mem[_221]) / 1000000000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if idx >= mem[_635]:
                                        revert with 0, 50
                                    if (mem[_852 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871] * mem[_221]) / 1000000000000 * 10^18 < mem[_852 + 160]:
                                        mem[(32 * idx) + _635 + 32] = (mem[_852 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871] * mem[_221]) / 1000000000000 * 10^18
                                    else:
                                        mem[(32 * idx) + _635 + 32] = mem[_852 + 160]
                                else:
                                    if idx >= mem[mem[_221 + 32]]:
                                        revert with 0, 50
                                    if mem[_221] and mem[_852 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871]) > -1 / mem[_221]:
                                        revert with 0, 17
                                    if (mem[_852 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871] * mem[_221]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_221 + 32] + 32]:
                                        revert with 0, 17
                                    if idx >= mem[_635]:
                                        revert with 0, 50
                                    if ((mem[_852 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32] < mem[_852 + 160]:
                                        mem[(32 * idx) + _635 + 32] = ((mem[_852 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32]
                                    else:
                                        mem[(32 * idx) + _635 + 32] = mem[_852 + 160]
                            else:
                                if block.timestamp < mem[_852 + 58 len 6]:
                                    revert with 0, 17
                                if mem[_852 + 96] and 1000000000000 * 10^18 > -1 / mem[_852 + 96]:
                                    revert with 0, 17
                                if 1000000000000 * 10^18 * mem[_852 + 96] and block.timestamp - mem[_852 + 58 len 6] > -1 / 1000000000000 * 10^18 * mem[_852 + 96]:
                                    revert with 0, 17
                                if not mem[_871]:
                                    revert with 0, 18
                                if mem[_852 + 128] > !((1000000000000 * 10^18 * block.timestamp * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[_852 + 58 len 6] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871]):
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                    if mem[_221] and mem[_852 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[_852 + 58 len 6] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871]) > -1 / mem[_221]:
                                        revert with 0, 17
                                    if (mem[_852 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[_852 + 58 len 6] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871] * mem[_221]) / 1000000000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if idx >= mem[_635]:
                                        revert with 0, 50
                                    if (mem[_852 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[_852 + 58 len 6] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871] * mem[_221]) / 1000000000000 * 10^18 < mem[_852 + 160]:
                                        mem[(32 * idx) + _635 + 32] = (mem[_852 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[_852 + 58 len 6] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871] * mem[_221]) / 1000000000000 * 10^18
                                    else:
                                        mem[(32 * idx) + _635 + 32] = mem[_852 + 160]
                                else:
                                    if idx >= mem[mem[_221 + 32]]:
                                        revert with 0, 50
                                    if mem[_221] and mem[_852 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[_852 + 58 len 6] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871]) > -1 / mem[_221]:
                                        revert with 0, 17
                                    if (mem[_852 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[_852 + 58 len 6] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871] * mem[_221]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_221 + 32] + 32]:
                                        revert with 0, 17
                                    if idx >= mem[_635]:
                                        revert with 0, 50
                                    if ((mem[_852 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[_852 + 58 len 6] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32] < mem[_852 + 160]:
                                        mem[(32 * idx) + _635 + 32] = ((mem[_852 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_852 + 96]) - (1000000000000 * 10^18 * mem[_852 + 58 len 6] * mem[_852 + 96]) / 168 * 24 * 3600 / mem[_871] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32]
                                    else:
                                        mem[(32 * idx) + _635 + 32] = mem[_852 + 160]
            if idx == -1:
                revert with 0, 17
            _844 = mem[_635]
            idx = idx + 1
            continue 
        mem[mem[64]] = 32
        _862 = mem[_635]
        mem[mem[64] + 32] = mem[_635]
        mem[mem[64] + 64 len 32 * _862] = mem[_635 + 32 len 32 * _862]
        return 32, mem[mem[64] + 32 len (32 * _862) + 32]
    mem[_635 + 32 len 32 * _632] = call.data[calldata.size len 32 * _632]
    if not mem[_221]:
        mem[_635 + (32 * _632) + 32] = 32
        mem[_635 + (32 * _632) + 64] = mem[_635]
        mem[_635 + (32 * _632) + 96 len 32 * mem[_635]] = mem[_635 + 32 len 32 * mem[_635]]
        return memory
          from mem[64]
           len _635 + (32 * _632) + (32 * mem[_635]) + -mem[64] + 96
    _845 = mem[_635]
    idx = 0
    while idx < _845:
        if idx >= mem[mem[96]]:
            revert with 0, 50
        _854 = mem[(32 * idx) + mem[96] + 32]
        if mem[mem[(32 * idx) + mem[96] + 32] + 58 len 6] < block.timestamp:
            if mem[mem[(32 * idx) + mem[96] + 32] + 160] > 0:
                mem[mem[64] + 4] = this.address
                require ext_code.size(arg1)
                staticcall arg1.balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _873 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_854 + 90 len 6] <= mem[128]:
                    if not mem[_873]:
                        revert with 0, 18
                    if mem[_854 + 128] > !(0 / mem[_873]):
                        revert with 0, 17
                    if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                        if mem[_221] and mem[_854 + 128] + (0 / mem[_873]) > -1 / mem[_221]:
                            revert with 0, 17
                        if (mem[_854 + 128] * mem[_221]) + (0 / mem[_873] * mem[_221]) / 1000000000000 * 10^18 < 0:
                            revert with 0, 17
                        if idx >= mem[_635]:
                            revert with 0, 50
                        if (mem[_854 + 128] * mem[_221]) + (0 / mem[_873] * mem[_221]) / 1000000000000 * 10^18 < mem[_854 + 160]:
                            mem[(32 * idx) + _635 + 32] = (mem[_854 + 128] * mem[_221]) + (0 / mem[_873] * mem[_221]) / 1000000000000 * 10^18
                        else:
                            mem[(32 * idx) + _635 + 32] = mem[_854 + 160]
                    else:
                        if idx >= mem[mem[_221 + 32]]:
                            revert with 0, 50
                        if mem[_221] and mem[_854 + 128] + (0 / mem[_873]) > -1 / mem[_221]:
                            revert with 0, 17
                        if (mem[_854 + 128] * mem[_221]) + (0 / mem[_873] * mem[_221]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_221 + 32] + 32]:
                            revert with 0, 17
                        if idx >= mem[_635]:
                            revert with 0, 50
                        if ((mem[_854 + 128] * mem[_221]) + (0 / mem[_873] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32] < mem[_854 + 160]:
                            mem[(32 * idx) + _635 + 32] = ((mem[_854 + 128] * mem[_221]) + (0 / mem[_873] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32]
                        else:
                            mem[(32 * idx) + _635 + 32] = mem[_854 + 160]
                else:
                    if block.timestamp > mem[_854 + 90 len 6]:
                        if mem[128] > mem[_854 + 58 len 6]:
                            if mem[_854 + 90 len 6] < mem[128]:
                                revert with 0, 17
                            if mem[_854 + 96] and 1000000000000 * 10^18 > -1 / mem[_854 + 96]:
                                revert with 0, 17
                            if 1000000000000 * 10^18 * mem[_854 + 96] and mem[_854 + 90 len 6] - mem[128] > -1 / 1000000000000 * 10^18 * mem[_854 + 96]:
                                revert with 0, 17
                            if not mem[_873]:
                                revert with 0, 18
                            if mem[_854 + 128] > !((1000000000000 * 10^18 * mem[_854 + 90 len 6] * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873]):
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                if mem[_221] and mem[_854 + 128] + ((1000000000000 * 10^18 * mem[_854 + 90 len 6] * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873]) > -1 / mem[_221]:
                                    revert with 0, 17
                                if (mem[_854 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_854 + 90 len 6] * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873] * mem[_221]) / 1000000000000 * 10^18 < 0:
                                    revert with 0, 17
                                if idx >= mem[_635]:
                                    revert with 0, 50
                                if (mem[_854 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_854 + 90 len 6] * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873] * mem[_221]) / 1000000000000 * 10^18 < mem[_854 + 160]:
                                    mem[(32 * idx) + _635 + 32] = (mem[_854 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_854 + 90 len 6] * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873] * mem[_221]) / 1000000000000 * 10^18
                                else:
                                    mem[(32 * idx) + _635 + 32] = mem[_854 + 160]
                            else:
                                if idx >= mem[mem[_221 + 32]]:
                                    revert with 0, 50
                                if mem[_221] and mem[_854 + 128] + ((1000000000000 * 10^18 * mem[_854 + 90 len 6] * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873]) > -1 / mem[_221]:
                                    revert with 0, 17
                                if (mem[_854 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_854 + 90 len 6] * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873] * mem[_221]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_221 + 32] + 32]:
                                    revert with 0, 17
                                if idx >= mem[_635]:
                                    revert with 0, 50
                                if ((mem[_854 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_854 + 90 len 6] * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32] < mem[_854 + 160]:
                                    mem[(32 * idx) + _635 + 32] = ((mem[_854 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_854 + 90 len 6] * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32]
                                else:
                                    mem[(32 * idx) + _635 + 32] = mem[_854 + 160]
                        else:
                            if mem[_854 + 90 len 6] < mem[_854 + 58 len 6]:
                                revert with 0, 17
                            if mem[_854 + 96] and 1000000000000 * 10^18 > -1 / mem[_854 + 96]:
                                revert with 0, 17
                            if 1000000000000 * 10^18 * mem[_854 + 96] and mem[_854 + 90 len 6] - mem[_854 + 58 len 6] > -1 / 1000000000000 * 10^18 * mem[_854 + 96]:
                                revert with 0, 17
                            if not mem[_873]:
                                revert with 0, 18
                            if mem[_854 + 128] > !((1000000000000 * 10^18 * mem[_854 + 90 len 6] * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[_854 + 58 len 6] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873]):
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                if mem[_221] and mem[_854 + 128] + ((1000000000000 * 10^18 * mem[_854 + 90 len 6] * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[_854 + 58 len 6] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873]) > -1 / mem[_221]:
                                    revert with 0, 17
                                if (mem[_854 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_854 + 90 len 6] * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[_854 + 58 len 6] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873] * mem[_221]) / 1000000000000 * 10^18 < 0:
                                    revert with 0, 17
                                if idx >= mem[_635]:
                                    revert with 0, 50
                                if (mem[_854 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_854 + 90 len 6] * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[_854 + 58 len 6] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873] * mem[_221]) / 1000000000000 * 10^18 < mem[_854 + 160]:
                                    mem[(32 * idx) + _635 + 32] = (mem[_854 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_854 + 90 len 6] * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[_854 + 58 len 6] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873] * mem[_221]) / 1000000000000 * 10^18
                                else:
                                    mem[(32 * idx) + _635 + 32] = mem[_854 + 160]
                            else:
                                if idx >= mem[mem[_221 + 32]]:
                                    revert with 0, 50
                                if mem[_221] and mem[_854 + 128] + ((1000000000000 * 10^18 * mem[_854 + 90 len 6] * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[_854 + 58 len 6] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873]) > -1 / mem[_221]:
                                    revert with 0, 17
                                if (mem[_854 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_854 + 90 len 6] * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[_854 + 58 len 6] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873] * mem[_221]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_221 + 32] + 32]:
                                    revert with 0, 17
                                if idx >= mem[_635]:
                                    revert with 0, 50
                                if ((mem[_854 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_854 + 90 len 6] * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[_854 + 58 len 6] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32] < mem[_854 + 160]:
                                    mem[(32 * idx) + _635 + 32] = ((mem[_854 + 128] * mem[_221]) + ((1000000000000 * 10^18 * mem[_854 + 90 len 6] * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[_854 + 58 len 6] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32]
                                else:
                                    mem[(32 * idx) + _635 + 32] = mem[_854 + 160]
                    else:
                        if mem[128] > mem[_854 + 58 len 6]:
                            if block.timestamp < mem[128]:
                                revert with 0, 17
                            if mem[_854 + 96] and 1000000000000 * 10^18 > -1 / mem[_854 + 96]:
                                revert with 0, 17
                            if 1000000000000 * 10^18 * mem[_854 + 96] and block.timestamp - mem[128] > -1 / 1000000000000 * 10^18 * mem[_854 + 96]:
                                revert with 0, 17
                            if not mem[_873]:
                                revert with 0, 18
                            if mem[_854 + 128] > !((1000000000000 * 10^18 * block.timestamp * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873]):
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                if mem[_221] and mem[_854 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873]) > -1 / mem[_221]:
                                    revert with 0, 17
                                if (mem[_854 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873] * mem[_221]) / 1000000000000 * 10^18 < 0:
                                    revert with 0, 17
                                if idx >= mem[_635]:
                                    revert with 0, 50
                                if (mem[_854 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873] * mem[_221]) / 1000000000000 * 10^18 < mem[_854 + 160]:
                                    mem[(32 * idx) + _635 + 32] = (mem[_854 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873] * mem[_221]) / 1000000000000 * 10^18
                                else:
                                    mem[(32 * idx) + _635 + 32] = mem[_854 + 160]
                            else:
                                if idx >= mem[mem[_221 + 32]]:
                                    revert with 0, 50
                                if mem[_221] and mem[_854 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873]) > -1 / mem[_221]:
                                    revert with 0, 17
                                if (mem[_854 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873] * mem[_221]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_221 + 32] + 32]:
                                    revert with 0, 17
                                if idx >= mem[_635]:
                                    revert with 0, 50
                                if ((mem[_854 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32] < mem[_854 + 160]:
                                    mem[(32 * idx) + _635 + 32] = ((mem[_854 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[128] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32]
                                else:
                                    mem[(32 * idx) + _635 + 32] = mem[_854 + 160]
                        else:
                            if block.timestamp < mem[_854 + 58 len 6]:
                                revert with 0, 17
                            if mem[_854 + 96] and 1000000000000 * 10^18 > -1 / mem[_854 + 96]:
                                revert with 0, 17
                            if 1000000000000 * 10^18 * mem[_854 + 96] and block.timestamp - mem[_854 + 58 len 6] > -1 / 1000000000000 * 10^18 * mem[_854 + 96]:
                                revert with 0, 17
                            if not mem[_873]:
                                revert with 0, 18
                            if mem[_854 + 128] > !((1000000000000 * 10^18 * block.timestamp * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[_854 + 58 len 6] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873]):
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                if mem[_221] and mem[_854 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[_854 + 58 len 6] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873]) > -1 / mem[_221]:
                                    revert with 0, 17
                                if (mem[_854 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[_854 + 58 len 6] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873] * mem[_221]) / 1000000000000 * 10^18 < 0:
                                    revert with 0, 17
                                if idx >= mem[_635]:
                                    revert with 0, 50
                                if (mem[_854 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[_854 + 58 len 6] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873] * mem[_221]) / 1000000000000 * 10^18 < mem[_854 + 160]:
                                    mem[(32 * idx) + _635 + 32] = (mem[_854 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[_854 + 58 len 6] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873] * mem[_221]) / 1000000000000 * 10^18
                                else:
                                    mem[(32 * idx) + _635 + 32] = mem[_854 + 160]
                            else:
                                if idx >= mem[mem[_221 + 32]]:
                                    revert with 0, 50
                                if mem[_221] and mem[_854 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[_854 + 58 len 6] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873]) > -1 / mem[_221]:
                                    revert with 0, 17
                                if (mem[_854 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[_854 + 58 len 6] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873] * mem[_221]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_221 + 32] + 32]:
                                    revert with 0, 17
                                if idx >= mem[_635]:
                                    revert with 0, 50
                                if ((mem[_854 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[_854 + 58 len 6] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32] < mem[_854 + 160]:
                                    mem[(32 * idx) + _635 + 32] = ((mem[_854 + 128] * mem[_221]) + ((1000000000000 * 10^18 * block.timestamp * mem[_854 + 96]) - (1000000000000 * 10^18 * mem[_854 + 58 len 6] * mem[_854 + 96]) / 168 * 24 * 3600 / mem[_873] * mem[_221]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_221 + 32] + 32]
                                else:
                                    mem[(32 * idx) + _635 + 32] = mem[_854 + 160]
        if idx == -1:
            revert with 0, 17
        _845 = mem[_635]
        idx = idx + 1
        continue 
    mem[mem[64]] = 32
    _864 = mem[_635]
    mem[mem[64] + 32] = mem[_635]
    mem[mem[64] + 64 len 32 * _864] = mem[_635 + 32 len 32 * _864]
    return 32, mem[mem[64] + 32 len (32 * _864) + 32]
}

function getUser(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    mem[96] = 0
    mem[128] = 96
    mem[64] = (32 * uint256(stor5[address(arg1)].field_0)) + 256
    mem[224] = uint256(stor5[address(arg1)].field_0)
    s = 256
    idx = 0
    while idx < uint256(stor5[address(arg1)].field_0):
        mem[0] = sha3(address(arg1), 5)
        _255 = mem[64]
        mem[64] = mem[64] + 192
        mem[_255] = address(stor5[address(arg1)][idx].field_0)
        mem[_255 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
        mem[_255 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
        mem[_255 + 96] = uint256(stor5[address(arg1)][idx].field_256)
        mem[_255 + 128] = uint256(stor5[address(arg1)][idx].field_512)
        mem[_255 + 160] = uint256(stor5[address(arg1)][idx].field_768)
        mem[s] = _255
        s = s + 32
        idx = idx + 1
        continue 
    mem[160] = 224
    mem[192] = uint256(stor5[address(arg1)].field_256)
    mem[0] = arg2
    mem[32] = sha3(address(arg1), 6)
    _252 = mem[64]
    mem[64] = mem[64] + 64
    mem[_252] = uint256(stor6[address(arg1)][address(arg2)].field_0)
    _253 = mem[64]
    mem[64] = mem[64] + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 32
    mem[_253] = uint256(stor6[address(arg1)][address(arg2)].field_256)
    if not uint256(stor6[address(arg1)][address(arg2)].field_256):
        mem[_252 + 32] = _253
        _257 = mem[224]
        if mem[224] > test266151307():
            revert with 0, 65
        _259 = mem[64]
        mem[mem[64]] = mem[224]
        mem[64] = mem[64] + (32 * _257) + 32
        if not _257:
            if not uint256(stor6[address(arg1)][address(arg2)].field_0):
                mem[_259 + (32 * _257) + 32] = uint256(stor6[address(arg1)][address(arg2)].field_0)
                mem[64] = _259 + (32 * _257) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 128
                mem[_259 + (32 * _257) + 96] = uint256(stor6[address(arg1)][address(arg2)].field_256)
                if not uint256(stor6[address(arg1)][address(arg2)].field_256):
                    mem[_259 + (32 * _257) + 64] = _259 + (32 * _257) + 96
                    mem[_259 + (32 * _257) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 128] = 64
                    mem[_259 + (32 * _257) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 192] = uint256(stor6[address(arg1)][address(arg2)].field_0)
                    mem[_259 + (32 * _257) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 224] = 64
                    mem[_259 + (32 * _257) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 256] = uint256(stor6[address(arg1)][address(arg2)].field_256)
                    mem[_259 + (32 * _257) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 288 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)] = mem[_259 + (32 * _257) + 128 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)]
                    var31001 = uint256(stor6[address(arg1)][address(arg2)].field_256)
                    var31002 = _259 + (32 * _257) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 128
                else:
                    mem[0] = sha3(address(arg2), sha3(address(arg1), 6)) + 1
                    mem[_259 + (32 * _257) + 128] = uint256(stor6[address(arg1)][address(arg2)][1].field_0)
                    idx = _259 + (32 * _257) + 128
                    s = 0
                    while _259 + (32 * _257) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 96 > idx:
                        mem[idx + 32] = uint256(stor6[address(arg1)][address(arg2)][s + 1].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[_259 + (32 * _257) + 64] = _259 + (32 * _257) + 96
                    mem[_259 + (32 * _257) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 128] = 64
                    mem[_259 + (32 * _257) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 192] = uint256(stor6[address(arg1)][address(arg2)].field_0)
                    mem[_259 + (32 * _257) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 224] = 64
                    mem[_259 + (32 * _257) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 256] = uint256(stor6[address(arg1)][address(arg2)].field_256)
                    mem[_259 + (32 * _257) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 288 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)] = mem[_259 + (32 * _257) + 128 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)]
                mem[_259 + (32 * _257) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160] = (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160
                mem[_259 + (32 * _257) + (64 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 288] = mem[_259]
                mem[_259 + (32 * _257) + (64 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 320 len 32 * mem[_259]] = mem[_259 + 32 len 32 * mem[_259]]
                return 64, 
                       (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160,
                       uint256(stor6[address(arg1)][address(arg2)].field_0),
                       64,
                       uint256(stor6[address(arg1)][address(arg2)].field_256),
                       mem[_259 + (32 * _257) + 128 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)],
                       mem[_259 + (32 * _257) + (64 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 288 len (32 * mem[_259]) + 32]
            _494 = mem[_259]
            idx = 0
            while idx < _494:
                if idx >= mem[mem[160]]:
                    revert with 0, 50
                _502 = mem[(32 * idx) + mem[160] + 32]
                if mem[mem[(32 * idx) + mem[160] + 32] + 58 len 6] < block.timestamp:
                    if mem[mem[(32 * idx) + mem[160] + 32] + 160] > 0:
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(arg1)
                        staticcall arg1.balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _532 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_502 + 90 len 6] <= mem[192]:
                            if not mem[_532]:
                                revert with 0, 18
                            if mem[_502 + 128] > !(0 / mem[_532]):
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                if mem[_252] and mem[_502 + 128] + (0 / mem[_532]) > -1 / mem[_252]:
                                    revert with 0, 17
                                if (mem[_502 + 128] * mem[_252]) + (0 / mem[_532] * mem[_252]) / 1000000000000 * 10^18 < 0:
                                    revert with 0, 17
                                if idx >= mem[_259]:
                                    revert with 0, 50
                                if (mem[_502 + 128] * mem[_252]) + (0 / mem[_532] * mem[_252]) / 1000000000000 * 10^18 < mem[_502 + 160]:
                                    mem[(32 * idx) + _259 + 32] = (mem[_502 + 128] * mem[_252]) + (0 / mem[_532] * mem[_252]) / 1000000000000 * 10^18
                                else:
                                    mem[(32 * idx) + _259 + 32] = mem[_502 + 160]
                            else:
                                if idx >= mem[mem[_252 + 32]]:
                                    revert with 0, 50
                                if mem[_252] and mem[_502 + 128] + (0 / mem[_532]) > -1 / mem[_252]:
                                    revert with 0, 17
                                if (mem[_502 + 128] * mem[_252]) + (0 / mem[_532] * mem[_252]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_252 + 32] + 32]:
                                    revert with 0, 17
                                if idx >= mem[_259]:
                                    revert with 0, 50
                                if ((mem[_502 + 128] * mem[_252]) + (0 / mem[_532] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32] < mem[_502 + 160]:
                                    mem[(32 * idx) + _259 + 32] = ((mem[_502 + 128] * mem[_252]) + (0 / mem[_532] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32]
                                else:
                                    mem[(32 * idx) + _259 + 32] = mem[_502 + 160]
                        else:
                            if block.timestamp > mem[_502 + 90 len 6]:
                                if mem[192] > mem[_502 + 58 len 6]:
                                    if mem[_502 + 90 len 6] < mem[192]:
                                        revert with 0, 17
                                    if mem[_502 + 96] and 1000000000000 * 10^18 > -1 / mem[_502 + 96]:
                                        revert with 0, 17
                                    if 1000000000000 * 10^18 * mem[_502 + 96] and mem[_502 + 90 len 6] - mem[192] > -1 / 1000000000000 * 10^18 * mem[_502 + 96]:
                                        revert with 0, 17
                                    if not mem[_532]:
                                        revert with 0, 18
                                    if mem[_502 + 128] > !((1000000000000 * 10^18 * mem[_502 + 90 len 6] * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532]):
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                        if mem[_252] and mem[_502 + 128] + ((1000000000000 * 10^18 * mem[_502 + 90 len 6] * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532]) > -1 / mem[_252]:
                                            revert with 0, 17
                                        if (mem[_502 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_502 + 90 len 6] * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532] * mem[_252]) / 1000000000000 * 10^18 < 0:
                                            revert with 0, 17
                                        if idx >= mem[_259]:
                                            revert with 0, 50
                                        if (mem[_502 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_502 + 90 len 6] * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532] * mem[_252]) / 1000000000000 * 10^18 < mem[_502 + 160]:
                                            mem[(32 * idx) + _259 + 32] = (mem[_502 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_502 + 90 len 6] * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532] * mem[_252]) / 1000000000000 * 10^18
                                        else:
                                            mem[(32 * idx) + _259 + 32] = mem[_502 + 160]
                                    else:
                                        if idx >= mem[mem[_252 + 32]]:
                                            revert with 0, 50
                                        if mem[_252] and mem[_502 + 128] + ((1000000000000 * 10^18 * mem[_502 + 90 len 6] * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532]) > -1 / mem[_252]:
                                            revert with 0, 17
                                        if (mem[_502 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_502 + 90 len 6] * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532] * mem[_252]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_252 + 32] + 32]:
                                            revert with 0, 17
                                        if idx >= mem[_259]:
                                            revert with 0, 50
                                        if ((mem[_502 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_502 + 90 len 6] * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32] < mem[_502 + 160]:
                                            mem[(32 * idx) + _259 + 32] = ((mem[_502 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_502 + 90 len 6] * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32]
                                        else:
                                            mem[(32 * idx) + _259 + 32] = mem[_502 + 160]
                                else:
                                    if mem[_502 + 90 len 6] < mem[_502 + 58 len 6]:
                                        revert with 0, 17
                                    if mem[_502 + 96] and 1000000000000 * 10^18 > -1 / mem[_502 + 96]:
                                        revert with 0, 17
                                    if 1000000000000 * 10^18 * mem[_502 + 96] and mem[_502 + 90 len 6] - mem[_502 + 58 len 6] > -1 / 1000000000000 * 10^18 * mem[_502 + 96]:
                                        revert with 0, 17
                                    if not mem[_532]:
                                        revert with 0, 18
                                    if mem[_502 + 128] > !((1000000000000 * 10^18 * mem[_502 + 90 len 6] * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[_502 + 58 len 6] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532]):
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                        if mem[_252] and mem[_502 + 128] + ((1000000000000 * 10^18 * mem[_502 + 90 len 6] * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[_502 + 58 len 6] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532]) > -1 / mem[_252]:
                                            revert with 0, 17
                                        if (mem[_502 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_502 + 90 len 6] * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[_502 + 58 len 6] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532] * mem[_252]) / 1000000000000 * 10^18 < 0:
                                            revert with 0, 17
                                        if idx >= mem[_259]:
                                            revert with 0, 50
                                        if (mem[_502 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_502 + 90 len 6] * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[_502 + 58 len 6] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532] * mem[_252]) / 1000000000000 * 10^18 < mem[_502 + 160]:
                                            mem[(32 * idx) + _259 + 32] = (mem[_502 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_502 + 90 len 6] * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[_502 + 58 len 6] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532] * mem[_252]) / 1000000000000 * 10^18
                                        else:
                                            mem[(32 * idx) + _259 + 32] = mem[_502 + 160]
                                    else:
                                        if idx >= mem[mem[_252 + 32]]:
                                            revert with 0, 50
                                        if mem[_252] and mem[_502 + 128] + ((1000000000000 * 10^18 * mem[_502 + 90 len 6] * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[_502 + 58 len 6] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532]) > -1 / mem[_252]:
                                            revert with 0, 17
                                        if (mem[_502 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_502 + 90 len 6] * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[_502 + 58 len 6] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532] * mem[_252]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_252 + 32] + 32]:
                                            revert with 0, 17
                                        if idx >= mem[_259]:
                                            revert with 0, 50
                                        if ((mem[_502 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_502 + 90 len 6] * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[_502 + 58 len 6] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32] < mem[_502 + 160]:
                                            mem[(32 * idx) + _259 + 32] = ((mem[_502 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_502 + 90 len 6] * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[_502 + 58 len 6] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32]
                                        else:
                                            mem[(32 * idx) + _259 + 32] = mem[_502 + 160]
                            else:
                                if mem[192] > mem[_502 + 58 len 6]:
                                    if block.timestamp < mem[192]:
                                        revert with 0, 17
                                    if mem[_502 + 96] and 1000000000000 * 10^18 > -1 / mem[_502 + 96]:
                                        revert with 0, 17
                                    if 1000000000000 * 10^18 * mem[_502 + 96] and block.timestamp - mem[192] > -1 / 1000000000000 * 10^18 * mem[_502 + 96]:
                                        revert with 0, 17
                                    if not mem[_532]:
                                        revert with 0, 18
                                    if mem[_502 + 128] > !((1000000000000 * 10^18 * block.timestamp * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532]):
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                        if mem[_252] and mem[_502 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532]) > -1 / mem[_252]:
                                            revert with 0, 17
                                        if (mem[_502 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532] * mem[_252]) / 1000000000000 * 10^18 < 0:
                                            revert with 0, 17
                                        if idx >= mem[_259]:
                                            revert with 0, 50
                                        if (mem[_502 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532] * mem[_252]) / 1000000000000 * 10^18 < mem[_502 + 160]:
                                            mem[(32 * idx) + _259 + 32] = (mem[_502 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532] * mem[_252]) / 1000000000000 * 10^18
                                        else:
                                            mem[(32 * idx) + _259 + 32] = mem[_502 + 160]
                                    else:
                                        if idx >= mem[mem[_252 + 32]]:
                                            revert with 0, 50
                                        if mem[_252] and mem[_502 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532]) > -1 / mem[_252]:
                                            revert with 0, 17
                                        if (mem[_502 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532] * mem[_252]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_252 + 32] + 32]:
                                            revert with 0, 17
                                        if idx >= mem[_259]:
                                            revert with 0, 50
                                        if ((mem[_502 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32] < mem[_502 + 160]:
                                            mem[(32 * idx) + _259 + 32] = ((mem[_502 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32]
                                        else:
                                            mem[(32 * idx) + _259 + 32] = mem[_502 + 160]
                                else:
                                    if block.timestamp < mem[_502 + 58 len 6]:
                                        revert with 0, 17
                                    if mem[_502 + 96] and 1000000000000 * 10^18 > -1 / mem[_502 + 96]:
                                        revert with 0, 17
                                    if 1000000000000 * 10^18 * mem[_502 + 96] and block.timestamp - mem[_502 + 58 len 6] > -1 / 1000000000000 * 10^18 * mem[_502 + 96]:
                                        revert with 0, 17
                                    if not mem[_532]:
                                        revert with 0, 18
                                    if mem[_502 + 128] > !((1000000000000 * 10^18 * block.timestamp * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[_502 + 58 len 6] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532]):
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                        if mem[_252] and mem[_502 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[_502 + 58 len 6] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532]) > -1 / mem[_252]:
                                            revert with 0, 17
                                        if (mem[_502 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[_502 + 58 len 6] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532] * mem[_252]) / 1000000000000 * 10^18 < 0:
                                            revert with 0, 17
                                        if idx >= mem[_259]:
                                            revert with 0, 50
                                        if (mem[_502 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[_502 + 58 len 6] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532] * mem[_252]) / 1000000000000 * 10^18 < mem[_502 + 160]:
                                            mem[(32 * idx) + _259 + 32] = (mem[_502 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[_502 + 58 len 6] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532] * mem[_252]) / 1000000000000 * 10^18
                                        else:
                                            mem[(32 * idx) + _259 + 32] = mem[_502 + 160]
                                    else:
                                        if idx >= mem[mem[_252 + 32]]:
                                            revert with 0, 50
                                        if mem[_252] and mem[_502 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[_502 + 58 len 6] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532]) > -1 / mem[_252]:
                                            revert with 0, 17
                                        if (mem[_502 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[_502 + 58 len 6] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532] * mem[_252]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_252 + 32] + 32]:
                                            revert with 0, 17
                                        if idx >= mem[_259]:
                                            revert with 0, 50
                                        if ((mem[_502 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[_502 + 58 len 6] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32] < mem[_502 + 160]:
                                            mem[(32 * idx) + _259 + 32] = ((mem[_502 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_502 + 96]) - (1000000000000 * 10^18 * mem[_502 + 58 len 6] * mem[_502 + 96]) / 168 * 24 * 3600 / mem[_532] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32]
                                        else:
                                            mem[(32 * idx) + _259 + 32] = mem[_502 + 160]
                if idx == -1:
                    revert with 0, 17
                _494 = mem[_259]
                idx = idx + 1
                continue 
            _506 = mem[64]
            mem[64] = mem[64] + 64
            mem[_506] = uint256(stor6[address(arg1)][address(arg2)].field_0)
            _507 = mem[64]
            mem[64] = mem[64] + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 32
            mem[_507] = uint256(stor6[address(arg1)][address(arg2)].field_256)
            if not uint256(stor6[address(arg1)][address(arg2)].field_256):
                mem[_506 + 32] = _507
                _520 = mem[64]
                mem[mem[64]] = 64
                mem[mem[64] + 64] = uint256(stor6[address(arg1)][address(arg2)].field_0)
                mem[mem[64] + 96] = 64
                mem[mem[64] + 128] = uint256(stor6[address(arg1)][address(arg2)].field_256)
                mem[mem[64] + 160 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)] = mem[_507 + 32 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)]
                var34001 = uint256(stor6[address(arg1)][address(arg2)].field_256)
                var34002 = _507 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 32
                mem[mem[64] + 32] = (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160
                _718 = mem[_259]
                mem[_520 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160] = mem[_259]
                mem[_520 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 192 len 32 * _718] = mem[_259 + 32 len 32 * _718]
                return memory
                  from mem[64]
                   len _520 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + (32 * _718) + -mem[64] + 192
            mem[0] = sha3(address(arg2), sha3(address(arg1), 6)) + 1
            mem[_507 + 32] = uint256(stor6[address(arg1)][address(arg2)][1].field_0)
            idx = _507 + 32
            s = 0
            while _507 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) > idx:
                mem[idx + 32] = uint256(stor6[address(arg1)][address(arg2)][s + 1].field_256)
                idx = idx + 32
                s = s + 1
                continue 
            mem[_506 + 32] = _507
            _985 = mem[64]
            mem[mem[64]] = 64
            mem[mem[64] + 64] = mem[_506]
            mem[mem[64] + 96] = 64
            mem[mem[64] + 128] = uint256(stor6[address(arg1)][address(arg2)].field_256)
            mem[mem[64] + 160 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)] = mem[_507 + 32 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)]
            mem[mem[64] + 32] = (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160
            _1225 = mem[_259]
            mem[_985 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160] = mem[_259]
            mem[_985 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 192 len 32 * _1225] = mem[_259 + 32 len 32 * _1225]
            return memory
              from mem[64]
               len _985 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + (32 * _1225) + -mem[64] + 192
        mem[_259 + 32 len 32 * _257] = call.data[calldata.size len 32 * _257]
        if not uint256(stor6[address(arg1)][address(arg2)].field_0):
            mem[_259 + (32 * _257) + 32] = uint256(stor6[address(arg1)][address(arg2)].field_0)
            mem[64] = _259 + (32 * _257) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 128
            mem[_259 + (32 * _257) + 96] = uint256(stor6[address(arg1)][address(arg2)].field_256)
            if uint256(stor6[address(arg1)][address(arg2)].field_256):
                mem[0] = sha3(address(arg2), sha3(address(arg1), 6)) + 1
                mem[_259 + (32 * _257) + 128] = uint256(stor6[address(arg1)][address(arg2)][1].field_0)
                idx = _259 + (32 * _257) + 128
                s = 0
                while _259 + (32 * _257) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 96 > idx:
                    mem[idx + 32] = uint256(stor6[address(arg1)][address(arg2)][s + 1].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
            mem[_259 + (32 * _257) + 64] = _259 + (32 * _257) + 96
            mem[_259 + (32 * _257) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 128] = 64
            mem[_259 + (32 * _257) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 192] = uint256(stor6[address(arg1)][address(arg2)].field_0)
            mem[_259 + (32 * _257) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 224] = 64
            mem[_259 + (32 * _257) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 256] = uint256(stor6[address(arg1)][address(arg2)].field_256)
            mem[_259 + (32 * _257) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 288 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)] = mem[_259 + (32 * _257) + 128 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)]
            mem[_259 + (32 * _257) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160] = (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160
            mem[_259 + (32 * _257) + (64 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 288] = mem[_259]
            mem[_259 + (32 * _257) + (64 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 320 len 32 * mem[_259]] = mem[_259 + 32 len 32 * mem[_259]]
            return 64, 
                   (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160,
                   uint256(stor6[address(arg1)][address(arg2)].field_0),
                   64,
                   uint256(stor6[address(arg1)][address(arg2)].field_256),
                   mem[_259 + (32 * _257) + 128 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)],
                   mem[_259 + (32 * _257) + (64 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 288 len (32 * mem[_259]) + 32]
        _495 = mem[_259]
        idx = 0
        while idx < _495:
            if idx >= mem[mem[160]]:
                revert with 0, 50
            _504 = mem[(32 * idx) + mem[160] + 32]
            if mem[mem[(32 * idx) + mem[160] + 32] + 58 len 6] < block.timestamp:
                if mem[mem[(32 * idx) + mem[160] + 32] + 160] > 0:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(arg1)
                    staticcall arg1.balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _533 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_504 + 90 len 6] <= mem[192]:
                        if not mem[_533]:
                            revert with 0, 18
                        if mem[_504 + 128] > !(0 / mem[_533]):
                            revert with 0, 17
                        if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                            if mem[_252] and mem[_504 + 128] + (0 / mem[_533]) > -1 / mem[_252]:
                                revert with 0, 17
                            if (mem[_504 + 128] * mem[_252]) + (0 / mem[_533] * mem[_252]) / 1000000000000 * 10^18 < 0:
                                revert with 0, 17
                            if idx >= mem[_259]:
                                revert with 0, 50
                            if (mem[_504 + 128] * mem[_252]) + (0 / mem[_533] * mem[_252]) / 1000000000000 * 10^18 < mem[_504 + 160]:
                                mem[(32 * idx) + _259 + 32] = (mem[_504 + 128] * mem[_252]) + (0 / mem[_533] * mem[_252]) / 1000000000000 * 10^18
                            else:
                                mem[(32 * idx) + _259 + 32] = mem[_504 + 160]
                        else:
                            if idx >= mem[mem[_252 + 32]]:
                                revert with 0, 50
                            if mem[_252] and mem[_504 + 128] + (0 / mem[_533]) > -1 / mem[_252]:
                                revert with 0, 17
                            if (mem[_504 + 128] * mem[_252]) + (0 / mem[_533] * mem[_252]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_252 + 32] + 32]:
                                revert with 0, 17
                            if idx >= mem[_259]:
                                revert with 0, 50
                            if ((mem[_504 + 128] * mem[_252]) + (0 / mem[_533] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32] < mem[_504 + 160]:
                                mem[(32 * idx) + _259 + 32] = ((mem[_504 + 128] * mem[_252]) + (0 / mem[_533] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32]
                            else:
                                mem[(32 * idx) + _259 + 32] = mem[_504 + 160]
                    else:
                        if block.timestamp > mem[_504 + 90 len 6]:
                            if mem[192] > mem[_504 + 58 len 6]:
                                if mem[_504 + 90 len 6] < mem[192]:
                                    revert with 0, 17
                                if mem[_504 + 96] and 1000000000000 * 10^18 > -1 / mem[_504 + 96]:
                                    revert with 0, 17
                                if 1000000000000 * 10^18 * mem[_504 + 96] and mem[_504 + 90 len 6] - mem[192] > -1 / 1000000000000 * 10^18 * mem[_504 + 96]:
                                    revert with 0, 17
                                if not mem[_533]:
                                    revert with 0, 18
                                if mem[_504 + 128] > !((1000000000000 * 10^18 * mem[_504 + 90 len 6] * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533]):
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                    if mem[_252] and mem[_504 + 128] + ((1000000000000 * 10^18 * mem[_504 + 90 len 6] * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533]) > -1 / mem[_252]:
                                        revert with 0, 17
                                    if (mem[_504 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_504 + 90 len 6] * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533] * mem[_252]) / 1000000000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if idx >= mem[_259]:
                                        revert with 0, 50
                                    if (mem[_504 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_504 + 90 len 6] * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533] * mem[_252]) / 1000000000000 * 10^18 < mem[_504 + 160]:
                                        mem[(32 * idx) + _259 + 32] = (mem[_504 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_504 + 90 len 6] * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533] * mem[_252]) / 1000000000000 * 10^18
                                    else:
                                        mem[(32 * idx) + _259 + 32] = mem[_504 + 160]
                                else:
                                    if idx >= mem[mem[_252 + 32]]:
                                        revert with 0, 50
                                    if mem[_252] and mem[_504 + 128] + ((1000000000000 * 10^18 * mem[_504 + 90 len 6] * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533]) > -1 / mem[_252]:
                                        revert with 0, 17
                                    if (mem[_504 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_504 + 90 len 6] * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533] * mem[_252]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_252 + 32] + 32]:
                                        revert with 0, 17
                                    if idx >= mem[_259]:
                                        revert with 0, 50
                                    if ((mem[_504 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_504 + 90 len 6] * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32] < mem[_504 + 160]:
                                        mem[(32 * idx) + _259 + 32] = ((mem[_504 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_504 + 90 len 6] * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32]
                                    else:
                                        mem[(32 * idx) + _259 + 32] = mem[_504 + 160]
                            else:
                                if mem[_504 + 90 len 6] < mem[_504 + 58 len 6]:
                                    revert with 0, 17
                                if mem[_504 + 96] and 1000000000000 * 10^18 > -1 / mem[_504 + 96]:
                                    revert with 0, 17
                                if 1000000000000 * 10^18 * mem[_504 + 96] and mem[_504 + 90 len 6] - mem[_504 + 58 len 6] > -1 / 1000000000000 * 10^18 * mem[_504 + 96]:
                                    revert with 0, 17
                                if not mem[_533]:
                                    revert with 0, 18
                                if mem[_504 + 128] > !((1000000000000 * 10^18 * mem[_504 + 90 len 6] * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[_504 + 58 len 6] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533]):
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                    if mem[_252] and mem[_504 + 128] + ((1000000000000 * 10^18 * mem[_504 + 90 len 6] * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[_504 + 58 len 6] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533]) > -1 / mem[_252]:
                                        revert with 0, 17
                                    if (mem[_504 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_504 + 90 len 6] * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[_504 + 58 len 6] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533] * mem[_252]) / 1000000000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if idx >= mem[_259]:
                                        revert with 0, 50
                                    if (mem[_504 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_504 + 90 len 6] * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[_504 + 58 len 6] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533] * mem[_252]) / 1000000000000 * 10^18 < mem[_504 + 160]:
                                        mem[(32 * idx) + _259 + 32] = (mem[_504 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_504 + 90 len 6] * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[_504 + 58 len 6] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533] * mem[_252]) / 1000000000000 * 10^18
                                    else:
                                        mem[(32 * idx) + _259 + 32] = mem[_504 + 160]
                                else:
                                    if idx >= mem[mem[_252 + 32]]:
                                        revert with 0, 50
                                    if mem[_252] and mem[_504 + 128] + ((1000000000000 * 10^18 * mem[_504 + 90 len 6] * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[_504 + 58 len 6] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533]) > -1 / mem[_252]:
                                        revert with 0, 17
                                    if (mem[_504 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_504 + 90 len 6] * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[_504 + 58 len 6] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533] * mem[_252]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_252 + 32] + 32]:
                                        revert with 0, 17
                                    if idx >= mem[_259]:
                                        revert with 0, 50
                                    if ((mem[_504 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_504 + 90 len 6] * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[_504 + 58 len 6] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32] < mem[_504 + 160]:
                                        mem[(32 * idx) + _259 + 32] = ((mem[_504 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_504 + 90 len 6] * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[_504 + 58 len 6] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32]
                                    else:
                                        mem[(32 * idx) + _259 + 32] = mem[_504 + 160]
                        else:
                            if mem[192] > mem[_504 + 58 len 6]:
                                if block.timestamp < mem[192]:
                                    revert with 0, 17
                                if mem[_504 + 96] and 1000000000000 * 10^18 > -1 / mem[_504 + 96]:
                                    revert with 0, 17
                                if 1000000000000 * 10^18 * mem[_504 + 96] and block.timestamp - mem[192] > -1 / 1000000000000 * 10^18 * mem[_504 + 96]:
                                    revert with 0, 17
                                if not mem[_533]:
                                    revert with 0, 18
                                if mem[_504 + 128] > !((1000000000000 * 10^18 * block.timestamp * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533]):
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                    if mem[_252] and mem[_504 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533]) > -1 / mem[_252]:
                                        revert with 0, 17
                                    if (mem[_504 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533] * mem[_252]) / 1000000000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if idx >= mem[_259]:
                                        revert with 0, 50
                                    if (mem[_504 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533] * mem[_252]) / 1000000000000 * 10^18 < mem[_504 + 160]:
                                        mem[(32 * idx) + _259 + 32] = (mem[_504 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533] * mem[_252]) / 1000000000000 * 10^18
                                    else:
                                        mem[(32 * idx) + _259 + 32] = mem[_504 + 160]
                                else:
                                    if idx >= mem[mem[_252 + 32]]:
                                        revert with 0, 50
                                    if mem[_252] and mem[_504 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533]) > -1 / mem[_252]:
                                        revert with 0, 17
                                    if (mem[_504 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533] * mem[_252]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_252 + 32] + 32]:
                                        revert with 0, 17
                                    if idx >= mem[_259]:
                                        revert with 0, 50
                                    if ((mem[_504 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32] < mem[_504 + 160]:
                                        mem[(32 * idx) + _259 + 32] = ((mem[_504 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32]
                                    else:
                                        mem[(32 * idx) + _259 + 32] = mem[_504 + 160]
                            else:
                                if block.timestamp < mem[_504 + 58 len 6]:
                                    revert with 0, 17
                                if mem[_504 + 96] and 1000000000000 * 10^18 > -1 / mem[_504 + 96]:
                                    revert with 0, 17
                                if 1000000000000 * 10^18 * mem[_504 + 96] and block.timestamp - mem[_504 + 58 len 6] > -1 / 1000000000000 * 10^18 * mem[_504 + 96]:
                                    revert with 0, 17
                                if not mem[_533]:
                                    revert with 0, 18
                                if mem[_504 + 128] > !((1000000000000 * 10^18 * block.timestamp * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[_504 + 58 len 6] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533]):
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                    if mem[_252] and mem[_504 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[_504 + 58 len 6] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533]) > -1 / mem[_252]:
                                        revert with 0, 17
                                    if (mem[_504 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[_504 + 58 len 6] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533] * mem[_252]) / 1000000000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if idx >= mem[_259]:
                                        revert with 0, 50
                                    if (mem[_504 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[_504 + 58 len 6] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533] * mem[_252]) / 1000000000000 * 10^18 < mem[_504 + 160]:
                                        mem[(32 * idx) + _259 + 32] = (mem[_504 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[_504 + 58 len 6] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533] * mem[_252]) / 1000000000000 * 10^18
                                    else:
                                        mem[(32 * idx) + _259 + 32] = mem[_504 + 160]
                                else:
                                    if idx >= mem[mem[_252 + 32]]:
                                        revert with 0, 50
                                    if mem[_252] and mem[_504 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[_504 + 58 len 6] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533]) > -1 / mem[_252]:
                                        revert with 0, 17
                                    if (mem[_504 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[_504 + 58 len 6] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533] * mem[_252]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_252 + 32] + 32]:
                                        revert with 0, 17
                                    if idx >= mem[_259]:
                                        revert with 0, 50
                                    if ((mem[_504 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[_504 + 58 len 6] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32] < mem[_504 + 160]:
                                        mem[(32 * idx) + _259 + 32] = ((mem[_504 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_504 + 96]) - (1000000000000 * 10^18 * mem[_504 + 58 len 6] * mem[_504 + 96]) / 168 * 24 * 3600 / mem[_533] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32]
                                    else:
                                        mem[(32 * idx) + _259 + 32] = mem[_504 + 160]
            if idx == -1:
                revert with 0, 17
            _495 = mem[_259]
            idx = idx + 1
            continue 
        _510 = mem[64]
        mem[64] = mem[64] + 64
        mem[_510] = uint256(stor6[address(arg1)][address(arg2)].field_0)
        _511 = mem[64]
        mem[64] = mem[64] + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 32
        mem[_511] = uint256(stor6[address(arg1)][address(arg2)].field_256)
        if not uint256(stor6[address(arg1)][address(arg2)].field_256):
            mem[_510 + 32] = _511
            _521 = mem[64]
            mem[mem[64]] = 64
            mem[mem[64] + 64] = uint256(stor6[address(arg1)][address(arg2)].field_0)
            mem[mem[64] + 96] = 64
            mem[mem[64] + 128] = uint256(stor6[address(arg1)][address(arg2)].field_256)
            mem[mem[64] + 160 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)] = mem[_511 + 32 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)]
            mem[mem[64] + 32] = (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160
            _722 = mem[_259]
            mem[_521 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160] = mem[_259]
            mem[_521 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 192 len 32 * _722] = mem[_259 + 32 len 32 * _722]
            return memory
              from mem[64]
               len _521 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + (32 * _722) + -mem[64] + 192
        mem[0] = sha3(address(arg2), sha3(address(arg1), 6)) + 1
        mem[_511 + 32] = uint256(stor6[address(arg1)][address(arg2)][1].field_0)
        idx = _511 + 32
        s = 0
        while _511 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) > idx:
            mem[idx + 32] = uint256(stor6[address(arg1)][address(arg2)][s + 1].field_256)
            idx = idx + 32
            s = s + 1
            continue 
        mem[_510 + 32] = _511
        _986 = mem[64]
        mem[mem[64]] = 64
        mem[mem[64] + 64] = mem[_510]
        mem[mem[64] + 96] = 64
        mem[mem[64] + 128] = uint256(stor6[address(arg1)][address(arg2)].field_256)
        mem[mem[64] + 160 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)] = mem[_511 + 32 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)]
        mem[mem[64] + 32] = (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160
        _1227 = mem[_259]
        mem[_986 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160] = mem[_259]
        mem[_986 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 192 len 32 * _1227] = mem[_259 + 32 len 32 * _1227]
        return memory
          from mem[64]
           len _986 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + (32 * _1227) + -mem[64] + 192
    mem[0] = sha3(address(arg2), sha3(address(arg1), 6)) + 1
    mem[_253 + 32] = uint256(stor6[address(arg1)][address(arg2)][1].field_0)
    idx = _253 + 32
    s = 0
    while _253 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) > idx:
        mem[idx + 32] = uint256(stor6[address(arg1)][address(arg2)][s + 1].field_256)
        idx = idx + 32
        s = s + 1
        continue 
    mem[_252 + 32] = _253
    _709 = mem[mem[160]]
    if mem[mem[160]] > test266151307():
        revert with 0, 65
    _714 = mem[64]
    mem[mem[64]] = mem[mem[160]]
    mem[64] = mem[64] + (32 * _709) + 32
    if not _709:
        if not mem[_252]:
            mem[_714 + (32 * _709) + 32] = uint256(stor6[address(arg1)][address(arg2)].field_0)
            mem[64] = _714 + (32 * _709) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 128
            mem[_714 + (32 * _709) + 96] = uint256(stor6[address(arg1)][address(arg2)].field_256)
            if uint256(stor6[address(arg1)][address(arg2)].field_256):
                mem[0] = sha3(address(arg2), sha3(address(arg1), 6)) + 1
                mem[_714 + (32 * _709) + 128] = uint256(stor6[address(arg1)][address(arg2)][1].field_0)
                idx = _714 + (32 * _709) + 128
                s = 0
                while _714 + (32 * _709) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 96 > idx:
                    mem[idx + 32] = uint256(stor6[address(arg1)][address(arg2)][s + 1].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
            mem[_714 + (32 * _709) + 64] = _714 + (32 * _709) + 96
            mem[_714 + (32 * _709) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 128] = 64
            mem[_714 + (32 * _709) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 192] = uint256(stor6[address(arg1)][address(arg2)].field_0)
            mem[_714 + (32 * _709) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 224] = 64
            mem[_714 + (32 * _709) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 256] = uint256(stor6[address(arg1)][address(arg2)].field_256)
            mem[_714 + (32 * _709) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 288 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)] = mem[_714 + (32 * _709) + 128 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)]
            mem[_714 + (32 * _709) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160] = (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160
            mem[_714 + (32 * _709) + (64 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 288] = mem[_714]
            mem[_714 + (32 * _709) + (64 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 320 len 32 * mem[_714]] = mem[_714 + 32 len 32 * mem[_714]]
            return 64, 
                   (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160,
                   uint256(stor6[address(arg1)][address(arg2)].field_0),
                   64,
                   uint256(stor6[address(arg1)][address(arg2)].field_256),
                   mem[_714 + (32 * _709) + 128 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)],
                   mem[_714 + (32 * _709) + (64 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 288 len (32 * mem[_714]) + 32]
        _973 = mem[_714]
        idx = 0
        while idx < _973:
            if idx >= mem[mem[160]]:
                revert with 0, 50
            _987 = mem[(32 * idx) + mem[160] + 32]
            if mem[mem[(32 * idx) + mem[160] + 32] + 58 len 6] < block.timestamp:
                if mem[mem[(32 * idx) + mem[160] + 32] + 160] > 0:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(arg1)
                    staticcall arg1.balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1035 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_987 + 90 len 6] <= mem[192]:
                        if not mem[_1035]:
                            revert with 0, 18
                        if mem[_987 + 128] > !(0 / mem[_1035]):
                            revert with 0, 17
                        if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                            if mem[_252] and mem[_987 + 128] + (0 / mem[_1035]) > -1 / mem[_252]:
                                revert with 0, 17
                            if (mem[_987 + 128] * mem[_252]) + (0 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18 < 0:
                                revert with 0, 17
                            if idx >= mem[_714]:
                                revert with 0, 50
                            if (mem[_987 + 128] * mem[_252]) + (0 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18 < mem[_987 + 160]:
                                mem[(32 * idx) + _714 + 32] = (mem[_987 + 128] * mem[_252]) + (0 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18
                            else:
                                mem[(32 * idx) + _714 + 32] = mem[_987 + 160]
                        else:
                            if idx >= mem[mem[_252 + 32]]:
                                revert with 0, 50
                            if mem[_252] and mem[_987 + 128] + (0 / mem[_1035]) > -1 / mem[_252]:
                                revert with 0, 17
                            if (mem[_987 + 128] * mem[_252]) + (0 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_252 + 32] + 32]:
                                revert with 0, 17
                            if idx >= mem[_714]:
                                revert with 0, 50
                            if ((mem[_987 + 128] * mem[_252]) + (0 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32] < mem[_987 + 160]:
                                mem[(32 * idx) + _714 + 32] = ((mem[_987 + 128] * mem[_252]) + (0 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32]
                            else:
                                mem[(32 * idx) + _714 + 32] = mem[_987 + 160]
                    else:
                        if block.timestamp > mem[_987 + 90 len 6]:
                            if mem[192] > mem[_987 + 58 len 6]:
                                if mem[_987 + 90 len 6] < mem[192]:
                                    revert with 0, 17
                                if mem[_987 + 96] and 1000000000000 * 10^18 > -1 / mem[_987 + 96]:
                                    revert with 0, 17
                                if 1000000000000 * 10^18 * mem[_987 + 96] and mem[_987 + 90 len 6] - mem[192] > -1 / 1000000000000 * 10^18 * mem[_987 + 96]:
                                    revert with 0, 17
                                if not mem[_1035]:
                                    revert with 0, 18
                                if mem[_987 + 128] > !((1000000000000 * 10^18 * mem[_987 + 90 len 6] * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035]):
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                    if mem[_252] and mem[_987 + 128] + ((1000000000000 * 10^18 * mem[_987 + 90 len 6] * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035]) > -1 / mem[_252]:
                                        revert with 0, 17
                                    if (mem[_987 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_987 + 90 len 6] * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if idx >= mem[_714]:
                                        revert with 0, 50
                                    if (mem[_987 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_987 + 90 len 6] * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18 < mem[_987 + 160]:
                                        mem[(32 * idx) + _714 + 32] = (mem[_987 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_987 + 90 len 6] * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18
                                    else:
                                        mem[(32 * idx) + _714 + 32] = mem[_987 + 160]
                                else:
                                    if idx >= mem[mem[_252 + 32]]:
                                        revert with 0, 50
                                    if mem[_252] and mem[_987 + 128] + ((1000000000000 * 10^18 * mem[_987 + 90 len 6] * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035]) > -1 / mem[_252]:
                                        revert with 0, 17
                                    if (mem[_987 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_987 + 90 len 6] * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_252 + 32] + 32]:
                                        revert with 0, 17
                                    if idx >= mem[_714]:
                                        revert with 0, 50
                                    if ((mem[_987 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_987 + 90 len 6] * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32] < mem[_987 + 160]:
                                        mem[(32 * idx) + _714 + 32] = ((mem[_987 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_987 + 90 len 6] * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32]
                                    else:
                                        mem[(32 * idx) + _714 + 32] = mem[_987 + 160]
                            else:
                                if mem[_987 + 90 len 6] < mem[_987 + 58 len 6]:
                                    revert with 0, 17
                                if mem[_987 + 96] and 1000000000000 * 10^18 > -1 / mem[_987 + 96]:
                                    revert with 0, 17
                                if 1000000000000 * 10^18 * mem[_987 + 96] and mem[_987 + 90 len 6] - mem[_987 + 58 len 6] > -1 / 1000000000000 * 10^18 * mem[_987 + 96]:
                                    revert with 0, 17
                                if not mem[_1035]:
                                    revert with 0, 18
                                if mem[_987 + 128] > !((1000000000000 * 10^18 * mem[_987 + 90 len 6] * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[_987 + 58 len 6] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035]):
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                    if mem[_252] and mem[_987 + 128] + ((1000000000000 * 10^18 * mem[_987 + 90 len 6] * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[_987 + 58 len 6] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035]) > -1 / mem[_252]:
                                        revert with 0, 17
                                    if (mem[_987 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_987 + 90 len 6] * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[_987 + 58 len 6] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if idx >= mem[_714]:
                                        revert with 0, 50
                                    if (mem[_987 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_987 + 90 len 6] * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[_987 + 58 len 6] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18 < mem[_987 + 160]:
                                        mem[(32 * idx) + _714 + 32] = (mem[_987 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_987 + 90 len 6] * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[_987 + 58 len 6] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18
                                    else:
                                        mem[(32 * idx) + _714 + 32] = mem[_987 + 160]
                                else:
                                    if idx >= mem[mem[_252 + 32]]:
                                        revert with 0, 50
                                    if mem[_252] and mem[_987 + 128] + ((1000000000000 * 10^18 * mem[_987 + 90 len 6] * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[_987 + 58 len 6] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035]) > -1 / mem[_252]:
                                        revert with 0, 17
                                    if (mem[_987 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_987 + 90 len 6] * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[_987 + 58 len 6] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_252 + 32] + 32]:
                                        revert with 0, 17
                                    if idx >= mem[_714]:
                                        revert with 0, 50
                                    if ((mem[_987 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_987 + 90 len 6] * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[_987 + 58 len 6] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32] < mem[_987 + 160]:
                                        mem[(32 * idx) + _714 + 32] = ((mem[_987 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_987 + 90 len 6] * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[_987 + 58 len 6] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32]
                                    else:
                                        mem[(32 * idx) + _714 + 32] = mem[_987 + 160]
                        else:
                            if mem[192] > mem[_987 + 58 len 6]:
                                if block.timestamp < mem[192]:
                                    revert with 0, 17
                                if mem[_987 + 96] and 1000000000000 * 10^18 > -1 / mem[_987 + 96]:
                                    revert with 0, 17
                                if 1000000000000 * 10^18 * mem[_987 + 96] and block.timestamp - mem[192] > -1 / 1000000000000 * 10^18 * mem[_987 + 96]:
                                    revert with 0, 17
                                if not mem[_1035]:
                                    revert with 0, 18
                                if mem[_987 + 128] > !((1000000000000 * 10^18 * block.timestamp * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035]):
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                    if mem[_252] and mem[_987 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035]) > -1 / mem[_252]:
                                        revert with 0, 17
                                    if (mem[_987 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if idx >= mem[_714]:
                                        revert with 0, 50
                                    if (mem[_987 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18 < mem[_987 + 160]:
                                        mem[(32 * idx) + _714 + 32] = (mem[_987 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18
                                    else:
                                        mem[(32 * idx) + _714 + 32] = mem[_987 + 160]
                                else:
                                    if idx >= mem[mem[_252 + 32]]:
                                        revert with 0, 50
                                    if mem[_252] and mem[_987 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035]) > -1 / mem[_252]:
                                        revert with 0, 17
                                    if (mem[_987 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_252 + 32] + 32]:
                                        revert with 0, 17
                                    if idx >= mem[_714]:
                                        revert with 0, 50
                                    if ((mem[_987 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32] < mem[_987 + 160]:
                                        mem[(32 * idx) + _714 + 32] = ((mem[_987 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32]
                                    else:
                                        mem[(32 * idx) + _714 + 32] = mem[_987 + 160]
                            else:
                                if block.timestamp < mem[_987 + 58 len 6]:
                                    revert with 0, 17
                                if mem[_987 + 96] and 1000000000000 * 10^18 > -1 / mem[_987 + 96]:
                                    revert with 0, 17
                                if 1000000000000 * 10^18 * mem[_987 + 96] and block.timestamp - mem[_987 + 58 len 6] > -1 / 1000000000000 * 10^18 * mem[_987 + 96]:
                                    revert with 0, 17
                                if not mem[_1035]:
                                    revert with 0, 18
                                if mem[_987 + 128] > !((1000000000000 * 10^18 * block.timestamp * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[_987 + 58 len 6] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035]):
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                    if mem[_252] and mem[_987 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[_987 + 58 len 6] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035]) > -1 / mem[_252]:
                                        revert with 0, 17
                                    if (mem[_987 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[_987 + 58 len 6] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if idx >= mem[_714]:
                                        revert with 0, 50
                                    if (mem[_987 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[_987 + 58 len 6] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18 < mem[_987 + 160]:
                                        mem[(32 * idx) + _714 + 32] = (mem[_987 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[_987 + 58 len 6] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18
                                    else:
                                        mem[(32 * idx) + _714 + 32] = mem[_987 + 160]
                                else:
                                    if idx >= mem[mem[_252 + 32]]:
                                        revert with 0, 50
                                    if mem[_252] and mem[_987 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[_987 + 58 len 6] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035]) > -1 / mem[_252]:
                                        revert with 0, 17
                                    if (mem[_987 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[_987 + 58 len 6] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_252 + 32] + 32]:
                                        revert with 0, 17
                                    if idx >= mem[_714]:
                                        revert with 0, 50
                                    if ((mem[_987 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[_987 + 58 len 6] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32] < mem[_987 + 160]:
                                        mem[(32 * idx) + _714 + 32] = ((mem[_987 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_987 + 96]) - (1000000000000 * 10^18 * mem[_987 + 58 len 6] * mem[_987 + 96]) / 168 * 24 * 3600 / mem[_1035] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32]
                                    else:
                                        mem[(32 * idx) + _714 + 32] = mem[_987 + 160]
            if idx == -1:
                revert with 0, 17
            _973 = mem[_714]
            idx = idx + 1
            continue 
        _999 = mem[64]
        mem[64] = mem[64] + 64
        mem[_999] = uint256(stor6[address(arg1)][address(arg2)].field_0)
        _1000 = mem[64]
        mem[64] = mem[64] + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 32
        mem[_1000] = uint256(stor6[address(arg1)][address(arg2)].field_256)
        if not uint256(stor6[address(arg1)][address(arg2)].field_256):
            mem[_999 + 32] = _1000
            _1019 = mem[64]
            mem[mem[64]] = 64
            mem[mem[64] + 64] = uint256(stor6[address(arg1)][address(arg2)].field_0)
            mem[mem[64] + 96] = 64
            mem[mem[64] + 128] = uint256(stor6[address(arg1)][address(arg2)].field_256)
            mem[mem[64] + 160 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)] = mem[_1000 + 32 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)]
            mem[mem[64] + 32] = (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160
            _1229 = mem[_714]
            mem[_1019 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160] = mem[_714]
            mem[_1019 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 192 len 32 * _1229] = mem[_714 + 32 len 32 * _1229]
            return memory
              from mem[64]
               len _1019 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + (32 * _1229) + -mem[64] + 192
        mem[0] = sha3(address(arg2), sha3(address(arg1), 6)) + 1
        mem[_1000 + 32] = uint256(stor6[address(arg1)][address(arg2)][1].field_0)
        idx = _1000 + 32
        s = 0
        while _1000 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) > idx:
            mem[idx + 32] = uint256(stor6[address(arg1)][address(arg2)][s + 1].field_256)
            idx = idx + 32
            s = s + 1
            continue 
        mem[_999 + 32] = _1000
        _1261 = mem[64]
        mem[mem[64]] = 64
        mem[mem[64] + 64] = mem[_999]
        mem[mem[64] + 96] = 64
        mem[mem[64] + 128] = uint256(stor6[address(arg1)][address(arg2)].field_256)
        mem[mem[64] + 160 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)] = mem[_1000 + 32 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)]
        mem[mem[64] + 32] = (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160
        _1291 = mem[_714]
        mem[_1261 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160] = mem[_714]
        mem[_1261 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 192 len 32 * _1291] = mem[_714 + 32 len 32 * _1291]
        return memory
          from mem[64]
           len _1261 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + (32 * _1291) + -mem[64] + 192
    mem[_714 + 32 len 32 * _709] = call.data[calldata.size len 32 * _709]
    if not mem[_252]:
        mem[_714 + (32 * _709) + 32] = uint256(stor6[address(arg1)][address(arg2)].field_0)
        mem[64] = _714 + (32 * _709) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 128
        mem[_714 + (32 * _709) + 96] = uint256(stor6[address(arg1)][address(arg2)].field_256)
        if uint256(stor6[address(arg1)][address(arg2)].field_256):
            mem[0] = sha3(address(arg2), sha3(address(arg1), 6)) + 1
            mem[_714 + (32 * _709) + 128] = uint256(stor6[address(arg1)][address(arg2)][1].field_0)
            idx = _714 + (32 * _709) + 128
            s = 0
            while _714 + (32 * _709) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 96 > idx:
                mem[idx + 32] = uint256(stor6[address(arg1)][address(arg2)][s + 1].field_256)
                idx = idx + 32
                s = s + 1
                continue 
        mem[_714 + (32 * _709) + 64] = _714 + (32 * _709) + 96
        mem[_714 + (32 * _709) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 128] = 64
        mem[_714 + (32 * _709) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 192] = uint256(stor6[address(arg1)][address(arg2)].field_0)
        mem[_714 + (32 * _709) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 224] = 64
        mem[_714 + (32 * _709) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 256] = uint256(stor6[address(arg1)][address(arg2)].field_256)
        mem[_714 + (32 * _709) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 288 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)] = mem[_714 + (32 * _709) + 128 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)]
        mem[_714 + (32 * _709) + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160] = (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160
        mem[_714 + (32 * _709) + (64 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 288] = mem[_714]
        mem[_714 + (32 * _709) + (64 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 320 len 32 * mem[_714]] = mem[_714 + 32 len 32 * mem[_714]]
        return 64, 
               (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160,
               uint256(stor6[address(arg1)][address(arg2)].field_0),
               64,
               uint256(stor6[address(arg1)][address(arg2)].field_256),
               mem[_714 + (32 * _709) + 128 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)],
               mem[_714 + (32 * _709) + (64 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 288 len (32 * mem[_714]) + 32]
    _974 = mem[_714]
    idx = 0
    while idx < _974:
        if idx >= mem[mem[160]]:
            revert with 0, 50
        _989 = mem[(32 * idx) + mem[160] + 32]
        if mem[mem[(32 * idx) + mem[160] + 32] + 58 len 6] < block.timestamp:
            if mem[mem[(32 * idx) + mem[160] + 32] + 160] > 0:
                mem[mem[64] + 4] = this.address
                require ext_code.size(arg1)
                staticcall arg1.balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1036 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_989 + 90 len 6] <= mem[192]:
                    if not mem[_1036]:
                        revert with 0, 18
                    if mem[_989 + 128] > !(0 / mem[_1036]):
                        revert with 0, 17
                    if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                        if mem[_252] and mem[_989 + 128] + (0 / mem[_1036]) > -1 / mem[_252]:
                            revert with 0, 17
                        if (mem[_989 + 128] * mem[_252]) + (0 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18 < 0:
                            revert with 0, 17
                        if idx >= mem[_714]:
                            revert with 0, 50
                        if (mem[_989 + 128] * mem[_252]) + (0 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18 < mem[_989 + 160]:
                            mem[(32 * idx) + _714 + 32] = (mem[_989 + 128] * mem[_252]) + (0 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18
                        else:
                            mem[(32 * idx) + _714 + 32] = mem[_989 + 160]
                    else:
                        if idx >= mem[mem[_252 + 32]]:
                            revert with 0, 50
                        if mem[_252] and mem[_989 + 128] + (0 / mem[_1036]) > -1 / mem[_252]:
                            revert with 0, 17
                        if (mem[_989 + 128] * mem[_252]) + (0 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_252 + 32] + 32]:
                            revert with 0, 17
                        if idx >= mem[_714]:
                            revert with 0, 50
                        if ((mem[_989 + 128] * mem[_252]) + (0 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32] < mem[_989 + 160]:
                            mem[(32 * idx) + _714 + 32] = ((mem[_989 + 128] * mem[_252]) + (0 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32]
                        else:
                            mem[(32 * idx) + _714 + 32] = mem[_989 + 160]
                else:
                    if block.timestamp > mem[_989 + 90 len 6]:
                        if mem[192] > mem[_989 + 58 len 6]:
                            if mem[_989 + 90 len 6] < mem[192]:
                                revert with 0, 17
                            if mem[_989 + 96] and 1000000000000 * 10^18 > -1 / mem[_989 + 96]:
                                revert with 0, 17
                            if 1000000000000 * 10^18 * mem[_989 + 96] and mem[_989 + 90 len 6] - mem[192] > -1 / 1000000000000 * 10^18 * mem[_989 + 96]:
                                revert with 0, 17
                            if not mem[_1036]:
                                revert with 0, 18
                            if mem[_989 + 128] > !((1000000000000 * 10^18 * mem[_989 + 90 len 6] * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036]):
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                if mem[_252] and mem[_989 + 128] + ((1000000000000 * 10^18 * mem[_989 + 90 len 6] * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036]) > -1 / mem[_252]:
                                    revert with 0, 17
                                if (mem[_989 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_989 + 90 len 6] * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18 < 0:
                                    revert with 0, 17
                                if idx >= mem[_714]:
                                    revert with 0, 50
                                if (mem[_989 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_989 + 90 len 6] * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18 < mem[_989 + 160]:
                                    mem[(32 * idx) + _714 + 32] = (mem[_989 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_989 + 90 len 6] * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18
                                else:
                                    mem[(32 * idx) + _714 + 32] = mem[_989 + 160]
                            else:
                                if idx >= mem[mem[_252 + 32]]:
                                    revert with 0, 50
                                if mem[_252] and mem[_989 + 128] + ((1000000000000 * 10^18 * mem[_989 + 90 len 6] * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036]) > -1 / mem[_252]:
                                    revert with 0, 17
                                if (mem[_989 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_989 + 90 len 6] * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_252 + 32] + 32]:
                                    revert with 0, 17
                                if idx >= mem[_714]:
                                    revert with 0, 50
                                if ((mem[_989 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_989 + 90 len 6] * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32] < mem[_989 + 160]:
                                    mem[(32 * idx) + _714 + 32] = ((mem[_989 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_989 + 90 len 6] * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32]
                                else:
                                    mem[(32 * idx) + _714 + 32] = mem[_989 + 160]
                        else:
                            if mem[_989 + 90 len 6] < mem[_989 + 58 len 6]:
                                revert with 0, 17
                            if mem[_989 + 96] and 1000000000000 * 10^18 > -1 / mem[_989 + 96]:
                                revert with 0, 17
                            if 1000000000000 * 10^18 * mem[_989 + 96] and mem[_989 + 90 len 6] - mem[_989 + 58 len 6] > -1 / 1000000000000 * 10^18 * mem[_989 + 96]:
                                revert with 0, 17
                            if not mem[_1036]:
                                revert with 0, 18
                            if mem[_989 + 128] > !((1000000000000 * 10^18 * mem[_989 + 90 len 6] * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[_989 + 58 len 6] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036]):
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                if mem[_252] and mem[_989 + 128] + ((1000000000000 * 10^18 * mem[_989 + 90 len 6] * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[_989 + 58 len 6] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036]) > -1 / mem[_252]:
                                    revert with 0, 17
                                if (mem[_989 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_989 + 90 len 6] * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[_989 + 58 len 6] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18 < 0:
                                    revert with 0, 17
                                if idx >= mem[_714]:
                                    revert with 0, 50
                                if (mem[_989 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_989 + 90 len 6] * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[_989 + 58 len 6] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18 < mem[_989 + 160]:
                                    mem[(32 * idx) + _714 + 32] = (mem[_989 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_989 + 90 len 6] * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[_989 + 58 len 6] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18
                                else:
                                    mem[(32 * idx) + _714 + 32] = mem[_989 + 160]
                            else:
                                if idx >= mem[mem[_252 + 32]]:
                                    revert with 0, 50
                                if mem[_252] and mem[_989 + 128] + ((1000000000000 * 10^18 * mem[_989 + 90 len 6] * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[_989 + 58 len 6] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036]) > -1 / mem[_252]:
                                    revert with 0, 17
                                if (mem[_989 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_989 + 90 len 6] * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[_989 + 58 len 6] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_252 + 32] + 32]:
                                    revert with 0, 17
                                if idx >= mem[_714]:
                                    revert with 0, 50
                                if ((mem[_989 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_989 + 90 len 6] * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[_989 + 58 len 6] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32] < mem[_989 + 160]:
                                    mem[(32 * idx) + _714 + 32] = ((mem[_989 + 128] * mem[_252]) + ((1000000000000 * 10^18 * mem[_989 + 90 len 6] * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[_989 + 58 len 6] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32]
                                else:
                                    mem[(32 * idx) + _714 + 32] = mem[_989 + 160]
                    else:
                        if mem[192] > mem[_989 + 58 len 6]:
                            if block.timestamp < mem[192]:
                                revert with 0, 17
                            if mem[_989 + 96] and 1000000000000 * 10^18 > -1 / mem[_989 + 96]:
                                revert with 0, 17
                            if 1000000000000 * 10^18 * mem[_989 + 96] and block.timestamp - mem[192] > -1 / 1000000000000 * 10^18 * mem[_989 + 96]:
                                revert with 0, 17
                            if not mem[_1036]:
                                revert with 0, 18
                            if mem[_989 + 128] > !((1000000000000 * 10^18 * block.timestamp * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036]):
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                if mem[_252] and mem[_989 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036]) > -1 / mem[_252]:
                                    revert with 0, 17
                                if (mem[_989 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18 < 0:
                                    revert with 0, 17
                                if idx >= mem[_714]:
                                    revert with 0, 50
                                if (mem[_989 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18 < mem[_989 + 160]:
                                    mem[(32 * idx) + _714 + 32] = (mem[_989 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18
                                else:
                                    mem[(32 * idx) + _714 + 32] = mem[_989 + 160]
                            else:
                                if idx >= mem[mem[_252 + 32]]:
                                    revert with 0, 50
                                if mem[_252] and mem[_989 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036]) > -1 / mem[_252]:
                                    revert with 0, 17
                                if (mem[_989 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_252 + 32] + 32]:
                                    revert with 0, 17
                                if idx >= mem[_714]:
                                    revert with 0, 50
                                if ((mem[_989 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32] < mem[_989 + 160]:
                                    mem[(32 * idx) + _714 + 32] = ((mem[_989 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[192] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32]
                                else:
                                    mem[(32 * idx) + _714 + 32] = mem[_989 + 160]
                        else:
                            if block.timestamp < mem[_989 + 58 len 6]:
                                revert with 0, 17
                            if mem[_989 + 96] and 1000000000000 * 10^18 > -1 / mem[_989 + 96]:
                                revert with 0, 17
                            if 1000000000000 * 10^18 * mem[_989 + 96] and block.timestamp - mem[_989 + 58 len 6] > -1 / 1000000000000 * 10^18 * mem[_989 + 96]:
                                revert with 0, 17
                            if not mem[_1036]:
                                revert with 0, 18
                            if mem[_989 + 128] > !((1000000000000 * 10^18 * block.timestamp * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[_989 + 58 len 6] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036]):
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][address(arg2)].field_256) <= idx:
                                if mem[_252] and mem[_989 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[_989 + 58 len 6] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036]) > -1 / mem[_252]:
                                    revert with 0, 17
                                if (mem[_989 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[_989 + 58 len 6] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18 < 0:
                                    revert with 0, 17
                                if idx >= mem[_714]:
                                    revert with 0, 50
                                if (mem[_989 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[_989 + 58 len 6] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18 < mem[_989 + 160]:
                                    mem[(32 * idx) + _714 + 32] = (mem[_989 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[_989 + 58 len 6] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18
                                else:
                                    mem[(32 * idx) + _714 + 32] = mem[_989 + 160]
                            else:
                                if idx >= mem[mem[_252 + 32]]:
                                    revert with 0, 50
                                if mem[_252] and mem[_989 + 128] + ((1000000000000 * 10^18 * block.timestamp * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[_989 + 58 len 6] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036]) > -1 / mem[_252]:
                                    revert with 0, 17
                                if (mem[_989 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[_989 + 58 len 6] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_252 + 32] + 32]:
                                    revert with 0, 17
                                if idx >= mem[_714]:
                                    revert with 0, 50
                                if ((mem[_989 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[_989 + 58 len 6] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32] < mem[_989 + 160]:
                                    mem[(32 * idx) + _714 + 32] = ((mem[_989 + 128] * mem[_252]) + ((1000000000000 * 10^18 * block.timestamp * mem[_989 + 96]) - (1000000000000 * 10^18 * mem[_989 + 58 len 6] * mem[_989 + 96]) / 168 * 24 * 3600 / mem[_1036] * mem[_252]) / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_252 + 32] + 32]
                                else:
                                    mem[(32 * idx) + _714 + 32] = mem[_989 + 160]
        if idx == -1:
            revert with 0, 17
        _974 = mem[_714]
        idx = idx + 1
        continue 
    _1003 = mem[64]
    mem[64] = mem[64] + 64
    mem[_1003] = uint256(stor6[address(arg1)][address(arg2)].field_0)
    _1004 = mem[64]
    mem[64] = mem[64] + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 32
    mem[_1004] = uint256(stor6[address(arg1)][address(arg2)].field_256)
    if not uint256(stor6[address(arg1)][address(arg2)].field_256):
        mem[_1003 + 32] = _1004
        _1020 = mem[64]
        mem[mem[64]] = 64
        mem[mem[64] + 64] = uint256(stor6[address(arg1)][address(arg2)].field_0)
        mem[mem[64] + 96] = 64
        mem[mem[64] + 128] = uint256(stor6[address(arg1)][address(arg2)].field_256)
        mem[mem[64] + 160 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)] = mem[_1004 + 32 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)]
        mem[mem[64] + 32] = (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160
        _1233 = mem[_714]
        mem[_1020 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160] = mem[_714]
        mem[_1020 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 192 len 32 * _1233] = mem[_714 + 32 len 32 * _1233]
        return memory
          from mem[64]
           len _1020 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + (32 * _1233) + -mem[64] + 192
    mem[0] = sha3(address(arg2), sha3(address(arg1), 6)) + 1
    mem[_1004 + 32] = uint256(stor6[address(arg1)][address(arg2)][1].field_0)
    idx = _1004 + 32
    s = 0
    while _1004 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) > idx:
        mem[idx + 32] = uint256(stor6[address(arg1)][address(arg2)][s + 1].field_256)
        idx = idx + 32
        s = s + 1
        continue 
    mem[_1003 + 32] = _1004
    _1262 = mem[64]
    mem[mem[64]] = 64
    mem[mem[64] + 64] = mem[_1003]
    mem[mem[64] + 96] = 64
    mem[mem[64] + 128] = uint256(stor6[address(arg1)][address(arg2)].field_256)
    mem[mem[64] + 160 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)] = mem[_1004 + 32 len 32 * uint256(stor6[address(arg1)][address(arg2)].field_256)]
    mem[mem[64] + 32] = (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160
    _1293 = mem[_714]
    mem[_1262 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 160] = mem[_714]
    mem[_1262 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + 192 len 32 * _1293] = mem[_714 + 32 len 32 * _1293]
    return memory
      from mem[64]
       len _1262 + (32 * uint256(stor6[address(arg1)][address(arg2)].field_256)) + (32 * _1293) + -mem[64] + 192
}

function updateBonus(address arg1, address arg2, uint256 arg3, uint48 arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg4 == arg4 % 281474976710656
    if stor1 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor1 = 2
    if paused:
        revert with 0, 'BonusRewards: paused'
    mem[0] = arg2
    mem[32] = sha3(address(arg1), 7)
    mem[64] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 128
    mem[96] = uint256(stor7[address(arg1)][address(arg2)].field_0)
    if not uint256(stor7[address(arg1)][address(arg2)].field_0):
        if owner != msg.sender:
            idx = 0
            while idx < uint256(stor7[address(arg1)][address(arg2)].field_0):
                if idx >= uint256(stor7[address(arg1)][address(arg2)].field_0):
                    revert with 0, 50
                if mem[(32 * idx) + 140 len 20] != msg.sender:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if not arg4 % 281474976710656:
                    mem[0] = arg1
                    mem[32] = 5
                    mem[64] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + (32 * uint256(stor5[address(arg1)].field_0)) + 224
                    mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192] = uint256(stor5[address(arg1)].field_0)
                    s = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224
                    idx = 0
                    while idx < uint256(stor5[address(arg1)].field_0):
                        mem[0] = sha3(address(arg1), 5)
                        _599 = mem[64]
                        mem[64] = mem[64] + 192
                        mem[_599] = address(stor5[address(arg1)][idx].field_0)
                        mem[_599 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                        mem[_599 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                        mem[_599 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                        mem[_599 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                        mem[_599 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                        mem[s] = _599
                        s = s + 32
                        idx = idx + 1
                        continue 
                    mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 128] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192
                    mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 160] = uint256(stor5[address(arg1)].field_256)
                    if uint256(stor5[address(arg1)].field_256) <= 0:
                        revert with 0, 'BonusRewards: pool does not exist'
                    _982 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                    idx = 0
                    while idx < _982:
                        if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                            revert with 0, 50
                        if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 12 len 20] == arg2:
                            if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                                revert with 0, 50
                            if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 90 len 6] > block.timestamp:
                                if idx >= uint256(stor5[address(arg1)].field_0):
                                    revert with 0, 50
                                mem[0] = arg1
                                mem[32] = 5
                                if uint256(stor5[address(arg1)].field_256):
                                    if block.timestamp > uint256(stor5[address(arg1)].field_256):
                                        uint256(stor5[address(arg1)].field_256) = block.timestamp
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(arg1)
                                        staticcall arg1.balanceOf(address rg1) with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _1145 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _1157 = mem[_1145]
                                        if mem[_1145]:
                                            s = 0
                                            while s < uint256(stor5[address(arg1)].field_0):
                                                mem[0] = sha3(address(arg1), 5)
                                                if uint256(stor5[address(arg1)].field_256) < stor5[address(arg1)][s].field_208 % 281474976710656:
                                                    if stor5[address(arg1)][s].field_160 % 281474976710656 < block.timestamp:
                                                        _1319 = mem[64]
                                                        mem[64] = mem[64] + 192
                                                        mem[_1319] = address(stor5[address(arg1)][s].field_0)
                                                        mem[_1319 + 32] = stor5[address(arg1)][s].field_160 % 281474976710656
                                                        mem[_1319 + 64] = stor5[address(arg1)][s].field_208 % 281474976710656
                                                        mem[_1319 + 96] = uint256(stor5[address(arg1)][s].field_256)
                                                        mem[_1319 + 128] = uint256(stor5[address(arg1)][s].field_512)
                                                        mem[_1319 + 160] = uint256(stor5[address(arg1)][s].field_768)
                                                        if stor5[address(arg1)][s].field_208 % 281474976710656 <= uint256(stor5[address(arg1)].field_256):
                                                            if not _1157:
                                                                revert with 0, 18
                                                            if uint256(stor5[address(arg1)][s].field_512) > !(0 / _1157):
                                                                revert with 0, 17
                                                            uint256(stor5[address(arg1)][s].field_512) += 0 / _1157
                                                        else:
                                                            if block.timestamp > stor5[address(arg1)][s].field_208 % 281474976710656:
                                                                if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                    if stor5[address(arg1)][s].field_208 % 281474976710656 < uint256(stor5[address(arg1)].field_256):
                                                                        revert with 0, 17
                                                                    if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                        revert with 0, 17
                                                                    if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and stor5[address(arg1)][s].field_208 % 281474976710656 - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                        revert with 0, 17
                                                                    if not _1157:
                                                                        revert with 0, 18
                                                                    if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][s].field_208 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1157):
                                                                        revert with 0, 17
                                                                    uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][s].field_208 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1157
                                                                else:
                                                                    if stor5[address(arg1)][s].field_0 % 281474976710656 < stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                        revert with 0, 17
                                                                    if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                        revert with 0, 17
                                                                    if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and stor5[address(arg1)][s].field_0 % 281474976710656 - stor5[address(arg1)][s].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                        revert with 0, 17
                                                                    if not _1157:
                                                                        revert with 0, 18
                                                                    if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][s].field_0 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1157):
                                                                        revert with 0, 17
                                                                    uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][s].field_0 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1157
                                                            else:
                                                                if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                    if block.timestamp < uint256(stor5[address(arg1)].field_256):
                                                                        revert with 0, 17
                                                                    if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                        revert with 0, 17
                                                                    if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and block.timestamp - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                        revert with 0, 17
                                                                    if not _1157:
                                                                        revert with 0, 18
                                                                    if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1157):
                                                                        revert with 0, 17
                                                                    uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1157
                                                                else:
                                                                    if block.timestamp < stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                        revert with 0, 17
                                                                    if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                        revert with 0, 17
                                                                    if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and block.timestamp - stor5[address(arg1)][s].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                        revert with 0, 17
                                                                    if not _1157:
                                                                        revert with 0, 18
                                                                    if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1157):
                                                                        revert with 0, 17
                                                                    uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1157
                                                if s == -1:
                                                    revert with 0, 17
                                                _982 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                                                s = s + 1
                                                continue 
                                if stor5[address(arg1)][idx].field_160 % 281474976710656 < block.timestamp:
                                    if stor5[address(arg1)][idx].field_208 % 281474976710656 < block.timestamp:
                                        revert with 0, 17
                                    if stor5[address(arg1)][idx].field_208 % 281474976710656 - block.timestamp and uint256(stor5[address(arg1)][idx].field_256) > -1 / stor5[address(arg1)][idx].field_208 % 281474976710656 - block.timestamp:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if (stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) / arg3 > !block.timestamp:
                                        revert with 0, 17
                                    stor5[address(arg1)][idx].field_208 % 281474976710656 = ((stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) / arg3) + block.timestamp % 281474976710656
                                else:
                                    if arg4 % 281474976710656 >= block.timestamp:
                                        stor5[address(arg1)][idx].field_160 % 281474976710656 = arg4 % 281474976710656
                                    if uint256(stor5[address(arg1)][idx].field_768) and 168 * 24 * 3600 > -1 / uint256(stor5[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if 168 * 24 * 3600 * uint256(stor5[address(arg1)][idx].field_768) / arg3 > !stor5[address(arg1)][idx].field_160 % 281474976710656:
                                        revert with 0, 17
                                    stor5[address(arg1)][idx].field_208 % 281474976710656 = (168 * 24 * 3600 * uint256(stor5[address(arg1)][idx].field_768) / arg3) + stor5[address(arg1)][idx].field_160 % 281474976710656 % 281474976710656
                                uint256(stor5[address(arg1)][idx].field_256) = arg3
                        if idx == -1:
                            revert with 0, 17
                        _982 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                        idx = idx + 1
                        continue 
                else:
                    if arg4 % 281474976710656 <= block.timestamp:
                        revert with 0, 'BonusRewards: startTime in the past'
                    mem[0] = arg1
                    mem[32] = 5
                    mem[64] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + (32 * uint256(stor5[address(arg1)].field_0)) + 224
                    mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192] = uint256(stor5[address(arg1)].field_0)
                    s = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224
                    idx = 0
                    while idx < uint256(stor5[address(arg1)].field_0):
                        mem[0] = sha3(address(arg1), 5)
                        _602 = mem[64]
                        mem[64] = mem[64] + 192
                        mem[_602] = address(stor5[address(arg1)][idx].field_0)
                        mem[_602 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                        mem[_602 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                        mem[_602 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                        mem[_602 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                        mem[_602 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                        mem[s] = _602
                        s = s + 32
                        idx = idx + 1
                        continue 
                    mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 128] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192
                    mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 160] = uint256(stor5[address(arg1)].field_256)
                    if uint256(stor5[address(arg1)].field_256) <= 0:
                        revert with 0, 'BonusRewards: pool does not exist'
                    _983 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                    idx = 0
                    while idx < _983:
                        if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                            revert with 0, 50
                        if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 12 len 20] == arg2:
                            if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                                revert with 0, 50
                            if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 90 len 6] > block.timestamp:
                                if idx >= uint256(stor5[address(arg1)].field_0):
                                    revert with 0, 50
                                mem[0] = arg1
                                mem[32] = 5
                                if uint256(stor5[address(arg1)].field_256):
                                    if block.timestamp > uint256(stor5[address(arg1)].field_256):
                                        uint256(stor5[address(arg1)].field_256) = block.timestamp
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(arg1)
                                        staticcall arg1.balanceOf(address rg1) with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _1146 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _1158 = mem[_1146]
                                        if mem[_1146]:
                                            s = 0
                                            while s < uint256(stor5[address(arg1)].field_0):
                                                mem[0] = sha3(address(arg1), 5)
                                                if uint256(stor5[address(arg1)].field_256) < stor5[address(arg1)][s].field_208 % 281474976710656:
                                                    if stor5[address(arg1)][s].field_160 % 281474976710656 < block.timestamp:
                                                        _1320 = mem[64]
                                                        mem[64] = mem[64] + 192
                                                        mem[_1320] = address(stor5[address(arg1)][s].field_0)
                                                        mem[_1320 + 32] = stor5[address(arg1)][s].field_160 % 281474976710656
                                                        mem[_1320 + 64] = stor5[address(arg1)][s].field_208 % 281474976710656
                                                        mem[_1320 + 96] = uint256(stor5[address(arg1)][s].field_256)
                                                        mem[_1320 + 128] = uint256(stor5[address(arg1)][s].field_512)
                                                        mem[_1320 + 160] = uint256(stor5[address(arg1)][s].field_768)
                                                        if stor5[address(arg1)][s].field_208 % 281474976710656 <= uint256(stor5[address(arg1)].field_256):
                                                            if not _1158:
                                                                revert with 0, 18
                                                            if uint256(stor5[address(arg1)][s].field_512) > !(0 / _1158):
                                                                revert with 0, 17
                                                            uint256(stor5[address(arg1)][s].field_512) += 0 / _1158
                                                        else:
                                                            if block.timestamp > stor5[address(arg1)][s].field_208 % 281474976710656:
                                                                if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                    if stor5[address(arg1)][s].field_208 % 281474976710656 < uint256(stor5[address(arg1)].field_256):
                                                                        revert with 0, 17
                                                                    if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                        revert with 0, 17
                                                                    if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and stor5[address(arg1)][s].field_208 % 281474976710656 - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                        revert with 0, 17
                                                                    if not _1158:
                                                                        revert with 0, 18
                                                                    if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][s].field_208 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1158):
                                                                        revert with 0, 17
                                                                    uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][s].field_208 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1158
                                                                else:
                                                                    if stor5[address(arg1)][s].field_0 % 281474976710656 < stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                        revert with 0, 17
                                                                    if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                        revert with 0, 17
                                                                    if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and stor5[address(arg1)][s].field_0 % 281474976710656 - stor5[address(arg1)][s].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                        revert with 0, 17
                                                                    if not _1158:
                                                                        revert with 0, 18
                                                                    if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][s].field_0 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1158):
                                                                        revert with 0, 17
                                                                    uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][s].field_0 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1158
                                                            else:
                                                                if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                    if block.timestamp < uint256(stor5[address(arg1)].field_256):
                                                                        revert with 0, 17
                                                                    if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                        revert with 0, 17
                                                                    if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and block.timestamp - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                        revert with 0, 17
                                                                    if not _1158:
                                                                        revert with 0, 18
                                                                    if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1158):
                                                                        revert with 0, 17
                                                                    uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1158
                                                                else:
                                                                    if block.timestamp < stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                        revert with 0, 17
                                                                    if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                        revert with 0, 17
                                                                    if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and block.timestamp - stor5[address(arg1)][s].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                        revert with 0, 17
                                                                    if not _1158:
                                                                        revert with 0, 18
                                                                    if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1158):
                                                                        revert with 0, 17
                                                                    uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1158
                                                if s == -1:
                                                    revert with 0, 17
                                                _983 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                                                s = s + 1
                                                continue 
                                if stor5[address(arg1)][idx].field_160 % 281474976710656 < block.timestamp:
                                    if stor5[address(arg1)][idx].field_208 % 281474976710656 < block.timestamp:
                                        revert with 0, 17
                                    if stor5[address(arg1)][idx].field_208 % 281474976710656 - block.timestamp and uint256(stor5[address(arg1)][idx].field_256) > -1 / stor5[address(arg1)][idx].field_208 % 281474976710656 - block.timestamp:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if (stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) / arg3 > !block.timestamp:
                                        revert with 0, 17
                                    stor5[address(arg1)][idx].field_208 % 281474976710656 = ((stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) / arg3) + block.timestamp % 281474976710656
                                else:
                                    if arg4 % 281474976710656 >= block.timestamp:
                                        stor5[address(arg1)][idx].field_160 % 281474976710656 = arg4 % 281474976710656
                                    if uint256(stor5[address(arg1)][idx].field_768) and 168 * 24 * 3600 > -1 / uint256(stor5[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if 168 * 24 * 3600 * uint256(stor5[address(arg1)][idx].field_768) / arg3 > !stor5[address(arg1)][idx].field_160 % 281474976710656:
                                        revert with 0, 17
                                    stor5[address(arg1)][idx].field_208 % 281474976710656 = (168 * 24 * 3600 * uint256(stor5[address(arg1)][idx].field_768) / arg3) + stor5[address(arg1)][idx].field_160 % 281474976710656 % 281474976710656
                                uint256(stor5[address(arg1)][idx].field_256) = arg3
                        if idx == -1:
                            revert with 0, 17
                        _983 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                        idx = idx + 1
                        continue 
                stor1 = 1
            revert with 0, 'BonusRewards: not authorized caller'
        if not arg4 % 281474976710656:
            mem[0] = arg1
            mem[32] = 5
            mem[64] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + (32 * uint256(stor5[address(arg1)].field_0)) + 224
            mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192] = uint256(stor5[address(arg1)].field_0)
            s = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224
            idx = 0
            while idx < uint256(stor5[address(arg1)].field_0):
                mem[0] = sha3(address(arg1), 5)
                _312 = mem[64]
                mem[64] = mem[64] + 192
                mem[_312] = address(stor5[address(arg1)][idx].field_0)
                mem[_312 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                mem[_312 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                mem[_312 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                mem[_312 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                mem[_312 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                mem[s] = _312
                s = s + 32
                idx = idx + 1
                continue 
            mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 128] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192
            mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 160] = uint256(stor5[address(arg1)].field_256)
            if uint256(stor5[address(arg1)].field_256) <= 0:
                revert with 0, 'BonusRewards: pool does not exist'
            _593 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
            idx = 0
            while idx < _593:
                if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                    revert with 0, 50
                if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 12 len 20] == arg2:
                    if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                        revert with 0, 50
                    if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 90 len 6] > block.timestamp:
                        if idx >= uint256(stor5[address(arg1)].field_0):
                            revert with 0, 50
                        mem[0] = arg1
                        mem[32] = 5
                        if uint256(stor5[address(arg1)].field_256):
                            if block.timestamp > uint256(stor5[address(arg1)].field_256):
                                uint256(stor5[address(arg1)].field_256) = block.timestamp
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _739 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _763 = mem[_739]
                                if mem[_739]:
                                    s = 0
                                    while s < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        if uint256(stor5[address(arg1)].field_256) < stor5[address(arg1)][s].field_208 % 281474976710656:
                                            if stor5[address(arg1)][s].field_160 % 281474976710656 < block.timestamp:
                                                _1034 = mem[64]
                                                mem[64] = mem[64] + 192
                                                mem[_1034] = address(stor5[address(arg1)][s].field_0)
                                                mem[_1034 + 32] = stor5[address(arg1)][s].field_160 % 281474976710656
                                                mem[_1034 + 64] = stor5[address(arg1)][s].field_208 % 281474976710656
                                                mem[_1034 + 96] = uint256(stor5[address(arg1)][s].field_256)
                                                mem[_1034 + 128] = uint256(stor5[address(arg1)][s].field_512)
                                                mem[_1034 + 160] = uint256(stor5[address(arg1)][s].field_768)
                                                if stor5[address(arg1)][s].field_208 % 281474976710656 <= uint256(stor5[address(arg1)].field_256):
                                                    if not _763:
                                                        revert with 0, 18
                                                    if uint256(stor5[address(arg1)][s].field_512) > !(0 / _763):
                                                        revert with 0, 17
                                                    uint256(stor5[address(arg1)][s].field_512) += 0 / _763
                                                else:
                                                    if block.timestamp > stor5[address(arg1)][s].field_208 % 281474976710656:
                                                        if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][s].field_160 % 281474976710656:
                                                            if stor5[address(arg1)][s].field_208 % 281474976710656 < uint256(stor5[address(arg1)].field_256):
                                                                revert with 0, 17
                                                            if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                revert with 0, 17
                                                            if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and stor5[address(arg1)][s].field_208 % 281474976710656 - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                revert with 0, 17
                                                            if not _763:
                                                                revert with 0, 18
                                                            if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][s].field_208 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _763):
                                                                revert with 0, 17
                                                            uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][s].field_208 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _763
                                                        else:
                                                            if stor5[address(arg1)][s].field_0 % 281474976710656 < stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                revert with 0, 17
                                                            if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                revert with 0, 17
                                                            if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and stor5[address(arg1)][s].field_0 % 281474976710656 - stor5[address(arg1)][s].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                revert with 0, 17
                                                            if not _763:
                                                                revert with 0, 18
                                                            if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][s].field_0 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _763):
                                                                revert with 0, 17
                                                            uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][s].field_0 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _763
                                                    else:
                                                        if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][s].field_160 % 281474976710656:
                                                            if block.timestamp < uint256(stor5[address(arg1)].field_256):
                                                                revert with 0, 17
                                                            if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                revert with 0, 17
                                                            if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and block.timestamp - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                revert with 0, 17
                                                            if not _763:
                                                                revert with 0, 18
                                                            if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _763):
                                                                revert with 0, 17
                                                            uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _763
                                                        else:
                                                            if block.timestamp < stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                revert with 0, 17
                                                            if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                revert with 0, 17
                                                            if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and block.timestamp - stor5[address(arg1)][s].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                revert with 0, 17
                                                            if not _763:
                                                                revert with 0, 18
                                                            if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _763):
                                                                revert with 0, 17
                                                            uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _763
                                        if s == -1:
                                            revert with 0, 17
                                        _593 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                                        s = s + 1
                                        continue 
                        if stor5[address(arg1)][idx].field_160 % 281474976710656 < block.timestamp:
                            if stor5[address(arg1)][idx].field_208 % 281474976710656 < block.timestamp:
                                revert with 0, 17
                            if stor5[address(arg1)][idx].field_208 % 281474976710656 - block.timestamp and uint256(stor5[address(arg1)][idx].field_256) > -1 / stor5[address(arg1)][idx].field_208 % 281474976710656 - block.timestamp:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if (stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) / arg3 > !block.timestamp:
                                revert with 0, 17
                            stor5[address(arg1)][idx].field_208 % 281474976710656 = ((stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) / arg3) + block.timestamp % 281474976710656
                        else:
                            if arg4 % 281474976710656 >= block.timestamp:
                                stor5[address(arg1)][idx].field_160 % 281474976710656 = arg4 % 281474976710656
                            if uint256(stor5[address(arg1)][idx].field_768) and 168 * 24 * 3600 > -1 / uint256(stor5[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if 168 * 24 * 3600 * uint256(stor5[address(arg1)][idx].field_768) / arg3 > !stor5[address(arg1)][idx].field_160 % 281474976710656:
                                revert with 0, 17
                            stor5[address(arg1)][idx].field_208 % 281474976710656 = (168 * 24 * 3600 * uint256(stor5[address(arg1)][idx].field_768) / arg3) + stor5[address(arg1)][idx].field_160 % 281474976710656 % 281474976710656
                        uint256(stor5[address(arg1)][idx].field_256) = arg3
                if idx == -1:
                    revert with 0, 17
                _593 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                idx = idx + 1
                continue 
        else:
            if arg4 % 281474976710656 <= block.timestamp:
                revert with 0, 'BonusRewards: startTime in the past'
            mem[0] = arg1
            mem[32] = 5
            mem[64] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + (32 * uint256(stor5[address(arg1)].field_0)) + 224
            mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192] = uint256(stor5[address(arg1)].field_0)
            s = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224
            idx = 0
            while idx < uint256(stor5[address(arg1)].field_0):
                mem[0] = sha3(address(arg1), 5)
                _315 = mem[64]
                mem[64] = mem[64] + 192
                mem[_315] = address(stor5[address(arg1)][idx].field_0)
                mem[_315 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                mem[_315 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                mem[_315 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                mem[_315 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                mem[_315 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                mem[s] = _315
                s = s + 32
                idx = idx + 1
                continue 
            mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 128] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192
            mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 160] = uint256(stor5[address(arg1)].field_256)
            if uint256(stor5[address(arg1)].field_256) <= 0:
                revert with 0, 'BonusRewards: pool does not exist'
            _594 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
            idx = 0
            while idx < _594:
                if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                    revert with 0, 50
                if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 12 len 20] == arg2:
                    if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                        revert with 0, 50
                    if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 90 len 6] > block.timestamp:
                        if idx >= uint256(stor5[address(arg1)].field_0):
                            revert with 0, 50
                        mem[0] = arg1
                        mem[32] = 5
                        if uint256(stor5[address(arg1)].field_256):
                            if block.timestamp > uint256(stor5[address(arg1)].field_256):
                                uint256(stor5[address(arg1)].field_256) = block.timestamp
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _740 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _764 = mem[_740]
                                if mem[_740]:
                                    s = 0
                                    while s < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        if uint256(stor5[address(arg1)].field_256) < stor5[address(arg1)][s].field_208 % 281474976710656:
                                            if stor5[address(arg1)][s].field_160 % 281474976710656 < block.timestamp:
                                                _1035 = mem[64]
                                                mem[64] = mem[64] + 192
                                                mem[_1035] = address(stor5[address(arg1)][s].field_0)
                                                mem[_1035 + 32] = stor5[address(arg1)][s].field_160 % 281474976710656
                                                mem[_1035 + 64] = stor5[address(arg1)][s].field_208 % 281474976710656
                                                mem[_1035 + 96] = uint256(stor5[address(arg1)][s].field_256)
                                                mem[_1035 + 128] = uint256(stor5[address(arg1)][s].field_512)
                                                mem[_1035 + 160] = uint256(stor5[address(arg1)][s].field_768)
                                                if stor5[address(arg1)][s].field_208 % 281474976710656 <= uint256(stor5[address(arg1)].field_256):
                                                    if not _764:
                                                        revert with 0, 18
                                                    if uint256(stor5[address(arg1)][s].field_512) > !(0 / _764):
                                                        revert with 0, 17
                                                    uint256(stor5[address(arg1)][s].field_512) += 0 / _764
                                                else:
                                                    if block.timestamp > stor5[address(arg1)][s].field_208 % 281474976710656:
                                                        if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][s].field_160 % 281474976710656:
                                                            if stor5[address(arg1)][s].field_208 % 281474976710656 < uint256(stor5[address(arg1)].field_256):
                                                                revert with 0, 17
                                                            if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                revert with 0, 17
                                                            if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and stor5[address(arg1)][s].field_208 % 281474976710656 - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                revert with 0, 17
                                                            if not _764:
                                                                revert with 0, 18
                                                            if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][s].field_208 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _764):
                                                                revert with 0, 17
                                                            uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][s].field_208 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _764
                                                        else:
                                                            if stor5[address(arg1)][s].field_0 % 281474976710656 < stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                revert with 0, 17
                                                            if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                revert with 0, 17
                                                            if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and stor5[address(arg1)][s].field_0 % 281474976710656 - stor5[address(arg1)][s].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                revert with 0, 17
                                                            if not _764:
                                                                revert with 0, 18
                                                            if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][s].field_0 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _764):
                                                                revert with 0, 17
                                                            uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][s].field_0 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _764
                                                    else:
                                                        if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][s].field_160 % 281474976710656:
                                                            if block.timestamp < uint256(stor5[address(arg1)].field_256):
                                                                revert with 0, 17
                                                            if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                revert with 0, 17
                                                            if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and block.timestamp - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                revert with 0, 17
                                                            if not _764:
                                                                revert with 0, 18
                                                            if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _764):
                                                                revert with 0, 17
                                                            uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _764
                                                        else:
                                                            if block.timestamp < stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                revert with 0, 17
                                                            if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                revert with 0, 17
                                                            if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and block.timestamp - stor5[address(arg1)][s].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                revert with 0, 17
                                                            if not _764:
                                                                revert with 0, 18
                                                            if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _764):
                                                                revert with 0, 17
                                                            uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _764
                                        if s == -1:
                                            revert with 0, 17
                                        _594 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                                        s = s + 1
                                        continue 
                        if stor5[address(arg1)][idx].field_160 % 281474976710656 < block.timestamp:
                            if stor5[address(arg1)][idx].field_208 % 281474976710656 < block.timestamp:
                                revert with 0, 17
                            if stor5[address(arg1)][idx].field_208 % 281474976710656 - block.timestamp and uint256(stor5[address(arg1)][idx].field_256) > -1 / stor5[address(arg1)][idx].field_208 % 281474976710656 - block.timestamp:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if (stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) / arg3 > !block.timestamp:
                                revert with 0, 17
                            stor5[address(arg1)][idx].field_208 % 281474976710656 = ((stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) / arg3) + block.timestamp % 281474976710656
                        else:
                            if arg4 % 281474976710656 >= block.timestamp:
                                stor5[address(arg1)][idx].field_160 % 281474976710656 = arg4 % 281474976710656
                            if uint256(stor5[address(arg1)][idx].field_768) and 168 * 24 * 3600 > -1 / uint256(stor5[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if 168 * 24 * 3600 * uint256(stor5[address(arg1)][idx].field_768) / arg3 > !stor5[address(arg1)][idx].field_160 % 281474976710656:
                                revert with 0, 17
                            stor5[address(arg1)][idx].field_208 % 281474976710656 = (168 * 24 * 3600 * uint256(stor5[address(arg1)][idx].field_768) / arg3) + stor5[address(arg1)][idx].field_160 % 281474976710656 % 281474976710656
                        uint256(stor5[address(arg1)][idx].field_256) = arg3
                if idx == -1:
                    revert with 0, 17
                _594 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                idx = idx + 1
                continue 
    else:
        mem[0] = sha3(address(arg2), sha3(address(arg1), 7))
        mem[128] = address(stor7[address(arg1)][address(arg2)].field_0)
        if (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 32 <= 64:
            if owner != msg.sender:
                idx = 0
                while idx < uint256(stor7[address(arg1)][address(arg2)].field_0):
                    if idx >= uint256(stor7[address(arg1)][address(arg2)].field_0):
                        revert with 0, 50
                    if mem[(32 * idx) + 140 len 20] != msg.sender:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if not arg4 % 281474976710656:
                        mem[0] = arg1
                        mem[32] = 5
                        mem[64] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + (32 * uint256(stor5[address(arg1)].field_0)) + 224
                        mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192] = uint256(stor5[address(arg1)].field_0)
                        s = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224
                        idx = 0
                        while idx < uint256(stor5[address(arg1)].field_0):
                            mem[0] = sha3(address(arg1), 5)
                            _607 = mem[64]
                            mem[64] = mem[64] + 192
                            mem[_607] = address(stor5[address(arg1)][idx].field_0)
                            mem[_607 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                            mem[_607 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                            mem[_607 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                            mem[_607 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                            mem[_607 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                            mem[s] = _607
                            s = s + 32
                            idx = idx + 1
                            continue 
                        mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 128] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192
                        mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 160] = uint256(stor5[address(arg1)].field_256)
                        if uint256(stor5[address(arg1)].field_256) <= 0:
                            revert with 0, 'BonusRewards: pool does not exist'
                        _985 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                        idx = 0
                        while idx < _985:
                            if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                                revert with 0, 50
                            if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 12 len 20] == arg2:
                                if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                                    revert with 0, 50
                                if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 90 len 6] > block.timestamp:
                                    if idx >= uint256(stor5[address(arg1)].field_0):
                                        revert with 0, 50
                                    mem[0] = arg1
                                    mem[32] = 5
                                    if uint256(stor5[address(arg1)].field_256):
                                        if block.timestamp > uint256(stor5[address(arg1)].field_256):
                                            uint256(stor5[address(arg1)].field_256) = block.timestamp
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(arg1)
                                            staticcall arg1.balanceOf(address rg1) with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _1150 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _1161 = mem[_1150]
                                            if mem[_1150]:
                                                s = 0
                                                while s < uint256(stor5[address(arg1)].field_0):
                                                    mem[0] = sha3(address(arg1), 5)
                                                    if uint256(stor5[address(arg1)].field_256) < stor5[address(arg1)][s].field_208 % 281474976710656:
                                                        if stor5[address(arg1)][s].field_160 % 281474976710656 < block.timestamp:
                                                            _1325 = mem[64]
                                                            mem[64] = mem[64] + 192
                                                            mem[_1325] = address(stor5[address(arg1)][s].field_0)
                                                            mem[_1325 + 32] = stor5[address(arg1)][s].field_160 % 281474976710656
                                                            mem[_1325 + 64] = stor5[address(arg1)][s].field_208 % 281474976710656
                                                            mem[_1325 + 96] = uint256(stor5[address(arg1)][s].field_256)
                                                            mem[_1325 + 128] = uint256(stor5[address(arg1)][s].field_512)
                                                            mem[_1325 + 160] = uint256(stor5[address(arg1)][s].field_768)
                                                            if stor5[address(arg1)][s].field_208 % 281474976710656 <= uint256(stor5[address(arg1)].field_256):
                                                                if not _1161:
                                                                    revert with 0, 18
                                                                if uint256(stor5[address(arg1)][s].field_512) > !(0 / _1161):
                                                                    revert with 0, 17
                                                                uint256(stor5[address(arg1)][s].field_512) += 0 / _1161
                                                            else:
                                                                if block.timestamp > stor5[address(arg1)][s].field_208 % 281474976710656:
                                                                    if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                        if stor5[address(arg1)][s].field_208 % 281474976710656 < uint256(stor5[address(arg1)].field_256):
                                                                            revert with 0, 17
                                                                        if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and stor5[address(arg1)][s].field_208 % 281474976710656 - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if not _1161:
                                                                            revert with 0, 18
                                                                        if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][s].field_208 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1161):
                                                                            revert with 0, 17
                                                                        uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][s].field_208 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1161
                                                                    else:
                                                                        if stor5[address(arg1)][s].field_0 % 281474976710656 < stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                            revert with 0, 17
                                                                        if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and stor5[address(arg1)][s].field_0 % 281474976710656 - stor5[address(arg1)][s].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if not _1161:
                                                                            revert with 0, 18
                                                                        if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][s].field_0 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1161):
                                                                            revert with 0, 17
                                                                        uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][s].field_0 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1161
                                                                else:
                                                                    if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                        if block.timestamp < uint256(stor5[address(arg1)].field_256):
                                                                            revert with 0, 17
                                                                        if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and block.timestamp - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if not _1161:
                                                                            revert with 0, 18
                                                                        if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1161):
                                                                            revert with 0, 17
                                                                        uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1161
                                                                    else:
                                                                        if block.timestamp < stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                            revert with 0, 17
                                                                        if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and block.timestamp - stor5[address(arg1)][s].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if not _1161:
                                                                            revert with 0, 18
                                                                        if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1161):
                                                                            revert with 0, 17
                                                                        uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1161
                                                    if s == -1:
                                                        revert with 0, 17
                                                    _985 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                                                    s = s + 1
                                                    continue 
                                    if stor5[address(arg1)][idx].field_160 % 281474976710656 < block.timestamp:
                                        if stor5[address(arg1)][idx].field_208 % 281474976710656 < block.timestamp:
                                            revert with 0, 17
                                        if stor5[address(arg1)][idx].field_208 % 281474976710656 - block.timestamp and uint256(stor5[address(arg1)][idx].field_256) > -1 / stor5[address(arg1)][idx].field_208 % 281474976710656 - block.timestamp:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if (stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) / arg3 > !block.timestamp:
                                            revert with 0, 17
                                        stor5[address(arg1)][idx].field_208 % 281474976710656 = ((stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) / arg3) + block.timestamp % 281474976710656
                                    else:
                                        if arg4 % 281474976710656 >= block.timestamp:
                                            stor5[address(arg1)][idx].field_160 % 281474976710656 = arg4 % 281474976710656
                                        if uint256(stor5[address(arg1)][idx].field_768) and 168 * 24 * 3600 > -1 / uint256(stor5[address(arg1)][idx].field_768):
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if 168 * 24 * 3600 * uint256(stor5[address(arg1)][idx].field_768) / arg3 > !stor5[address(arg1)][idx].field_160 % 281474976710656:
                                            revert with 0, 17
                                        stor5[address(arg1)][idx].field_208 % 281474976710656 = (168 * 24 * 3600 * uint256(stor5[address(arg1)][idx].field_768) / arg3) + stor5[address(arg1)][idx].field_160 % 281474976710656 % 281474976710656
                                    uint256(stor5[address(arg1)][idx].field_256) = arg3
                            if idx == -1:
                                revert with 0, 17
                            _985 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                            idx = idx + 1
                            continue 
                    else:
                        if arg4 % 281474976710656 <= block.timestamp:
                            revert with 0, 'BonusRewards: startTime in the past'
                        mem[0] = arg1
                        mem[32] = 5
                        mem[64] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + (32 * uint256(stor5[address(arg1)].field_0)) + 224
                        mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192] = uint256(stor5[address(arg1)].field_0)
                        s = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224
                        idx = 0
                        while idx < uint256(stor5[address(arg1)].field_0):
                            mem[0] = sha3(address(arg1), 5)
                            _610 = mem[64]
                            mem[64] = mem[64] + 192
                            mem[_610] = address(stor5[address(arg1)][idx].field_0)
                            mem[_610 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                            mem[_610 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                            mem[_610 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                            mem[_610 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                            mem[_610 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                            mem[s] = _610
                            s = s + 32
                            idx = idx + 1
                            continue 
                        mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 128] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192
                        mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 160] = uint256(stor5[address(arg1)].field_256)
                        if uint256(stor5[address(arg1)].field_256) <= 0:
                            revert with 0, 'BonusRewards: pool does not exist'
                        _986 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                        idx = 0
                        while idx < _986:
                            if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                                revert with 0, 50
                            if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 12 len 20] == arg2:
                                if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                                    revert with 0, 50
                                if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 90 len 6] > block.timestamp:
                                    if idx >= uint256(stor5[address(arg1)].field_0):
                                        revert with 0, 50
                                    mem[0] = arg1
                                    mem[32] = 5
                                    if uint256(stor5[address(arg1)].field_256):
                                        if block.timestamp > uint256(stor5[address(arg1)].field_256):
                                            uint256(stor5[address(arg1)].field_256) = block.timestamp
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(arg1)
                                            staticcall arg1.balanceOf(address rg1) with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _1151 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _1162 = mem[_1151]
                                            if mem[_1151]:
                                                s = 0
                                                while s < uint256(stor5[address(arg1)].field_0):
                                                    mem[0] = sha3(address(arg1), 5)
                                                    if uint256(stor5[address(arg1)].field_256) < stor5[address(arg1)][s].field_208 % 281474976710656:
                                                        if stor5[address(arg1)][s].field_160 % 281474976710656 < block.timestamp:
                                                            _1326 = mem[64]
                                                            mem[64] = mem[64] + 192
                                                            mem[_1326] = address(stor5[address(arg1)][s].field_0)
                                                            mem[_1326 + 32] = stor5[address(arg1)][s].field_160 % 281474976710656
                                                            mem[_1326 + 64] = stor5[address(arg1)][s].field_208 % 281474976710656
                                                            mem[_1326 + 96] = uint256(stor5[address(arg1)][s].field_256)
                                                            mem[_1326 + 128] = uint256(stor5[address(arg1)][s].field_512)
                                                            mem[_1326 + 160] = uint256(stor5[address(arg1)][s].field_768)
                                                            if stor5[address(arg1)][s].field_208 % 281474976710656 <= uint256(stor5[address(arg1)].field_256):
                                                                if not _1162:
                                                                    revert with 0, 18
                                                                if uint256(stor5[address(arg1)][s].field_512) > !(0 / _1162):
                                                                    revert with 0, 17
                                                                uint256(stor5[address(arg1)][s].field_512) += 0 / _1162
                                                            else:
                                                                if block.timestamp > stor5[address(arg1)][s].field_208 % 281474976710656:
                                                                    if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                        if stor5[address(arg1)][s].field_208 % 281474976710656 < uint256(stor5[address(arg1)].field_256):
                                                                            revert with 0, 17
                                                                        if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and stor5[address(arg1)][s].field_208 % 281474976710656 - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if not _1162:
                                                                            revert with 0, 18
                                                                        if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][s].field_208 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1162):
                                                                            revert with 0, 17
                                                                        uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][s].field_208 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1162
                                                                    else:
                                                                        if stor5[address(arg1)][s].field_0 % 281474976710656 < stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                            revert with 0, 17
                                                                        if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and stor5[address(arg1)][s].field_0 % 281474976710656 - stor5[address(arg1)][s].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if not _1162:
                                                                            revert with 0, 18
                                                                        if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][s].field_0 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1162):
                                                                            revert with 0, 17
                                                                        uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][s].field_0 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1162
                                                                else:
                                                                    if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                        if block.timestamp < uint256(stor5[address(arg1)].field_256):
                                                                            revert with 0, 17
                                                                        if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and block.timestamp - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if not _1162:
                                                                            revert with 0, 18
                                                                        if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1162):
                                                                            revert with 0, 17
                                                                        uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1162
                                                                    else:
                                                                        if block.timestamp < stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                            revert with 0, 17
                                                                        if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and block.timestamp - stor5[address(arg1)][s].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if not _1162:
                                                                            revert with 0, 18
                                                                        if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1162):
                                                                            revert with 0, 17
                                                                        uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1162
                                                    if s == -1:
                                                        revert with 0, 17
                                                    _986 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                                                    s = s + 1
                                                    continue 
                                    if stor5[address(arg1)][idx].field_160 % 281474976710656 < block.timestamp:
                                        if stor5[address(arg1)][idx].field_208 % 281474976710656 < block.timestamp:
                                            revert with 0, 17
                                        if stor5[address(arg1)][idx].field_208 % 281474976710656 - block.timestamp and uint256(stor5[address(arg1)][idx].field_256) > -1 / stor5[address(arg1)][idx].field_208 % 281474976710656 - block.timestamp:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if (stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) / arg3 > !block.timestamp:
                                            revert with 0, 17
                                        stor5[address(arg1)][idx].field_208 % 281474976710656 = ((stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) / arg3) + block.timestamp % 281474976710656
                                    else:
                                        if arg4 % 281474976710656 >= block.timestamp:
                                            stor5[address(arg1)][idx].field_160 % 281474976710656 = arg4 % 281474976710656
                                        if uint256(stor5[address(arg1)][idx].field_768) and 168 * 24 * 3600 > -1 / uint256(stor5[address(arg1)][idx].field_768):
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if 168 * 24 * 3600 * uint256(stor5[address(arg1)][idx].field_768) / arg3 > !stor5[address(arg1)][idx].field_160 % 281474976710656:
                                            revert with 0, 17
                                        stor5[address(arg1)][idx].field_208 % 281474976710656 = (168 * 24 * 3600 * uint256(stor5[address(arg1)][idx].field_768) / arg3) + stor5[address(arg1)][idx].field_160 % 281474976710656 % 281474976710656
                                    uint256(stor5[address(arg1)][idx].field_256) = arg3
                            if idx == -1:
                                revert with 0, 17
                            _986 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                            idx = idx + 1
                            continue 
                    stor1 = 1
                revert with 0, 'BonusRewards: not authorized caller'
            if not arg4 % 281474976710656:
                mem[0] = arg1
                mem[32] = 5
                mem[64] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + (32 * uint256(stor5[address(arg1)].field_0)) + 224
                mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192] = uint256(stor5[address(arg1)].field_0)
                s = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224
                idx = 0
                while idx < uint256(stor5[address(arg1)].field_0):
                    mem[0] = sha3(address(arg1), 5)
                    _319 = mem[64]
                    mem[64] = mem[64] + 192
                    mem[_319] = address(stor5[address(arg1)][idx].field_0)
                    mem[_319 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                    mem[_319 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                    mem[_319 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                    mem[_319 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                    mem[_319 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                    mem[s] = _319
                    s = s + 32
                    idx = idx + 1
                    continue 
                mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 128] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192
                mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 160] = uint256(stor5[address(arg1)].field_256)
                if uint256(stor5[address(arg1)].field_256) <= 0:
                    revert with 0, 'BonusRewards: pool does not exist'
                _595 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                idx = 0
                while idx < _595:
                    if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                        revert with 0, 50
                    if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 12 len 20] == arg2:
                        if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                            revert with 0, 50
                        if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 90 len 6] > block.timestamp:
                            if idx >= uint256(stor5[address(arg1)].field_0):
                                revert with 0, 50
                            mem[0] = arg1
                            mem[32] = 5
                            if uint256(stor5[address(arg1)].field_256):
                                if block.timestamp > uint256(stor5[address(arg1)].field_256):
                                    uint256(stor5[address(arg1)].field_256) = block.timestamp
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _748 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _771 = mem[_748]
                                    if mem[_748]:
                                        s = 0
                                        while s < uint256(stor5[address(arg1)].field_0):
                                            mem[0] = sha3(address(arg1), 5)
                                            if uint256(stor5[address(arg1)].field_256) < stor5[address(arg1)][s].field_208 % 281474976710656:
                                                if stor5[address(arg1)][s].field_160 % 281474976710656 < block.timestamp:
                                                    _1041 = mem[64]
                                                    mem[64] = mem[64] + 192
                                                    mem[_1041] = address(stor5[address(arg1)][s].field_0)
                                                    mem[_1041 + 32] = stor5[address(arg1)][s].field_160 % 281474976710656
                                                    mem[_1041 + 64] = stor5[address(arg1)][s].field_208 % 281474976710656
                                                    mem[_1041 + 96] = uint256(stor5[address(arg1)][s].field_256)
                                                    mem[_1041 + 128] = uint256(stor5[address(arg1)][s].field_512)
                                                    mem[_1041 + 160] = uint256(stor5[address(arg1)][s].field_768)
                                                    if stor5[address(arg1)][s].field_208 % 281474976710656 <= uint256(stor5[address(arg1)].field_256):
                                                        if not _771:
                                                            revert with 0, 18
                                                        if uint256(stor5[address(arg1)][s].field_512) > !(0 / _771):
                                                            revert with 0, 17
                                                        uint256(stor5[address(arg1)][s].field_512) += 0 / _771
                                                    else:
                                                        if block.timestamp > stor5[address(arg1)][s].field_208 % 281474976710656:
                                                            if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                if stor5[address(arg1)][s].field_208 % 281474976710656 < uint256(stor5[address(arg1)].field_256):
                                                                    revert with 0, 17
                                                                if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and stor5[address(arg1)][s].field_208 % 281474976710656 - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if not _771:
                                                                    revert with 0, 18
                                                                if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][s].field_208 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _771):
                                                                    revert with 0, 17
                                                                uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][s].field_208 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _771
                                                            else:
                                                                if stor5[address(arg1)][s].field_0 % 281474976710656 < stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                    revert with 0, 17
                                                                if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and stor5[address(arg1)][s].field_0 % 281474976710656 - stor5[address(arg1)][s].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if not _771:
                                                                    revert with 0, 18
                                                                if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][s].field_0 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _771):
                                                                    revert with 0, 17
                                                                uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][s].field_0 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _771
                                                        else:
                                                            if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                if block.timestamp < uint256(stor5[address(arg1)].field_256):
                                                                    revert with 0, 17
                                                                if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and block.timestamp - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if not _771:
                                                                    revert with 0, 18
                                                                if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _771):
                                                                    revert with 0, 17
                                                                uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _771
                                                            else:
                                                                if block.timestamp < stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                    revert with 0, 17
                                                                if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and block.timestamp - stor5[address(arg1)][s].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if not _771:
                                                                    revert with 0, 18
                                                                if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _771):
                                                                    revert with 0, 17
                                                                uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _771
                                            if s == -1:
                                                revert with 0, 17
                                            _595 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                                            s = s + 1
                                            continue 
                            if stor5[address(arg1)][idx].field_160 % 281474976710656 < block.timestamp:
                                if stor5[address(arg1)][idx].field_208 % 281474976710656 < block.timestamp:
                                    revert with 0, 17
                                if stor5[address(arg1)][idx].field_208 % 281474976710656 - block.timestamp and uint256(stor5[address(arg1)][idx].field_256) > -1 / stor5[address(arg1)][idx].field_208 % 281474976710656 - block.timestamp:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if (stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) / arg3 > !block.timestamp:
                                    revert with 0, 17
                                stor5[address(arg1)][idx].field_208 % 281474976710656 = ((stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) / arg3) + block.timestamp % 281474976710656
                            else:
                                if arg4 % 281474976710656 >= block.timestamp:
                                    stor5[address(arg1)][idx].field_160 % 281474976710656 = arg4 % 281474976710656
                                if uint256(stor5[address(arg1)][idx].field_768) and 168 * 24 * 3600 > -1 / uint256(stor5[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if 168 * 24 * 3600 * uint256(stor5[address(arg1)][idx].field_768) / arg3 > !stor5[address(arg1)][idx].field_160 % 281474976710656:
                                    revert with 0, 17
                                stor5[address(arg1)][idx].field_208 % 281474976710656 = (168 * 24 * 3600 * uint256(stor5[address(arg1)][idx].field_768) / arg3) + stor5[address(arg1)][idx].field_160 % 281474976710656 % 281474976710656
                            uint256(stor5[address(arg1)][idx].field_256) = arg3
                    if idx == -1:
                        revert with 0, 17
                    _595 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                    idx = idx + 1
                    continue 
            else:
                if arg4 % 281474976710656 <= block.timestamp:
                    revert with 0, 'BonusRewards: startTime in the past'
                mem[0] = arg1
                mem[32] = 5
                mem[64] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + (32 * uint256(stor5[address(arg1)].field_0)) + 224
                mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192] = uint256(stor5[address(arg1)].field_0)
                s = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224
                idx = 0
                while idx < uint256(stor5[address(arg1)].field_0):
                    mem[0] = sha3(address(arg1), 5)
                    _322 = mem[64]
                    mem[64] = mem[64] + 192
                    mem[_322] = address(stor5[address(arg1)][idx].field_0)
                    mem[_322 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                    mem[_322 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                    mem[_322 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                    mem[_322 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                    mem[_322 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                    mem[s] = _322
                    s = s + 32
                    idx = idx + 1
                    continue 
                mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 128] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192
                mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 160] = uint256(stor5[address(arg1)].field_256)
                if uint256(stor5[address(arg1)].field_256) <= 0:
                    revert with 0, 'BonusRewards: pool does not exist'
                _596 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                idx = 0
                while idx < _596:
                    if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                        revert with 0, 50
                    if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 12 len 20] == arg2:
                        if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                            revert with 0, 50
                        if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 90 len 6] > block.timestamp:
                            if idx >= uint256(stor5[address(arg1)].field_0):
                                revert with 0, 50
                            mem[0] = arg1
                            mem[32] = 5
                            if uint256(stor5[address(arg1)].field_256):
                                if block.timestamp > uint256(stor5[address(arg1)].field_256):
                                    uint256(stor5[address(arg1)].field_256) = block.timestamp
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _749 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _772 = mem[_749]
                                    if mem[_749]:
                                        s = 0
                                        while s < uint256(stor5[address(arg1)].field_0):
                                            mem[0] = sha3(address(arg1), 5)
                                            if uint256(stor5[address(arg1)].field_256) < stor5[address(arg1)][s].field_208 % 281474976710656:
                                                if stor5[address(arg1)][s].field_160 % 281474976710656 < block.timestamp:
                                                    _1042 = mem[64]
                                                    mem[64] = mem[64] + 192
                                                    mem[_1042] = address(stor5[address(arg1)][s].field_0)
                                                    mem[_1042 + 32] = stor5[address(arg1)][s].field_160 % 281474976710656
                                                    mem[_1042 + 64] = stor5[address(arg1)][s].field_208 % 281474976710656
                                                    mem[_1042 + 96] = uint256(stor5[address(arg1)][s].field_256)
                                                    mem[_1042 + 128] = uint256(stor5[address(arg1)][s].field_512)
                                                    mem[_1042 + 160] = uint256(stor5[address(arg1)][s].field_768)
                                                    if stor5[address(arg1)][s].field_208 % 281474976710656 <= uint256(stor5[address(arg1)].field_256):
                                                        if not _772:
                                                            revert with 0, 18
                                                        if uint256(stor5[address(arg1)][s].field_512) > !(0 / _772):
                                                            revert with 0, 17
                                                        uint256(stor5[address(arg1)][s].field_512) += 0 / _772
                                                    else:
                                                        if block.timestamp > stor5[address(arg1)][s].field_208 % 281474976710656:
                                                            if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                if stor5[address(arg1)][s].field_208 % 281474976710656 < uint256(stor5[address(arg1)].field_256):
                                                                    revert with 0, 17
                                                                if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and stor5[address(arg1)][s].field_208 % 281474976710656 - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if not _772:
                                                                    revert with 0, 18
                                                                if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][s].field_208 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _772):
                                                                    revert with 0, 17
                                                                uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][s].field_208 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _772
                                                            else:
                                                                if stor5[address(arg1)][s].field_0 % 281474976710656 < stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                    revert with 0, 17
                                                                if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and stor5[address(arg1)][s].field_0 % 281474976710656 - stor5[address(arg1)][s].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if not _772:
                                                                    revert with 0, 18
                                                                if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][s].field_0 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _772):
                                                                    revert with 0, 17
                                                                uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][s].field_0 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _772
                                                        else:
                                                            if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                if block.timestamp < uint256(stor5[address(arg1)].field_256):
                                                                    revert with 0, 17
                                                                if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and block.timestamp - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if not _772:
                                                                    revert with 0, 18
                                                                if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _772):
                                                                    revert with 0, 17
                                                                uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _772
                                                            else:
                                                                if block.timestamp < stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                    revert with 0, 17
                                                                if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and block.timestamp - stor5[address(arg1)][s].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if not _772:
                                                                    revert with 0, 18
                                                                if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _772):
                                                                    revert with 0, 17
                                                                uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _772
                                            if s == -1:
                                                revert with 0, 17
                                            _596 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                                            s = s + 1
                                            continue 
                            if stor5[address(arg1)][idx].field_160 % 281474976710656 < block.timestamp:
                                if stor5[address(arg1)][idx].field_208 % 281474976710656 < block.timestamp:
                                    revert with 0, 17
                                if stor5[address(arg1)][idx].field_208 % 281474976710656 - block.timestamp and uint256(stor5[address(arg1)][idx].field_256) > -1 / stor5[address(arg1)][idx].field_208 % 281474976710656 - block.timestamp:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if (stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) / arg3 > !block.timestamp:
                                    revert with 0, 17
                                stor5[address(arg1)][idx].field_208 % 281474976710656 = ((stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) / arg3) + block.timestamp % 281474976710656
                            else:
                                if arg4 % 281474976710656 >= block.timestamp:
                                    stor5[address(arg1)][idx].field_160 % 281474976710656 = arg4 % 281474976710656
                                if uint256(stor5[address(arg1)][idx].field_768) and 168 * 24 * 3600 > -1 / uint256(stor5[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if 168 * 24 * 3600 * uint256(stor5[address(arg1)][idx].field_768) / arg3 > !stor5[address(arg1)][idx].field_160 % 281474976710656:
                                    revert with 0, 17
                                stor5[address(arg1)][idx].field_208 % 281474976710656 = (168 * 24 * 3600 * uint256(stor5[address(arg1)][idx].field_768) / arg3) + stor5[address(arg1)][idx].field_160 % 281474976710656 % 281474976710656
                            uint256(stor5[address(arg1)][idx].field_256) = arg3
                    if idx == -1:
                        revert with 0, 17
                    _596 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                    idx = idx + 1
                    continue 
        else:
            mem[160] = address(stor7[address(arg1)][address(arg2)].field_256)
            idx = 160
            s = 1
            while (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 96 > idx:
                mem[idx + 32] = address(stor7[address(arg1)][address(arg2)][s].field_256)
                idx = idx + 32
                s = s + 1
                continue 
            if owner != msg.sender:
                idx = 0
                while idx < uint256(stor7[address(arg1)][address(arg2)].field_0):
                    if idx >= uint256(stor7[address(arg1)][address(arg2)].field_0):
                        revert with 0, 50
                    if mem[(32 * idx) + 140 len 20] != msg.sender:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if not arg4 % 281474976710656:
                        mem[0] = arg1
                        mem[32] = 5
                        mem[64] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + (32 * uint256(stor5[address(arg1)].field_0)) + 224
                        mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192] = uint256(stor5[address(arg1)].field_0)
                        s = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224
                        idx = 0
                        while idx < uint256(stor5[address(arg1)].field_0):
                            mem[0] = sha3(address(arg1), 5)
                            _1289 = mem[64]
                            mem[64] = mem[64] + 192
                            mem[_1289] = address(stor5[address(arg1)][idx].field_0)
                            mem[_1289 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                            mem[_1289 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                            mem[_1289 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                            mem[_1289 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                            mem[_1289 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                            mem[s] = _1289
                            s = s + 32
                            idx = idx + 1
                            continue 
                        mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 128] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192
                        mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 160] = uint256(stor5[address(arg1)].field_256)
                        if uint256(stor5[address(arg1)].field_256) <= 0:
                            revert with 0, 'BonusRewards: pool does not exist'
                        _1457 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                        idx = 0
                        while idx < _1457:
                            if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                                revert with 0, 50
                            if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 12 len 20] == arg2:
                                if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                                    revert with 0, 50
                                if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 90 len 6] > block.timestamp:
                                    if idx >= uint256(stor5[address(arg1)].field_0):
                                        revert with 0, 50
                                    mem[0] = arg1
                                    mem[32] = 5
                                    if uint256(stor5[address(arg1)].field_256):
                                        if block.timestamp > uint256(stor5[address(arg1)].field_256):
                                            uint256(stor5[address(arg1)].field_256) = block.timestamp
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(arg1)
                                            staticcall arg1.balanceOf(address rg1) with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _1507 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _1509 = mem[_1507]
                                            if mem[_1507]:
                                                s = 0
                                                while s < uint256(stor5[address(arg1)].field_0):
                                                    mem[0] = sha3(address(arg1), 5)
                                                    if uint256(stor5[address(arg1)].field_256) < stor5[address(arg1)][s].field_208 % 281474976710656:
                                                        if stor5[address(arg1)][s].field_160 % 281474976710656 < block.timestamp:
                                                            _1539 = mem[64]
                                                            mem[64] = mem[64] + 192
                                                            mem[_1539] = address(stor5[address(arg1)][s].field_0)
                                                            mem[_1539 + 32] = stor5[address(arg1)][s].field_160 % 281474976710656
                                                            mem[_1539 + 64] = stor5[address(arg1)][s].field_208 % 281474976710656
                                                            mem[_1539 + 96] = uint256(stor5[address(arg1)][s].field_256)
                                                            mem[_1539 + 128] = uint256(stor5[address(arg1)][s].field_512)
                                                            mem[_1539 + 160] = uint256(stor5[address(arg1)][s].field_768)
                                                            if stor5[address(arg1)][s].field_208 % 281474976710656 <= uint256(stor5[address(arg1)].field_256):
                                                                if not _1509:
                                                                    revert with 0, 18
                                                                if uint256(stor5[address(arg1)][s].field_512) > !(0 / _1509):
                                                                    revert with 0, 17
                                                                uint256(stor5[address(arg1)][s].field_512) += 0 / _1509
                                                            else:
                                                                if block.timestamp > stor5[address(arg1)][s].field_208 % 281474976710656:
                                                                    if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                        if stor5[address(arg1)][s].field_208 % 281474976710656 < uint256(stor5[address(arg1)].field_256):
                                                                            revert with 0, 17
                                                                        if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and stor5[address(arg1)][s].field_208 % 281474976710656 - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if not _1509:
                                                                            revert with 0, 18
                                                                        if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][s].field_208 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1509):
                                                                            revert with 0, 17
                                                                        uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][s].field_208 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1509
                                                                    else:
                                                                        if stor5[address(arg1)][s].field_0 % 281474976710656 < stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                            revert with 0, 17
                                                                        if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and stor5[address(arg1)][s].field_0 % 281474976710656 - stor5[address(arg1)][s].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if not _1509:
                                                                            revert with 0, 18
                                                                        if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][s].field_0 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1509):
                                                                            revert with 0, 17
                                                                        uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][s].field_0 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1509
                                                                else:
                                                                    if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                        if block.timestamp < uint256(stor5[address(arg1)].field_256):
                                                                            revert with 0, 17
                                                                        if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and block.timestamp - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if not _1509:
                                                                            revert with 0, 18
                                                                        if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1509):
                                                                            revert with 0, 17
                                                                        uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1509
                                                                    else:
                                                                        if block.timestamp < stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                            revert with 0, 17
                                                                        if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and block.timestamp - stor5[address(arg1)][s].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if not _1509:
                                                                            revert with 0, 18
                                                                        if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1509):
                                                                            revert with 0, 17
                                                                        uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1509
                                                    if s == -1:
                                                        revert with 0, 17
                                                    _1457 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                                                    s = s + 1
                                                    continue 
                                    if stor5[address(arg1)][idx].field_160 % 281474976710656 < block.timestamp:
                                        if stor5[address(arg1)][idx].field_208 % 281474976710656 < block.timestamp:
                                            revert with 0, 17
                                        if stor5[address(arg1)][idx].field_208 % 281474976710656 - block.timestamp and uint256(stor5[address(arg1)][idx].field_256) > -1 / stor5[address(arg1)][idx].field_208 % 281474976710656 - block.timestamp:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if (stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) / arg3 > !block.timestamp:
                                            revert with 0, 17
                                        stor5[address(arg1)][idx].field_208 % 281474976710656 = ((stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) / arg3) + block.timestamp % 281474976710656
                                    else:
                                        if arg4 % 281474976710656 >= block.timestamp:
                                            stor5[address(arg1)][idx].field_160 % 281474976710656 = arg4 % 281474976710656
                                        if uint256(stor5[address(arg1)][idx].field_768) and 168 * 24 * 3600 > -1 / uint256(stor5[address(arg1)][idx].field_768):
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if 168 * 24 * 3600 * uint256(stor5[address(arg1)][idx].field_768) / arg3 > !stor5[address(arg1)][idx].field_160 % 281474976710656:
                                            revert with 0, 17
                                        stor5[address(arg1)][idx].field_208 % 281474976710656 = (168 * 24 * 3600 * uint256(stor5[address(arg1)][idx].field_768) / arg3) + stor5[address(arg1)][idx].field_160 % 281474976710656 % 281474976710656
                                    uint256(stor5[address(arg1)][idx].field_256) = arg3
                            if idx == -1:
                                revert with 0, 17
                            _1457 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                            idx = idx + 1
                            continue 
                    else:
                        if arg4 % 281474976710656 <= block.timestamp:
                            revert with 0, 'BonusRewards: startTime in the past'
                        mem[0] = arg1
                        mem[32] = 5
                        mem[64] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + (32 * uint256(stor5[address(arg1)].field_0)) + 224
                        mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192] = uint256(stor5[address(arg1)].field_0)
                        s = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224
                        idx = 0
                        while idx < uint256(stor5[address(arg1)].field_0):
                            mem[0] = sha3(address(arg1), 5)
                            _1292 = mem[64]
                            mem[64] = mem[64] + 192
                            mem[_1292] = address(stor5[address(arg1)][idx].field_0)
                            mem[_1292 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                            mem[_1292 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                            mem[_1292 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                            mem[_1292 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                            mem[_1292 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                            mem[s] = _1292
                            s = s + 32
                            idx = idx + 1
                            continue 
                        mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 128] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192
                        mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 160] = uint256(stor5[address(arg1)].field_256)
                        if uint256(stor5[address(arg1)].field_256) <= 0:
                            revert with 0, 'BonusRewards: pool does not exist'
                        _1458 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                        idx = 0
                        while idx < _1458:
                            if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                                revert with 0, 50
                            if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 12 len 20] == arg2:
                                if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                                    revert with 0, 50
                                if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 90 len 6] > block.timestamp:
                                    if idx >= uint256(stor5[address(arg1)].field_0):
                                        revert with 0, 50
                                    mem[0] = arg1
                                    mem[32] = 5
                                    if uint256(stor5[address(arg1)].field_256):
                                        if block.timestamp > uint256(stor5[address(arg1)].field_256):
                                            uint256(stor5[address(arg1)].field_256) = block.timestamp
                                            mem[mem[64] + 4] = this.address
                                            require ext_code.size(arg1)
                                            staticcall arg1.balanceOf(address rg1) with:
                                                    gas gas_remaining wei
                                                   args address(this.address)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _1508 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _1510 = mem[_1508]
                                            if mem[_1508]:
                                                s = 0
                                                while s < uint256(stor5[address(arg1)].field_0):
                                                    mem[0] = sha3(address(arg1), 5)
                                                    if uint256(stor5[address(arg1)].field_256) < stor5[address(arg1)][s].field_208 % 281474976710656:
                                                        if stor5[address(arg1)][s].field_160 % 281474976710656 < block.timestamp:
                                                            _1540 = mem[64]
                                                            mem[64] = mem[64] + 192
                                                            mem[_1540] = address(stor5[address(arg1)][s].field_0)
                                                            mem[_1540 + 32] = stor5[address(arg1)][s].field_160 % 281474976710656
                                                            mem[_1540 + 64] = stor5[address(arg1)][s].field_208 % 281474976710656
                                                            mem[_1540 + 96] = uint256(stor5[address(arg1)][s].field_256)
                                                            mem[_1540 + 128] = uint256(stor5[address(arg1)][s].field_512)
                                                            mem[_1540 + 160] = uint256(stor5[address(arg1)][s].field_768)
                                                            if stor5[address(arg1)][s].field_208 % 281474976710656 <= uint256(stor5[address(arg1)].field_256):
                                                                if not _1510:
                                                                    revert with 0, 18
                                                                if uint256(stor5[address(arg1)][s].field_512) > !(0 / _1510):
                                                                    revert with 0, 17
                                                                uint256(stor5[address(arg1)][s].field_512) += 0 / _1510
                                                            else:
                                                                if block.timestamp > stor5[address(arg1)][s].field_208 % 281474976710656:
                                                                    if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                        if stor5[address(arg1)][s].field_208 % 281474976710656 < uint256(stor5[address(arg1)].field_256):
                                                                            revert with 0, 17
                                                                        if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and stor5[address(arg1)][s].field_208 % 281474976710656 - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if not _1510:
                                                                            revert with 0, 18
                                                                        if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][s].field_208 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1510):
                                                                            revert with 0, 17
                                                                        uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][s].field_208 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1510
                                                                    else:
                                                                        if stor5[address(arg1)][s].field_0 % 281474976710656 < stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                            revert with 0, 17
                                                                        if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and stor5[address(arg1)][s].field_0 % 281474976710656 - stor5[address(arg1)][s].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if not _1510:
                                                                            revert with 0, 18
                                                                        if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][s].field_0 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1510):
                                                                            revert with 0, 17
                                                                        uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][s].field_0 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1510
                                                                else:
                                                                    if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                        if block.timestamp < uint256(stor5[address(arg1)].field_256):
                                                                            revert with 0, 17
                                                                        if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and block.timestamp - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if not _1510:
                                                                            revert with 0, 18
                                                                        if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1510):
                                                                            revert with 0, 17
                                                                        uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1510
                                                                    else:
                                                                        if block.timestamp < stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                            revert with 0, 17
                                                                        if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and block.timestamp - stor5[address(arg1)][s].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                            revert with 0, 17
                                                                        if not _1510:
                                                                            revert with 0, 18
                                                                        if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1510):
                                                                            revert with 0, 17
                                                                        uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1510
                                                    if s == -1:
                                                        revert with 0, 17
                                                    _1458 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                                                    s = s + 1
                                                    continue 
                                    if stor5[address(arg1)][idx].field_160 % 281474976710656 < block.timestamp:
                                        if stor5[address(arg1)][idx].field_208 % 281474976710656 < block.timestamp:
                                            revert with 0, 17
                                        if stor5[address(arg1)][idx].field_208 % 281474976710656 - block.timestamp and uint256(stor5[address(arg1)][idx].field_256) > -1 / stor5[address(arg1)][idx].field_208 % 281474976710656 - block.timestamp:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if (stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) / arg3 > !block.timestamp:
                                            revert with 0, 17
                                        stor5[address(arg1)][idx].field_208 % 281474976710656 = ((stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) / arg3) + block.timestamp % 281474976710656
                                    else:
                                        if arg4 % 281474976710656 >= block.timestamp:
                                            stor5[address(arg1)][idx].field_160 % 281474976710656 = arg4 % 281474976710656
                                        if uint256(stor5[address(arg1)][idx].field_768) and 168 * 24 * 3600 > -1 / uint256(stor5[address(arg1)][idx].field_768):
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if 168 * 24 * 3600 * uint256(stor5[address(arg1)][idx].field_768) / arg3 > !stor5[address(arg1)][idx].field_160 % 281474976710656:
                                            revert with 0, 17
                                        stor5[address(arg1)][idx].field_208 % 281474976710656 = (168 * 24 * 3600 * uint256(stor5[address(arg1)][idx].field_768) / arg3) + stor5[address(arg1)][idx].field_160 % 281474976710656 % 281474976710656
                                    uint256(stor5[address(arg1)][idx].field_256) = arg3
                            if idx == -1:
                                revert with 0, 17
                            _1458 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                            idx = idx + 1
                            continue 
                    stor1 = 1
                revert with 0, 'BonusRewards: not authorized caller'
            if not arg4 % 281474976710656:
                mem[0] = arg1
                mem[32] = 5
                mem[64] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + (32 * uint256(stor5[address(arg1)].field_0)) + 224
                mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192] = uint256(stor5[address(arg1)].field_0)
                s = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224
                idx = 0
                while idx < uint256(stor5[address(arg1)].field_0):
                    mem[0] = sha3(address(arg1), 5)
                    _992 = mem[64]
                    mem[64] = mem[64] + 192
                    mem[_992] = address(stor5[address(arg1)][idx].field_0)
                    mem[_992 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                    mem[_992 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                    mem[_992 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                    mem[_992 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                    mem[_992 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                    mem[s] = _992
                    s = s + 32
                    idx = idx + 1
                    continue 
                mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 128] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192
                mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 160] = uint256(stor5[address(arg1)].field_256)
                if uint256(stor5[address(arg1)].field_256) <= 0:
                    revert with 0, 'BonusRewards: pool does not exist'
                _1285 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                idx = 0
                while idx < _1285:
                    if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                        revert with 0, 50
                    if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 12 len 20] == arg2:
                        if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                            revert with 0, 50
                        if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 90 len 6] > block.timestamp:
                            if idx >= uint256(stor5[address(arg1)].field_0):
                                revert with 0, 50
                            mem[0] = arg1
                            mem[32] = 5
                            if uint256(stor5[address(arg1)].field_256):
                                if block.timestamp > uint256(stor5[address(arg1)].field_256):
                                    uint256(stor5[address(arg1)].field_256) = block.timestamp
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1395 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _1399 = mem[_1395]
                                    if mem[_1395]:
                                        s = 0
                                        while s < uint256(stor5[address(arg1)].field_0):
                                            mem[0] = sha3(address(arg1), 5)
                                            if uint256(stor5[address(arg1)].field_256) < stor5[address(arg1)][s].field_208 % 281474976710656:
                                                if stor5[address(arg1)][s].field_160 % 281474976710656 < block.timestamp:
                                                    _1473 = mem[64]
                                                    mem[64] = mem[64] + 192
                                                    mem[_1473] = address(stor5[address(arg1)][s].field_0)
                                                    mem[_1473 + 32] = stor5[address(arg1)][s].field_160 % 281474976710656
                                                    mem[_1473 + 64] = stor5[address(arg1)][s].field_208 % 281474976710656
                                                    mem[_1473 + 96] = uint256(stor5[address(arg1)][s].field_256)
                                                    mem[_1473 + 128] = uint256(stor5[address(arg1)][s].field_512)
                                                    mem[_1473 + 160] = uint256(stor5[address(arg1)][s].field_768)
                                                    if stor5[address(arg1)][s].field_208 % 281474976710656 <= uint256(stor5[address(arg1)].field_256):
                                                        if not _1399:
                                                            revert with 0, 18
                                                        if uint256(stor5[address(arg1)][s].field_512) > !(0 / _1399):
                                                            revert with 0, 17
                                                        uint256(stor5[address(arg1)][s].field_512) += 0 / _1399
                                                    else:
                                                        if block.timestamp > stor5[address(arg1)][s].field_208 % 281474976710656:
                                                            if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                if stor5[address(arg1)][s].field_208 % 281474976710656 < uint256(stor5[address(arg1)].field_256):
                                                                    revert with 0, 17
                                                                if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and stor5[address(arg1)][s].field_208 % 281474976710656 - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if not _1399:
                                                                    revert with 0, 18
                                                                if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][s].field_208 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1399):
                                                                    revert with 0, 17
                                                                uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][s].field_208 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1399
                                                            else:
                                                                if stor5[address(arg1)][s].field_0 % 281474976710656 < stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                    revert with 0, 17
                                                                if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and stor5[address(arg1)][s].field_0 % 281474976710656 - stor5[address(arg1)][s].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if not _1399:
                                                                    revert with 0, 18
                                                                if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][s].field_0 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1399):
                                                                    revert with 0, 17
                                                                uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][s].field_0 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1399
                                                        else:
                                                            if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                if block.timestamp < uint256(stor5[address(arg1)].field_256):
                                                                    revert with 0, 17
                                                                if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and block.timestamp - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if not _1399:
                                                                    revert with 0, 18
                                                                if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1399):
                                                                    revert with 0, 17
                                                                uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1399
                                                            else:
                                                                if block.timestamp < stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                    revert with 0, 17
                                                                if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and block.timestamp - stor5[address(arg1)][s].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if not _1399:
                                                                    revert with 0, 18
                                                                if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1399):
                                                                    revert with 0, 17
                                                                uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1399
                                            if s == -1:
                                                revert with 0, 17
                                            _1285 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                                            s = s + 1
                                            continue 
                            if stor5[address(arg1)][idx].field_160 % 281474976710656 < block.timestamp:
                                if stor5[address(arg1)][idx].field_208 % 281474976710656 < block.timestamp:
                                    revert with 0, 17
                                if stor5[address(arg1)][idx].field_208 % 281474976710656 - block.timestamp and uint256(stor5[address(arg1)][idx].field_256) > -1 / stor5[address(arg1)][idx].field_208 % 281474976710656 - block.timestamp:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if (stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) / arg3 > !block.timestamp:
                                    revert with 0, 17
                                stor5[address(arg1)][idx].field_208 % 281474976710656 = ((stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) / arg3) + block.timestamp % 281474976710656
                            else:
                                if arg4 % 281474976710656 >= block.timestamp:
                                    stor5[address(arg1)][idx].field_160 % 281474976710656 = arg4 % 281474976710656
                                if uint256(stor5[address(arg1)][idx].field_768) and 168 * 24 * 3600 > -1 / uint256(stor5[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if 168 * 24 * 3600 * uint256(stor5[address(arg1)][idx].field_768) / arg3 > !stor5[address(arg1)][idx].field_160 % 281474976710656:
                                    revert with 0, 17
                                stor5[address(arg1)][idx].field_208 % 281474976710656 = (168 * 24 * 3600 * uint256(stor5[address(arg1)][idx].field_768) / arg3) + stor5[address(arg1)][idx].field_160 % 281474976710656 % 281474976710656
                            uint256(stor5[address(arg1)][idx].field_256) = arg3
                    if idx == -1:
                        revert with 0, 17
                    _1285 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                    idx = idx + 1
                    continue 
            else:
                if arg4 % 281474976710656 <= block.timestamp:
                    revert with 0, 'BonusRewards: startTime in the past'
                mem[0] = arg1
                mem[32] = 5
                mem[64] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + (32 * uint256(stor5[address(arg1)].field_0)) + 224
                mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192] = uint256(stor5[address(arg1)].field_0)
                s = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224
                idx = 0
                while idx < uint256(stor5[address(arg1)].field_0):
                    mem[0] = sha3(address(arg1), 5)
                    _995 = mem[64]
                    mem[64] = mem[64] + 192
                    mem[_995] = address(stor5[address(arg1)][idx].field_0)
                    mem[_995 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                    mem[_995 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                    mem[_995 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                    mem[_995 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                    mem[_995 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                    mem[s] = _995
                    s = s + 32
                    idx = idx + 1
                    continue 
                mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 128] = (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192
                mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 160] = uint256(stor5[address(arg1)].field_256)
                if uint256(stor5[address(arg1)].field_256) <= 0:
                    revert with 0, 'BonusRewards: pool does not exist'
                _1286 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                idx = 0
                while idx < _1286:
                    if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                        revert with 0, 50
                    if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 12 len 20] == arg2:
                        if idx >= mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]:
                            revert with 0, 50
                        if mem[mem[(32 * idx) + (32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 224] + 90 len 6] > block.timestamp:
                            if idx >= uint256(stor5[address(arg1)].field_0):
                                revert with 0, 50
                            mem[0] = arg1
                            mem[32] = 5
                            if uint256(stor5[address(arg1)].field_256):
                                if block.timestamp > uint256(stor5[address(arg1)].field_256):
                                    uint256(stor5[address(arg1)].field_256) = block.timestamp
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1396 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _1400 = mem[_1396]
                                    if mem[_1396]:
                                        s = 0
                                        while s < uint256(stor5[address(arg1)].field_0):
                                            mem[0] = sha3(address(arg1), 5)
                                            if uint256(stor5[address(arg1)].field_256) < stor5[address(arg1)][s].field_208 % 281474976710656:
                                                if stor5[address(arg1)][s].field_160 % 281474976710656 < block.timestamp:
                                                    _1474 = mem[64]
                                                    mem[64] = mem[64] + 192
                                                    mem[_1474] = address(stor5[address(arg1)][s].field_0)
                                                    mem[_1474 + 32] = stor5[address(arg1)][s].field_160 % 281474976710656
                                                    mem[_1474 + 64] = stor5[address(arg1)][s].field_208 % 281474976710656
                                                    mem[_1474 + 96] = uint256(stor5[address(arg1)][s].field_256)
                                                    mem[_1474 + 128] = uint256(stor5[address(arg1)][s].field_512)
                                                    mem[_1474 + 160] = uint256(stor5[address(arg1)][s].field_768)
                                                    if stor5[address(arg1)][s].field_208 % 281474976710656 <= uint256(stor5[address(arg1)].field_256):
                                                        if not _1400:
                                                            revert with 0, 18
                                                        if uint256(stor5[address(arg1)][s].field_512) > !(0 / _1400):
                                                            revert with 0, 17
                                                        uint256(stor5[address(arg1)][s].field_512) += 0 / _1400
                                                    else:
                                                        if block.timestamp > stor5[address(arg1)][s].field_208 % 281474976710656:
                                                            if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                if stor5[address(arg1)][s].field_208 % 281474976710656 < uint256(stor5[address(arg1)].field_256):
                                                                    revert with 0, 17
                                                                if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and stor5[address(arg1)][s].field_208 % 281474976710656 - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if not _1400:
                                                                    revert with 0, 18
                                                                if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][s].field_208 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1400):
                                                                    revert with 0, 17
                                                                uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][s].field_208 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1400
                                                            else:
                                                                if stor5[address(arg1)][s].field_0 % 281474976710656 < stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                    revert with 0, 17
                                                                if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and stor5[address(arg1)][s].field_0 % 281474976710656 - stor5[address(arg1)][s].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if not _1400:
                                                                    revert with 0, 18
                                                                if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][s].field_0 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1400):
                                                                    revert with 0, 17
                                                                uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][s].field_0 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1400
                                                        else:
                                                            if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                if block.timestamp < uint256(stor5[address(arg1)].field_256):
                                                                    revert with 0, 17
                                                                if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and block.timestamp - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if not _1400:
                                                                    revert with 0, 18
                                                                if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1400):
                                                                    revert with 0, 17
                                                                uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1400
                                                            else:
                                                                if block.timestamp < stor5[address(arg1)][s].field_160 % 281474976710656:
                                                                    revert with 0, 17
                                                                if uint256(stor5[address(arg1)][s].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256) and block.timestamp - stor5[address(arg1)][s].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][s].field_256):
                                                                    revert with 0, 17
                                                                if not _1400:
                                                                    revert with 0, 18
                                                                if uint256(stor5[address(arg1)][s].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1400):
                                                                    revert with 0, 17
                                                                uint256(stor5[address(arg1)][s].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][s].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][s].field_160 % 281474976710656 * uint256(stor5[address(arg1)][s].field_256)) / 168 * 24 * 3600 / _1400
                                            if s == -1:
                                                revert with 0, 17
                                            _1286 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                                            s = s + 1
                                            continue 
                            if stor5[address(arg1)][idx].field_160 % 281474976710656 < block.timestamp:
                                if stor5[address(arg1)][idx].field_208 % 281474976710656 < block.timestamp:
                                    revert with 0, 17
                                if stor5[address(arg1)][idx].field_208 % 281474976710656 - block.timestamp and uint256(stor5[address(arg1)][idx].field_256) > -1 / stor5[address(arg1)][idx].field_208 % 281474976710656 - block.timestamp:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if (stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) / arg3 > !block.timestamp:
                                    revert with 0, 17
                                stor5[address(arg1)][idx].field_208 % 281474976710656 = ((stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) / arg3) + block.timestamp % 281474976710656
                            else:
                                if arg4 % 281474976710656 >= block.timestamp:
                                    stor5[address(arg1)][idx].field_160 % 281474976710656 = arg4 % 281474976710656
                                if uint256(stor5[address(arg1)][idx].field_768) and 168 * 24 * 3600 > -1 / uint256(stor5[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if 168 * 24 * 3600 * uint256(stor5[address(arg1)][idx].field_768) / arg3 > !stor5[address(arg1)][idx].field_160 % 281474976710656:
                                    revert with 0, 17
                                stor5[address(arg1)][idx].field_208 % 281474976710656 = (168 * 24 * 3600 * uint256(stor5[address(arg1)][idx].field_768) / arg3) + stor5[address(arg1)][idx].field_160 % 281474976710656 % 281474976710656
                            uint256(stor5[address(arg1)][idx].field_256) = arg3
                    if idx == -1:
                        revert with 0, 17
                    _1286 = mem[(32 * uint256(stor7[address(arg1)][address(arg2)].field_0)) + 192]
                    idx = idx + 1
                    continue 
    stor1 = 1
}

function deposit(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if stor1 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor1 = 2
    if paused:
        revert with 0, 'BonusRewards: paused'
    if not uint256(stor5[address(arg1)].field_256):
        revert with 0, 'Blacksmith: pool does not exists'
    mem[100] = msg.sender
    require ext_code.size(arg1)
    staticcall arg1.balanceOf(address rg1) with:
            gas gas_remaining wei
           args msg.sender
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] < arg2:
        revert with 0, 'Blacksmith: insufficient balance'
    if not uint256(stor5[address(arg1)].field_256):
        mem[ceil32(return_data.size) + 96] = uint256(stor6[address(arg1)][msg.sender].field_0)
        mem[ceil32(return_data.size) + 160] = uint256(stor6[address(arg1)][msg.sender].field_256)
        if not uint256(stor6[address(arg1)][msg.sender].field_256):
            mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + 160
            if not uint256(stor6[address(arg1)][msg.sender].field_0):
                mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 196] = this.address
                require ext_code.size(arg1)
                staticcall arg1.balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 228] = msg.sender
                mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 260] = this.address
                mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 292] = arg2
                mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192] = 100
                mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 228 len 28] = Mask(224, 32, msg.sender) >> 32
                mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224 len 4] = transferFrom(address rg1, address rg2, uint256 rg3)
                mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 324] = 32
                mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 356] = 'SafeERC20: low-level call failed'
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(arg1):
                    revert with 0, 'Address: call to non-contract'
                mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388 len 128] = transferFrom(address rg1, address rg2, uint256 rg3), msg.sender, address(this.address), arg2, 0
                mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 488] = 0
                call arg1 with:
                   funct Mask(32, 224, transferFrom(address rg1, address rg2, uint256 rg3), msg.sender, address(this.address), arg2, 0) >> 224
                     gas gas_remaining wei
                    args (Mask(768, -544, transferFrom(address rg1, address rg2, uint256 rg3), msg.sender, address(this.address), arg2, 0) << 544)
                if not return_data.size:
                    if not ext_call.success:
                        if ext_call.return_data[0]:
                            revert with memory
                              from 128
                               len ext_call.return_data[0]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if not ext_call.return_data[0]:
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 392] = this.address
                        require ext_code.size(arg1)
                        staticcall arg1.balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] < ext_call.return_data[0]:
                            revert with 0, 17
                        if uint256(stor6[address(arg1)][msg.sender].field_0) > !0:
                            revert with 0, 17
                        mem[64] = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + (32 * uint256(stor5[address(arg1)].field_0)) + 420
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = uint256(stor5[address(arg1)].field_0)
                        s = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420
                        idx = 0
                        while idx < uint256(stor5[address(arg1)].field_0):
                            mem[0] = sha3(address(arg1), 5)
                            _11022 = mem[64]
                            mem[64] = mem[64] + 192
                            mem[_11022] = address(stor5[address(arg1)][idx].field_0)
                            mem[_11022 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                            mem[_11022 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                            mem[_11022 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                            mem[_11022 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                            mem[_11022 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                            mem[s] = _11022
                            s = s + 32
                            idx = idx + 1
                            continue 
                    else:
                        require ext_call.return_data[0] >= 32
                        require uint32(msg.sender), mem[132 len 28] == bool(uint32(msg.sender), mem[132 len 28])
                        if not uint32(msg.sender), mem[132 len 28]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 392] = this.address
                        require ext_code.size(arg1)
                        staticcall arg1.balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] < ext_call.return_data[0]:
                            revert with 0, 17
                        if uint256(stor6[address(arg1)][msg.sender].field_0) > !0:
                            revert with 0, 17
                        mem[64] = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + (32 * uint256(stor5[address(arg1)].field_0)) + 420
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = uint256(stor5[address(arg1)].field_0)
                        s = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420
                        idx = 0
                        while idx < uint256(stor5[address(arg1)].field_0):
                            mem[0] = sha3(address(arg1), 5)
                            _11026 = mem[64]
                            mem[64] = mem[64] + 192
                            mem[_11026] = address(stor5[address(arg1)][idx].field_0)
                            mem[_11026 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                            mem[_11026 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                            mem[_11026 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                            mem[_11026 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                            mem[_11026 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                            mem[s] = _11026
                            s = s + 32
                            idx = idx + 1
                            continue 
                    idx = 0
                    while idx < mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388]:
                        if idx >= mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388]:
                            revert with 0, 50
                        if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                            revert with 0, 17
                        if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                            if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                revert with 0, 50
                            mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                            uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420] + 128] / 1000000000000 * 10^18
                        else:
                            uint256(stor6[address(arg1)][msg.sender].field_256)++
                            mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                            uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420] + 128] / 1000000000000 * 10^18
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                else:
                    mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = return_data.size
                    mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if not return_data.size:
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 393] = this.address
                        require ext_code.size(arg1)
                        staticcall arg1.balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] < ext_call.return_data[0]:
                            revert with 0, 17
                        if uint256(stor6[address(arg1)][msg.sender].field_0) > !0:
                            revert with 0, 17
                        mem[64] = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 421
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389] = uint256(stor5[address(arg1)].field_0)
                        s = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421
                        idx = 0
                        while idx < uint256(stor5[address(arg1)].field_0):
                            mem[0] = sha3(address(arg1), 5)
                            _11031 = mem[64]
                            mem[64] = mem[64] + 192
                            mem[_11031] = address(stor5[address(arg1)][idx].field_0)
                            mem[_11031 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                            mem[_11031 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                            mem[_11031 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                            mem[_11031 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                            mem[_11031 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                            mem[s] = _11031
                            s = s + 32
                            idx = idx + 1
                            continue 
                    else:
                        require return_data.size >= 32
                        require mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420] == bool(mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420])
                        if not mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 393] = this.address
                        require ext_code.size(arg1)
                        staticcall arg1.balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] < ext_call.return_data[0]:
                            revert with 0, 17
                        if uint256(stor6[address(arg1)][msg.sender].field_0) > !0:
                            revert with 0, 17
                        mem[64] = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 421
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389] = uint256(stor5[address(arg1)].field_0)
                        s = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421
                        idx = 0
                        while idx < uint256(stor5[address(arg1)].field_0):
                            mem[0] = sha3(address(arg1), 5)
                            _11035 = mem[64]
                            mem[64] = mem[64] + 192
                            mem[_11035] = address(stor5[address(arg1)][idx].field_0)
                            mem[_11035 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                            mem[_11035 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                            mem[_11035 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                            mem[_11035 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                            mem[_11035 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                            mem[s] = _11035
                            s = s + 32
                            idx = idx + 1
                            continue 
                    idx = 0
                    while idx < mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389]:
                        if idx >= mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389]:
                            revert with 0, 50
                        if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                            revert with 0, 17
                        if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                            if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                revert with 0, 50
                            mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                            uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421] + 128] / 1000000000000 * 10^18
                        else:
                            uint256(stor6[address(arg1)][msg.sender].field_256)++
                            mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                            uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421] + 128] / 1000000000000 * 10^18
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                emit Deposit(0, msg.sender, arg1);
            else:
                mem[0] = arg1
                mem[32] = 5
                mem[64] = ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + (32 * uint256(stor5[address(arg1)].field_0)) + 224
                mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192] = uint256(stor5[address(arg1)].field_0)
                s = ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224
                idx = 0
                while idx < uint256(stor5[address(arg1)].field_0):
                    mem[0] = sha3(address(arg1), 5)
                    _5545 = mem[64]
                    mem[64] = mem[64] + 192
                    mem[_5545] = address(stor5[address(arg1)][idx].field_0)
                    mem[_5545 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                    mem[_5545 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                    mem[_5545 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                    mem[_5545 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                    mem[_5545 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                    mem[s] = _5545
                    s = s + 32
                    idx = idx + 1
                    continue 
                _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                idx = 0
                while idx < _10997:
                    if uint256(stor6[address(arg1)][msg.sender].field_256) <= idx:
                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                            revert with 0, 50
                        _11167 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128]
                        _11168 = mem[ceil32(return_data.size) + 96]
                        if mem[ceil32(return_data.size) + 96] and mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] > -1 / mem[ceil32(return_data.size) + 96]:
                            revert with 0, 17
                        if mem[ceil32(return_data.size) + 96] * mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18 < 0:
                            revert with 0, 17
                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                            revert with 0, 50
                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] >= mem[ceil32(return_data.size) + 96] * mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18:
                            if mem[ceil32(return_data.size) + 96] * mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18:
                                if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                    revert with 0, 50
                                _11676 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224]]
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_11676))
                                staticcall address(_11676).balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _11849 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _11911 = mem[_11849]
                                if mem[_11849] > _11168 * _11167 / 1000000000000 * 10^18:
                                    _11998 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = _11168 * _11167 / 1000000000000 * 10^18
                                    _12073 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_12073 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12073 + 36 len 28]
                                    mem[64] = _11998 + 164
                                    mem[_11998 + 100] = 32
                                    mem[_11998 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_11676)):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(address(_11676)):
                                        revert with 0, 'Address: call to non-contract'
                                    _12783 = mem[_12073]
                                    s = 0
                                    while s < _12783:
                                        mem[s + _11998 + 164] = mem[s + _12073 + 32]
                                        _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                        s = s + 32
                                        continue 
                                    if ceil32(_12783) > _12783:
                                        mem[_12783 + _11998 + 164] = 0
                                    call address(_11676).mem[_11998 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_11998 + 168 len _12783 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_11998 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_11998 + 168] = 32
                                            mem[_11998 + 200] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _11998 + 232] = mem[idx + _11998 + 132]
                                                _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_11998 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[64] = _11998 + ceil32(return_data.size) + 165
                                        mem[_11998 + 164] = return_data.size
                                        mem[_11998 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_11998 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_11998 + ceil32(return_data.size) + 169] = 32
                                            mem[_11998 + ceil32(return_data.size) + 201] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _11998 + ceil32(return_data.size) + 233] = mem[idx + _11998 + 132]
                                                _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_11998 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_11998 + 196] == bool(mem[_11998 + 196])
                                            if not mem[_11998 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                        revert with 0, 50
                                    if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _11168 * _11167 / 1000000000000 * 10^18:
                                        revert with 0, 17
                                    mem[32] = 5
                                    if idx >= uint256(stor5[address(arg1)].field_0):
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 5)
                                    uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - (_11168 * _11167 / 1000000000000 * 10^18)
                                else:
                                    if not mem[_11849]:
                                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < 0:
                                            revert with 0, 17
                                        mem[32] = 5
                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 5)
                                        uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                    else:
                                        _12021 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = _11911
                                        _12129 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[64] = mem[64] + 100
                                        mem[_12129 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12129 + 36 len 28]
                                        mem[64] = _12021 + 164
                                        mem[_12021 + 100] = 32
                                        mem[_12021 + 132] = 'SafeERC20: low-level call failed'
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_11676)):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(address(_11676)):
                                            revert with 0, 'Address: call to non-contract'
                                        _12874 = mem[_12129]
                                        s = 0
                                        while s < _12874:
                                            mem[s + _12021 + 164] = mem[s + _12129 + 32]
                                            _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                            s = s + 32
                                            continue 
                                        if ceil32(_12874) > _12874:
                                            mem[_12874 + _12021 + 164] = 0
                                        call address(_11676).mem[_12021 + 164 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_12021 + 168 len _12874 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                mem[_12021 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_12021 + 168] = 32
                                                mem[_12021 + 200] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _12021 + 232] = mem[idx + _12021 + 132]
                                                    _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_12021 + 232]
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[64] = _12021 + ceil32(return_data.size) + 165
                                            mem[_12021 + 164] = return_data.size
                                            mem[_12021 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_12021 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_12021 + ceil32(return_data.size) + 169] = 32
                                                mem[_12021 + ceil32(return_data.size) + 201] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _12021 + ceil32(return_data.size) + 233] = mem[idx + _12021 + 132]
                                                    _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_12021 + ceil32(return_data.size) + 233]
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_12021 + 196] == bool(mem[_12021 + 196])
                                                if not mem[_12021 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _11911:
                                            revert with 0, 17
                                        mem[32] = 5
                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 5)
                                        uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _11911
                        else:
                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                revert with 0, 50
                            _11643 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                            if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]:
                                if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                    revert with 0, 50
                                _11703 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224]]
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_11703))
                                staticcall address(_11703).balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _11877 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _11943 = mem[_11877]
                                if mem[_11877] > _11643:
                                    _12019 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = _11643
                                    _12127 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_12127 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12127 + 36 len 28]
                                    mem[64] = _12019 + 164
                                    mem[_12019 + 100] = 32
                                    mem[_12019 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_11703)):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(address(_11703)):
                                        revert with 0, 'Address: call to non-contract'
                                    _12873 = mem[_12127]
                                    s = 0
                                    while s < _12873:
                                        mem[s + _12019 + 164] = mem[s + _12127 + 32]
                                        _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                        s = s + 32
                                        continue 
                                    if ceil32(_12873) > _12873:
                                        mem[_12873 + _12019 + 164] = 0
                                    call address(_11703).mem[_12019 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_12019 + 168 len _12873 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_12019 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_12019 + 168] = 32
                                            mem[_12019 + 200] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _12019 + 232] = mem[idx + _12019 + 132]
                                                _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_12019 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[64] = _12019 + ceil32(return_data.size) + 165
                                        mem[_12019 + 164] = return_data.size
                                        mem[_12019 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_12019 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_12019 + ceil32(return_data.size) + 169] = 32
                                            mem[_12019 + ceil32(return_data.size) + 201] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _12019 + ceil32(return_data.size) + 233] = mem[idx + _12019 + 132]
                                                _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_12019 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_12019 + 196] == bool(mem[_12019 + 196])
                                            if not mem[_12019 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                        revert with 0, 50
                                    if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _11643:
                                        revert with 0, 17
                                    mem[32] = 5
                                    if idx >= uint256(stor5[address(arg1)].field_0):
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 5)
                                    uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _11643
                                else:
                                    if not mem[_11877]:
                                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < 0:
                                            revert with 0, 17
                                        mem[32] = 5
                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 5)
                                        uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                    else:
                                        _12070 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = _11943
                                        _12206 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[64] = mem[64] + 100
                                        mem[_12206 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12206 + 36 len 28]
                                        mem[64] = _12070 + 164
                                        mem[_12070 + 100] = 32
                                        mem[_12070 + 132] = 'SafeERC20: low-level call failed'
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_11703)):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(address(_11703)):
                                            revert with 0, 'Address: call to non-contract'
                                        _12995 = mem[_12206]
                                        s = 0
                                        while s < _12995:
                                            mem[s + _12070 + 164] = mem[s + _12206 + 32]
                                            _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                            s = s + 32
                                            continue 
                                        if ceil32(_12995) > _12995:
                                            mem[_12995 + _12070 + 164] = 0
                                        call address(_11703).mem[_12070 + 164 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_12070 + 168 len _12995 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                mem[_12070 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_12070 + 168] = 32
                                                mem[_12070 + 200] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _12070 + 232] = mem[idx + _12070 + 132]
                                                    _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_12070 + 232]
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[64] = _12070 + ceil32(return_data.size) + 165
                                            mem[_12070 + 164] = return_data.size
                                            mem[_12070 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_12070 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_12070 + ceil32(return_data.size) + 169] = 32
                                                mem[_12070 + ceil32(return_data.size) + 201] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _12070 + ceil32(return_data.size) + 233] = mem[idx + _12070 + 132]
                                                    _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_12070 + ceil32(return_data.size) + 233]
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_12070 + 196] == bool(mem[_12070 + 196])
                                                if not mem[_12070 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _11943:
                                            revert with 0, 17
                                        mem[32] = 5
                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 5)
                                        uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _11943
                    else:
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        _11159 = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                            revert with 0, 50
                        _11289 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128]
                        _11290 = mem[ceil32(return_data.size) + 96]
                        if mem[ceil32(return_data.size) + 96] and mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] > -1 / mem[ceil32(return_data.size) + 96]:
                            revert with 0, 17
                        if mem[ceil32(return_data.size) + 96] * mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18 < mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]:
                            revert with 0, 17
                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                            revert with 0, 50
                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] >= (mem[ceil32(return_data.size) + 96] * mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18) - mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]:
                            if (mem[ceil32(return_data.size) + 96] * mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18) - mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]:
                                if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                    revert with 0, 50
                                _11707 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224]]
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_11707))
                                staticcall address(_11707).balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _11878 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _11944 = mem[_11878]
                                if mem[_11878] > (_11290 * _11289 / 1000000000000 * 10^18) - _11159:
                                    _12022 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = (_11290 * _11289 / 1000000000000 * 10^18) - _11159
                                    _12136 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_12136 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12136 + 36 len 28]
                                    mem[64] = _12022 + 164
                                    mem[_12022 + 100] = 32
                                    mem[_12022 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_11707)):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(address(_11707)):
                                        revert with 0, 'Address: call to non-contract'
                                    _12883 = mem[_12136]
                                    s = 0
                                    while s < _12883:
                                        mem[s + _12022 + 164] = mem[s + _12136 + 32]
                                        _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                        s = s + 32
                                        continue 
                                    if ceil32(_12883) > _12883:
                                        mem[_12883 + _12022 + 164] = 0
                                    call address(_11707).mem[_12022 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_12022 + 168 len _12883 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_12022 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_12022 + 168] = 32
                                            mem[_12022 + 200] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _12022 + 232] = mem[idx + _12022 + 132]
                                                _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_12022 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[64] = _12022 + ceil32(return_data.size) + 165
                                        mem[_12022 + 164] = return_data.size
                                        mem[_12022 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_12022 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_12022 + ceil32(return_data.size) + 169] = 32
                                            mem[_12022 + ceil32(return_data.size) + 201] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _12022 + ceil32(return_data.size) + 233] = mem[idx + _12022 + 132]
                                                _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_12022 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_12022 + 196] == bool(mem[_12022 + 196])
                                            if not mem[_12022 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                        revert with 0, 50
                                    if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < (_11290 * _11289 / 1000000000000 * 10^18) - _11159:
                                        revert with 0, 17
                                    mem[32] = 5
                                    if idx >= uint256(stor5[address(arg1)].field_0):
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 5)
                                    uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - (_11290 * _11289 / 1000000000000 * 10^18) + _11159
                                else:
                                    if not mem[_11878]:
                                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < 0:
                                            revert with 0, 17
                                        mem[32] = 5
                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 5)
                                        uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                    else:
                                        _12077 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = _11944
                                        _12214 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[64] = mem[64] + 100
                                        mem[_12214 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12214 + 36 len 28]
                                        mem[64] = _12077 + 164
                                        mem[_12077 + 100] = 32
                                        mem[_12077 + 132] = 'SafeERC20: low-level call failed'
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_11707)):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(address(_11707)):
                                            revert with 0, 'Address: call to non-contract'
                                        _13004 = mem[_12214]
                                        s = 0
                                        while s < _13004:
                                            mem[s + _12077 + 164] = mem[s + _12214 + 32]
                                            _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                            s = s + 32
                                            continue 
                                        if ceil32(_13004) > _13004:
                                            mem[_13004 + _12077 + 164] = 0
                                        call address(_11707).mem[_12077 + 164 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_12077 + 168 len _13004 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                mem[_12077 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_12077 + 168] = 32
                                                mem[_12077 + 200] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _12077 + 232] = mem[idx + _12077 + 132]
                                                    _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_12077 + 232]
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[64] = _12077 + ceil32(return_data.size) + 165
                                            mem[_12077 + 164] = return_data.size
                                            mem[_12077 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_12077 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_12077 + ceil32(return_data.size) + 169] = 32
                                                mem[_12077 + ceil32(return_data.size) + 201] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _12077 + ceil32(return_data.size) + 233] = mem[idx + _12077 + 132]
                                                    _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_12077 + ceil32(return_data.size) + 233]
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_12077 + 196] == bool(mem[_12077 + 196])
                                                if not mem[_12077 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _11944:
                                            revert with 0, 17
                                        mem[32] = 5
                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 5)
                                        uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _11944
                        else:
                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                revert with 0, 50
                            _11660 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                            if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]:
                                if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                    revert with 0, 50
                                _11744 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224]]
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_11744))
                                staticcall address(_11744).balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _11912 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _11967 = mem[_11912]
                                if mem[_11912] > _11660:
                                    _12075 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = _11660
                                    _12212 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_12212 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12212 + 36 len 28]
                                    mem[64] = _12075 + 164
                                    mem[_12075 + 100] = 32
                                    mem[_12075 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_11744)):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(address(_11744)):
                                        revert with 0, 'Address: call to non-contract'
                                    _13003 = mem[_12212]
                                    s = 0
                                    while s < _13003:
                                        mem[s + _12075 + 164] = mem[s + _12212 + 32]
                                        _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                        s = s + 32
                                        continue 
                                    if ceil32(_13003) > _13003:
                                        mem[_13003 + _12075 + 164] = 0
                                    call address(_11744).mem[_12075 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_12075 + 168 len _13003 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_12075 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_12075 + 168] = 32
                                            mem[_12075 + 200] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _12075 + 232] = mem[idx + _12075 + 132]
                                                _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_12075 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[64] = _12075 + ceil32(return_data.size) + 165
                                        mem[_12075 + 164] = return_data.size
                                        mem[_12075 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_12075 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_12075 + ceil32(return_data.size) + 169] = 32
                                            mem[_12075 + ceil32(return_data.size) + 201] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _12075 + ceil32(return_data.size) + 233] = mem[idx + _12075 + 132]
                                                _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_12075 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_12075 + 196] == bool(mem[_12075 + 196])
                                            if not mem[_12075 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                        revert with 0, 50
                                    if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _11660:
                                        revert with 0, 17
                                    mem[32] = 5
                                    if idx >= uint256(stor5[address(arg1)].field_0):
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 5)
                                    uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _11660
                                else:
                                    if not mem[_11912]:
                                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < 0:
                                            revert with 0, 17
                                        mem[32] = 5
                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 5)
                                        uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                    else:
                                        _12133 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = _11967
                                        _12311 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[64] = mem[64] + 100
                                        mem[_12311 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12311 + 36 len 28]
                                        mem[64] = _12133 + 164
                                        mem[_12133 + 100] = 32
                                        mem[_12133 + 132] = 'SafeERC20: low-level call failed'
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_11744)):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(address(_11744)):
                                            revert with 0, 'Address: call to non-contract'
                                        _13109 = mem[_12311]
                                        s = 0
                                        while s < _13109:
                                            mem[s + _12133 + 164] = mem[s + _12311 + 32]
                                            _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                            s = s + 32
                                            continue 
                                        if ceil32(_13109) > _13109:
                                            mem[_13109 + _12133 + 164] = 0
                                        call address(_11744).mem[_12133 + 164 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_12133 + 168 len _13109 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                mem[_12133 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_12133 + 168] = 32
                                                mem[_12133 + 200] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _12133 + 232] = mem[idx + _12133 + 132]
                                                    _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_12133 + 232]
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[64] = _12133 + ceil32(return_data.size) + 165
                                            mem[_12133 + 164] = return_data.size
                                            mem[_12133 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_12133 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_12133 + ceil32(return_data.size) + 169] = 32
                                                mem[_12133 + ceil32(return_data.size) + 201] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _12133 + ceil32(return_data.size) + 233] = mem[idx + _12133 + 132]
                                                    _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_12133 + ceil32(return_data.size) + 233]
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_12133 + 196] == bool(mem[_12133 + 196])
                                                if not mem[_12133 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _11967:
                                            revert with 0, 17
                                        mem[32] = 5
                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 5)
                                        uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _11967
                    if idx == -1:
                        revert with 0, 17
                    _10997 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(arg1)
                staticcall arg1.balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _11434 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _11471 = mem[_11434]
                _11510 = mem[64]
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = this.address
                mem[mem[64] + 100] = arg2
                _11576 = mem[64]
                mem[mem[64]] = 100
                mem[mem[64] + 32 len 4] = transferFrom(address rg1, address rg2, uint256 rg3)
                mem[64] = mem[64] + 196
                mem[_11510 + 132] = 32
                mem[_11510 + 164] = 'SafeERC20: low-level call failed'
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(arg1):
                    revert with 0, 'Address: call to non-contract'
                _11781 = mem[_11576]
                mem[_11510 + 196 len ceil32(mem[_11576])] = mem[_11576 + 32 len ceil32(mem[_11576])]
                if ceil32(_11781) <= _11781:
                    call arg1 with:
                         gas gas_remaining wei
                        args mem[_11510 + 200 len _11781 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if not mem[96]:
                            mem[_11510 + 200] = this.address
                            require ext_code.size(arg1)
                            staticcall arg1.balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_11510 + 196] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < _11471:
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _11471):
                                revert with 0, 17
                            uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _11471
                            mem[64] = _11510 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                            mem[_11510 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                            s = _11510 + ceil32(return_data.size) + 228
                            idx = 0
                            while idx < uint256(stor5[address(arg1)].field_0):
                                mem[0] = sha3(address(arg1), 5)
                                _30131 = mem[64]
                                mem[64] = mem[64] + 192
                                mem[_30131] = address(stor5[address(arg1)][idx].field_0)
                                mem[_30131 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                mem[_30131 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                mem[_30131 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                mem[_30131 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                mem[_30131 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                mem[s] = _30131
                                s = s + 32
                                idx = idx + 1
                                continue 
                        else:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_11510 + 200] = this.address
                            require ext_code.size(arg1)
                            staticcall arg1.balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_11510 + 196] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < _11471:
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _11471):
                                revert with 0, 17
                            uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _11471
                            mem[64] = _11510 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                            mem[_11510 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                            s = _11510 + ceil32(return_data.size) + 228
                            idx = 0
                            while idx < uint256(stor5[address(arg1)].field_0):
                                mem[0] = sha3(address(arg1), 5)
                                _30135 = mem[64]
                                mem[64] = mem[64] + 192
                                mem[_30135] = address(stor5[address(arg1)][idx].field_0)
                                mem[_30135 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                mem[_30135 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                mem[_30135 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                mem[_30135 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                mem[_30135 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                mem[s] = _30135
                                s = s + 32
                                idx = idx + 1
                                continue 
                        idx = 0
                        while idx < mem[_11510 + ceil32(return_data.size) + 196]:
                            if idx >= mem[_11510 + ceil32(return_data.size) + 196]:
                                revert with 0, 50
                            if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _11510 + ceil32(return_data.size) + 228] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                revert with 0, 17
                            if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                    revert with 0, 50
                                mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _11510 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                            else:
                                uint256(stor6[address(arg1)][msg.sender].field_256)++
                                mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _11510 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                    else:
                        mem[_11510 + 196] = return_data.size
                        mem[_11510 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if not return_data.size:
                            mem[_11510 + ceil32(return_data.size) + 201] = this.address
                            require ext_code.size(arg1)
                            staticcall arg1.balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_11510 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < _11471:
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _11471):
                                revert with 0, 17
                            uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _11471
                            mem[64] = _11510 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                            mem[_11510 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                            s = _11510 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                            idx = 0
                            while idx < uint256(stor5[address(arg1)].field_0):
                                mem[0] = sha3(address(arg1), 5)
                                _30140 = mem[64]
                                mem[64] = mem[64] + 192
                                mem[_30140] = address(stor5[address(arg1)][idx].field_0)
                                mem[_30140 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                mem[_30140 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                mem[_30140 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                mem[_30140 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                mem[_30140 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                mem[s] = _30140
                                s = s + 32
                                idx = idx + 1
                                continue 
                        else:
                            require return_data.size >= 32
                            require mem[_11510 + 228] == bool(mem[_11510 + 228])
                            if not mem[_11510 + 228]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_11510 + ceil32(return_data.size) + 201] = this.address
                            require ext_code.size(arg1)
                            staticcall arg1.balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_11510 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < _11471:
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _11471):
                                revert with 0, 17
                            uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _11471
                            mem[64] = _11510 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                            mem[_11510 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                            s = _11510 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                            idx = 0
                            while idx < uint256(stor5[address(arg1)].field_0):
                                mem[0] = sha3(address(arg1), 5)
                                _30144 = mem[64]
                                mem[64] = mem[64] + 192
                                mem[_30144] = address(stor5[address(arg1)][idx].field_0)
                                mem[_30144 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                mem[_30144 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                mem[_30144 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                mem[_30144 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                mem[_30144 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                mem[s] = _30144
                                s = s + 32
                                idx = idx + 1
                                continue 
                        idx = 0
                        while idx < mem[_11510 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                            if idx >= mem[_11510 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                revert with 0, 50
                            if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _11510 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                revert with 0, 17
                            if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                    revert with 0, 50
                                mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _11510 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                            else:
                                uint256(stor6[address(arg1)][msg.sender].field_256)++
                                mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _11510 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                else:
                    mem[_11781 + _11510 + 196] = 0
                    call arg1 with:
                         gas gas_remaining wei
                        args mem[_11510 + 200 len _11781 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if not mem[96]:
                            mem[_11510 + 200] = this.address
                            require ext_code.size(arg1)
                            staticcall arg1.balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_11510 + 196] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < _11471:
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _11471):
                                revert with 0, 17
                            uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _11471
                            mem[64] = _11510 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                            mem[_11510 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                            s = _11510 + ceil32(return_data.size) + 228
                            idx = 0
                            while idx < uint256(stor5[address(arg1)].field_0):
                                mem[0] = sha3(address(arg1), 5)
                                _30149 = mem[64]
                                mem[64] = mem[64] + 192
                                mem[_30149] = address(stor5[address(arg1)][idx].field_0)
                                mem[_30149 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                mem[_30149 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                mem[_30149 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                mem[_30149 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                mem[_30149 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                mem[s] = _30149
                                s = s + 32
                                idx = idx + 1
                                continue 
                        else:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_11510 + 200] = this.address
                            require ext_code.size(arg1)
                            staticcall arg1.balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_11510 + 196] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < _11471:
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _11471):
                                revert with 0, 17
                            uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _11471
                            mem[64] = _11510 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                            mem[_11510 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                            s = _11510 + ceil32(return_data.size) + 228
                            idx = 0
                            while idx < uint256(stor5[address(arg1)].field_0):
                                mem[0] = sha3(address(arg1), 5)
                                _30153 = mem[64]
                                mem[64] = mem[64] + 192
                                mem[_30153] = address(stor5[address(arg1)][idx].field_0)
                                mem[_30153 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                mem[_30153 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                mem[_30153 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                mem[_30153 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                mem[_30153 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                mem[s] = _30153
                                s = s + 32
                                idx = idx + 1
                                continue 
                        idx = 0
                        while idx < mem[_11510 + ceil32(return_data.size) + 196]:
                            if idx >= mem[_11510 + ceil32(return_data.size) + 196]:
                                revert with 0, 50
                            if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _11510 + ceil32(return_data.size) + 228] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                revert with 0, 17
                            if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                    revert with 0, 50
                                mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _11510 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                            else:
                                uint256(stor6[address(arg1)][msg.sender].field_256)++
                                mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _11510 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                    else:
                        mem[_11510 + 196] = return_data.size
                        mem[_11510 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if not return_data.size:
                            mem[_11510 + ceil32(return_data.size) + 201] = this.address
                            require ext_code.size(arg1)
                            staticcall arg1.balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_11510 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < _11471:
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _11471):
                                revert with 0, 17
                            uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _11471
                            mem[64] = _11510 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                            mem[_11510 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                            s = _11510 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                            idx = 0
                            while idx < uint256(stor5[address(arg1)].field_0):
                                mem[0] = sha3(address(arg1), 5)
                                _30158 = mem[64]
                                mem[64] = mem[64] + 192
                                mem[_30158] = address(stor5[address(arg1)][idx].field_0)
                                mem[_30158 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                mem[_30158 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                mem[_30158 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                mem[_30158 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                mem[_30158 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                mem[s] = _30158
                                s = s + 32
                                idx = idx + 1
                                continue 
                        else:
                            require return_data.size >= 32
                            require mem[_11510 + 228] == bool(mem[_11510 + 228])
                            if not mem[_11510 + 228]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_11510 + ceil32(return_data.size) + 201] = this.address
                            require ext_code.size(arg1)
                            staticcall arg1.balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_11510 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < _11471:
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _11471):
                                revert with 0, 17
                            uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _11471
                            mem[64] = _11510 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                            mem[_11510 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                            s = _11510 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                            idx = 0
                            while idx < uint256(stor5[address(arg1)].field_0):
                                mem[0] = sha3(address(arg1), 5)
                                _30162 = mem[64]
                                mem[64] = mem[64] + 192
                                mem[_30162] = address(stor5[address(arg1)][idx].field_0)
                                mem[_30162 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                mem[_30162 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                mem[_30162 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                mem[_30162 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                mem[_30162 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                mem[s] = _30162
                                s = s + 32
                                idx = idx + 1
                                continue 
                        idx = 0
                        while idx < mem[_11510 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                            if idx >= mem[_11510 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                revert with 0, 50
                            if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _11510 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                revert with 0, 17
                            if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                    revert with 0, 50
                                mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _11510 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                            else:
                                uint256(stor6[address(arg1)][msg.sender].field_256)++
                                mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _11510 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                emit Deposit((ext_call.return_data[0] - _11471), msg.sender, arg1);
        else:
            mem[ceil32(return_data.size) + 192] = uint256(stor6[address(arg1)][msg.sender][1].field_0)
            idx = ceil32(return_data.size) + 192
            s = 0
            while ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 160 > idx:
                mem[idx + 32] = uint256(stor6[address(arg1)][msg.sender][s + 1].field_256)
                idx = idx + 32
                s = s + 1
                continue 
            mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + 160
            if not uint256(stor6[address(arg1)][msg.sender].field_0):
                mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 196] = this.address
                require ext_code.size(arg1)
                staticcall arg1.balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 228] = msg.sender
                mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 260] = this.address
                mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 292] = arg2
                mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192] = 100
                mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224 len 4] = transferFrom(address rg1, address rg2, uint256 rg3)
                mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 324] = 32
                mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 356] = 'SafeERC20: low-level call failed'
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(arg1):
                    revert with 0, 'Address: call to non-contract'
                mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388 len 128] = 0, msg.sender, address(this.address), arg2, 0
                mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 488] = 0
                call arg1 with:
                   funct Mask(32, 224, 0, msg.sender, address(this.address), arg2, 0) >> 224
                     gas gas_remaining wei
                    args (Mask(768, -544, 0, msg.sender, address(this.address), arg2, 0) << 544)
                if not return_data.size:
                    if not ext_call.success:
                        if ext_call.return_data[0]:
                            revert with memory
                              from 128
                               len ext_call.return_data[0]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if not ext_call.return_data[0]:
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 392] = this.address
                        require ext_code.size(arg1)
                        staticcall arg1.balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] < ext_call.return_data[0]:
                            revert with 0, 17
                        if uint256(stor6[address(arg1)][msg.sender].field_0) > !0:
                            revert with 0, 17
                        mem[64] = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + (32 * uint256(stor5[address(arg1)].field_0)) + 420
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = uint256(stor5[address(arg1)].field_0)
                        s = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420
                        idx = 0
                        while idx < uint256(stor5[address(arg1)].field_0):
                            mem[0] = sha3(address(arg1), 5)
                            _30217 = mem[64]
                            mem[64] = mem[64] + 192
                            mem[_30217] = address(stor5[address(arg1)][idx].field_0)
                            mem[_30217 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                            mem[_30217 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                            mem[_30217 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                            mem[_30217 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                            mem[_30217 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                            mem[s] = _30217
                            s = s + 32
                            idx = idx + 1
                            continue 
                    else:
                        require ext_call.return_data[0] >= 32
                        require uint32(msg.sender), mem[132 len 28] == bool(uint32(msg.sender), mem[132 len 28])
                        if not uint32(msg.sender), mem[132 len 28]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 392] = this.address
                        require ext_code.size(arg1)
                        staticcall arg1.balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] < ext_call.return_data[0]:
                            revert with 0, 17
                        if uint256(stor6[address(arg1)][msg.sender].field_0) > !0:
                            revert with 0, 17
                        mem[64] = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + (32 * uint256(stor5[address(arg1)].field_0)) + 420
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = uint256(stor5[address(arg1)].field_0)
                        s = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420
                        idx = 0
                        while idx < uint256(stor5[address(arg1)].field_0):
                            mem[0] = sha3(address(arg1), 5)
                            _30221 = mem[64]
                            mem[64] = mem[64] + 192
                            mem[_30221] = address(stor5[address(arg1)][idx].field_0)
                            mem[_30221 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                            mem[_30221 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                            mem[_30221 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                            mem[_30221 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                            mem[_30221 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                            mem[s] = _30221
                            s = s + 32
                            idx = idx + 1
                            continue 
                    idx = 0
                    while idx < mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388]:
                        if idx >= mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388]:
                            revert with 0, 50
                        if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                            revert with 0, 17
                        if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                            if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                revert with 0, 50
                            mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                            uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420] + 128] / 1000000000000 * 10^18
                        else:
                            uint256(stor6[address(arg1)][msg.sender].field_256)++
                            mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                            uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420] + 128] / 1000000000000 * 10^18
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                else:
                    mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = return_data.size
                    mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if not return_data.size:
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 393] = this.address
                        require ext_code.size(arg1)
                        staticcall arg1.balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] < ext_call.return_data[0]:
                            revert with 0, 17
                        if uint256(stor6[address(arg1)][msg.sender].field_0) > !0:
                            revert with 0, 17
                        mem[64] = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 421
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389] = uint256(stor5[address(arg1)].field_0)
                        s = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421
                        idx = 0
                        while idx < uint256(stor5[address(arg1)].field_0):
                            mem[0] = sha3(address(arg1), 5)
                            _30226 = mem[64]
                            mem[64] = mem[64] + 192
                            mem[_30226] = address(stor5[address(arg1)][idx].field_0)
                            mem[_30226 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                            mem[_30226 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                            mem[_30226 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                            mem[_30226 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                            mem[_30226 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                            mem[s] = _30226
                            s = s + 32
                            idx = idx + 1
                            continue 
                    else:
                        require return_data.size >= 32
                        require mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420] == bool(mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420])
                        if not mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 393] = this.address
                        require ext_code.size(arg1)
                        staticcall arg1.balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] < ext_call.return_data[0]:
                            revert with 0, 17
                        if uint256(stor6[address(arg1)][msg.sender].field_0) > !0:
                            revert with 0, 17
                        mem[64] = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 421
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389] = uint256(stor5[address(arg1)].field_0)
                        s = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421
                        idx = 0
                        while idx < uint256(stor5[address(arg1)].field_0):
                            mem[0] = sha3(address(arg1), 5)
                            _30230 = mem[64]
                            mem[64] = mem[64] + 192
                            mem[_30230] = address(stor5[address(arg1)][idx].field_0)
                            mem[_30230 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                            mem[_30230 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                            mem[_30230 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                            mem[_30230 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                            mem[_30230 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                            mem[s] = _30230
                            s = s + 32
                            idx = idx + 1
                            continue 
                    idx = 0
                    while idx < mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389]:
                        if idx >= mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389]:
                            revert with 0, 50
                        if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                            revert with 0, 17
                        if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                            if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                revert with 0, 50
                            mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                            uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421] + 128] / 1000000000000 * 10^18
                        else:
                            uint256(stor6[address(arg1)][msg.sender].field_256)++
                            mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                            uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421] + 128] / 1000000000000 * 10^18
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                emit Deposit(0, msg.sender, arg1);
            else:
                mem[0] = arg1
                mem[32] = 5
                mem[64] = ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + (32 * uint256(stor5[address(arg1)].field_0)) + 224
                mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192] = uint256(stor5[address(arg1)].field_0)
                s = ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224
                idx = 0
                while idx < uint256(stor5[address(arg1)].field_0):
                    mem[0] = sha3(address(arg1), 5)
                    _20294 = mem[64]
                    mem[64] = mem[64] + 192
                    mem[_20294] = address(stor5[address(arg1)][idx].field_0)
                    mem[_20294 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                    mem[_20294 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                    mem[_20294 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                    mem[_20294 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                    mem[_20294 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                    mem[s] = _20294
                    s = s + 32
                    idx = idx + 1
                    continue 
                _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                idx = 0
                while idx < _30116:
                    if uint256(stor6[address(arg1)][msg.sender].field_256) <= idx:
                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                            revert with 0, 50
                        _30668 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128]
                        _30669 = mem[ceil32(return_data.size) + 96]
                        if mem[ceil32(return_data.size) + 96] and mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] > -1 / mem[ceil32(return_data.size) + 96]:
                            revert with 0, 17
                        if mem[ceil32(return_data.size) + 96] * mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18 < 0:
                            revert with 0, 17
                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                            revert with 0, 50
                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] >= mem[ceil32(return_data.size) + 96] * mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18:
                            if mem[ceil32(return_data.size) + 96] * mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18:
                                if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                    revert with 0, 50
                                _31984 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224]]
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_31984))
                                staticcall address(_31984).balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _32277 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _32371 = mem[_32277]
                                if mem[_32277] > _30669 * _30668 / 1000000000000 * 10^18:
                                    _32489 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = _30669 * _30668 / 1000000000000 * 10^18
                                    _32553 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_32553 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_32553 + 36 len 28]
                                    mem[64] = _32489 + 164
                                    mem[_32489 + 100] = 32
                                    mem[_32489 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_31984)):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(address(_31984)):
                                        revert with 0, 'Address: call to non-contract'
                                    _33030 = mem[_32553]
                                    s = 0
                                    while s < _33030:
                                        mem[s + _32489 + 164] = mem[s + _32553 + 32]
                                        _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                        s = s + 32
                                        continue 
                                    if ceil32(_33030) > _33030:
                                        mem[_33030 + _32489 + 164] = 0
                                    call address(_31984).mem[_32489 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_32489 + 168 len _33030 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_32489 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_32489 + 168] = 32
                                            mem[_32489 + 200] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _32489 + 232] = mem[idx + _32489 + 132]
                                                _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_32489 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[64] = _32489 + ceil32(return_data.size) + 165
                                        mem[_32489 + 164] = return_data.size
                                        mem[_32489 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_32489 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_32489 + ceil32(return_data.size) + 169] = 32
                                            mem[_32489 + ceil32(return_data.size) + 201] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _32489 + ceil32(return_data.size) + 233] = mem[idx + _32489 + 132]
                                                _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_32489 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_32489 + 196] == bool(mem[_32489 + 196])
                                            if not mem[_32489 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                        revert with 0, 50
                                    if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _30669 * _30668 / 1000000000000 * 10^18:
                                        revert with 0, 17
                                    mem[32] = 5
                                    if idx >= uint256(stor5[address(arg1)].field_0):
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 5)
                                    uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - (_30669 * _30668 / 1000000000000 * 10^18)
                                else:
                                    if not mem[_32277]:
                                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < 0:
                                            revert with 0, 17
                                        mem[32] = 5
                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 5)
                                        uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                    else:
                                        _32500 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = _32371
                                        _32607 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[64] = mem[64] + 100
                                        mem[_32607 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_32607 + 36 len 28]
                                        mem[64] = _32500 + 164
                                        mem[_32500 + 100] = 32
                                        mem[_32500 + 132] = 'SafeERC20: low-level call failed'
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_31984)):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(address(_31984)):
                                            revert with 0, 'Address: call to non-contract'
                                        _33091 = mem[_32607]
                                        s = 0
                                        while s < _33091:
                                            mem[s + _32500 + 164] = mem[s + _32607 + 32]
                                            _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                            s = s + 32
                                            continue 
                                        if ceil32(_33091) > _33091:
                                            mem[_33091 + _32500 + 164] = 0
                                        call address(_31984).mem[_32500 + 164 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_32500 + 168 len _33091 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                mem[_32500 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_32500 + 168] = 32
                                                mem[_32500 + 200] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _32500 + 232] = mem[idx + _32500 + 132]
                                                    _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_32500 + 232]
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[64] = _32500 + ceil32(return_data.size) + 165
                                            mem[_32500 + 164] = return_data.size
                                            mem[_32500 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_32500 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_32500 + ceil32(return_data.size) + 169] = 32
                                                mem[_32500 + ceil32(return_data.size) + 201] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _32500 + ceil32(return_data.size) + 233] = mem[idx + _32500 + 132]
                                                    _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_32500 + ceil32(return_data.size) + 233]
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_32500 + 196] == bool(mem[_32500 + 196])
                                                if not mem[_32500 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _32371:
                                            revert with 0, 17
                                        mem[32] = 5
                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 5)
                                        uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _32371
                        else:
                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                revert with 0, 50
                            _31886 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                            if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]:
                                if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                    revert with 0, 50
                                _32038 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224]]
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_32038))
                                staticcall address(_32038).balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _32351 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _32379 = mem[_32351]
                                if mem[_32351] > _31886:
                                    _32498 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = _31886
                                    _32605 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_32605 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_32605 + 36 len 28]
                                    mem[64] = _32498 + 164
                                    mem[_32498 + 100] = 32
                                    mem[_32498 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_32038)):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(address(_32038)):
                                        revert with 0, 'Address: call to non-contract'
                                    _33090 = mem[_32605]
                                    s = 0
                                    while s < _33090:
                                        mem[s + _32498 + 164] = mem[s + _32605 + 32]
                                        _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                        s = s + 32
                                        continue 
                                    if ceil32(_33090) > _33090:
                                        mem[_33090 + _32498 + 164] = 0
                                    call address(_32038).mem[_32498 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_32498 + 168 len _33090 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_32498 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_32498 + 168] = 32
                                            mem[_32498 + 200] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _32498 + 232] = mem[idx + _32498 + 132]
                                                _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_32498 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[64] = _32498 + ceil32(return_data.size) + 165
                                        mem[_32498 + 164] = return_data.size
                                        mem[_32498 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_32498 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_32498 + ceil32(return_data.size) + 169] = 32
                                            mem[_32498 + ceil32(return_data.size) + 201] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _32498 + ceil32(return_data.size) + 233] = mem[idx + _32498 + 132]
                                                _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_32498 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_32498 + 196] == bool(mem[_32498 + 196])
                                            if not mem[_32498 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                        revert with 0, 50
                                    if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _31886:
                                        revert with 0, 17
                                    mem[32] = 5
                                    if idx >= uint256(stor5[address(arg1)].field_0):
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 5)
                                    uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _31886
                                else:
                                    if not mem[_32351]:
                                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < 0:
                                            revert with 0, 17
                                        mem[32] = 5
                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 5)
                                        uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                    else:
                                        _32550 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = _32379
                                        _32666 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[64] = mem[64] + 100
                                        mem[_32666 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_32666 + 36 len 28]
                                        mem[64] = _32550 + 164
                                        mem[_32550 + 100] = 32
                                        mem[_32550 + 132] = 'SafeERC20: low-level call failed'
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_32038)):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(address(_32038)):
                                            revert with 0, 'Address: call to non-contract'
                                        _33168 = mem[_32666]
                                        s = 0
                                        while s < _33168:
                                            mem[s + _32550 + 164] = mem[s + _32666 + 32]
                                            _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                            s = s + 32
                                            continue 
                                        if ceil32(_33168) > _33168:
                                            mem[_33168 + _32550 + 164] = 0
                                        call address(_32038).mem[_32550 + 164 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_32550 + 168 len _33168 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                mem[_32550 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_32550 + 168] = 32
                                                mem[_32550 + 200] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _32550 + 232] = mem[idx + _32550 + 132]
                                                    _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_32550 + 232]
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[64] = _32550 + ceil32(return_data.size) + 165
                                            mem[_32550 + 164] = return_data.size
                                            mem[_32550 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_32550 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_32550 + ceil32(return_data.size) + 169] = 32
                                                mem[_32550 + ceil32(return_data.size) + 201] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _32550 + ceil32(return_data.size) + 233] = mem[idx + _32550 + 132]
                                                    _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_32550 + ceil32(return_data.size) + 233]
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_32550 + 196] == bool(mem[_32550 + 196])
                                                if not mem[_32550 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _32379:
                                            revert with 0, 17
                                        mem[32] = 5
                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 5)
                                        uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _32379
                    else:
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        _30532 = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                            revert with 0, 50
                        _31031 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128]
                        _31032 = mem[ceil32(return_data.size) + 96]
                        if mem[ceil32(return_data.size) + 96] and mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] > -1 / mem[ceil32(return_data.size) + 96]:
                            revert with 0, 17
                        if mem[ceil32(return_data.size) + 96] * mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18 < mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]:
                            revert with 0, 17
                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                            revert with 0, 50
                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] >= (mem[ceil32(return_data.size) + 96] * mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18) - mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]:
                            if (mem[ceil32(return_data.size) + 96] * mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18) - mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]:
                                if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                    revert with 0, 50
                                _32042 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224]]
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_32042))
                                staticcall address(_32042).balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _32352 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _32380 = mem[_32352]
                                if mem[_32352] > (_31032 * _31031 / 1000000000000 * 10^18) - _30532:
                                    _32501 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = (_31032 * _31031 / 1000000000000 * 10^18) - _30532
                                    _32614 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_32614 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_32614 + 36 len 28]
                                    mem[64] = _32501 + 164
                                    mem[_32501 + 100] = 32
                                    mem[_32501 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_32042)):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(address(_32042)):
                                        revert with 0, 'Address: call to non-contract'
                                    _33100 = mem[_32614]
                                    s = 0
                                    while s < _33100:
                                        mem[s + _32501 + 164] = mem[s + _32614 + 32]
                                        _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                        s = s + 32
                                        continue 
                                    if ceil32(_33100) > _33100:
                                        mem[_33100 + _32501 + 164] = 0
                                    call address(_32042).mem[_32501 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_32501 + 168 len _33100 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_32501 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_32501 + 168] = 32
                                            mem[_32501 + 200] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _32501 + 232] = mem[idx + _32501 + 132]
                                                _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_32501 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[64] = _32501 + ceil32(return_data.size) + 165
                                        mem[_32501 + 164] = return_data.size
                                        mem[_32501 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_32501 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_32501 + ceil32(return_data.size) + 169] = 32
                                            mem[_32501 + ceil32(return_data.size) + 201] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _32501 + ceil32(return_data.size) + 233] = mem[idx + _32501 + 132]
                                                _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_32501 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_32501 + 196] == bool(mem[_32501 + 196])
                                            if not mem[_32501 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                        revert with 0, 50
                                    if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < (_31032 * _31031 / 1000000000000 * 10^18) - _30532:
                                        revert with 0, 17
                                    mem[32] = 5
                                    if idx >= uint256(stor5[address(arg1)].field_0):
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 5)
                                    uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - (_31032 * _31031 / 1000000000000 * 10^18) + _30532
                                else:
                                    if not mem[_32352]:
                                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < 0:
                                            revert with 0, 17
                                        mem[32] = 5
                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 5)
                                        uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                    else:
                                        _32557 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = _32380
                                        _32674 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[64] = mem[64] + 100
                                        mem[_32674 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_32674 + 36 len 28]
                                        mem[64] = _32557 + 164
                                        mem[_32557 + 100] = 32
                                        mem[_32557 + 132] = 'SafeERC20: low-level call failed'
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_32042)):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(address(_32042)):
                                            revert with 0, 'Address: call to non-contract'
                                        _33177 = mem[_32674]
                                        s = 0
                                        while s < _33177:
                                            mem[s + _32557 + 164] = mem[s + _32674 + 32]
                                            _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                            s = s + 32
                                            continue 
                                        if ceil32(_33177) > _33177:
                                            mem[_33177 + _32557 + 164] = 0
                                        call address(_32042).mem[_32557 + 164 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_32557 + 168 len _33177 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                mem[_32557 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_32557 + 168] = 32
                                                mem[_32557 + 200] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _32557 + 232] = mem[idx + _32557 + 132]
                                                    _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_32557 + 232]
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[64] = _32557 + ceil32(return_data.size) + 165
                                            mem[_32557 + 164] = return_data.size
                                            mem[_32557 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_32557 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_32557 + ceil32(return_data.size) + 169] = 32
                                                mem[_32557 + ceil32(return_data.size) + 201] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _32557 + ceil32(return_data.size) + 233] = mem[idx + _32557 + 132]
                                                    _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_32557 + ceil32(return_data.size) + 233]
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_32557 + 196] == bool(mem[_32557 + 196])
                                                if not mem[_32557 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _32380:
                                            revert with 0, 17
                                        mem[32] = 5
                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 5)
                                        uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _32380
                        else:
                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                revert with 0, 50
                            _31964 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                            if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]:
                                if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                    revert with 0, 50
                                _32103 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224]]
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_32103))
                                staticcall address(_32103).balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _32372 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _32430 = mem[_32372]
                                if mem[_32372] > _31964:
                                    _32555 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = _31964
                                    _32672 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_32672 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_32672 + 36 len 28]
                                    mem[64] = _32555 + 164
                                    mem[_32555 + 100] = 32
                                    mem[_32555 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_32103)):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(address(_32103)):
                                        revert with 0, 'Address: call to non-contract'
                                    _33176 = mem[_32672]
                                    s = 0
                                    while s < _33176:
                                        mem[s + _32555 + 164] = mem[s + _32672 + 32]
                                        _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                        s = s + 32
                                        continue 
                                    if ceil32(_33176) > _33176:
                                        mem[_33176 + _32555 + 164] = 0
                                    call address(_32103).mem[_32555 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_32555 + 168 len _33176 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_32555 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_32555 + 168] = 32
                                            mem[_32555 + 200] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _32555 + 232] = mem[idx + _32555 + 132]
                                                _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_32555 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[64] = _32555 + ceil32(return_data.size) + 165
                                        mem[_32555 + 164] = return_data.size
                                        mem[_32555 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_32555 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_32555 + ceil32(return_data.size) + 169] = 32
                                            mem[_32555 + ceil32(return_data.size) + 201] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _32555 + ceil32(return_data.size) + 233] = mem[idx + _32555 + 132]
                                                _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_32555 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_32555 + 196] == bool(mem[_32555 + 196])
                                            if not mem[_32555 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                        revert with 0, 50
                                    if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _31964:
                                        revert with 0, 17
                                    mem[32] = 5
                                    if idx >= uint256(stor5[address(arg1)].field_0):
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 5)
                                    uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _31964
                                else:
                                    if not mem[_32372]:
                                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < 0:
                                            revert with 0, 17
                                        mem[32] = 5
                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 5)
                                        uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                    else:
                                        _32611 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = _32430
                                        _32750 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[64] = mem[64] + 100
                                        mem[_32750 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_32750 + 36 len 28]
                                        mem[64] = _32611 + 164
                                        mem[_32611 + 100] = 32
                                        mem[_32611 + 132] = 'SafeERC20: low-level call failed'
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_32103)):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(address(_32103)):
                                            revert with 0, 'Address: call to non-contract'
                                        _33281 = mem[_32750]
                                        s = 0
                                        while s < _33281:
                                            mem[s + _32611 + 164] = mem[s + _32750 + 32]
                                            _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                            s = s + 32
                                            continue 
                                        if ceil32(_33281) > _33281:
                                            mem[_33281 + _32611 + 164] = 0
                                        call address(_32103).mem[_32611 + 164 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_32611 + 168 len _33281 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                mem[_32611 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_32611 + 168] = 32
                                                mem[_32611 + 200] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _32611 + 232] = mem[idx + _32611 + 132]
                                                    _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_32611 + 232]
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[64] = _32611 + ceil32(return_data.size) + 165
                                            mem[_32611 + 164] = return_data.size
                                            mem[_32611 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_32611 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_32611 + ceil32(return_data.size) + 169] = 32
                                                mem[_32611 + ceil32(return_data.size) + 201] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _32611 + ceil32(return_data.size) + 233] = mem[idx + _32611 + 132]
                                                    _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_32611 + ceil32(return_data.size) + 233]
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_32611 + 196] == bool(mem[_32611 + 196])
                                                if not mem[_32611 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _32430:
                                            revert with 0, 17
                                        mem[32] = 5
                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 5)
                                        uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _32430
                    if idx == -1:
                        revert with 0, 17
                    _30116 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(arg1)
                staticcall arg1.balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _31276 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _31403 = mem[_31276]
                _31511 = mem[64]
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = this.address
                mem[mem[64] + 100] = arg2
                _31683 = mem[64]
                mem[mem[64]] = 100
                mem[mem[64] + 32 len 4] = transferFrom(address rg1, address rg2, uint256 rg3)
                mem[64] = mem[64] + 196
                mem[_31511 + 132] = 32
                mem[_31511 + 164] = 'SafeERC20: low-level call failed'
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(arg1):
                    revert with 0, 'Address: call to non-contract'
                _32203 = mem[_31683]
                mem[_31511 + 196 len ceil32(mem[_31683])] = mem[_31683 + 32 len ceil32(mem[_31683])]
                if ceil32(_32203) <= _32203:
                    call arg1 with:
                         gas gas_remaining wei
                        args mem[_31511 + 200 len _32203 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if not mem[96]:
                            mem[_31511 + 200] = this.address
                            require ext_code.size(arg1)
                            staticcall arg1.balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_31511 + 196] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < _31403:
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _31403):
                                revert with 0, 17
                            uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _31403
                            mem[64] = _31511 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                            mem[_31511 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                            s = _31511 + ceil32(return_data.size) + 228
                            idx = 0
                            while idx < uint256(stor5[address(arg1)].field_0):
                                mem[0] = sha3(address(arg1), 5)
                                _41930 = mem[64]
                                mem[64] = mem[64] + 192
                                mem[_41930] = address(stor5[address(arg1)][idx].field_0)
                                mem[_41930 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                mem[_41930 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                mem[_41930 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                mem[_41930 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                mem[_41930 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                mem[s] = _41930
                                s = s + 32
                                idx = idx + 1
                                continue 
                        else:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_31511 + 200] = this.address
                            require ext_code.size(arg1)
                            staticcall arg1.balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_31511 + 196] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < _31403:
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _31403):
                                revert with 0, 17
                            uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _31403
                            mem[64] = _31511 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                            mem[_31511 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                            s = _31511 + ceil32(return_data.size) + 228
                            idx = 0
                            while idx < uint256(stor5[address(arg1)].field_0):
                                mem[0] = sha3(address(arg1), 5)
                                _41934 = mem[64]
                                mem[64] = mem[64] + 192
                                mem[_41934] = address(stor5[address(arg1)][idx].field_0)
                                mem[_41934 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                mem[_41934 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                mem[_41934 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                mem[_41934 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                mem[_41934 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                mem[s] = _41934
                                s = s + 32
                                idx = idx + 1
                                continue 
                        idx = 0
                        while idx < mem[_31511 + ceil32(return_data.size) + 196]:
                            if idx >= mem[_31511 + ceil32(return_data.size) + 196]:
                                revert with 0, 50
                            if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _31511 + ceil32(return_data.size) + 228] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                revert with 0, 17
                            if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                    revert with 0, 50
                                mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _31511 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                            else:
                                uint256(stor6[address(arg1)][msg.sender].field_256)++
                                mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _31511 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                    else:
                        mem[_31511 + 196] = return_data.size
                        mem[_31511 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if not return_data.size:
                            mem[_31511 + ceil32(return_data.size) + 201] = this.address
                            require ext_code.size(arg1)
                            staticcall arg1.balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_31511 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < _31403:
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _31403):
                                revert with 0, 17
                            uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _31403
                            mem[64] = _31511 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                            mem[_31511 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                            s = _31511 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                            idx = 0
                            while idx < uint256(stor5[address(arg1)].field_0):
                                mem[0] = sha3(address(arg1), 5)
                                _41939 = mem[64]
                                mem[64] = mem[64] + 192
                                mem[_41939] = address(stor5[address(arg1)][idx].field_0)
                                mem[_41939 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                mem[_41939 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                mem[_41939 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                mem[_41939 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                mem[_41939 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                mem[s] = _41939
                                s = s + 32
                                idx = idx + 1
                                continue 
                        else:
                            require return_data.size >= 32
                            require mem[_31511 + 228] == bool(mem[_31511 + 228])
                            if not mem[_31511 + 228]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_31511 + ceil32(return_data.size) + 201] = this.address
                            require ext_code.size(arg1)
                            staticcall arg1.balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_31511 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < _31403:
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _31403):
                                revert with 0, 17
                            uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _31403
                            mem[64] = _31511 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                            mem[_31511 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                            s = _31511 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                            idx = 0
                            while idx < uint256(stor5[address(arg1)].field_0):
                                mem[0] = sha3(address(arg1), 5)
                                _41943 = mem[64]
                                mem[64] = mem[64] + 192
                                mem[_41943] = address(stor5[address(arg1)][idx].field_0)
                                mem[_41943 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                mem[_41943 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                mem[_41943 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                mem[_41943 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                mem[_41943 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                mem[s] = _41943
                                s = s + 32
                                idx = idx + 1
                                continue 
                        idx = 0
                        while idx < mem[_31511 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                            if idx >= mem[_31511 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                revert with 0, 50
                            if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _31511 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                revert with 0, 17
                            if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                    revert with 0, 50
                                mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _31511 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                            else:
                                uint256(stor6[address(arg1)][msg.sender].field_256)++
                                mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _31511 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                else:
                    mem[_32203 + _31511 + 196] = 0
                    call arg1 with:
                         gas gas_remaining wei
                        args mem[_31511 + 200 len _32203 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if not mem[96]:
                            mem[_31511 + 200] = this.address
                            require ext_code.size(arg1)
                            staticcall arg1.balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_31511 + 196] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < _31403:
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _31403):
                                revert with 0, 17
                            uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _31403
                            mem[64] = _31511 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                            mem[_31511 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                            s = _31511 + ceil32(return_data.size) + 228
                            idx = 0
                            while idx < uint256(stor5[address(arg1)].field_0):
                                mem[0] = sha3(address(arg1), 5)
                                _41948 = mem[64]
                                mem[64] = mem[64] + 192
                                mem[_41948] = address(stor5[address(arg1)][idx].field_0)
                                mem[_41948 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                mem[_41948 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                mem[_41948 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                mem[_41948 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                mem[_41948 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                mem[s] = _41948
                                s = s + 32
                                idx = idx + 1
                                continue 
                        else:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_31511 + 200] = this.address
                            require ext_code.size(arg1)
                            staticcall arg1.balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_31511 + 196] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < _31403:
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _31403):
                                revert with 0, 17
                            uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _31403
                            mem[64] = _31511 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                            mem[_31511 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                            s = _31511 + ceil32(return_data.size) + 228
                            idx = 0
                            while idx < uint256(stor5[address(arg1)].field_0):
                                mem[0] = sha3(address(arg1), 5)
                                _41952 = mem[64]
                                mem[64] = mem[64] + 192
                                mem[_41952] = address(stor5[address(arg1)][idx].field_0)
                                mem[_41952 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                mem[_41952 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                mem[_41952 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                mem[_41952 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                mem[_41952 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                mem[s] = _41952
                                s = s + 32
                                idx = idx + 1
                                continue 
                        idx = 0
                        while idx < mem[_31511 + ceil32(return_data.size) + 196]:
                            if idx >= mem[_31511 + ceil32(return_data.size) + 196]:
                                revert with 0, 50
                            if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _31511 + ceil32(return_data.size) + 228] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                revert with 0, 17
                            if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                    revert with 0, 50
                                mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _31511 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                            else:
                                uint256(stor6[address(arg1)][msg.sender].field_256)++
                                mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _31511 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                    else:
                        mem[_31511 + 196] = return_data.size
                        mem[_31511 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if not return_data.size:
                            mem[_31511 + ceil32(return_data.size) + 201] = this.address
                            require ext_code.size(arg1)
                            staticcall arg1.balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_31511 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < _31403:
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _31403):
                                revert with 0, 17
                            uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _31403
                            mem[64] = _31511 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                            mem[_31511 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                            s = _31511 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                            idx = 0
                            while idx < uint256(stor5[address(arg1)].field_0):
                                mem[0] = sha3(address(arg1), 5)
                                _41957 = mem[64]
                                mem[64] = mem[64] + 192
                                mem[_41957] = address(stor5[address(arg1)][idx].field_0)
                                mem[_41957 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                mem[_41957 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                mem[_41957 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                mem[_41957 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                mem[_41957 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                mem[s] = _41957
                                s = s + 32
                                idx = idx + 1
                                continue 
                        else:
                            require return_data.size >= 32
                            require mem[_31511 + 228] == bool(mem[_31511 + 228])
                            if not mem[_31511 + 228]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_31511 + ceil32(return_data.size) + 201] = this.address
                            require ext_code.size(arg1)
                            staticcall arg1.balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_31511 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < _31403:
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _31403):
                                revert with 0, 17
                            uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _31403
                            mem[64] = _31511 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                            mem[_31511 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                            s = _31511 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                            idx = 0
                            while idx < uint256(stor5[address(arg1)].field_0):
                                mem[0] = sha3(address(arg1), 5)
                                _41961 = mem[64]
                                mem[64] = mem[64] + 192
                                mem[_41961] = address(stor5[address(arg1)][idx].field_0)
                                mem[_41961 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                mem[_41961 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                mem[_41961 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                mem[_41961 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                mem[_41961 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                mem[s] = _41961
                                s = s + 32
                                idx = idx + 1
                                continue 
                        idx = 0
                        while idx < mem[_31511 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                            if idx >= mem[_31511 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                revert with 0, 50
                            if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _31511 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                revert with 0, 17
                            if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                    revert with 0, 50
                                mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _31511 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                            else:
                                uint256(stor6[address(arg1)][msg.sender].field_256)++
                                mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _31511 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                emit Deposit((ext_call.return_data[0] - _31403), msg.sender, arg1);
    else:
        if block.timestamp <= uint256(stor5[address(arg1)].field_256):
            mem[ceil32(return_data.size) + 96] = uint256(stor6[address(arg1)][msg.sender].field_0)
            mem[ceil32(return_data.size) + 160] = uint256(stor6[address(arg1)][msg.sender].field_256)
            if not uint256(stor6[address(arg1)][msg.sender].field_256):
                mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + 160
                if not uint256(stor6[address(arg1)][msg.sender].field_0):
                    mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 196] = this.address
                    require ext_code.size(arg1)
                    staticcall arg1.balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 228] = msg.sender
                    mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 260] = this.address
                    mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 292] = arg2
                    mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192] = 100
                    mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 228 len 28] = Mask(224, 32, msg.sender) >> 32
                    mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224 len 4] = transferFrom(address rg1, address rg2, uint256 rg3)
                    mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 324] = 32
                    mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 356] = 'SafeERC20: low-level call failed'
                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                        revert with 0, 'Address: call to non-contract'
                    if not ext_code.hash(arg1):
                        revert with 0, 'Address: call to non-contract'
                    mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388 len 128] = transferFrom(address rg1, address rg2, uint256 rg3), msg.sender, address(this.address), arg2, 0
                    mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 488] = 0
                    call arg1 with:
                       funct Mask(32, 224, transferFrom(address rg1, address rg2, uint256 rg3), msg.sender, address(this.address), arg2, 0) >> 224
                         gas gas_remaining wei
                        args (Mask(768, -544, transferFrom(address rg1, address rg2, uint256 rg3), msg.sender, address(this.address), arg2, 0) << 544)
                    if not return_data.size:
                        if not ext_call.success:
                            if ext_call.return_data[0]:
                                revert with memory
                                  from 128
                                   len ext_call.return_data[0]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if not ext_call.return_data[0]:
                            mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 392] = this.address
                            require ext_code.size(arg1)
                            staticcall arg1.balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][msg.sender].field_0) > !0:
                                revert with 0, 17
                            mem[64] = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + (32 * uint256(stor5[address(arg1)].field_0)) + 420
                            mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = uint256(stor5[address(arg1)].field_0)
                            s = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420
                            idx = 0
                            while idx < uint256(stor5[address(arg1)].field_0):
                                mem[0] = sha3(address(arg1), 5)
                                _11099 = mem[64]
                                mem[64] = mem[64] + 192
                                mem[_11099] = address(stor5[address(arg1)][idx].field_0)
                                mem[_11099 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                mem[_11099 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                mem[_11099 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                mem[_11099 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                mem[_11099 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                mem[s] = _11099
                                s = s + 32
                                idx = idx + 1
                                continue 
                        else:
                            require ext_call.return_data[0] >= 32
                            require uint32(msg.sender), mem[132 len 28] == bool(uint32(msg.sender), mem[132 len 28])
                            if not uint32(msg.sender), mem[132 len 28]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 392] = this.address
                            require ext_code.size(arg1)
                            staticcall arg1.balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][msg.sender].field_0) > !0:
                                revert with 0, 17
                            mem[64] = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + (32 * uint256(stor5[address(arg1)].field_0)) + 420
                            mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = uint256(stor5[address(arg1)].field_0)
                            s = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420
                            idx = 0
                            while idx < uint256(stor5[address(arg1)].field_0):
                                mem[0] = sha3(address(arg1), 5)
                                _11103 = mem[64]
                                mem[64] = mem[64] + 192
                                mem[_11103] = address(stor5[address(arg1)][idx].field_0)
                                mem[_11103 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                mem[_11103 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                mem[_11103 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                mem[_11103 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                mem[_11103 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                mem[s] = _11103
                                s = s + 32
                                idx = idx + 1
                                continue 
                        idx = 0
                        while idx < mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388]:
                            if idx >= mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388]:
                                revert with 0, 50
                            if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                revert with 0, 17
                            if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                    revert with 0, 50
                                mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420] + 128] / 1000000000000 * 10^18
                            else:
                                uint256(stor6[address(arg1)][msg.sender].field_256)++
                                mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420] + 128] / 1000000000000 * 10^18
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                    else:
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = return_data.size
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if not return_data.size:
                            mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 393] = this.address
                            require ext_code.size(arg1)
                            staticcall arg1.balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][msg.sender].field_0) > !0:
                                revert with 0, 17
                            mem[64] = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 421
                            mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389] = uint256(stor5[address(arg1)].field_0)
                            s = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421
                            idx = 0
                            while idx < uint256(stor5[address(arg1)].field_0):
                                mem[0] = sha3(address(arg1), 5)
                                _11108 = mem[64]
                                mem[64] = mem[64] + 192
                                mem[_11108] = address(stor5[address(arg1)][idx].field_0)
                                mem[_11108 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                mem[_11108 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                mem[_11108 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                mem[_11108 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                mem[_11108 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                mem[s] = _11108
                                s = s + 32
                                idx = idx + 1
                                continue 
                        else:
                            require return_data.size >= 32
                            require mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420] == bool(mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420])
                            if not mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 393] = this.address
                            require ext_code.size(arg1)
                            staticcall arg1.balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][msg.sender].field_0) > !0:
                                revert with 0, 17
                            mem[64] = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 421
                            mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389] = uint256(stor5[address(arg1)].field_0)
                            s = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421
                            idx = 0
                            while idx < uint256(stor5[address(arg1)].field_0):
                                mem[0] = sha3(address(arg1), 5)
                                _11112 = mem[64]
                                mem[64] = mem[64] + 192
                                mem[_11112] = address(stor5[address(arg1)][idx].field_0)
                                mem[_11112 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                mem[_11112 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                mem[_11112 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                mem[_11112 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                mem[_11112 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                mem[s] = _11112
                                s = s + 32
                                idx = idx + 1
                                continue 
                        idx = 0
                        while idx < mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389]:
                            if idx >= mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389]:
                                revert with 0, 50
                            if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                revert with 0, 17
                            if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                    revert with 0, 50
                                mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421] + 128] / 1000000000000 * 10^18
                            else:
                                uint256(stor6[address(arg1)][msg.sender].field_256)++
                                mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421] + 128] / 1000000000000 * 10^18
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                    emit Deposit(0, msg.sender, arg1);
                else:
                    mem[0] = arg1
                    mem[32] = 5
                    mem[64] = ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + (32 * uint256(stor5[address(arg1)].field_0)) + 224
                    mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192] = uint256(stor5[address(arg1)].field_0)
                    s = ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224
                    idx = 0
                    while idx < uint256(stor5[address(arg1)].field_0):
                        mem[0] = sha3(address(arg1), 5)
                        _5551 = mem[64]
                        mem[64] = mem[64] + 192
                        mem[_5551] = address(stor5[address(arg1)][idx].field_0)
                        mem[_5551 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                        mem[_5551 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                        mem[_5551 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                        mem[_5551 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                        mem[_5551 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                        mem[s] = _5551
                        s = s + 32
                        idx = idx + 1
                        continue 
                    _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                    idx = 0
                    while idx < _10999:
                        if uint256(stor6[address(arg1)][msg.sender].field_256) <= idx:
                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                revert with 0, 50
                            _11249 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128]
                            _11250 = mem[ceil32(return_data.size) + 96]
                            if mem[ceil32(return_data.size) + 96] and mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] > -1 / mem[ceil32(return_data.size) + 96]:
                                revert with 0, 17
                            if mem[ceil32(return_data.size) + 96] * mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18 < 0:
                                revert with 0, 17
                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                revert with 0, 50
                            if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] >= mem[ceil32(return_data.size) + 96] * mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18:
                                if mem[ceil32(return_data.size) + 96] * mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18:
                                    if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                        revert with 0, 50
                                    _11697 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224]]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(_11697))
                                    staticcall address(_11697).balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11868 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _11933 = mem[_11868]
                                    if mem[_11868] > _11250 * _11249 / 1000000000000 * 10^18:
                                        _12014 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = _11250 * _11249 / 1000000000000 * 10^18
                                        _12110 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[64] = mem[64] + 100
                                        mem[_12110 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12110 + 36 len 28]
                                        mem[64] = _12014 + 164
                                        mem[_12014 + 100] = 32
                                        mem[_12014 + 132] = 'SafeERC20: low-level call failed'
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_11697)):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(address(_11697)):
                                            revert with 0, 'Address: call to non-contract'
                                        _12856 = mem[_12110]
                                        s = 0
                                        while s < _12856:
                                            mem[s + _12014 + 164] = mem[s + _12110 + 32]
                                            _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                            s = s + 32
                                            continue 
                                        if ceil32(_12856) > _12856:
                                            mem[_12856 + _12014 + 164] = 0
                                        call address(_11697).mem[_12014 + 164 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_12014 + 168 len _12856 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                mem[_12014 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_12014 + 168] = 32
                                                mem[_12014 + 200] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _12014 + 232] = mem[idx + _12014 + 132]
                                                    _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_12014 + 232]
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[64] = _12014 + ceil32(return_data.size) + 165
                                            mem[_12014 + 164] = return_data.size
                                            mem[_12014 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_12014 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_12014 + ceil32(return_data.size) + 169] = 32
                                                mem[_12014 + ceil32(return_data.size) + 201] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _12014 + ceil32(return_data.size) + 233] = mem[idx + _12014 + 132]
                                                    _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_12014 + ceil32(return_data.size) + 233]
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_12014 + 196] == bool(mem[_12014 + 196])
                                                if not mem[_12014 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _11250 * _11249 / 1000000000000 * 10^18:
                                            revert with 0, 17
                                        mem[32] = 5
                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 5)
                                        uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - (_11250 * _11249 / 1000000000000 * 10^18)
                                    else:
                                        if not mem[_11868]:
                                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                revert with 0, 50
                                            if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < 0:
                                                revert with 0, 17
                                            mem[32] = 5
                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                revert with 0, 50
                                            mem[0] = sha3(address(arg1), 5)
                                            uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                        else:
                                            _12058 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = _11933
                                            _12187 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_12187 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12187 + 36 len 28]
                                            mem[64] = _12058 + 164
                                            mem[_12058 + 100] = 32
                                            mem[_12058 + 132] = 'SafeERC20: low-level call failed'
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_11697)):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(_11697)):
                                                revert with 0, 'Address: call to non-contract'
                                            _12961 = mem[_12187]
                                            s = 0
                                            while s < _12961:
                                                mem[s + _12058 + 164] = mem[s + _12187 + 32]
                                                _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                s = s + 32
                                                continue 
                                            if ceil32(_12961) > _12961:
                                                mem[_12961 + _12058 + 164] = 0
                                            call address(_11697).mem[_12058 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_12058 + 168 len _12961 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_12058 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_12058 + 168] = 32
                                                    mem[_12058 + 200] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _12058 + 232] = mem[idx + _12058 + 132]
                                                        _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_12058 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _12058 + ceil32(return_data.size) + 165
                                                mem[_12058 + 164] = return_data.size
                                                mem[_12058 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_12058 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_12058 + ceil32(return_data.size) + 169] = 32
                                                    mem[_12058 + ceil32(return_data.size) + 201] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _12058 + ceil32(return_data.size) + 233] = mem[idx + _12058 + 132]
                                                        _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_12058 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_12058 + 196] == bool(mem[_12058 + 196])
                                                    if not mem[_12058 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                revert with 0, 50
                                            if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _11933:
                                                revert with 0, 17
                                            mem[32] = 5
                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                revert with 0, 50
                                            mem[0] = sha3(address(arg1), 5)
                                            uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _11933
                            else:
                                if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                    revert with 0, 50
                                _11655 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]:
                                    if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                        revert with 0, 50
                                    _11730 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224]]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(_11730))
                                    staticcall address(_11730).balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11903 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _11960 = mem[_11903]
                                    if mem[_11903] > _11655:
                                        _12056 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = _11655
                                        _12185 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[64] = mem[64] + 100
                                        mem[_12185 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12185 + 36 len 28]
                                        mem[64] = _12056 + 164
                                        mem[_12056 + 100] = 32
                                        mem[_12056 + 132] = 'SafeERC20: low-level call failed'
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_11730)):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(address(_11730)):
                                            revert with 0, 'Address: call to non-contract'
                                        _12960 = mem[_12185]
                                        s = 0
                                        while s < _12960:
                                            mem[s + _12056 + 164] = mem[s + _12185 + 32]
                                            _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                            s = s + 32
                                            continue 
                                        if ceil32(_12960) > _12960:
                                            mem[_12960 + _12056 + 164] = 0
                                        call address(_11730).mem[_12056 + 164 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_12056 + 168 len _12960 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                mem[_12056 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_12056 + 168] = 32
                                                mem[_12056 + 200] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _12056 + 232] = mem[idx + _12056 + 132]
                                                    _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_12056 + 232]
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[64] = _12056 + ceil32(return_data.size) + 165
                                            mem[_12056 + 164] = return_data.size
                                            mem[_12056 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_12056 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_12056 + ceil32(return_data.size) + 169] = 32
                                                mem[_12056 + ceil32(return_data.size) + 201] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _12056 + ceil32(return_data.size) + 233] = mem[idx + _12056 + 132]
                                                    _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_12056 + ceil32(return_data.size) + 233]
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_12056 + 196] == bool(mem[_12056 + 196])
                                                if not mem[_12056 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _11655:
                                            revert with 0, 17
                                        mem[32] = 5
                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 5)
                                        uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _11655
                                    else:
                                        if not mem[_11903]:
                                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                revert with 0, 50
                                            if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < 0:
                                                revert with 0, 17
                                            mem[32] = 5
                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                revert with 0, 50
                                            mem[0] = sha3(address(arg1), 5)
                                            uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                        else:
                                            _12107 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = _11960
                                            _12283 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_12283 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12283 + 36 len 28]
                                            mem[64] = _12107 + 164
                                            mem[_12107 + 100] = 32
                                            mem[_12107 + 132] = 'SafeERC20: low-level call failed'
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_11730)):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(_11730)):
                                                revert with 0, 'Address: call to non-contract'
                                            _13083 = mem[_12283]
                                            s = 0
                                            while s < _13083:
                                                mem[s + _12107 + 164] = mem[s + _12283 + 32]
                                                _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                s = s + 32
                                                continue 
                                            if ceil32(_13083) > _13083:
                                                mem[_13083 + _12107 + 164] = 0
                                            call address(_11730).mem[_12107 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_12107 + 168 len _13083 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_12107 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_12107 + 168] = 32
                                                    mem[_12107 + 200] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _12107 + 232] = mem[idx + _12107 + 132]
                                                        _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_12107 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _12107 + ceil32(return_data.size) + 165
                                                mem[_12107 + 164] = return_data.size
                                                mem[_12107 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_12107 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_12107 + ceil32(return_data.size) + 169] = 32
                                                    mem[_12107 + ceil32(return_data.size) + 201] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _12107 + ceil32(return_data.size) + 233] = mem[idx + _12107 + 132]
                                                        _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_12107 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_12107 + 196] == bool(mem[_12107 + 196])
                                                    if not mem[_12107 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                revert with 0, 50
                                            if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _11960:
                                                revert with 0, 17
                                            mem[32] = 5
                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                revert with 0, 50
                                            mem[0] = sha3(address(arg1), 5)
                                            uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _11960
                        else:
                            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                                revert with 0, 50
                            _11165 = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                revert with 0, 50
                            _11368 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128]
                            _11369 = mem[ceil32(return_data.size) + 96]
                            if mem[ceil32(return_data.size) + 96] and mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] > -1 / mem[ceil32(return_data.size) + 96]:
                                revert with 0, 17
                            if mem[ceil32(return_data.size) + 96] * mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18 < mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]:
                                revert with 0, 17
                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                revert with 0, 50
                            if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] >= (mem[ceil32(return_data.size) + 96] * mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18) - mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]:
                                if (mem[ceil32(return_data.size) + 96] * mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18) - mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]:
                                    if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                        revert with 0, 50
                                    _11734 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224]]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(_11734))
                                    staticcall address(_11734).balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11904 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _11961 = mem[_11904]
                                    if mem[_11904] > (_11369 * _11368 / 1000000000000 * 10^18) - _11165:
                                        _12059 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = (_11369 * _11368 / 1000000000000 * 10^18) - _11165
                                        _12194 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[64] = mem[64] + 100
                                        mem[_12194 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12194 + 36 len 28]
                                        mem[64] = _12059 + 164
                                        mem[_12059 + 100] = 32
                                        mem[_12059 + 132] = 'SafeERC20: low-level call failed'
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_11734)):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(address(_11734)):
                                            revert with 0, 'Address: call to non-contract'
                                        _12970 = mem[_12194]
                                        s = 0
                                        while s < _12970:
                                            mem[s + _12059 + 164] = mem[s + _12194 + 32]
                                            _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                            s = s + 32
                                            continue 
                                        if ceil32(_12970) > _12970:
                                            mem[_12970 + _12059 + 164] = 0
                                        call address(_11734).mem[_12059 + 164 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_12059 + 168 len _12970 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                mem[_12059 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_12059 + 168] = 32
                                                mem[_12059 + 200] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _12059 + 232] = mem[idx + _12059 + 132]
                                                    _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_12059 + 232]
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[64] = _12059 + ceil32(return_data.size) + 165
                                            mem[_12059 + 164] = return_data.size
                                            mem[_12059 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_12059 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_12059 + ceil32(return_data.size) + 169] = 32
                                                mem[_12059 + ceil32(return_data.size) + 201] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _12059 + ceil32(return_data.size) + 233] = mem[idx + _12059 + 132]
                                                    _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_12059 + ceil32(return_data.size) + 233]
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_12059 + 196] == bool(mem[_12059 + 196])
                                                if not mem[_12059 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < (_11369 * _11368 / 1000000000000 * 10^18) - _11165:
                                            revert with 0, 17
                                        mem[32] = 5
                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 5)
                                        uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - (_11369 * _11368 / 1000000000000 * 10^18) + _11165
                                    else:
                                        if not mem[_11904]:
                                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                revert with 0, 50
                                            if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < 0:
                                                revert with 0, 17
                                            mem[32] = 5
                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                revert with 0, 50
                                            mem[0] = sha3(address(arg1), 5)
                                            uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                        else:
                                            _12114 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = _11961
                                            _12291 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_12291 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12291 + 36 len 28]
                                            mem[64] = _12114 + 164
                                            mem[_12114 + 100] = 32
                                            mem[_12114 + 132] = 'SafeERC20: low-level call failed'
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_11734)):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(_11734)):
                                                revert with 0, 'Address: call to non-contract'
                                            _13092 = mem[_12291]
                                            s = 0
                                            while s < _13092:
                                                mem[s + _12114 + 164] = mem[s + _12291 + 32]
                                                _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                s = s + 32
                                                continue 
                                            if ceil32(_13092) > _13092:
                                                mem[_13092 + _12114 + 164] = 0
                                            call address(_11734).mem[_12114 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_12114 + 168 len _13092 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_12114 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_12114 + 168] = 32
                                                    mem[_12114 + 200] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _12114 + 232] = mem[idx + _12114 + 132]
                                                        _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_12114 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _12114 + ceil32(return_data.size) + 165
                                                mem[_12114 + 164] = return_data.size
                                                mem[_12114 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_12114 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_12114 + ceil32(return_data.size) + 169] = 32
                                                    mem[_12114 + ceil32(return_data.size) + 201] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _12114 + ceil32(return_data.size) + 233] = mem[idx + _12114 + 132]
                                                        _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_12114 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_12114 + 196] == bool(mem[_12114 + 196])
                                                    if not mem[_12114 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                revert with 0, 50
                                            if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _11961:
                                                revert with 0, 17
                                            mem[32] = 5
                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                revert with 0, 50
                                            mem[0] = sha3(address(arg1), 5)
                                            uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _11961
                            else:
                                if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                    revert with 0, 50
                                _11673 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]:
                                    if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                        revert with 0, 50
                                    _11776 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224]]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(_11776))
                                    staticcall address(_11776).balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11934 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _11991 = mem[_11934]
                                    if mem[_11934] > _11673:
                                        _12112 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = _11673
                                        _12289 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[64] = mem[64] + 100
                                        mem[_12289 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12289 + 36 len 28]
                                        mem[64] = _12112 + 164
                                        mem[_12112 + 100] = 32
                                        mem[_12112 + 132] = 'SafeERC20: low-level call failed'
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_11776)):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(address(_11776)):
                                            revert with 0, 'Address: call to non-contract'
                                        _13091 = mem[_12289]
                                        s = 0
                                        while s < _13091:
                                            mem[s + _12112 + 164] = mem[s + _12289 + 32]
                                            _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                            s = s + 32
                                            continue 
                                        if ceil32(_13091) > _13091:
                                            mem[_13091 + _12112 + 164] = 0
                                        call address(_11776).mem[_12112 + 164 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_12112 + 168 len _13091 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                mem[_12112 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_12112 + 168] = 32
                                                mem[_12112 + 200] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _12112 + 232] = mem[idx + _12112 + 132]
                                                    _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_12112 + 232]
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[64] = _12112 + ceil32(return_data.size) + 165
                                            mem[_12112 + 164] = return_data.size
                                            mem[_12112 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_12112 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_12112 + ceil32(return_data.size) + 169] = 32
                                                mem[_12112 + ceil32(return_data.size) + 201] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _12112 + ceil32(return_data.size) + 233] = mem[idx + _12112 + 132]
                                                    _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_12112 + ceil32(return_data.size) + 233]
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_12112 + 196] == bool(mem[_12112 + 196])
                                                if not mem[_12112 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _11673:
                                            revert with 0, 17
                                        mem[32] = 5
                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 5)
                                        uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _11673
                                    else:
                                        if not mem[_11934]:
                                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                revert with 0, 50
                                            if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < 0:
                                                revert with 0, 17
                                            mem[32] = 5
                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                revert with 0, 50
                                            mem[0] = sha3(address(arg1), 5)
                                            uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                        else:
                                            _12191 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = _11991
                                            _12382 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_12382 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12382 + 36 len 28]
                                            mem[64] = _12191 + 164
                                            mem[_12191 + 100] = 32
                                            mem[_12191 + 132] = 'SafeERC20: low-level call failed'
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_11776)):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(_11776)):
                                                revert with 0, 'Address: call to non-contract'
                                            _13177 = mem[_12382]
                                            s = 0
                                            while s < _13177:
                                                mem[s + _12191 + 164] = mem[s + _12382 + 32]
                                                _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                s = s + 32
                                                continue 
                                            if ceil32(_13177) > _13177:
                                                mem[_13177 + _12191 + 164] = 0
                                            call address(_11776).mem[_12191 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_12191 + 168 len _13177 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_12191 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_12191 + 168] = 32
                                                    mem[_12191 + 200] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _12191 + 232] = mem[idx + _12191 + 132]
                                                        _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_12191 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _12191 + ceil32(return_data.size) + 165
                                                mem[_12191 + 164] = return_data.size
                                                mem[_12191 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_12191 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_12191 + ceil32(return_data.size) + 169] = 32
                                                    mem[_12191 + ceil32(return_data.size) + 201] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _12191 + ceil32(return_data.size) + 233] = mem[idx + _12191 + 132]
                                                        _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_12191 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_12191 + 196] == bool(mem[_12191 + 196])
                                                    if not mem[_12191 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                revert with 0, 50
                                            if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _11991:
                                                revert with 0, 17
                                            mem[32] = 5
                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                revert with 0, 50
                                            mem[0] = sha3(address(arg1), 5)
                                            uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _11991
                        if idx == -1:
                            revert with 0, 17
                        _10999 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(arg1)
                    staticcall arg1.balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _11448 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _11486 = mem[_11448]
                    _11533 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = this.address
                    mem[mem[64] + 100] = arg2
                    _11591 = mem[64]
                    mem[mem[64]] = 100
                    mem[mem[64] + 32 len 4] = transferFrom(address rg1, address rg2, uint256 rg3)
                    mem[64] = mem[64] + 196
                    mem[_11533 + 132] = 32
                    mem[_11533 + 164] = 'SafeERC20: low-level call failed'
                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                        revert with 0, 'Address: call to non-contract'
                    if not ext_code.hash(arg1):
                        revert with 0, 'Address: call to non-contract'
                    _11805 = mem[_11591]
                    mem[_11533 + 196 len ceil32(mem[_11591])] = mem[_11591 + 32 len ceil32(mem[_11591])]
                    if ceil32(_11805) <= _11805:
                        call arg1 with:
                             gas gas_remaining wei
                            args mem[_11533 + 200 len _11805 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if not mem[96]:
                                mem[_11533 + 200] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[_11533 + 196] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < _11486:
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _11486):
                                    revert with 0, 17
                                uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _11486
                                mem[64] = _11533 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                mem[_11533 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                s = _11533 + ceil32(return_data.size) + 228
                                idx = 0
                                while idx < uint256(stor5[address(arg1)].field_0):
                                    mem[0] = sha3(address(arg1), 5)
                                    _30351 = mem[64]
                                    mem[64] = mem[64] + 192
                                    mem[_30351] = address(stor5[address(arg1)][idx].field_0)
                                    mem[_30351 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                    mem[_30351 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                    mem[_30351 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                    mem[_30351 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                    mem[_30351 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                    mem[s] = _30351
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                            else:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                mem[_11533 + 200] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[_11533 + 196] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < _11486:
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _11486):
                                    revert with 0, 17
                                uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _11486
                                mem[64] = _11533 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                mem[_11533 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                s = _11533 + ceil32(return_data.size) + 228
                                idx = 0
                                while idx < uint256(stor5[address(arg1)].field_0):
                                    mem[0] = sha3(address(arg1), 5)
                                    _30355 = mem[64]
                                    mem[64] = mem[64] + 192
                                    mem[_30355] = address(stor5[address(arg1)][idx].field_0)
                                    mem[_30355 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                    mem[_30355 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                    mem[_30355 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                    mem[_30355 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                    mem[_30355 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                    mem[s] = _30355
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                            idx = 0
                            while idx < mem[_11533 + ceil32(return_data.size) + 196]:
                                if idx >= mem[_11533 + ceil32(return_data.size) + 196]:
                                    revert with 0, 50
                                if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _11533 + ceil32(return_data.size) + 228] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                    revert with 0, 17
                                if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                    if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                        revert with 0, 50
                                    mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                    uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _11533 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                else:
                                    uint256(stor6[address(arg1)][msg.sender].field_256)++
                                    mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                    uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _11533 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[_11533 + 196] = return_data.size
                            mem[_11533 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if not return_data.size:
                                mem[_11533 + ceil32(return_data.size) + 201] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[_11533 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < _11486:
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _11486):
                                    revert with 0, 17
                                uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _11486
                                mem[64] = _11533 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                mem[_11533 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                s = _11533 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                idx = 0
                                while idx < uint256(stor5[address(arg1)].field_0):
                                    mem[0] = sha3(address(arg1), 5)
                                    _30360 = mem[64]
                                    mem[64] = mem[64] + 192
                                    mem[_30360] = address(stor5[address(arg1)][idx].field_0)
                                    mem[_30360 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                    mem[_30360 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                    mem[_30360 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                    mem[_30360 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                    mem[_30360 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                    mem[s] = _30360
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                            else:
                                require return_data.size >= 32
                                require mem[_11533 + 228] == bool(mem[_11533 + 228])
                                if not mem[_11533 + 228]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                mem[_11533 + ceil32(return_data.size) + 201] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[_11533 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < _11486:
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _11486):
                                    revert with 0, 17
                                uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _11486
                                mem[64] = _11533 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                mem[_11533 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                s = _11533 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                idx = 0
                                while idx < uint256(stor5[address(arg1)].field_0):
                                    mem[0] = sha3(address(arg1), 5)
                                    _30364 = mem[64]
                                    mem[64] = mem[64] + 192
                                    mem[_30364] = address(stor5[address(arg1)][idx].field_0)
                                    mem[_30364 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                    mem[_30364 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                    mem[_30364 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                    mem[_30364 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                    mem[_30364 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                    mem[s] = _30364
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                            idx = 0
                            while idx < mem[_11533 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                if idx >= mem[_11533 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                    revert with 0, 50
                                if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _11533 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                    revert with 0, 17
                                if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                    if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                        revert with 0, 50
                                    mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                    uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _11533 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                else:
                                    uint256(stor6[address(arg1)][msg.sender].field_256)++
                                    mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                    uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _11533 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        mem[_11805 + _11533 + 196] = 0
                        call arg1 with:
                             gas gas_remaining wei
                            args mem[_11533 + 200 len _11805 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if not mem[96]:
                                mem[_11533 + 200] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[_11533 + 196] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < _11486:
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _11486):
                                    revert with 0, 17
                                uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _11486
                                mem[64] = _11533 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                mem[_11533 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                s = _11533 + ceil32(return_data.size) + 228
                                idx = 0
                                while idx < uint256(stor5[address(arg1)].field_0):
                                    mem[0] = sha3(address(arg1), 5)
                                    _30369 = mem[64]
                                    mem[64] = mem[64] + 192
                                    mem[_30369] = address(stor5[address(arg1)][idx].field_0)
                                    mem[_30369 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                    mem[_30369 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                    mem[_30369 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                    mem[_30369 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                    mem[_30369 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                    mem[s] = _30369
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                            else:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                mem[_11533 + 200] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[_11533 + 196] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < _11486:
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _11486):
                                    revert with 0, 17
                                uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _11486
                                mem[64] = _11533 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                mem[_11533 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                s = _11533 + ceil32(return_data.size) + 228
                                idx = 0
                                while idx < uint256(stor5[address(arg1)].field_0):
                                    mem[0] = sha3(address(arg1), 5)
                                    _30373 = mem[64]
                                    mem[64] = mem[64] + 192
                                    mem[_30373] = address(stor5[address(arg1)][idx].field_0)
                                    mem[_30373 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                    mem[_30373 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                    mem[_30373 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                    mem[_30373 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                    mem[_30373 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                    mem[s] = _30373
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                            idx = 0
                            while idx < mem[_11533 + ceil32(return_data.size) + 196]:
                                if idx >= mem[_11533 + ceil32(return_data.size) + 196]:
                                    revert with 0, 50
                                if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _11533 + ceil32(return_data.size) + 228] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                    revert with 0, 17
                                if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                    if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                        revert with 0, 50
                                    mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                    uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _11533 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                else:
                                    uint256(stor6[address(arg1)][msg.sender].field_256)++
                                    mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                    uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _11533 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[_11533 + 196] = return_data.size
                            mem[_11533 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if not return_data.size:
                                mem[_11533 + ceil32(return_data.size) + 201] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[_11533 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < _11486:
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _11486):
                                    revert with 0, 17
                                uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _11486
                                mem[64] = _11533 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                mem[_11533 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                s = _11533 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                idx = 0
                                while idx < uint256(stor5[address(arg1)].field_0):
                                    mem[0] = sha3(address(arg1), 5)
                                    _30378 = mem[64]
                                    mem[64] = mem[64] + 192
                                    mem[_30378] = address(stor5[address(arg1)][idx].field_0)
                                    mem[_30378 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                    mem[_30378 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                    mem[_30378 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                    mem[_30378 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                    mem[_30378 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                    mem[s] = _30378
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                            else:
                                require return_data.size >= 32
                                require mem[_11533 + 228] == bool(mem[_11533 + 228])
                                if not mem[_11533 + 228]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                mem[_11533 + ceil32(return_data.size) + 201] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[_11533 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < _11486:
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _11486):
                                    revert with 0, 17
                                uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _11486
                                mem[64] = _11533 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                mem[_11533 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                s = _11533 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                idx = 0
                                while idx < uint256(stor5[address(arg1)].field_0):
                                    mem[0] = sha3(address(arg1), 5)
                                    _30382 = mem[64]
                                    mem[64] = mem[64] + 192
                                    mem[_30382] = address(stor5[address(arg1)][idx].field_0)
                                    mem[_30382 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                    mem[_30382 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                    mem[_30382 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                    mem[_30382 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                    mem[_30382 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                    mem[s] = _30382
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                            idx = 0
                            while idx < mem[_11533 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                if idx >= mem[_11533 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                    revert with 0, 50
                                if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _11533 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                    revert with 0, 17
                                if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                    if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                        revert with 0, 50
                                    mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                    uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _11533 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                else:
                                    uint256(stor6[address(arg1)][msg.sender].field_256)++
                                    mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                    uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _11533 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    emit Deposit((ext_call.return_data[0] - _11486), msg.sender, arg1);
            else:
                mem[ceil32(return_data.size) + 192] = uint256(stor6[address(arg1)][msg.sender][1].field_0)
                idx = ceil32(return_data.size) + 192
                s = 0
                while ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 160 > idx:
                    mem[idx + 32] = uint256(stor6[address(arg1)][msg.sender][s + 1].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + 160
                if not uint256(stor6[address(arg1)][msg.sender].field_0):
                    mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 196] = this.address
                    require ext_code.size(arg1)
                    staticcall arg1.balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 228] = msg.sender
                    mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 260] = this.address
                    mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 292] = arg2
                    mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192] = 100
                    mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224 len 4] = transferFrom(address rg1, address rg2, uint256 rg3)
                    mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 324] = 32
                    mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 356] = 'SafeERC20: low-level call failed'
                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                        revert with 0, 'Address: call to non-contract'
                    if not ext_code.hash(arg1):
                        revert with 0, 'Address: call to non-contract'
                    mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388 len 128] = 0, msg.sender, address(this.address), arg2, 0
                    mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 488] = 0
                    call arg1 with:
                       funct Mask(32, 224, 0, msg.sender, address(this.address), arg2, 0) >> 224
                         gas gas_remaining wei
                        args (Mask(768, -544, 0, msg.sender, address(this.address), arg2, 0) << 544)
                    if not return_data.size:
                        if not ext_call.success:
                            if ext_call.return_data[0]:
                                revert with memory
                                  from 128
                                   len ext_call.return_data[0]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if not ext_call.return_data[0]:
                            mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 392] = this.address
                            require ext_code.size(arg1)
                            staticcall arg1.balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][msg.sender].field_0) > !0:
                                revert with 0, 17
                            mem[64] = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + (32 * uint256(stor5[address(arg1)].field_0)) + 420
                            mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = uint256(stor5[address(arg1)].field_0)
                            s = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420
                            idx = 0
                            while idx < uint256(stor5[address(arg1)].field_0):
                                mem[0] = sha3(address(arg1), 5)
                                _30437 = mem[64]
                                mem[64] = mem[64] + 192
                                mem[_30437] = address(stor5[address(arg1)][idx].field_0)
                                mem[_30437 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                mem[_30437 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                mem[_30437 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                mem[_30437 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                mem[_30437 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                mem[s] = _30437
                                s = s + 32
                                idx = idx + 1
                                continue 
                        else:
                            require ext_call.return_data[0] >= 32
                            require uint32(msg.sender), mem[132 len 28] == bool(uint32(msg.sender), mem[132 len 28])
                            if not uint32(msg.sender), mem[132 len 28]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 392] = this.address
                            require ext_code.size(arg1)
                            staticcall arg1.balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][msg.sender].field_0) > !0:
                                revert with 0, 17
                            mem[64] = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + (32 * uint256(stor5[address(arg1)].field_0)) + 420
                            mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = uint256(stor5[address(arg1)].field_0)
                            s = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420
                            idx = 0
                            while idx < uint256(stor5[address(arg1)].field_0):
                                mem[0] = sha3(address(arg1), 5)
                                _30441 = mem[64]
                                mem[64] = mem[64] + 192
                                mem[_30441] = address(stor5[address(arg1)][idx].field_0)
                                mem[_30441 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                mem[_30441 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                mem[_30441 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                mem[_30441 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                mem[_30441 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                mem[s] = _30441
                                s = s + 32
                                idx = idx + 1
                                continue 
                        idx = 0
                        while idx < mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388]:
                            if idx >= mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388]:
                                revert with 0, 50
                            if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                revert with 0, 17
                            if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                    revert with 0, 50
                                mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420] + 128] / 1000000000000 * 10^18
                            else:
                                uint256(stor6[address(arg1)][msg.sender].field_256)++
                                mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420] + 128] / 1000000000000 * 10^18
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                    else:
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = return_data.size
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if not return_data.size:
                            mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 393] = this.address
                            require ext_code.size(arg1)
                            staticcall arg1.balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][msg.sender].field_0) > !0:
                                revert with 0, 17
                            mem[64] = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 421
                            mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389] = uint256(stor5[address(arg1)].field_0)
                            s = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421
                            idx = 0
                            while idx < uint256(stor5[address(arg1)].field_0):
                                mem[0] = sha3(address(arg1), 5)
                                _30446 = mem[64]
                                mem[64] = mem[64] + 192
                                mem[_30446] = address(stor5[address(arg1)][idx].field_0)
                                mem[_30446 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                mem[_30446 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                mem[_30446 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                mem[_30446 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                mem[_30446 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                mem[s] = _30446
                                s = s + 32
                                idx = idx + 1
                                continue 
                        else:
                            require return_data.size >= 32
                            require mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420] == bool(mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420])
                            if not mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 393] = this.address
                            require ext_code.size(arg1)
                            staticcall arg1.balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 17
                            if uint256(stor6[address(arg1)][msg.sender].field_0) > !0:
                                revert with 0, 17
                            mem[64] = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 421
                            mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389] = uint256(stor5[address(arg1)].field_0)
                            s = (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421
                            idx = 0
                            while idx < uint256(stor5[address(arg1)].field_0):
                                mem[0] = sha3(address(arg1), 5)
                                _30450 = mem[64]
                                mem[64] = mem[64] + 192
                                mem[_30450] = address(stor5[address(arg1)][idx].field_0)
                                mem[_30450 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                mem[_30450 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                mem[_30450 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                mem[_30450 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                mem[_30450 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                mem[s] = _30450
                                s = s + 32
                                idx = idx + 1
                                continue 
                        idx = 0
                        while idx < mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389]:
                            if idx >= mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389]:
                                revert with 0, 50
                            if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                revert with 0, 17
                            if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                    revert with 0, 50
                                mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421] + 128] / 1000000000000 * 10^18
                            else:
                                uint256(stor6[address(arg1)][msg.sender].field_256)++
                                mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + (4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421] + 128] / 1000000000000 * 10^18
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                    emit Deposit(0, msg.sender, arg1);
                else:
                    mem[0] = arg1
                    mem[32] = 5
                    mem[64] = ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + (32 * uint256(stor5[address(arg1)].field_0)) + 224
                    mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192] = uint256(stor5[address(arg1)].field_0)
                    s = ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224
                    idx = 0
                    while idx < uint256(stor5[address(arg1)].field_0):
                        mem[0] = sha3(address(arg1), 5)
                        _20355 = mem[64]
                        mem[64] = mem[64] + 192
                        mem[_20355] = address(stor5[address(arg1)][idx].field_0)
                        mem[_20355 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                        mem[_20355 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                        mem[_20355 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                        mem[_20355 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                        mem[_20355 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                        mem[s] = _20355
                        s = s + 32
                        idx = idx + 1
                        continue 
                    _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                    idx = 0
                    while idx < _30126:
                        if uint256(stor6[address(arg1)][msg.sender].field_256) <= idx:
                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                revert with 0, 50
                            _30962 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128]
                            _30963 = mem[ceil32(return_data.size) + 96]
                            if mem[ceil32(return_data.size) + 96] and mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] > -1 / mem[ceil32(return_data.size) + 96]:
                                revert with 0, 17
                            if mem[ceil32(return_data.size) + 96] * mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18 < 0:
                                revert with 0, 17
                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                revert with 0, 50
                            if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] >= mem[ceil32(return_data.size) + 96] * mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18:
                                if mem[ceil32(return_data.size) + 96] * mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18:
                                    if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                        revert with 0, 50
                                    _32035 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224]]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(_32035))
                                    staticcall address(_32035).balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _32348 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _32377 = mem[_32348]
                                    if mem[_32348] > _30963 * _30962 / 1000000000000 * 10^18:
                                        _32497 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = _30963 * _30962 / 1000000000000 * 10^18
                                        _32590 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[64] = mem[64] + 100
                                        mem[_32590 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_32590 + 36 len 28]
                                        mem[64] = _32497 + 164
                                        mem[_32497 + 100] = 32
                                        mem[_32497 + 132] = 'SafeERC20: low-level call failed'
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_32035)):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(address(_32035)):
                                            revert with 0, 'Address: call to non-contract'
                                        _33083 = mem[_32590]
                                        s = 0
                                        while s < _33083:
                                            mem[s + _32497 + 164] = mem[s + _32590 + 32]
                                            _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                            s = s + 32
                                            continue 
                                        if ceil32(_33083) > _33083:
                                            mem[_33083 + _32497 + 164] = 0
                                        call address(_32035).mem[_32497 + 164 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_32497 + 168 len _33083 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                mem[_32497 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_32497 + 168] = 32
                                                mem[_32497 + 200] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _32497 + 232] = mem[idx + _32497 + 132]
                                                    _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_32497 + 232]
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[64] = _32497 + ceil32(return_data.size) + 165
                                            mem[_32497 + 164] = return_data.size
                                            mem[_32497 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_32497 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_32497 + ceil32(return_data.size) + 169] = 32
                                                mem[_32497 + ceil32(return_data.size) + 201] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _32497 + ceil32(return_data.size) + 233] = mem[idx + _32497 + 132]
                                                    _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_32497 + ceil32(return_data.size) + 233]
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_32497 + 196] == bool(mem[_32497 + 196])
                                                if not mem[_32497 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _30963 * _30962 / 1000000000000 * 10^18:
                                            revert with 0, 17
                                        mem[32] = 5
                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 5)
                                        uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - (_30963 * _30962 / 1000000000000 * 10^18)
                                    else:
                                        if not mem[_32348]:
                                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                revert with 0, 50
                                            if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < 0:
                                                revert with 0, 17
                                            mem[32] = 5
                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                revert with 0, 50
                                            mem[0] = sha3(address(arg1), 5)
                                            uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                        else:
                                            _32543 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = _32377
                                            _32653 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_32653 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_32653 + 36 len 28]
                                            mem[64] = _32543 + 164
                                            mem[_32543 + 100] = 32
                                            mem[_32543 + 132] = 'SafeERC20: low-level call failed'
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_32035)):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(_32035)):
                                                revert with 0, 'Address: call to non-contract'
                                            _33154 = mem[_32653]
                                            s = 0
                                            while s < _33154:
                                                mem[s + _32543 + 164] = mem[s + _32653 + 32]
                                                _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                s = s + 32
                                                continue 
                                            if ceil32(_33154) > _33154:
                                                mem[_33154 + _32543 + 164] = 0
                                            call address(_32035).mem[_32543 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_32543 + 168 len _33154 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_32543 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_32543 + 168] = 32
                                                    mem[_32543 + 200] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _32543 + 232] = mem[idx + _32543 + 132]
                                                        _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_32543 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _32543 + ceil32(return_data.size) + 165
                                                mem[_32543 + 164] = return_data.size
                                                mem[_32543 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_32543 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_32543 + ceil32(return_data.size) + 169] = 32
                                                    mem[_32543 + ceil32(return_data.size) + 201] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _32543 + ceil32(return_data.size) + 233] = mem[idx + _32543 + 132]
                                                        _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_32543 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_32543 + 196] == bool(mem[_32543 + 196])
                                                    if not mem[_32543 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                revert with 0, 50
                                            if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _32377:
                                                revert with 0, 17
                                            mem[32] = 5
                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                revert with 0, 50
                                            mem[0] = sha3(address(arg1), 5)
                                            uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _32377
                            else:
                                if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                    revert with 0, 50
                                _31960 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]:
                                    if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                        revert with 0, 50
                                    _32093 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224]]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(_32093))
                                    staticcall address(_32093).balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _32369 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _32426 = mem[_32369]
                                    if mem[_32369] > _31960:
                                        _32541 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = _31960
                                        _32651 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[64] = mem[64] + 100
                                        mem[_32651 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_32651 + 36 len 28]
                                        mem[64] = _32541 + 164
                                        mem[_32541 + 100] = 32
                                        mem[_32541 + 132] = 'SafeERC20: low-level call failed'
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_32093)):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(address(_32093)):
                                            revert with 0, 'Address: call to non-contract'
                                        _33153 = mem[_32651]
                                        s = 0
                                        while s < _33153:
                                            mem[s + _32541 + 164] = mem[s + _32651 + 32]
                                            _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                            s = s + 32
                                            continue 
                                        if ceil32(_33153) > _33153:
                                            mem[_33153 + _32541 + 164] = 0
                                        call address(_32093).mem[_32541 + 164 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_32541 + 168 len _33153 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                mem[_32541 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_32541 + 168] = 32
                                                mem[_32541 + 200] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _32541 + 232] = mem[idx + _32541 + 132]
                                                    _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_32541 + 232]
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[64] = _32541 + ceil32(return_data.size) + 165
                                            mem[_32541 + 164] = return_data.size
                                            mem[_32541 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_32541 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_32541 + ceil32(return_data.size) + 169] = 32
                                                mem[_32541 + ceil32(return_data.size) + 201] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _32541 + ceil32(return_data.size) + 233] = mem[idx + _32541 + 132]
                                                    _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_32541 + ceil32(return_data.size) + 233]
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_32541 + 196] == bool(mem[_32541 + 196])
                                                if not mem[_32541 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _31960:
                                            revert with 0, 17
                                        mem[32] = 5
                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 5)
                                        uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _31960
                                    else:
                                        if not mem[_32369]:
                                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                revert with 0, 50
                                            if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < 0:
                                                revert with 0, 17
                                            mem[32] = 5
                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                revert with 0, 50
                                            mem[0] = sha3(address(arg1), 5)
                                            uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                        else:
                                            _32587 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = _32426
                                            _32733 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_32733 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_32733 + 36 len 28]
                                            mem[64] = _32587 + 164
                                            mem[_32587 + 100] = 32
                                            mem[_32587 + 132] = 'SafeERC20: low-level call failed'
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_32093)):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(_32093)):
                                                revert with 0, 'Address: call to non-contract'
                                            _33262 = mem[_32733]
                                            s = 0
                                            while s < _33262:
                                                mem[s + _32587 + 164] = mem[s + _32733 + 32]
                                                _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                s = s + 32
                                                continue 
                                            if ceil32(_33262) > _33262:
                                                mem[_33262 + _32587 + 164] = 0
                                            call address(_32093).mem[_32587 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_32587 + 168 len _33262 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_32587 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_32587 + 168] = 32
                                                    mem[_32587 + 200] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _32587 + 232] = mem[idx + _32587 + 132]
                                                        _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_32587 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _32587 + ceil32(return_data.size) + 165
                                                mem[_32587 + 164] = return_data.size
                                                mem[_32587 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_32587 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_32587 + ceil32(return_data.size) + 169] = 32
                                                    mem[_32587 + ceil32(return_data.size) + 201] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _32587 + ceil32(return_data.size) + 233] = mem[idx + _32587 + 132]
                                                        _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_32587 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_32587 + 196] == bool(mem[_32587 + 196])
                                                    if not mem[_32587 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                revert with 0, 50
                                            if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _32426:
                                                revert with 0, 17
                                            mem[32] = 5
                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                revert with 0, 50
                                            mem[0] = sha3(address(arg1), 5)
                                            uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _32426
                        else:
                            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                                revert with 0, 50
                            _30570 = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                revert with 0, 50
                            _31190 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128]
                            _31191 = mem[ceil32(return_data.size) + 96]
                            if mem[ceil32(return_data.size) + 96] and mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] > -1 / mem[ceil32(return_data.size) + 96]:
                                revert with 0, 17
                            if mem[ceil32(return_data.size) + 96] * mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18 < mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]:
                                revert with 0, 17
                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                revert with 0, 50
                            if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] >= (mem[ceil32(return_data.size) + 96] * mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18) - mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]:
                                if (mem[ceil32(return_data.size) + 96] * mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18) - mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]:
                                    if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                        revert with 0, 50
                                    _32097 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224]]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(_32097))
                                    staticcall address(_32097).balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _32370 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _32427 = mem[_32370]
                                    if mem[_32370] > (_31191 * _31190 / 1000000000000 * 10^18) - _30570:
                                        _32544 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = (_31191 * _31190 / 1000000000000 * 10^18) - _30570
                                        _32660 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[64] = mem[64] + 100
                                        mem[_32660 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_32660 + 36 len 28]
                                        mem[64] = _32544 + 164
                                        mem[_32544 + 100] = 32
                                        mem[_32544 + 132] = 'SafeERC20: low-level call failed'
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_32097)):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(address(_32097)):
                                            revert with 0, 'Address: call to non-contract'
                                        _33163 = mem[_32660]
                                        s = 0
                                        while s < _33163:
                                            mem[s + _32544 + 164] = mem[s + _32660 + 32]
                                            _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                            s = s + 32
                                            continue 
                                        if ceil32(_33163) > _33163:
                                            mem[_33163 + _32544 + 164] = 0
                                        call address(_32097).mem[_32544 + 164 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_32544 + 168 len _33163 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                mem[_32544 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_32544 + 168] = 32
                                                mem[_32544 + 200] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _32544 + 232] = mem[idx + _32544 + 132]
                                                    _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_32544 + 232]
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[64] = _32544 + ceil32(return_data.size) + 165
                                            mem[_32544 + 164] = return_data.size
                                            mem[_32544 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_32544 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_32544 + ceil32(return_data.size) + 169] = 32
                                                mem[_32544 + ceil32(return_data.size) + 201] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _32544 + ceil32(return_data.size) + 233] = mem[idx + _32544 + 132]
                                                    _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_32544 + ceil32(return_data.size) + 233]
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_32544 + 196] == bool(mem[_32544 + 196])
                                                if not mem[_32544 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < (_31191 * _31190 / 1000000000000 * 10^18) - _30570:
                                            revert with 0, 17
                                        mem[32] = 5
                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 5)
                                        uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - (_31191 * _31190 / 1000000000000 * 10^18) + _30570
                                    else:
                                        if not mem[_32370]:
                                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                revert with 0, 50
                                            if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < 0:
                                                revert with 0, 17
                                            mem[32] = 5
                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                revert with 0, 50
                                            mem[0] = sha3(address(arg1), 5)
                                            uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                        else:
                                            _32594 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = _32427
                                            _32741 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_32741 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_32741 + 36 len 28]
                                            mem[64] = _32594 + 164
                                            mem[_32594 + 100] = 32
                                            mem[_32594 + 132] = 'SafeERC20: low-level call failed'
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_32097)):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(_32097)):
                                                revert with 0, 'Address: call to non-contract'
                                            _33271 = mem[_32741]
                                            s = 0
                                            while s < _33271:
                                                mem[s + _32594 + 164] = mem[s + _32741 + 32]
                                                _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                s = s + 32
                                                continue 
                                            if ceil32(_33271) > _33271:
                                                mem[_33271 + _32594 + 164] = 0
                                            call address(_32097).mem[_32594 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_32594 + 168 len _33271 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_32594 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_32594 + 168] = 32
                                                    mem[_32594 + 200] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _32594 + 232] = mem[idx + _32594 + 132]
                                                        _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_32594 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _32594 + ceil32(return_data.size) + 165
                                                mem[_32594 + 164] = return_data.size
                                                mem[_32594 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_32594 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_32594 + ceil32(return_data.size) + 169] = 32
                                                    mem[_32594 + ceil32(return_data.size) + 201] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _32594 + ceil32(return_data.size) + 233] = mem[idx + _32594 + 132]
                                                        _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_32594 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_32594 + 196] == bool(mem[_32594 + 196])
                                                    if not mem[_32594 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                revert with 0, 50
                                            if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _32427:
                                                revert with 0, 17
                                            mem[32] = 5
                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                revert with 0, 50
                                            mem[0] = sha3(address(arg1), 5)
                                            uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _32427
                            else:
                                if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                    revert with 0, 50
                                _31981 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]:
                                    if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                        revert with 0, 50
                                    _32201 = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224]]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(_32201))
                                    staticcall address(_32201).balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _32378 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _32486 = mem[_32378]
                                    if mem[_32378] > _31981:
                                        _32592 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = _31981
                                        _32739 = mem[64]
                                        mem[mem[64]] = 68
                                        mem[64] = mem[64] + 100
                                        mem[_32739 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_32739 + 36 len 28]
                                        mem[64] = _32592 + 164
                                        mem[_32592 + 100] = 32
                                        mem[_32592 + 132] = 'SafeERC20: low-level call failed'
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_32201)):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(address(_32201)):
                                            revert with 0, 'Address: call to non-contract'
                                        _33270 = mem[_32739]
                                        s = 0
                                        while s < _33270:
                                            mem[s + _32592 + 164] = mem[s + _32739 + 32]
                                            _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                            s = s + 32
                                            continue 
                                        if ceil32(_33270) > _33270:
                                            mem[_33270 + _32592 + 164] = 0
                                        call address(_32201).mem[_32592 + 164 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_32592 + 168 len _33270 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                if mem[96]:
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                mem[_32592 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_32592 + 168] = 32
                                                mem[_32592 + 200] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _32592 + 232] = mem[idx + _32592 + 132]
                                                    _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_32592 + 232]
                                            if mem[96]:
                                                require mem[96] >= 32
                                                require mem[128] == bool(mem[128])
                                                if not mem[128]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        else:
                                            mem[64] = _32592 + ceil32(return_data.size) + 165
                                            mem[_32592 + 164] = return_data.size
                                            mem[_32592 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                if return_data.size:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_32592 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_32592 + ceil32(return_data.size) + 169] = 32
                                                mem[_32592 + ceil32(return_data.size) + 201] = 32
                                                idx = 0
                                                while idx < 32:
                                                    mem[idx + _32592 + ceil32(return_data.size) + 233] = mem[idx + _32592 + 132]
                                                    _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 32, 32, mem[_32592 + ceil32(return_data.size) + 233]
                                            if return_data.size:
                                                require return_data.size >= 32
                                                require mem[_32592 + 196] == bool(mem[_32592 + 196])
                                                if not mem[_32592 + 196]:
                                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                        if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _31981:
                                            revert with 0, 17
                                        mem[32] = 5
                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 5)
                                        uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _31981
                                    else:
                                        if not mem[_32378]:
                                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                revert with 0, 50
                                            if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < 0:
                                                revert with 0, 17
                                            mem[32] = 5
                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                revert with 0, 50
                                            mem[0] = sha3(address(arg1), 5)
                                            uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                        else:
                                            _32657 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = _32486
                                            _32823 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_32823 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_32823 + 36 len 28]
                                            mem[64] = _32657 + 164
                                            mem[_32657 + 100] = 32
                                            mem[_32657 + 132] = 'SafeERC20: low-level call failed'
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_32201)):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(_32201)):
                                                revert with 0, 'Address: call to non-contract'
                                            _33327 = mem[_32823]
                                            s = 0
                                            while s < _33327:
                                                mem[s + _32657 + 164] = mem[s + _32823 + 32]
                                                _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                s = s + 32
                                                continue 
                                            if ceil32(_33327) > _33327:
                                                mem[_33327 + _32657 + 164] = 0
                                            call address(_32201).mem[_32657 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_32657 + 168 len _33327 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_32657 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_32657 + 168] = 32
                                                    mem[_32657 + 200] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _32657 + 232] = mem[idx + _32657 + 132]
                                                        _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_32657 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _32657 + ceil32(return_data.size) + 165
                                                mem[_32657 + 164] = return_data.size
                                                mem[_32657 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_32657 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_32657 + ceil32(return_data.size) + 169] = 32
                                                    mem[_32657 + ceil32(return_data.size) + 201] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _32657 + ceil32(return_data.size) + 233] = mem[idx + _32657 + 132]
                                                        _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_32657 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_32657 + 196] == bool(mem[_32657 + 196])
                                                    if not mem[_32657 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx >= mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                revert with 0, 50
                                            if mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _32486:
                                                revert with 0, 17
                                            mem[32] = 5
                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                revert with 0, 50
                                            mem[0] = sha3(address(arg1), 5)
                                            uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _32486
                        if idx == -1:
                            revert with 0, 17
                        _30126 = mem[ceil32(return_data.size) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(arg1)
                    staticcall arg1.balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _31322 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _31454 = mem[_31322]
                    _31586 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = this.address
                    mem[mem[64] + 100] = arg2
                    _31738 = mem[64]
                    mem[mem[64]] = 100
                    mem[mem[64] + 32 len 4] = transferFrom(address rg1, address rg2, uint256 rg3)
                    mem[64] = mem[64] + 196
                    mem[_31586 + 132] = 32
                    mem[_31586 + 164] = 'SafeERC20: low-level call failed'
                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                        revert with 0, 'Address: call to non-contract'
                    if not ext_code.hash(arg1):
                        revert with 0, 'Address: call to non-contract'
                    _32215 = mem[_31738]
                    mem[_31586 + 196 len ceil32(mem[_31738])] = mem[_31738 + 32 len ceil32(mem[_31738])]
                    if ceil32(_32215) <= _32215:
                        call arg1 with:
                             gas gas_remaining wei
                            args mem[_31586 + 200 len _32215 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if not mem[96]:
                                mem[_31586 + 200] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[_31586 + 196] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < _31454:
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _31454):
                                    revert with 0, 17
                                uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _31454
                                mem[64] = _31586 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                mem[_31586 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                s = _31586 + ceil32(return_data.size) + 228
                                idx = 0
                                while idx < uint256(stor5[address(arg1)].field_0):
                                    mem[0] = sha3(address(arg1), 5)
                                    _42075 = mem[64]
                                    mem[64] = mem[64] + 192
                                    mem[_42075] = address(stor5[address(arg1)][idx].field_0)
                                    mem[_42075 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                    mem[_42075 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                    mem[_42075 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                    mem[_42075 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                    mem[_42075 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                    mem[s] = _42075
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                            else:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                mem[_31586 + 200] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[_31586 + 196] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < _31454:
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _31454):
                                    revert with 0, 17
                                uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _31454
                                mem[64] = _31586 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                mem[_31586 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                s = _31586 + ceil32(return_data.size) + 228
                                idx = 0
                                while idx < uint256(stor5[address(arg1)].field_0):
                                    mem[0] = sha3(address(arg1), 5)
                                    _42079 = mem[64]
                                    mem[64] = mem[64] + 192
                                    mem[_42079] = address(stor5[address(arg1)][idx].field_0)
                                    mem[_42079 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                    mem[_42079 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                    mem[_42079 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                    mem[_42079 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                    mem[_42079 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                    mem[s] = _42079
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                            idx = 0
                            while idx < mem[_31586 + ceil32(return_data.size) + 196]:
                                if idx >= mem[_31586 + ceil32(return_data.size) + 196]:
                                    revert with 0, 50
                                if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _31586 + ceil32(return_data.size) + 228] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                    revert with 0, 17
                                if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                    if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                        revert with 0, 50
                                    mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                    uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _31586 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                else:
                                    uint256(stor6[address(arg1)][msg.sender].field_256)++
                                    mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                    uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _31586 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[_31586 + 196] = return_data.size
                            mem[_31586 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if not return_data.size:
                                mem[_31586 + ceil32(return_data.size) + 201] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[_31586 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < _31454:
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _31454):
                                    revert with 0, 17
                                uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _31454
                                mem[64] = _31586 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                mem[_31586 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                s = _31586 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                idx = 0
                                while idx < uint256(stor5[address(arg1)].field_0):
                                    mem[0] = sha3(address(arg1), 5)
                                    _42084 = mem[64]
                                    mem[64] = mem[64] + 192
                                    mem[_42084] = address(stor5[address(arg1)][idx].field_0)
                                    mem[_42084 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                    mem[_42084 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                    mem[_42084 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                    mem[_42084 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                    mem[_42084 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                    mem[s] = _42084
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                            else:
                                require return_data.size >= 32
                                require mem[_31586 + 228] == bool(mem[_31586 + 228])
                                if not mem[_31586 + 228]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                mem[_31586 + ceil32(return_data.size) + 201] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[_31586 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < _31454:
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _31454):
                                    revert with 0, 17
                                uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _31454
                                mem[64] = _31586 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                mem[_31586 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                s = _31586 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                idx = 0
                                while idx < uint256(stor5[address(arg1)].field_0):
                                    mem[0] = sha3(address(arg1), 5)
                                    _42088 = mem[64]
                                    mem[64] = mem[64] + 192
                                    mem[_42088] = address(stor5[address(arg1)][idx].field_0)
                                    mem[_42088 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                    mem[_42088 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                    mem[_42088 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                    mem[_42088 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                    mem[_42088 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                    mem[s] = _42088
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                            idx = 0
                            while idx < mem[_31586 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                if idx >= mem[_31586 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                    revert with 0, 50
                                if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _31586 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                    revert with 0, 17
                                if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                    if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                        revert with 0, 50
                                    mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                    uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _31586 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                else:
                                    uint256(stor6[address(arg1)][msg.sender].field_256)++
                                    mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                    uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _31586 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        mem[_32215 + _31586 + 196] = 0
                        call arg1 with:
                             gas gas_remaining wei
                            args mem[_31586 + 200 len _32215 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if not mem[96]:
                                mem[_31586 + 200] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[_31586 + 196] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < _31454:
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _31454):
                                    revert with 0, 17
                                uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _31454
                                mem[64] = _31586 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                mem[_31586 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                s = _31586 + ceil32(return_data.size) + 228
                                idx = 0
                                while idx < uint256(stor5[address(arg1)].field_0):
                                    mem[0] = sha3(address(arg1), 5)
                                    _42093 = mem[64]
                                    mem[64] = mem[64] + 192
                                    mem[_42093] = address(stor5[address(arg1)][idx].field_0)
                                    mem[_42093 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                    mem[_42093 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                    mem[_42093 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                    mem[_42093 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                    mem[_42093 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                    mem[s] = _42093
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                            else:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                mem[_31586 + 200] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[_31586 + 196] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < _31454:
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _31454):
                                    revert with 0, 17
                                uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _31454
                                mem[64] = _31586 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                mem[_31586 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                s = _31586 + ceil32(return_data.size) + 228
                                idx = 0
                                while idx < uint256(stor5[address(arg1)].field_0):
                                    mem[0] = sha3(address(arg1), 5)
                                    _42097 = mem[64]
                                    mem[64] = mem[64] + 192
                                    mem[_42097] = address(stor5[address(arg1)][idx].field_0)
                                    mem[_42097 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                    mem[_42097 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                    mem[_42097 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                    mem[_42097 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                    mem[_42097 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                    mem[s] = _42097
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                            idx = 0
                            while idx < mem[_31586 + ceil32(return_data.size) + 196]:
                                if idx >= mem[_31586 + ceil32(return_data.size) + 196]:
                                    revert with 0, 50
                                if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _31586 + ceil32(return_data.size) + 228] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                    revert with 0, 17
                                if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                    if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                        revert with 0, 50
                                    mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                    uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _31586 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                else:
                                    uint256(stor6[address(arg1)][msg.sender].field_256)++
                                    mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                    uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _31586 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[_31586 + 196] = return_data.size
                            mem[_31586 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if not return_data.size:
                                mem[_31586 + ceil32(return_data.size) + 201] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[_31586 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < _31454:
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _31454):
                                    revert with 0, 17
                                uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _31454
                                mem[64] = _31586 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                mem[_31586 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                s = _31586 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                idx = 0
                                while idx < uint256(stor5[address(arg1)].field_0):
                                    mem[0] = sha3(address(arg1), 5)
                                    _42102 = mem[64]
                                    mem[64] = mem[64] + 192
                                    mem[_42102] = address(stor5[address(arg1)][idx].field_0)
                                    mem[_42102 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                    mem[_42102 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                    mem[_42102 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                    mem[_42102 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                    mem[_42102 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                    mem[s] = _42102
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                            else:
                                require return_data.size >= 32
                                require mem[_31586 + 228] == bool(mem[_31586 + 228])
                                if not mem[_31586 + 228]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                mem[_31586 + ceil32(return_data.size) + 201] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[_31586 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < _31454:
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _31454):
                                    revert with 0, 17
                                uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _31454
                                mem[64] = _31586 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                mem[_31586 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                s = _31586 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                idx = 0
                                while idx < uint256(stor5[address(arg1)].field_0):
                                    mem[0] = sha3(address(arg1), 5)
                                    _42106 = mem[64]
                                    mem[64] = mem[64] + 192
                                    mem[_42106] = address(stor5[address(arg1)][idx].field_0)
                                    mem[_42106 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                    mem[_42106 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                    mem[_42106 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                    mem[_42106 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                    mem[_42106 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                    mem[s] = _42106
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                            idx = 0
                            while idx < mem[_31586 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                if idx >= mem[_31586 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                    revert with 0, 50
                                if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _31586 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                    revert with 0, 17
                                if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                    if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                        revert with 0, 50
                                    mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                    uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _31586 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                else:
                                    uint256(stor6[address(arg1)][msg.sender].field_256)++
                                    mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                    uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _31586 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    emit Deposit((ext_call.return_data[0] - _31454), msg.sender, arg1);
        else:
            uint256(stor5[address(arg1)].field_256) = block.timestamp
            mem[ceil32(return_data.size) + 100] = this.address
            require ext_code.size(arg1)
            staticcall arg1.balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[64] = (2 * ceil32(return_data.size)) + 96
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                mem[(2 * ceil32(return_data.size)) + 96] = uint256(stor6[address(arg1)][msg.sender].field_0)
                mem[(2 * ceil32(return_data.size)) + 160] = uint256(stor6[address(arg1)][msg.sender].field_256)
                if not uint256(stor6[address(arg1)][msg.sender].field_256):
                    mem[(2 * ceil32(return_data.size)) + 128] = (2 * ceil32(return_data.size)) + 160
                    if not uint256(stor6[address(arg1)][msg.sender].field_0):
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 196] = this.address
                        require ext_code.size(arg1)
                        staticcall arg1.balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 228] = msg.sender
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 260] = this.address
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 292] = arg2
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192] = 100
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 228 len 28] = Mask(224, 32, msg.sender) >> 32
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224 len 4] = transferFrom(address rg1, address rg2, uint256 rg3)
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 324] = 32
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 356] = 'SafeERC20: low-level call failed'
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                            revert with 0, 'Address: call to non-contract'
                        if not ext_code.hash(arg1):
                            revert with 0, 'Address: call to non-contract'
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388 len 128] = transferFrom(address rg1, address rg2, uint256 rg3), msg.sender, address(this.address), arg2, 0
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 488] = 0
                        call arg1 with:
                           funct Mask(32, 224, transferFrom(address rg1, address rg2, uint256 rg3), msg.sender, address(this.address), arg2, 0) >> 224
                             gas gas_remaining wei
                            args (Mask(768, -544, transferFrom(address rg1, address rg2, uint256 rg3), msg.sender, address(this.address), arg2, 0) << 544)
                        if not return_data.size:
                            if not ext_call.success:
                                if ext_call.return_data[0]:
                                    revert with memory
                                      from 128
                                       len ext_call.return_data[0]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if not ext_call.return_data[0]:
                                mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 392] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][msg.sender].field_0) > !0:
                                    revert with 0, 17
                                mem[64] = (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + (32 * uint256(stor5[address(arg1)].field_0)) + 420
                                mem[(6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = uint256(stor5[address(arg1)].field_0)
                                s = (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420
                                idx = 0
                                while idx < uint256(stor5[address(arg1)].field_0):
                                    mem[0] = sha3(address(arg1), 5)
                                    _11062 = mem[64]
                                    mem[64] = mem[64] + 192
                                    mem[_11062] = address(stor5[address(arg1)][idx].field_0)
                                    mem[_11062 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                    mem[_11062 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                    mem[_11062 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                    mem[_11062 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                    mem[_11062 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                    mem[s] = _11062
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                            else:
                                require ext_call.return_data[0] >= 32
                                require uint32(msg.sender), mem[132 len 28] == bool(uint32(msg.sender), mem[132 len 28])
                                if not uint32(msg.sender), mem[132 len 28]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 392] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][msg.sender].field_0) > !0:
                                    revert with 0, 17
                                mem[64] = (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + (32 * uint256(stor5[address(arg1)].field_0)) + 420
                                mem[(6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = uint256(stor5[address(arg1)].field_0)
                                s = (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420
                                idx = 0
                                while idx < uint256(stor5[address(arg1)].field_0):
                                    mem[0] = sha3(address(arg1), 5)
                                    _11066 = mem[64]
                                    mem[64] = mem[64] + 192
                                    mem[_11066] = address(stor5[address(arg1)][idx].field_0)
                                    mem[_11066 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                    mem[_11066 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                    mem[_11066 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                    mem[_11066 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                    mem[_11066 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                    mem[s] = _11066
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                            idx = 0
                            while idx < mem[(6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388]:
                                if idx >= mem[(6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388]:
                                    revert with 0, 50
                                if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                    revert with 0, 17
                                if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                    if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                        revert with 0, 50
                                    mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                    uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420] + 128] / 1000000000000 * 10^18
                                else:
                                    uint256(stor6[address(arg1)][msg.sender].field_256)++
                                    mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                    uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420] + 128] / 1000000000000 * 10^18
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = return_data.size
                            mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if not return_data.size:
                                mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 393] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][msg.sender].field_0) > !0:
                                    revert with 0, 17
                                mem[64] = (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 421
                                mem[(6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389] = uint256(stor5[address(arg1)].field_0)
                                s = (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421
                                idx = 0
                                while idx < uint256(stor5[address(arg1)].field_0):
                                    mem[0] = sha3(address(arg1), 5)
                                    _11071 = mem[64]
                                    mem[64] = mem[64] + 192
                                    mem[_11071] = address(stor5[address(arg1)][idx].field_0)
                                    mem[_11071 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                    mem[_11071 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                    mem[_11071 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                    mem[_11071 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                    mem[_11071 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                    mem[s] = _11071
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                            else:
                                require return_data.size >= 32
                                require mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420] == bool(mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420])
                                if not mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 393] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][msg.sender].field_0) > !0:
                                    revert with 0, 17
                                mem[64] = (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 421
                                mem[(6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389] = uint256(stor5[address(arg1)].field_0)
                                s = (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421
                                idx = 0
                                while idx < uint256(stor5[address(arg1)].field_0):
                                    mem[0] = sha3(address(arg1), 5)
                                    _11075 = mem[64]
                                    mem[64] = mem[64] + 192
                                    mem[_11075] = address(stor5[address(arg1)][idx].field_0)
                                    mem[_11075 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                    mem[_11075 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                    mem[_11075 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                    mem[_11075 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                    mem[_11075 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                    mem[s] = _11075
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                            idx = 0
                            while idx < mem[(6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389]:
                                if idx >= mem[(6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389]:
                                    revert with 0, 50
                                if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                    revert with 0, 17
                                if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                    if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                        revert with 0, 50
                                    mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                    uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421] + 128] / 1000000000000 * 10^18
                                else:
                                    uint256(stor6[address(arg1)][msg.sender].field_256)++
                                    mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                    uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421] + 128] / 1000000000000 * 10^18
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        emit Deposit(0, msg.sender, arg1);
                    else:
                        mem[0] = arg1
                        mem[32] = 5
                        mem[64] = (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + (32 * uint256(stor5[address(arg1)].field_0)) + 224
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192] = uint256(stor5[address(arg1)].field_0)
                        s = (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224
                        idx = 0
                        while idx < uint256(stor5[address(arg1)].field_0):
                            mem[0] = sha3(address(arg1), 5)
                            _5548 = mem[64]
                            mem[64] = mem[64] + 192
                            mem[_5548] = address(stor5[address(arg1)][idx].field_0)
                            mem[_5548 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                            mem[_5548 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                            mem[_5548 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                            mem[_5548 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                            mem[_5548 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                            mem[s] = _5548
                            s = s + 32
                            idx = idx + 1
                            continue 
                        _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                        idx = 0
                        while idx < _10998:
                            if uint256(stor6[address(arg1)][msg.sender].field_256) <= idx:
                                if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                    revert with 0, 50
                                _11210 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128]
                                _11211 = mem[(2 * ceil32(return_data.size)) + 96]
                                if mem[(2 * ceil32(return_data.size)) + 96] and mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] > -1 / mem[(2 * ceil32(return_data.size)) + 96]:
                                    revert with 0, 17
                                if mem[(2 * ceil32(return_data.size)) + 96] * mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18 < 0:
                                    revert with 0, 17
                                if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                    revert with 0, 50
                                if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] >= mem[(2 * ceil32(return_data.size)) + 96] * mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18:
                                    if mem[(2 * ceil32(return_data.size)) + 96] * mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18:
                                        if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        _11690 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224]]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(_11690))
                                        staticcall address(_11690).balanceOf(address rg1) with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _11860 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _11923 = mem[_11860]
                                        if mem[_11860] > _11211 * _11210 / 1000000000000 * 10^18:
                                            _12007 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = _11211 * _11210 / 1000000000000 * 10^18
                                            _12095 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_12095 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12095 + 36 len 28]
                                            mem[64] = _12007 + 164
                                            mem[_12007 + 100] = 32
                                            mem[_12007 + 132] = 'SafeERC20: low-level call failed'
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_11690)):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(_11690)):
                                                revert with 0, 'Address: call to non-contract'
                                            _12824 = mem[_12095]
                                            s = 0
                                            while s < _12824:
                                                mem[s + _12007 + 164] = mem[s + _12095 + 32]
                                                _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                s = s + 32
                                                continue 
                                            if ceil32(_12824) > _12824:
                                                mem[_12824 + _12007 + 164] = 0
                                            call address(_11690).mem[_12007 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_12007 + 168 len _12824 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_12007 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_12007 + 168] = 32
                                                    mem[_12007 + 200] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _12007 + 232] = mem[idx + _12007 + 132]
                                                        _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_12007 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _12007 + ceil32(return_data.size) + 165
                                                mem[_12007 + 164] = return_data.size
                                                mem[_12007 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_12007 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_12007 + ceil32(return_data.size) + 169] = 32
                                                    mem[_12007 + ceil32(return_data.size) + 201] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _12007 + ceil32(return_data.size) + 233] = mem[idx + _12007 + 132]
                                                        _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_12007 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_12007 + 196] == bool(mem[_12007 + 196])
                                                    if not mem[_12007 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                revert with 0, 50
                                            if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _11211 * _11210 / 1000000000000 * 10^18:
                                                revert with 0, 17
                                            mem[32] = 5
                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                revert with 0, 50
                                            mem[0] = sha3(address(arg1), 5)
                                            uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - (_11211 * _11210 / 1000000000000 * 10^18)
                                        else:
                                            if not mem[_11860]:
                                                if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                    revert with 0, 50
                                                if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < 0:
                                                    revert with 0, 17
                                                mem[32] = 5
                                                if idx >= uint256(stor5[address(arg1)].field_0):
                                                    revert with 0, 50
                                                mem[0] = sha3(address(arg1), 5)
                                                uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                            else:
                                                _12049 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = _11923
                                                _12160 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_12160 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12160 + 36 len 28]
                                                mem[64] = _12049 + 164
                                                mem[_12049 + 100] = 32
                                                mem[_12049 + 132] = 'SafeERC20: low-level call failed'
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_11690)):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(address(_11690)):
                                                    revert with 0, 'Address: call to non-contract'
                                                _12927 = mem[_12160]
                                                s = 0
                                                while s < _12927:
                                                    mem[s + _12049 + 164] = mem[s + _12160 + 32]
                                                    _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_12927) > _12927:
                                                    mem[_12927 + _12049 + 164] = 0
                                                call address(_11690).mem[_12049 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_12049 + 168 len _12927 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_12049 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_12049 + 168] = 32
                                                        mem[_12049 + 200] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _12049 + 232] = mem[idx + _12049 + 132]
                                                            _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_12049 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _12049 + ceil32(return_data.size) + 165
                                                    mem[_12049 + 164] = return_data.size
                                                    mem[_12049 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_12049 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_12049 + ceil32(return_data.size) + 169] = 32
                                                        mem[_12049 + ceil32(return_data.size) + 201] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _12049 + ceil32(return_data.size) + 233] = mem[idx + _12049 + 132]
                                                            _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_12049 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_12049 + 196] == bool(mem[_12049 + 196])
                                                        if not mem[_12049 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                    revert with 0, 50
                                                if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _11923:
                                                    revert with 0, 17
                                                mem[32] = 5
                                                if idx >= uint256(stor5[address(arg1)].field_0):
                                                    revert with 0, 50
                                                mem[0] = sha3(address(arg1), 5)
                                                uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _11923
                                else:
                                    if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                        revert with 0, 50
                                    _11651 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                    if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]:
                                        if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        _11720 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224]]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(_11720))
                                        staticcall address(_11720).balanceOf(address rg1) with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _11894 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _11955 = mem[_11894]
                                        if mem[_11894] > _11651:
                                            _12047 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = _11651
                                            _12158 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_12158 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12158 + 36 len 28]
                                            mem[64] = _12047 + 164
                                            mem[_12047 + 100] = 32
                                            mem[_12047 + 132] = 'SafeERC20: low-level call failed'
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_11720)):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(_11720)):
                                                revert with 0, 'Address: call to non-contract'
                                            _12926 = mem[_12158]
                                            s = 0
                                            while s < _12926:
                                                mem[s + _12047 + 164] = mem[s + _12158 + 32]
                                                _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                s = s + 32
                                                continue 
                                            if ceil32(_12926) > _12926:
                                                mem[_12926 + _12047 + 164] = 0
                                            call address(_11720).mem[_12047 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_12047 + 168 len _12926 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_12047 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_12047 + 168] = 32
                                                    mem[_12047 + 200] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _12047 + 232] = mem[idx + _12047 + 132]
                                                        _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_12047 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _12047 + ceil32(return_data.size) + 165
                                                mem[_12047 + 164] = return_data.size
                                                mem[_12047 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_12047 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_12047 + ceil32(return_data.size) + 169] = 32
                                                    mem[_12047 + ceil32(return_data.size) + 201] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _12047 + ceil32(return_data.size) + 233] = mem[idx + _12047 + 132]
                                                        _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_12047 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_12047 + 196] == bool(mem[_12047 + 196])
                                                    if not mem[_12047 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                revert with 0, 50
                                            if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _11651:
                                                revert with 0, 17
                                            mem[32] = 5
                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                revert with 0, 50
                                            mem[0] = sha3(address(arg1), 5)
                                            uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _11651
                                        else:
                                            if not mem[_11894]:
                                                if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                    revert with 0, 50
                                                if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < 0:
                                                    revert with 0, 17
                                                mem[32] = 5
                                                if idx >= uint256(stor5[address(arg1)].field_0):
                                                    revert with 0, 50
                                                mem[0] = sha3(address(arg1), 5)
                                                uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                            else:
                                                _12092 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = _11955
                                                _12257 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_12257 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12257 + 36 len 28]
                                                mem[64] = _12092 + 164
                                                mem[_12092 + 100] = 32
                                                mem[_12092 + 132] = 'SafeERC20: low-level call failed'
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_11720)):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(address(_11720)):
                                                    revert with 0, 'Address: call to non-contract'
                                                _13060 = mem[_12257]
                                                s = 0
                                                while s < _13060:
                                                    mem[s + _12092 + 164] = mem[s + _12257 + 32]
                                                    _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_13060) > _13060:
                                                    mem[_13060 + _12092 + 164] = 0
                                                call address(_11720).mem[_12092 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_12092 + 168 len _13060 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_12092 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_12092 + 168] = 32
                                                        mem[_12092 + 200] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _12092 + 232] = mem[idx + _12092 + 132]
                                                            _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_12092 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _12092 + ceil32(return_data.size) + 165
                                                    mem[_12092 + 164] = return_data.size
                                                    mem[_12092 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_12092 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_12092 + ceil32(return_data.size) + 169] = 32
                                                        mem[_12092 + ceil32(return_data.size) + 201] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _12092 + ceil32(return_data.size) + 233] = mem[idx + _12092 + 132]
                                                            _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_12092 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_12092 + 196] == bool(mem[_12092 + 196])
                                                        if not mem[_12092 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                    revert with 0, 50
                                                if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _11955:
                                                    revert with 0, 17
                                                mem[32] = 5
                                                if idx >= uint256(stor5[address(arg1)].field_0):
                                                    revert with 0, 50
                                                mem[0] = sha3(address(arg1), 5)
                                                uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _11955
                            else:
                                if idx >= mem[mem[(2 * ceil32(return_data.size)) + 128]]:
                                    revert with 0, 50
                                _11162 = mem[(32 * idx) + mem[(2 * ceil32(return_data.size)) + 128] + 32]
                                if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                    revert with 0, 50
                                _11331 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128]
                                _11332 = mem[(2 * ceil32(return_data.size)) + 96]
                                if mem[(2 * ceil32(return_data.size)) + 96] and mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] > -1 / mem[(2 * ceil32(return_data.size)) + 96]:
                                    revert with 0, 17
                                if mem[(2 * ceil32(return_data.size)) + 96] * mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18 < mem[(32 * idx) + mem[(2 * ceil32(return_data.size)) + 128] + 32]:
                                    revert with 0, 17
                                if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                    revert with 0, 50
                                if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] >= (mem[(2 * ceil32(return_data.size)) + 96] * mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18) - mem[(32 * idx) + mem[(2 * ceil32(return_data.size)) + 128] + 32]:
                                    if (mem[(2 * ceil32(return_data.size)) + 96] * mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18) - mem[(32 * idx) + mem[(2 * ceil32(return_data.size)) + 128] + 32]:
                                        if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        _11724 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224]]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(_11724))
                                        staticcall address(_11724).balanceOf(address rg1) with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _11895 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _11956 = mem[_11895]
                                        if mem[_11895] > (_11332 * _11331 / 1000000000000 * 10^18) - _11162:
                                            _12050 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = (_11332 * _11331 / 1000000000000 * 10^18) - _11162
                                            _12167 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_12167 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12167 + 36 len 28]
                                            mem[64] = _12050 + 164
                                            mem[_12050 + 100] = 32
                                            mem[_12050 + 132] = 'SafeERC20: low-level call failed'
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_11724)):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(_11724)):
                                                revert with 0, 'Address: call to non-contract'
                                            _12936 = mem[_12167]
                                            s = 0
                                            while s < _12936:
                                                mem[s + _12050 + 164] = mem[s + _12167 + 32]
                                                _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                s = s + 32
                                                continue 
                                            if ceil32(_12936) > _12936:
                                                mem[_12936 + _12050 + 164] = 0
                                            call address(_11724).mem[_12050 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_12050 + 168 len _12936 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_12050 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_12050 + 168] = 32
                                                    mem[_12050 + 200] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _12050 + 232] = mem[idx + _12050 + 132]
                                                        _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_12050 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _12050 + ceil32(return_data.size) + 165
                                                mem[_12050 + 164] = return_data.size
                                                mem[_12050 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_12050 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_12050 + ceil32(return_data.size) + 169] = 32
                                                    mem[_12050 + ceil32(return_data.size) + 201] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _12050 + ceil32(return_data.size) + 233] = mem[idx + _12050 + 132]
                                                        _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_12050 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_12050 + 196] == bool(mem[_12050 + 196])
                                                    if not mem[_12050 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                revert with 0, 50
                                            if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < (_11332 * _11331 / 1000000000000 * 10^18) - _11162:
                                                revert with 0, 17
                                            mem[32] = 5
                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                revert with 0, 50
                                            mem[0] = sha3(address(arg1), 5)
                                            uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - (_11332 * _11331 / 1000000000000 * 10^18) + _11162
                                        else:
                                            if not mem[_11895]:
                                                if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                    revert with 0, 50
                                                if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < 0:
                                                    revert with 0, 17
                                                mem[32] = 5
                                                if idx >= uint256(stor5[address(arg1)].field_0):
                                                    revert with 0, 50
                                                mem[0] = sha3(address(arg1), 5)
                                                uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                            else:
                                                _12099 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = _11956
                                                _12265 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_12265 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12265 + 36 len 28]
                                                mem[64] = _12099 + 164
                                                mem[_12099 + 100] = 32
                                                mem[_12099 + 132] = 'SafeERC20: low-level call failed'
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_11724)):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(address(_11724)):
                                                    revert with 0, 'Address: call to non-contract'
                                                _13069 = mem[_12265]
                                                s = 0
                                                while s < _13069:
                                                    mem[s + _12099 + 164] = mem[s + _12265 + 32]
                                                    _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_13069) > _13069:
                                                    mem[_13069 + _12099 + 164] = 0
                                                call address(_11724).mem[_12099 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_12099 + 168 len _13069 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_12099 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_12099 + 168] = 32
                                                        mem[_12099 + 200] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _12099 + 232] = mem[idx + _12099 + 132]
                                                            _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_12099 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _12099 + ceil32(return_data.size) + 165
                                                    mem[_12099 + 164] = return_data.size
                                                    mem[_12099 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_12099 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_12099 + ceil32(return_data.size) + 169] = 32
                                                        mem[_12099 + ceil32(return_data.size) + 201] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _12099 + ceil32(return_data.size) + 233] = mem[idx + _12099 + 132]
                                                            _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_12099 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_12099 + 196] == bool(mem[_12099 + 196])
                                                        if not mem[_12099 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                    revert with 0, 50
                                                if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _11956:
                                                    revert with 0, 17
                                                mem[32] = 5
                                                if idx >= uint256(stor5[address(arg1)].field_0):
                                                    revert with 0, 50
                                                mem[0] = sha3(address(arg1), 5)
                                                uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _11956
                                else:
                                    if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                        revert with 0, 50
                                    _11670 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                    if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]:
                                        if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        _11766 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224]]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(_11766))
                                        staticcall address(_11766).balanceOf(address rg1) with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _11924 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _11984 = mem[_11924]
                                        if mem[_11924] > _11670:
                                            _12097 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = _11670
                                            _12263 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_12263 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12263 + 36 len 28]
                                            mem[64] = _12097 + 164
                                            mem[_12097 + 100] = 32
                                            mem[_12097 + 132] = 'SafeERC20: low-level call failed'
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_11766)):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(_11766)):
                                                revert with 0, 'Address: call to non-contract'
                                            _13068 = mem[_12263]
                                            s = 0
                                            while s < _13068:
                                                mem[s + _12097 + 164] = mem[s + _12263 + 32]
                                                _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                s = s + 32
                                                continue 
                                            if ceil32(_13068) > _13068:
                                                mem[_13068 + _12097 + 164] = 0
                                            call address(_11766).mem[_12097 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_12097 + 168 len _13068 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_12097 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_12097 + 168] = 32
                                                    mem[_12097 + 200] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _12097 + 232] = mem[idx + _12097 + 132]
                                                        _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_12097 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _12097 + ceil32(return_data.size) + 165
                                                mem[_12097 + 164] = return_data.size
                                                mem[_12097 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_12097 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_12097 + ceil32(return_data.size) + 169] = 32
                                                    mem[_12097 + ceil32(return_data.size) + 201] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _12097 + ceil32(return_data.size) + 233] = mem[idx + _12097 + 132]
                                                        _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_12097 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_12097 + 196] == bool(mem[_12097 + 196])
                                                    if not mem[_12097 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                revert with 0, 50
                                            if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _11670:
                                                revert with 0, 17
                                            mem[32] = 5
                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                revert with 0, 50
                                            mem[0] = sha3(address(arg1), 5)
                                            uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _11670
                                        else:
                                            if not mem[_11924]:
                                                if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                    revert with 0, 50
                                                if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < 0:
                                                    revert with 0, 17
                                                mem[32] = 5
                                                if idx >= uint256(stor5[address(arg1)].field_0):
                                                    revert with 0, 50
                                                mem[0] = sha3(address(arg1), 5)
                                                uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                            else:
                                                _12164 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = _11984
                                                _12365 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_12365 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12365 + 36 len 28]
                                                mem[64] = _12164 + 164
                                                mem[_12164 + 100] = 32
                                                mem[_12164 + 132] = 'SafeERC20: low-level call failed'
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_11766)):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(address(_11766)):
                                                    revert with 0, 'Address: call to non-contract'
                                                _13152 = mem[_12365]
                                                s = 0
                                                while s < _13152:
                                                    mem[s + _12164 + 164] = mem[s + _12365 + 32]
                                                    _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_13152) > _13152:
                                                    mem[_13152 + _12164 + 164] = 0
                                                call address(_11766).mem[_12164 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_12164 + 168 len _13152 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_12164 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_12164 + 168] = 32
                                                        mem[_12164 + 200] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _12164 + 232] = mem[idx + _12164 + 132]
                                                            _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_12164 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _12164 + ceil32(return_data.size) + 165
                                                    mem[_12164 + 164] = return_data.size
                                                    mem[_12164 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_12164 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_12164 + ceil32(return_data.size) + 169] = 32
                                                        mem[_12164 + ceil32(return_data.size) + 201] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _12164 + ceil32(return_data.size) + 233] = mem[idx + _12164 + 132]
                                                            _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_12164 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_12164 + 196] == bool(mem[_12164 + 196])
                                                        if not mem[_12164 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                    revert with 0, 50
                                                if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _11984:
                                                    revert with 0, 17
                                                mem[32] = 5
                                                if idx >= uint256(stor5[address(arg1)].field_0):
                                                    revert with 0, 50
                                                mem[0] = sha3(address(arg1), 5)
                                                uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _11984
                            if idx == -1:
                                revert with 0, 17
                            _10998 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                            idx = idx + 1
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(arg1)
                        staticcall arg1.balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _11445 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _11481 = mem[_11445]
                        _11524 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = this.address
                        mem[mem[64] + 100] = arg2
                        _11588 = mem[64]
                        mem[mem[64]] = 100
                        mem[mem[64] + 32 len 4] = transferFrom(address rg1, address rg2, uint256 rg3)
                        mem[64] = mem[64] + 196
                        mem[_11524 + 132] = 32
                        mem[_11524 + 164] = 'SafeERC20: low-level call failed'
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                            revert with 0, 'Address: call to non-contract'
                        if not ext_code.hash(arg1):
                            revert with 0, 'Address: call to non-contract'
                        _11796 = mem[_11588]
                        mem[_11524 + 196 len ceil32(mem[_11588])] = mem[_11588 + 32 len ceil32(mem[_11588])]
                        if ceil32(_11796) <= _11796:
                            call arg1 with:
                                 gas gas_remaining wei
                                args mem[_11524 + 200 len _11796 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if not mem[96]:
                                    mem[_11524 + 200] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_11524 + 196] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _11481:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _11481):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _11481
                                    mem[64] = _11524 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                    mem[_11524 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                    s = _11524 + ceil32(return_data.size) + 228
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _30247 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_30247] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_30247 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_30247 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_30247 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_30247 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_30247 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _30247
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                else:
                                    require mem[96] >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_11524 + 200] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_11524 + 196] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _11481:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _11481):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _11481
                                    mem[64] = _11524 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                    mem[_11524 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                    s = _11524 + ceil32(return_data.size) + 228
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _30251 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_30251] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_30251 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_30251 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_30251 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_30251 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_30251 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _30251
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                idx = 0
                                while idx < mem[_11524 + ceil32(return_data.size) + 196]:
                                    if idx >= mem[_11524 + ceil32(return_data.size) + 196]:
                                        revert with 0, 50
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _11524 + ceil32(return_data.size) + 228] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                        revert with 0, 17
                                    if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                        if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                            revert with 0, 50
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _11524 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                    else:
                                        uint256(stor6[address(arg1)][msg.sender].field_256)++
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _11524 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[_11524 + 196] = return_data.size
                                mem[_11524 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if not return_data.size:
                                    mem[_11524 + ceil32(return_data.size) + 201] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_11524 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _11481:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _11481):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _11481
                                    mem[64] = _11524 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                    mem[_11524 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                    s = _11524 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _30256 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_30256] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_30256 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_30256 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_30256 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_30256 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_30256 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _30256
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                else:
                                    require return_data.size >= 32
                                    require mem[_11524 + 228] == bool(mem[_11524 + 228])
                                    if not mem[_11524 + 228]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_11524 + ceil32(return_data.size) + 201] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_11524 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _11481:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _11481):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _11481
                                    mem[64] = _11524 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                    mem[_11524 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                    s = _11524 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _30260 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_30260] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_30260 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_30260 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_30260 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_30260 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_30260 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _30260
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                idx = 0
                                while idx < mem[_11524 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                    if idx >= mem[_11524 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                        revert with 0, 50
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _11524 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                        revert with 0, 17
                                    if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                        if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                            revert with 0, 50
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _11524 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                    else:
                                        uint256(stor6[address(arg1)][msg.sender].field_256)++
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _11524 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        else:
                            mem[_11796 + _11524 + 196] = 0
                            call arg1 with:
                                 gas gas_remaining wei
                                args mem[_11524 + 200 len _11796 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if not mem[96]:
                                    mem[_11524 + 200] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_11524 + 196] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _11481:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _11481):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _11481
                                    mem[64] = _11524 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                    mem[_11524 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                    s = _11524 + ceil32(return_data.size) + 228
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _30265 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_30265] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_30265 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_30265 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_30265 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_30265 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_30265 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _30265
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                else:
                                    require mem[96] >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_11524 + 200] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_11524 + 196] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _11481:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _11481):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _11481
                                    mem[64] = _11524 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                    mem[_11524 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                    s = _11524 + ceil32(return_data.size) + 228
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _30269 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_30269] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_30269 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_30269 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_30269 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_30269 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_30269 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _30269
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                idx = 0
                                while idx < mem[_11524 + ceil32(return_data.size) + 196]:
                                    if idx >= mem[_11524 + ceil32(return_data.size) + 196]:
                                        revert with 0, 50
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _11524 + ceil32(return_data.size) + 228] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                        revert with 0, 17
                                    if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                        if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                            revert with 0, 50
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _11524 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                    else:
                                        uint256(stor6[address(arg1)][msg.sender].field_256)++
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _11524 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[_11524 + 196] = return_data.size
                                mem[_11524 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if not return_data.size:
                                    mem[_11524 + ceil32(return_data.size) + 201] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_11524 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _11481:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _11481):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _11481
                                    mem[64] = _11524 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                    mem[_11524 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                    s = _11524 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _30274 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_30274] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_30274 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_30274 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_30274 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_30274 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_30274 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _30274
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                else:
                                    require return_data.size >= 32
                                    require mem[_11524 + 228] == bool(mem[_11524 + 228])
                                    if not mem[_11524 + 228]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_11524 + ceil32(return_data.size) + 201] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_11524 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _11481:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _11481):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _11481
                                    mem[64] = _11524 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                    mem[_11524 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                    s = _11524 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _30278 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_30278] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_30278 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_30278 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_30278 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_30278 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_30278 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _30278
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                idx = 0
                                while idx < mem[_11524 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                    if idx >= mem[_11524 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                        revert with 0, 50
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _11524 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                        revert with 0, 17
                                    if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                        if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                            revert with 0, 50
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _11524 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                    else:
                                        uint256(stor6[address(arg1)][msg.sender].field_256)++
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _11524 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        emit Deposit((ext_call.return_data[0] - _11481), msg.sender, arg1);
                else:
                    mem[(2 * ceil32(return_data.size)) + 192] = uint256(stor6[address(arg1)][msg.sender][1].field_0)
                    idx = (2 * ceil32(return_data.size)) + 192
                    s = 0
                    while (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 160 > idx:
                        mem[idx + 32] = uint256(stor6[address(arg1)][msg.sender][s + 1].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[(2 * ceil32(return_data.size)) + 128] = (2 * ceil32(return_data.size)) + 160
                    if not uint256(stor6[address(arg1)][msg.sender].field_0):
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 196] = this.address
                        require ext_code.size(arg1)
                        staticcall arg1.balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 228] = msg.sender
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 260] = this.address
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 292] = arg2
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192] = 100
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224 len 4] = transferFrom(address rg1, address rg2, uint256 rg3)
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 324] = 32
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 356] = 'SafeERC20: low-level call failed'
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                            revert with 0, 'Address: call to non-contract'
                        if not ext_code.hash(arg1):
                            revert with 0, 'Address: call to non-contract'
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388 len 128] = 0, msg.sender, address(this.address), arg2, 0
                        mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 488] = 0
                        call arg1 with:
                           funct Mask(32, 224, 0, msg.sender, address(this.address), arg2, 0) >> 224
                             gas gas_remaining wei
                            args (Mask(768, -544, 0, msg.sender, address(this.address), arg2, 0) << 544)
                        if not return_data.size:
                            if not ext_call.success:
                                if ext_call.return_data[0]:
                                    revert with memory
                                      from 128
                                       len ext_call.return_data[0]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if not ext_call.return_data[0]:
                                mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 392] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][msg.sender].field_0) > !0:
                                    revert with 0, 17
                                mem[64] = (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + (32 * uint256(stor5[address(arg1)].field_0)) + 420
                                mem[(6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = uint256(stor5[address(arg1)].field_0)
                                s = (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420
                                idx = 0
                                while idx < uint256(stor5[address(arg1)].field_0):
                                    mem[0] = sha3(address(arg1), 5)
                                    _30333 = mem[64]
                                    mem[64] = mem[64] + 192
                                    mem[_30333] = address(stor5[address(arg1)][idx].field_0)
                                    mem[_30333 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                    mem[_30333 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                    mem[_30333 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                    mem[_30333 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                    mem[_30333 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                    mem[s] = _30333
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                            else:
                                require ext_call.return_data[0] >= 32
                                require uint32(msg.sender), mem[132 len 28] == bool(uint32(msg.sender), mem[132 len 28])
                                if not uint32(msg.sender), mem[132 len 28]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 392] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][msg.sender].field_0) > !0:
                                    revert with 0, 17
                                mem[64] = (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + (32 * uint256(stor5[address(arg1)].field_0)) + 420
                                mem[(6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = uint256(stor5[address(arg1)].field_0)
                                s = (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420
                                idx = 0
                                while idx < uint256(stor5[address(arg1)].field_0):
                                    mem[0] = sha3(address(arg1), 5)
                                    _30337 = mem[64]
                                    mem[64] = mem[64] + 192
                                    mem[_30337] = address(stor5[address(arg1)][idx].field_0)
                                    mem[_30337 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                    mem[_30337 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                    mem[_30337 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                    mem[_30337 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                    mem[_30337 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                    mem[s] = _30337
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                            idx = 0
                            while idx < mem[(6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388]:
                                if idx >= mem[(6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388]:
                                    revert with 0, 50
                                if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                    revert with 0, 17
                                if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                    if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                        revert with 0, 50
                                    mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                    uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420] + 128] / 1000000000000 * 10^18
                                else:
                                    uint256(stor6[address(arg1)][msg.sender].field_256)++
                                    mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                    uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420] + 128] / 1000000000000 * 10^18
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 388] = return_data.size
                            mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if not return_data.size:
                                mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 393] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][msg.sender].field_0) > !0:
                                    revert with 0, 17
                                mem[64] = (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 421
                                mem[(6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389] = uint256(stor5[address(arg1)].field_0)
                                s = (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421
                                idx = 0
                                while idx < uint256(stor5[address(arg1)].field_0):
                                    mem[0] = sha3(address(arg1), 5)
                                    _30342 = mem[64]
                                    mem[64] = mem[64] + 192
                                    mem[_30342] = address(stor5[address(arg1)][idx].field_0)
                                    mem[_30342 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                    mem[_30342 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                    mem[_30342 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                    mem[_30342 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                    mem[_30342 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                    mem[s] = _30342
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                            else:
                                require return_data.size >= 32
                                require mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420] == bool(mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420])
                                if not mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 420]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 393] = this.address
                                require ext_code.size(arg1)
                                staticcall arg1.balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[(4 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 17
                                if uint256(stor6[address(arg1)][msg.sender].field_0) > !0:
                                    revert with 0, 17
                                mem[64] = (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 421
                                mem[(6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389] = uint256(stor5[address(arg1)].field_0)
                                s = (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421
                                idx = 0
                                while idx < uint256(stor5[address(arg1)].field_0):
                                    mem[0] = sha3(address(arg1), 5)
                                    _30346 = mem[64]
                                    mem[64] = mem[64] + 192
                                    mem[_30346] = address(stor5[address(arg1)][idx].field_0)
                                    mem[_30346 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                    mem[_30346 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                    mem[_30346 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                    mem[_30346 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                    mem[_30346 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                    mem[s] = _30346
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                            idx = 0
                            while idx < mem[(6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389]:
                                if idx >= mem[(6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 389]:
                                    revert with 0, 50
                                if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                    revert with 0, 17
                                if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                    if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                        revert with 0, 50
                                    mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                    uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421] + 128] / 1000000000000 * 10^18
                                else:
                                    uint256(stor6[address(arg1)][msg.sender].field_256)++
                                    mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                    uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + (6 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + ceil32(return_data.size) + 421] + 128] / 1000000000000 * 10^18
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        emit Deposit(0, msg.sender, arg1);
                    else:
                        mem[0] = arg1
                        mem[32] = 5
                        mem[64] = (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + (32 * uint256(stor5[address(arg1)].field_0)) + 224
                        mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192] = uint256(stor5[address(arg1)].field_0)
                        s = (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224
                        idx = 0
                        while idx < uint256(stor5[address(arg1)].field_0):
                            mem[0] = sha3(address(arg1), 5)
                            _20343 = mem[64]
                            mem[64] = mem[64] + 192
                            mem[_20343] = address(stor5[address(arg1)][idx].field_0)
                            mem[_20343 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                            mem[_20343 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                            mem[_20343 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                            mem[_20343 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                            mem[_20343 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                            mem[s] = _20343
                            s = s + 32
                            idx = idx + 1
                            continue 
                        _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                        idx = 0
                        while idx < _30125:
                            if uint256(stor6[address(arg1)][msg.sender].field_256) <= idx:
                                if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                    revert with 0, 50
                                _30830 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128]
                                _30831 = mem[(2 * ceil32(return_data.size)) + 96]
                                if mem[(2 * ceil32(return_data.size)) + 96] and mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] > -1 / mem[(2 * ceil32(return_data.size)) + 96]:
                                    revert with 0, 17
                                if mem[(2 * ceil32(return_data.size)) + 96] * mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18 < 0:
                                    revert with 0, 17
                                if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                    revert with 0, 50
                                if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] >= mem[(2 * ceil32(return_data.size)) + 96] * mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18:
                                    if mem[(2 * ceil32(return_data.size)) + 96] * mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18:
                                        if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        _32031 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224]]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(_32031))
                                        staticcall address(_32031).balanceOf(address rg1) with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _32346 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _32375 = mem[_32346]
                                        if mem[_32346] > _30831 * _30830 / 1000000000000 * 10^18:
                                            _32494 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = _30831 * _30830 / 1000000000000 * 10^18
                                            _32577 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_32577 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_32577 + 36 len 28]
                                            mem[64] = _32494 + 164
                                            mem[_32494 + 100] = 32
                                            mem[_32494 + 132] = 'SafeERC20: low-level call failed'
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_32031)):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(_32031)):
                                                revert with 0, 'Address: call to non-contract'
                                            _33061 = mem[_32577]
                                            s = 0
                                            while s < _33061:
                                                mem[s + _32494 + 164] = mem[s + _32577 + 32]
                                                _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                s = s + 32
                                                continue 
                                            if ceil32(_33061) > _33061:
                                                mem[_33061 + _32494 + 164] = 0
                                            call address(_32031).mem[_32494 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_32494 + 168 len _33061 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_32494 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_32494 + 168] = 32
                                                    mem[_32494 + 200] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _32494 + 232] = mem[idx + _32494 + 132]
                                                        _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_32494 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _32494 + ceil32(return_data.size) + 165
                                                mem[_32494 + 164] = return_data.size
                                                mem[_32494 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_32494 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_32494 + ceil32(return_data.size) + 169] = 32
                                                    mem[_32494 + ceil32(return_data.size) + 201] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _32494 + ceil32(return_data.size) + 233] = mem[idx + _32494 + 132]
                                                        _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_32494 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_32494 + 196] == bool(mem[_32494 + 196])
                                                    if not mem[_32494 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                revert with 0, 50
                                            if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _30831 * _30830 / 1000000000000 * 10^18:
                                                revert with 0, 17
                                            mem[32] = 5
                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                revert with 0, 50
                                            mem[0] = sha3(address(arg1), 5)
                                            uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - (_30831 * _30830 / 1000000000000 * 10^18)
                                        else:
                                            if not mem[_32346]:
                                                if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                    revert with 0, 50
                                                if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < 0:
                                                    revert with 0, 17
                                                mem[32] = 5
                                                if idx >= uint256(stor5[address(arg1)].field_0):
                                                    revert with 0, 50
                                                mem[0] = sha3(address(arg1), 5)
                                                uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                            else:
                                                _32539 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = _32375
                                                _32632 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_32632 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_32632 + 36 len 28]
                                                mem[64] = _32539 + 164
                                                mem[_32539 + 100] = 32
                                                mem[_32539 + 132] = 'SafeERC20: low-level call failed'
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_32031)):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(address(_32031)):
                                                    revert with 0, 'Address: call to non-contract'
                                                _33140 = mem[_32632]
                                                s = 0
                                                while s < _33140:
                                                    mem[s + _32539 + 164] = mem[s + _32632 + 32]
                                                    _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_33140) > _33140:
                                                    mem[_33140 + _32539 + 164] = 0
                                                call address(_32031).mem[_32539 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_32539 + 168 len _33140 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_32539 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_32539 + 168] = 32
                                                        mem[_32539 + 200] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _32539 + 232] = mem[idx + _32539 + 132]
                                                            _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_32539 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _32539 + ceil32(return_data.size) + 165
                                                    mem[_32539 + 164] = return_data.size
                                                    mem[_32539 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_32539 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_32539 + ceil32(return_data.size) + 169] = 32
                                                        mem[_32539 + ceil32(return_data.size) + 201] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _32539 + ceil32(return_data.size) + 233] = mem[idx + _32539 + 132]
                                                            _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_32539 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_32539 + 196] == bool(mem[_32539 + 196])
                                                        if not mem[_32539 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                    revert with 0, 50
                                                if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _32375:
                                                    revert with 0, 17
                                                mem[32] = 5
                                                if idx >= uint256(stor5[address(arg1)].field_0):
                                                    revert with 0, 50
                                                mem[0] = sha3(address(arg1), 5)
                                                uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _32375
                                else:
                                    if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                        revert with 0, 50
                                    _31957 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                    if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]:
                                        if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        _32087 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224]]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(_32087))
                                        staticcall address(_32087).balanceOf(address rg1) with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _32366 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _32424 = mem[_32366]
                                        if mem[_32366] > _31957:
                                            _32537 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = _31957
                                            _32630 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_32630 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_32630 + 36 len 28]
                                            mem[64] = _32537 + 164
                                            mem[_32537 + 100] = 32
                                            mem[_32537 + 132] = 'SafeERC20: low-level call failed'
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_32087)):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(_32087)):
                                                revert with 0, 'Address: call to non-contract'
                                            _33139 = mem[_32630]
                                            s = 0
                                            while s < _33139:
                                                mem[s + _32537 + 164] = mem[s + _32630 + 32]
                                                _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                s = s + 32
                                                continue 
                                            if ceil32(_33139) > _33139:
                                                mem[_33139 + _32537 + 164] = 0
                                            call address(_32087).mem[_32537 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_32537 + 168 len _33139 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_32537 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_32537 + 168] = 32
                                                    mem[_32537 + 200] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _32537 + 232] = mem[idx + _32537 + 132]
                                                        _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_32537 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _32537 + ceil32(return_data.size) + 165
                                                mem[_32537 + 164] = return_data.size
                                                mem[_32537 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_32537 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_32537 + ceil32(return_data.size) + 169] = 32
                                                    mem[_32537 + ceil32(return_data.size) + 201] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _32537 + ceil32(return_data.size) + 233] = mem[idx + _32537 + 132]
                                                        _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_32537 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_32537 + 196] == bool(mem[_32537 + 196])
                                                    if not mem[_32537 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                revert with 0, 50
                                            if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _31957:
                                                revert with 0, 17
                                            mem[32] = 5
                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                revert with 0, 50
                                            mem[0] = sha3(address(arg1), 5)
                                            uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _31957
                                        else:
                                            if not mem[_32366]:
                                                if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                    revert with 0, 50
                                                if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < 0:
                                                    revert with 0, 17
                                                mem[32] = 5
                                                if idx >= uint256(stor5[address(arg1)].field_0):
                                                    revert with 0, 50
                                                mem[0] = sha3(address(arg1), 5)
                                                uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                            else:
                                                _32574 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = _32424
                                                _32718 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_32718 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_32718 + 36 len 28]
                                                mem[64] = _32574 + 164
                                                mem[_32574 + 100] = 32
                                                mem[_32574 + 132] = 'SafeERC20: low-level call failed'
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_32087)):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(address(_32087)):
                                                    revert with 0, 'Address: call to non-contract'
                                                _33246 = mem[_32718]
                                                s = 0
                                                while s < _33246:
                                                    mem[s + _32574 + 164] = mem[s + _32718 + 32]
                                                    _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_33246) > _33246:
                                                    mem[_33246 + _32574 + 164] = 0
                                                call address(_32087).mem[_32574 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_32574 + 168 len _33246 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_32574 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_32574 + 168] = 32
                                                        mem[_32574 + 200] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _32574 + 232] = mem[idx + _32574 + 132]
                                                            _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_32574 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _32574 + ceil32(return_data.size) + 165
                                                    mem[_32574 + 164] = return_data.size
                                                    mem[_32574 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_32574 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_32574 + ceil32(return_data.size) + 169] = 32
                                                        mem[_32574 + ceil32(return_data.size) + 201] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _32574 + ceil32(return_data.size) + 233] = mem[idx + _32574 + 132]
                                                            _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_32574 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_32574 + 196] == bool(mem[_32574 + 196])
                                                        if not mem[_32574 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                    revert with 0, 50
                                                if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _32424:
                                                    revert with 0, 17
                                                mem[32] = 5
                                                if idx >= uint256(stor5[address(arg1)].field_0):
                                                    revert with 0, 50
                                                mem[0] = sha3(address(arg1), 5)
                                                uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _32424
                            else:
                                if idx >= mem[mem[(2 * ceil32(return_data.size)) + 128]]:
                                    revert with 0, 50
                                _30567 = mem[(32 * idx) + mem[(2 * ceil32(return_data.size)) + 128] + 32]
                                if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                    revert with 0, 50
                                _31122 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128]
                                _31123 = mem[(2 * ceil32(return_data.size)) + 96]
                                if mem[(2 * ceil32(return_data.size)) + 96] and mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] > -1 / mem[(2 * ceil32(return_data.size)) + 96]:
                                    revert with 0, 17
                                if mem[(2 * ceil32(return_data.size)) + 96] * mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18 < mem[(32 * idx) + mem[(2 * ceil32(return_data.size)) + 128] + 32]:
                                    revert with 0, 17
                                if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                    revert with 0, 50
                                if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] >= (mem[(2 * ceil32(return_data.size)) + 96] * mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18) - mem[(32 * idx) + mem[(2 * ceil32(return_data.size)) + 128] + 32]:
                                    if (mem[(2 * ceil32(return_data.size)) + 96] * mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 128] / 1000000000000 * 10^18) - mem[(32 * idx) + mem[(2 * ceil32(return_data.size)) + 128] + 32]:
                                        if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        _32091 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224]]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(_32091))
                                        staticcall address(_32091).balanceOf(address rg1) with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _32367 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _32425 = mem[_32367]
                                        if mem[_32367] > (_31123 * _31122 / 1000000000000 * 10^18) - _30567:
                                            _32540 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = (_31123 * _31122 / 1000000000000 * 10^18) - _30567
                                            _32639 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_32639 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_32639 + 36 len 28]
                                            mem[64] = _32540 + 164
                                            mem[_32540 + 100] = 32
                                            mem[_32540 + 132] = 'SafeERC20: low-level call failed'
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_32091)):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(_32091)):
                                                revert with 0, 'Address: call to non-contract'
                                            _33149 = mem[_32639]
                                            s = 0
                                            while s < _33149:
                                                mem[s + _32540 + 164] = mem[s + _32639 + 32]
                                                _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                s = s + 32
                                                continue 
                                            if ceil32(_33149) > _33149:
                                                mem[_33149 + _32540 + 164] = 0
                                            call address(_32091).mem[_32540 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_32540 + 168 len _33149 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_32540 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_32540 + 168] = 32
                                                    mem[_32540 + 200] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _32540 + 232] = mem[idx + _32540 + 132]
                                                        _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_32540 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _32540 + ceil32(return_data.size) + 165
                                                mem[_32540 + 164] = return_data.size
                                                mem[_32540 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_32540 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_32540 + ceil32(return_data.size) + 169] = 32
                                                    mem[_32540 + ceil32(return_data.size) + 201] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _32540 + ceil32(return_data.size) + 233] = mem[idx + _32540 + 132]
                                                        _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_32540 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_32540 + 196] == bool(mem[_32540 + 196])
                                                    if not mem[_32540 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                revert with 0, 50
                                            if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < (_31123 * _31122 / 1000000000000 * 10^18) - _30567:
                                                revert with 0, 17
                                            mem[32] = 5
                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                revert with 0, 50
                                            mem[0] = sha3(address(arg1), 5)
                                            uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - (_31123 * _31122 / 1000000000000 * 10^18) + _30567
                                        else:
                                            if not mem[_32367]:
                                                if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                    revert with 0, 50
                                                if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < 0:
                                                    revert with 0, 17
                                                mem[32] = 5
                                                if idx >= uint256(stor5[address(arg1)].field_0):
                                                    revert with 0, 50
                                                mem[0] = sha3(address(arg1), 5)
                                                uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                            else:
                                                _32581 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = _32425
                                                _32726 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_32726 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_32726 + 36 len 28]
                                                mem[64] = _32581 + 164
                                                mem[_32581 + 100] = 32
                                                mem[_32581 + 132] = 'SafeERC20: low-level call failed'
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_32091)):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(address(_32091)):
                                                    revert with 0, 'Address: call to non-contract'
                                                _33255 = mem[_32726]
                                                s = 0
                                                while s < _33255:
                                                    mem[s + _32581 + 164] = mem[s + _32726 + 32]
                                                    _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_33255) > _33255:
                                                    mem[_33255 + _32581 + 164] = 0
                                                call address(_32091).mem[_32581 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_32581 + 168 len _33255 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_32581 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_32581 + 168] = 32
                                                        mem[_32581 + 200] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _32581 + 232] = mem[idx + _32581 + 132]
                                                            _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_32581 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _32581 + ceil32(return_data.size) + 165
                                                    mem[_32581 + 164] = return_data.size
                                                    mem[_32581 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_32581 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_32581 + ceil32(return_data.size) + 169] = 32
                                                        mem[_32581 + ceil32(return_data.size) + 201] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _32581 + ceil32(return_data.size) + 233] = mem[idx + _32581 + 132]
                                                            _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_32581 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_32581 + 196] == bool(mem[_32581 + 196])
                                                        if not mem[_32581 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                    revert with 0, 50
                                                if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _32425:
                                                    revert with 0, 17
                                                mem[32] = 5
                                                if idx >= uint256(stor5[address(arg1)].field_0):
                                                    revert with 0, 50
                                                mem[0] = sha3(address(arg1), 5)
                                                uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _32425
                                else:
                                    if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                        revert with 0, 50
                                    _31978 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                    if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]:
                                        if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                            revert with 0, 50
                                        _32194 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224]]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(_32194))
                                        staticcall address(_32194).balanceOf(address rg1) with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _32376 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _32483 = mem[_32376]
                                        if mem[_32376] > _31978:
                                            _32579 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = _31978
                                            _32724 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_32724 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_32724 + 36 len 28]
                                            mem[64] = _32579 + 164
                                            mem[_32579 + 100] = 32
                                            mem[_32579 + 132] = 'SafeERC20: low-level call failed'
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_32194)):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(_32194)):
                                                revert with 0, 'Address: call to non-contract'
                                            _33254 = mem[_32724]
                                            s = 0
                                            while s < _33254:
                                                mem[s + _32579 + 164] = mem[s + _32724 + 32]
                                                _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                s = s + 32
                                                continue 
                                            if ceil32(_33254) > _33254:
                                                mem[_33254 + _32579 + 164] = 0
                                            call address(_32194).mem[_32579 + 164 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_32579 + 168 len _33254 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    if mem[96]:
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    mem[_32579 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_32579 + 168] = 32
                                                    mem[_32579 + 200] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _32579 + 232] = mem[idx + _32579 + 132]
                                                        _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_32579 + 232]
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    require mem[128] == bool(mem[128])
                                                    if not mem[128]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            else:
                                                mem[64] = _32579 + ceil32(return_data.size) + 165
                                                mem[_32579 + 164] = return_data.size
                                                mem[_32579 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    if return_data.size:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_32579 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_32579 + ceil32(return_data.size) + 169] = 32
                                                    mem[_32579 + ceil32(return_data.size) + 201] = 32
                                                    idx = 0
                                                    while idx < 32:
                                                        mem[idx + _32579 + ceil32(return_data.size) + 233] = mem[idx + _32579 + 132]
                                                        _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 32, 32, mem[_32579 + ceil32(return_data.size) + 233]
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    require mem[_32579 + 196] == bool(mem[_32579 + 196])
                                                    if not mem[_32579 + 196]:
                                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                            if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                revert with 0, 50
                                            if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _31978:
                                                revert with 0, 17
                                            mem[32] = 5
                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                revert with 0, 50
                                            mem[0] = sha3(address(arg1), 5)
                                            uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _31978
                                        else:
                                            if not mem[_32376]:
                                                if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                    revert with 0, 50
                                                if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < 0:
                                                    revert with 0, 17
                                                mem[32] = 5
                                                if idx >= uint256(stor5[address(arg1)].field_0):
                                                    revert with 0, 50
                                                mem[0] = sha3(address(arg1), 5)
                                                uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160]
                                            else:
                                                _32636 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = _32483
                                                _32813 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_32813 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_32813 + 36 len 28]
                                                mem[64] = _32636 + 164
                                                mem[_32636 + 100] = 32
                                                mem[_32636 + 132] = 'SafeERC20: low-level call failed'
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_32194)):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(address(_32194)):
                                                    revert with 0, 'Address: call to non-contract'
                                                _33315 = mem[_32813]
                                                s = 0
                                                while s < _33315:
                                                    mem[s + _32636 + 164] = mem[s + _32813 + 32]
                                                    _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_33315) > _33315:
                                                    mem[_33315 + _32636 + 164] = 0
                                                call address(_32194).mem[_32636 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_32636 + 168 len _33315 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_32636 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_32636 + 168] = 32
                                                        mem[_32636 + 200] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _32636 + 232] = mem[idx + _32636 + 132]
                                                            _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_32636 + 232]
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                else:
                                                    mem[64] = _32636 + ceil32(return_data.size) + 165
                                                    mem[_32636 + 164] = return_data.size
                                                    mem[_32636 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_32636 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_32636 + ceil32(return_data.size) + 169] = 32
                                                        mem[_32636 + ceil32(return_data.size) + 201] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _32636 + ceil32(return_data.size) + 233] = mem[idx + _32636 + 132]
                                                            _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_32636 + ceil32(return_data.size) + 233]
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        require mem[_32636 + 196] == bool(mem[_32636 + 196])
                                                        if not mem[_32636 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                if idx >= mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]:
                                                    revert with 0, 50
                                                if mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] < _32483:
                                                    revert with 0, 17
                                                mem[32] = 5
                                                if idx >= uint256(stor5[address(arg1)].field_0):
                                                    revert with 0, 50
                                                mem[0] = sha3(address(arg1), 5)
                                                uint256(stor5[address(arg1)][idx].field_768) = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 224] + 160] - _32483
                            if idx == -1:
                                revert with 0, 17
                            _30125 = mem[(2 * ceil32(return_data.size)) + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 192]
                            idx = idx + 1
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(arg1)
                        staticcall arg1.balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _31321 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _31453 = mem[_31321]
                        _31569 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = this.address
                        mem[mem[64] + 100] = arg2
                        _31735 = mem[64]
                        mem[mem[64]] = 100
                        mem[mem[64] + 32 len 4] = transferFrom(address rg1, address rg2, uint256 rg3)
                        mem[64] = mem[64] + 196
                        mem[_31569 + 132] = 32
                        mem[_31569 + 164] = 'SafeERC20: low-level call failed'
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                            revert with 0, 'Address: call to non-contract'
                        if not ext_code.hash(arg1):
                            revert with 0, 'Address: call to non-contract'
                        _32212 = mem[_31735]
                        mem[_31569 + 196 len ceil32(mem[_31735])] = mem[_31735 + 32 len ceil32(mem[_31735])]
                        if ceil32(_32212) <= _32212:
                            call arg1 with:
                                 gas gas_remaining wei
                                args mem[_31569 + 200 len _32212 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if not mem[96]:
                                    mem[_31569 + 200] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_31569 + 196] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _31453:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _31453):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _31453
                                    mem[64] = _31569 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                    mem[_31569 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                    s = _31569 + ceil32(return_data.size) + 228
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _42007 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_42007] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_42007 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_42007 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_42007 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_42007 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_42007 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _42007
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                else:
                                    require mem[96] >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_31569 + 200] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_31569 + 196] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _31453:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _31453):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _31453
                                    mem[64] = _31569 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                    mem[_31569 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                    s = _31569 + ceil32(return_data.size) + 228
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _42011 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_42011] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_42011 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_42011 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_42011 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_42011 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_42011 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _42011
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                idx = 0
                                while idx < mem[_31569 + ceil32(return_data.size) + 196]:
                                    if idx >= mem[_31569 + ceil32(return_data.size) + 196]:
                                        revert with 0, 50
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _31569 + ceil32(return_data.size) + 228] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                        revert with 0, 17
                                    if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                        if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                            revert with 0, 50
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _31569 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                    else:
                                        uint256(stor6[address(arg1)][msg.sender].field_256)++
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _31569 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[_31569 + 196] = return_data.size
                                mem[_31569 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if not return_data.size:
                                    mem[_31569 + ceil32(return_data.size) + 201] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_31569 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _31453:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _31453):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _31453
                                    mem[64] = _31569 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                    mem[_31569 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                    s = _31569 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _42016 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_42016] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_42016 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_42016 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_42016 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_42016 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_42016 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _42016
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                else:
                                    require return_data.size >= 32
                                    require mem[_31569 + 228] == bool(mem[_31569 + 228])
                                    if not mem[_31569 + 228]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_31569 + ceil32(return_data.size) + 201] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_31569 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _31453:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _31453):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _31453
                                    mem[64] = _31569 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                    mem[_31569 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                    s = _31569 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _42020 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_42020] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_42020 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_42020 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_42020 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_42020 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_42020 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _42020
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                idx = 0
                                while idx < mem[_31569 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                    if idx >= mem[_31569 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                        revert with 0, 50
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _31569 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                        revert with 0, 17
                                    if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                        if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                            revert with 0, 50
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _31569 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                    else:
                                        uint256(stor6[address(arg1)][msg.sender].field_256)++
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _31569 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        else:
                            mem[_32212 + _31569 + 196] = 0
                            call arg1 with:
                                 gas gas_remaining wei
                                args mem[_31569 + 200 len _32212 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if not mem[96]:
                                    mem[_31569 + 200] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_31569 + 196] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _31453:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _31453):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _31453
                                    mem[64] = _31569 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                    mem[_31569 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                    s = _31569 + ceil32(return_data.size) + 228
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _42025 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_42025] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_42025 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_42025 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_42025 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_42025 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_42025 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _42025
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                else:
                                    require mem[96] >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_31569 + 200] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_31569 + 196] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _31453:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _31453):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _31453
                                    mem[64] = _31569 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                    mem[_31569 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                    s = _31569 + ceil32(return_data.size) + 228
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _42029 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_42029] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_42029 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_42029 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_42029 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_42029 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_42029 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _42029
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                idx = 0
                                while idx < mem[_31569 + ceil32(return_data.size) + 196]:
                                    if idx >= mem[_31569 + ceil32(return_data.size) + 196]:
                                        revert with 0, 50
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _31569 + ceil32(return_data.size) + 228] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                        revert with 0, 17
                                    if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                        if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                            revert with 0, 50
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _31569 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                    else:
                                        uint256(stor6[address(arg1)][msg.sender].field_256)++
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _31569 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[_31569 + 196] = return_data.size
                                mem[_31569 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if not return_data.size:
                                    mem[_31569 + ceil32(return_data.size) + 201] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_31569 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _31453:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _31453):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _31453
                                    mem[64] = _31569 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                    mem[_31569 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                    s = _31569 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _42034 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_42034] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_42034 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_42034 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_42034 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_42034 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_42034 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _42034
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                else:
                                    require return_data.size >= 32
                                    require mem[_31569 + 228] == bool(mem[_31569 + 228])
                                    if not mem[_31569 + 228]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_31569 + ceil32(return_data.size) + 201] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_31569 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _31453:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _31453):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _31453
                                    mem[64] = _31569 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                    mem[_31569 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                    s = _31569 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _42038 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_42038] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_42038 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_42038 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_42038 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_42038 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_42038 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _42038
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                idx = 0
                                while idx < mem[_31569 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                    if idx >= mem[_31569 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                        revert with 0, 50
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _31569 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                        revert with 0, 17
                                    if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                        if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                            revert with 0, 50
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _31569 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                    else:
                                        uint256(stor6[address(arg1)][msg.sender].field_256)++
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _31569 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        emit Deposit((ext_call.return_data[0] - _31453), msg.sender, arg1);
            else:
                idx = 0
                while idx < uint256(stor5[address(arg1)].field_0):
                    mem[0] = sha3(address(arg1), 5)
                    if uint256(stor5[address(arg1)].field_256) < stor5[address(arg1)][idx].field_208 % 281474976710656:
                        if stor5[address(arg1)][idx].field_160 % 281474976710656 < block.timestamp:
                            _5580 = mem[64]
                            mem[64] = mem[64] + 192
                            mem[_5580] = address(stor5[address(arg1)][idx].field_0)
                            mem[_5580 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                            mem[_5580 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                            mem[_5580 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                            mem[_5580 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                            mem[_5580 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                            if stor5[address(arg1)][idx].field_208 % 281474976710656 <= uint256(stor5[address(arg1)].field_256):
                                if not ext_call.return_data[0]:
                                    revert with 0, 18
                                if uint256(stor5[address(arg1)][idx].field_512) > !(0 / ext_call.return_data[0]):
                                    revert with 0, 17
                                uint256(stor5[address(arg1)][idx].field_512) += 0 / ext_call.return_data[0]
                            else:
                                if block.timestamp > stor5[address(arg1)][idx].field_208 % 281474976710656:
                                    if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][idx].field_160 % 281474976710656:
                                        if stor5[address(arg1)][idx].field_208 % 281474976710656 < uint256(stor5[address(arg1)].field_256):
                                            revert with 0, 17
                                        if uint256(stor5[address(arg1)][idx].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][idx].field_256):
                                            revert with 0, 17
                                        if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][idx].field_256) and stor5[address(arg1)][idx].field_208 % 281474976710656 - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][idx].field_256):
                                            revert with 0, 17
                                        if not ext_call.return_data[0]:
                                            revert with 0, 18
                                        if uint256(stor5[address(arg1)][idx].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][idx].field_256)) / 168 * 24 * 3600 / ext_call.return_data[0]):
                                            revert with 0, 17
                                        uint256(stor5[address(arg1)][idx].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][idx].field_208 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][idx].field_256)) / 168 * 24 * 3600 / ext_call.return_data[0]
                                    else:
                                        if stor5[address(arg1)][idx].field_0 % 281474976710656 < stor5[address(arg1)][idx].field_160 % 281474976710656:
                                            revert with 0, 17
                                        if uint256(stor5[address(arg1)][idx].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][idx].field_256):
                                            revert with 0, 17
                                        if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][idx].field_256) and stor5[address(arg1)][idx].field_0 % 281474976710656 - stor5[address(arg1)][idx].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][idx].field_256):
                                            revert with 0, 17
                                        if not ext_call.return_data[0]:
                                            revert with 0, 18
                                        if uint256(stor5[address(arg1)][idx].field_512) > !((1000000000000 * 10^18 * stor5[address(arg1)][idx].field_0 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][idx].field_160 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) / 168 * 24 * 3600 / ext_call.return_data[0]):
                                            revert with 0, 17
                                        uint256(stor5[address(arg1)][idx].field_512) += (1000000000000 * 10^18 * stor5[address(arg1)][idx].field_0 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][idx].field_160 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) / 168 * 24 * 3600 / ext_call.return_data[0]
                                else:
                                    if uint256(stor5[address(arg1)].field_256) > stor5[address(arg1)][idx].field_160 % 281474976710656:
                                        if block.timestamp < uint256(stor5[address(arg1)].field_256):
                                            revert with 0, 17
                                        if uint256(stor5[address(arg1)][idx].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][idx].field_256):
                                            revert with 0, 17
                                        if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][idx].field_256) and block.timestamp - uint256(stor5[address(arg1)].field_256) > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][idx].field_256):
                                            revert with 0, 17
                                        if not ext_call.return_data[0]:
                                            revert with 0, 18
                                        if uint256(stor5[address(arg1)][idx].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][idx].field_256)) / 168 * 24 * 3600 / ext_call.return_data[0]):
                                            revert with 0, 17
                                        uint256(stor5[address(arg1)][idx].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) - (1000000000000 * 10^18 * uint256(stor5[address(arg1)].field_256) * uint256(stor5[address(arg1)][idx].field_256)) / 168 * 24 * 3600 / ext_call.return_data[0]
                                    else:
                                        if block.timestamp < stor5[address(arg1)][idx].field_160 % 281474976710656:
                                            revert with 0, 17
                                        if uint256(stor5[address(arg1)][idx].field_256) and 1000000000000 * 10^18 > -1 / uint256(stor5[address(arg1)][idx].field_256):
                                            revert with 0, 17
                                        if 1000000000000 * 10^18 * uint256(stor5[address(arg1)][idx].field_256) and block.timestamp - stor5[address(arg1)][idx].field_160 % 281474976710656 > -1 / 1000000000000 * 10^18 * uint256(stor5[address(arg1)][idx].field_256):
                                            revert with 0, 17
                                        if not ext_call.return_data[0]:
                                            revert with 0, 18
                                        if uint256(stor5[address(arg1)][idx].field_512) > !((1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][idx].field_160 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) / 168 * 24 * 3600 / ext_call.return_data[0]):
                                            revert with 0, 17
                                        uint256(stor5[address(arg1)][idx].field_512) += (1000000000000 * 10^18 * block.timestamp * uint256(stor5[address(arg1)][idx].field_256)) - (1000000000000 * 10^18 * stor5[address(arg1)][idx].field_160 % 281474976710656 * uint256(stor5[address(arg1)][idx].field_256)) / 168 * 24 * 3600 / ext_call.return_data[0]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[0] = msg.sender
                mem[32] = sha3(address(arg1), 6)
                _5559 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5559] = uint256(stor6[address(arg1)][msg.sender].field_0)
                _5560 = mem[64]
                mem[64] = mem[64] + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) + 32
                mem[_5560] = uint256(stor6[address(arg1)][msg.sender].field_256)
                if not uint256(stor6[address(arg1)][msg.sender].field_256):
                    mem[_5559 + 32] = _5560
                    if not uint256(stor6[address(arg1)][msg.sender].field_0):
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(arg1)
                        staticcall arg1.balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5718 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _5762 = mem[_5718]
                        _5817 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = this.address
                        mem[mem[64] + 100] = arg2
                        _5855 = mem[64]
                        mem[mem[64]] = 100
                        mem[mem[64] + 32 len 4] = transferFrom(address rg1, address rg2, uint256 rg3)
                        mem[64] = mem[64] + 196
                        mem[_5817 + 132] = 32
                        mem[_5817 + 164] = 'SafeERC20: low-level call failed'
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                            revert with 0, 'Address: call to non-contract'
                        if not ext_code.hash(arg1):
                            revert with 0, 'Address: call to non-contract'
                        _6046 = mem[_5855]
                        mem[_5817 + 196 len ceil32(mem[_5855])] = mem[_5855 + 32 len ceil32(mem[_5855])]
                        if ceil32(_6046) <= _6046:
                            call arg1 with:
                                 gas gas_remaining wei
                                args mem[_5817 + 200 len _6046 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if not mem[96]:
                                    mem[_5817 + 200] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_5817 + 196] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _5762:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _5762):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _5762
                                    mem[64] = _5817 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                    mem[_5817 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                    s = _5817 + ceil32(return_data.size) + 228
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _20300 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_20300] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_20300 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_20300 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_20300 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_20300 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_20300 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _20300
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                else:
                                    require mem[96] >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_5817 + 200] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_5817 + 196] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _5762:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _5762):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _5762
                                    mem[64] = _5817 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                    mem[_5817 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                    s = _5817 + ceil32(return_data.size) + 228
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _20304 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_20304] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_20304 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_20304 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_20304 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_20304 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_20304 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _20304
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                idx = 0
                                while idx < mem[_5817 + ceil32(return_data.size) + 196]:
                                    if idx >= mem[_5817 + ceil32(return_data.size) + 196]:
                                        revert with 0, 50
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _5817 + ceil32(return_data.size) + 228] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                        revert with 0, 17
                                    if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                        if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                            revert with 0, 50
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _5817 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                    else:
                                        uint256(stor6[address(arg1)][msg.sender].field_256)++
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _5817 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[_5817 + 196] = return_data.size
                                mem[_5817 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if not return_data.size:
                                    mem[_5817 + ceil32(return_data.size) + 201] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_5817 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _5762:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _5762):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _5762
                                    mem[64] = _5817 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                    mem[_5817 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                    s = _5817 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _20309 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_20309] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_20309 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_20309 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_20309 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_20309 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_20309 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _20309
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                else:
                                    require return_data.size >= 32
                                    require mem[_5817 + 228] == bool(mem[_5817 + 228])
                                    if not mem[_5817 + 228]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_5817 + ceil32(return_data.size) + 201] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_5817 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _5762:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _5762):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _5762
                                    mem[64] = _5817 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                    mem[_5817 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                    s = _5817 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _20313 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_20313] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_20313 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_20313 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_20313 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_20313 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_20313 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _20313
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                idx = 0
                                while idx < mem[_5817 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                    if idx >= mem[_5817 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                        revert with 0, 50
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _5817 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                        revert with 0, 17
                                    if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                        if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                            revert with 0, 50
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _5817 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                    else:
                                        uint256(stor6[address(arg1)][msg.sender].field_256)++
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _5817 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        else:
                            mem[_6046 + _5817 + 196] = 0
                            call arg1 with:
                                 gas gas_remaining wei
                                args mem[_5817 + 200 len _6046 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if not mem[96]:
                                    mem[_5817 + 200] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_5817 + 196] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _5762:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _5762):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _5762
                                    mem[64] = _5817 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                    mem[_5817 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                    s = _5817 + ceil32(return_data.size) + 228
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _20318 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_20318] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_20318 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_20318 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_20318 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_20318 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_20318 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _20318
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                else:
                                    require mem[96] >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_5817 + 200] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_5817 + 196] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _5762:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _5762):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _5762
                                    mem[64] = _5817 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                    mem[_5817 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                    s = _5817 + ceil32(return_data.size) + 228
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _20322 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_20322] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_20322 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_20322 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_20322 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_20322 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_20322 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _20322
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                idx = 0
                                while idx < mem[_5817 + ceil32(return_data.size) + 196]:
                                    if idx >= mem[_5817 + ceil32(return_data.size) + 196]:
                                        revert with 0, 50
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _5817 + ceil32(return_data.size) + 228] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                        revert with 0, 17
                                    if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                        if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                            revert with 0, 50
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _5817 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                    else:
                                        uint256(stor6[address(arg1)][msg.sender].field_256)++
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _5817 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[_5817 + 196] = return_data.size
                                mem[_5817 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if not return_data.size:
                                    mem[_5817 + ceil32(return_data.size) + 201] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_5817 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _5762:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _5762):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _5762
                                    mem[64] = _5817 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                    mem[_5817 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                    s = _5817 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _20327 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_20327] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_20327 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_20327 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_20327 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_20327 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_20327 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _20327
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                else:
                                    require return_data.size >= 32
                                    require mem[_5817 + 228] == bool(mem[_5817 + 228])
                                    if not mem[_5817 + 228]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_5817 + ceil32(return_data.size) + 201] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_5817 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _5762:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _5762):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _5762
                                    mem[64] = _5817 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                    mem[_5817 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                    s = _5817 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _20331 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_20331] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_20331 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_20331 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_20331 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_20331 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_20331 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _20331
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                idx = 0
                                while idx < mem[_5817 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                    if idx >= mem[_5817 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                        revert with 0, 50
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _5817 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                        revert with 0, 17
                                    if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                        if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                            revert with 0, 50
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _5817 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                    else:
                                        uint256(stor6[address(arg1)][msg.sender].field_256)++
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _5817 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        emit Deposit((ext_call.return_data[0] - _5762), msg.sender, arg1);
                    else:
                        mem[0] = arg1
                        mem[32] = 5
                        _5598 = mem[64]
                        mem[64] = mem[64] + (32 * uint256(stor5[address(arg1)].field_0)) + 32
                        mem[_5598] = uint256(stor5[address(arg1)].field_0)
                        s = _5598 + 32
                        idx = 0
                        while idx < uint256(stor5[address(arg1)].field_0):
                            mem[0] = sha3(address(arg1), 5)
                            _11038 = mem[64]
                            mem[64] = mem[64] + 192
                            mem[_11038] = address(stor5[address(arg1)][idx].field_0)
                            mem[_11038 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                            mem[_11038 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                            mem[_11038 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                            mem[_11038 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                            mem[_11038 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                            mem[s] = _11038
                            s = s + 32
                            idx = idx + 1
                            continue 
                        _20267 = mem[_5598]
                        idx = 0
                        while idx < _20267:
                            if uint256(stor6[address(arg1)][msg.sender].field_256) <= idx:
                                if idx >= mem[_5598]:
                                    revert with 0, 50
                                _20576 = mem[mem[(32 * idx) + _5598 + 32] + 128]
                                _20577 = mem[_5559]
                                if mem[_5559] and mem[mem[(32 * idx) + _5598 + 32] + 128] > -1 / mem[_5559]:
                                    revert with 0, 17
                                if mem[_5559] * mem[mem[(32 * idx) + _5598 + 32] + 128] / 1000000000000 * 10^18 < 0:
                                    revert with 0, 17
                                if idx >= mem[_5598]:
                                    revert with 0, 50
                                if mem[mem[(32 * idx) + _5598 + 32] + 160] >= mem[_5559] * mem[mem[(32 * idx) + _5598 + 32] + 128] / 1000000000000 * 10^18:
                                    if mem[_5559] * mem[mem[(32 * idx) + _5598 + 32] + 128] / 1000000000000 * 10^18:
                                        if idx >= mem[_5598]:
                                            revert with 0, 50
                                        _22562 = mem[mem[(32 * idx) + _5598 + 32]]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(_22562))
                                        staticcall address(_22562).balanceOf(address rg1) with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _23297 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _23486 = mem[_23297]
                                        if mem[_23297] > _20577 * _20576 / 1000000000000 * 10^18:
                                            _23795 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = _20577 * _20576 / 1000000000000 * 10^18
                                            _23937 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_23937 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_23937 + 36 len 28]
                                            mem[64] = _23795 + 164
                                            mem[_23795 + 100] = 32
                                            mem[_23795 + 132] = 'SafeERC20: low-level call failed'
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_22562)):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(_22562)):
                                                revert with 0, 'Address: call to non-contract'
                                            _24757 = mem[_23937]
                                            s = 0
                                            while s < _24757:
                                                mem[s + _23795 + 164] = mem[s + _23937 + 32]
                                                _20267 = mem[_5598]
                                                s = s + 32
                                                continue 
                                            if ceil32(_24757) <= _24757:
                                                call address(_22562).mem[_23795 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_23795 + 168 len _24757 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_23795 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_23795 + 168] = 32
                                                        mem[_23795 + 200] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _23795 + 232] = mem[idx + _23795 + 132]
                                                            _20267 = mem[_5598]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_23795 + 232]
                                                    if not mem[96]:
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _31913 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < _20577 * _20576 / 1000000000000 * 10^18:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _31913 - (_20577 * _20576 / 1000000000000 * 10^18)
                                                    else:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _32304 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < _20577 * _20576 / 1000000000000 * 10^18:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _32304 - (_20577 * _20576 / 1000000000000 * 10^18)
                                                else:
                                                    mem[64] = _23795 + ceil32(return_data.size) + 165
                                                    mem[_23795 + 164] = return_data.size
                                                    mem[_23795 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_23795 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_23795 + ceil32(return_data.size) + 169] = 32
                                                        mem[_23795 + ceil32(return_data.size) + 201] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _23795 + ceil32(return_data.size) + 233] = mem[idx + _23795 + 132]
                                                            _20267 = mem[_5598]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_23795 + ceil32(return_data.size) + 233]
                                                    if not return_data.size:
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _31915 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < _20577 * _20576 / 1000000000000 * 10^18:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _31915 - (_20577 * _20576 / 1000000000000 * 10^18)
                                                    else:
                                                        require return_data.size >= 32
                                                        require mem[_23795 + 196] == bool(mem[_23795 + 196])
                                                        if not mem[_23795 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _32306 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < _20577 * _20576 / 1000000000000 * 10^18:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _32306 - (_20577 * _20576 / 1000000000000 * 10^18)
                                            else:
                                                mem[_24757 + _23795 + 164] = 0
                                                call address(_22562).mem[_23795 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_23795 + 168 len _24757 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_23795 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_23795 + 168] = 32
                                                        mem[_23795 + 200] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _23795 + 232] = mem[idx + _23795 + 132]
                                                            _20267 = mem[_5598]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_23795 + 232]
                                                    if not mem[96]:
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _31917 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < _20577 * _20576 / 1000000000000 * 10^18:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _31917 - (_20577 * _20576 / 1000000000000 * 10^18)
                                                    else:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _32308 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < _20577 * _20576 / 1000000000000 * 10^18:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _32308 - (_20577 * _20576 / 1000000000000 * 10^18)
                                                else:
                                                    mem[64] = _23795 + ceil32(return_data.size) + 165
                                                    mem[_23795 + 164] = return_data.size
                                                    mem[_23795 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_23795 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_23795 + ceil32(return_data.size) + 169] = 32
                                                        mem[_23795 + ceil32(return_data.size) + 201] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _23795 + ceil32(return_data.size) + 233] = mem[idx + _23795 + 132]
                                                            _20267 = mem[_5598]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_23795 + ceil32(return_data.size) + 233]
                                                    if not return_data.size:
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _31919 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < _20577 * _20576 / 1000000000000 * 10^18:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _31919 - (_20577 * _20576 / 1000000000000 * 10^18)
                                                    else:
                                                        require return_data.size >= 32
                                                        require mem[_23795 + 196] == bool(mem[_23795 + 196])
                                                        if not mem[_23795 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _32310 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < _20577 * _20576 / 1000000000000 * 10^18:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _32310 - (_20577 * _20576 / 1000000000000 * 10^18)
                                        else:
                                            if not mem[_23297]:
                                                if idx >= mem[_5598]:
                                                    revert with 0, 50
                                                _23936 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                if mem[mem[(32 * idx) + _5598 + 32] + 160] < 0:
                                                    revert with 0, 17
                                                mem[32] = 5
                                                if idx >= uint256(stor5[address(arg1)].field_0):
                                                    revert with 0, 50
                                                mem[0] = sha3(address(arg1), 5)
                                                uint256(stor5[address(arg1)][idx].field_768) = _23936
                                            else:
                                                _23841 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = _23486
                                                _23982 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_23982 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_23982 + 36 len 28]
                                                mem[64] = _23841 + 164
                                                mem[_23841 + 100] = 32
                                                mem[_23841 + 132] = 'SafeERC20: low-level call failed'
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_22562)):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(address(_22562)):
                                                    revert with 0, 'Address: call to non-contract'
                                                _24828 = mem[_23982]
                                                s = 0
                                                while s < _24828:
                                                    mem[s + _23841 + 164] = mem[s + _23982 + 32]
                                                    _20267 = mem[_5598]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_24828) <= _24828:
                                                    call address(_22562).mem[_23841 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_23841 + 168 len _24828 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96]:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_23841 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_23841 + 168] = 32
                                                            mem[_23841 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _23841 + 232] = mem[idx + _23841 + 132]
                                                                _20267 = mem[_5598]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_23841 + 232]
                                                        if not mem[96]:
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _31905 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23486:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _31905 - _23486
                                                        else:
                                                            require mem[96] >= 32
                                                            require mem[128] == bool(mem[128])
                                                            if not mem[128]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _32296 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23486:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _32296 - _23486
                                                    else:
                                                        mem[64] = _23841 + ceil32(return_data.size) + 165
                                                        mem[_23841 + 164] = return_data.size
                                                        mem[_23841 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_23841 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_23841 + ceil32(return_data.size) + 169] = 32
                                                            mem[_23841 + ceil32(return_data.size) + 201] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _23841 + ceil32(return_data.size) + 233] = mem[idx + _23841 + 132]
                                                                _20267 = mem[_5598]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_23841 + ceil32(return_data.size) + 233]
                                                        if not return_data.size:
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _31907 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23486:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _31907 - _23486
                                                        else:
                                                            require return_data.size >= 32
                                                            require mem[_23841 + 196] == bool(mem[_23841 + 196])
                                                            if not mem[_23841 + 196]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _32298 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23486:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _32298 - _23486
                                                else:
                                                    mem[_24828 + _23841 + 164] = 0
                                                    call address(_22562).mem[_23841 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_23841 + 168 len _24828 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96]:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_23841 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_23841 + 168] = 32
                                                            mem[_23841 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _23841 + 232] = mem[idx + _23841 + 132]
                                                                _20267 = mem[_5598]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_23841 + 232]
                                                        if not mem[96]:
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _31909 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23486:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _31909 - _23486
                                                        else:
                                                            require mem[96] >= 32
                                                            require mem[128] == bool(mem[128])
                                                            if not mem[128]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _32300 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23486:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _32300 - _23486
                                                    else:
                                                        mem[64] = _23841 + ceil32(return_data.size) + 165
                                                        mem[_23841 + 164] = return_data.size
                                                        mem[_23841 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_23841 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_23841 + ceil32(return_data.size) + 169] = 32
                                                            mem[_23841 + ceil32(return_data.size) + 201] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _23841 + ceil32(return_data.size) + 233] = mem[idx + _23841 + 132]
                                                                _20267 = mem[_5598]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_23841 + ceil32(return_data.size) + 233]
                                                        if not return_data.size:
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _31911 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23486:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _31911 - _23486
                                                        else:
                                                            require return_data.size >= 32
                                                            require mem[_23841 + 196] == bool(mem[_23841 + 196])
                                                            if not mem[_23841 + 196]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _32302 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23486:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _32302 - _23486
                                else:
                                    if idx >= mem[_5598]:
                                        revert with 0, 50
                                    _22342 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                    if mem[mem[(32 * idx) + _5598 + 32] + 160]:
                                        if idx >= mem[_5598]:
                                            revert with 0, 50
                                        _22697 = mem[mem[(32 * idx) + _5598 + 32]]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(_22697))
                                        staticcall address(_22697).balanceOf(address rg1) with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _23452 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _23543 = mem[_23452]
                                        if mem[_23452] > _22342:
                                            _23839 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = _22342
                                            _23980 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_23980 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_23980 + 36 len 28]
                                            mem[64] = _23839 + 164
                                            mem[_23839 + 100] = 32
                                            mem[_23839 + 132] = 'SafeERC20: low-level call failed'
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_22697)):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(_22697)):
                                                revert with 0, 'Address: call to non-contract'
                                            _24827 = mem[_23980]
                                            s = 0
                                            while s < _24827:
                                                mem[s + _23839 + 164] = mem[s + _23980 + 32]
                                                _20267 = mem[_5598]
                                                s = s + 32
                                                continue 
                                            if ceil32(_24827) <= _24827:
                                                call address(_22697).mem[_23839 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_23839 + 168 len _24827 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_23839 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_23839 + 168] = 32
                                                        mem[_23839 + 200] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _23839 + 232] = mem[idx + _23839 + 132]
                                                            _20267 = mem[_5598]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_23839 + 232]
                                                    if not mem[96]:
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _31897 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < _22342:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _31897 - _22342
                                                    else:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _32288 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < _22342:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _32288 - _22342
                                                else:
                                                    mem[64] = _23839 + ceil32(return_data.size) + 165
                                                    mem[_23839 + 164] = return_data.size
                                                    mem[_23839 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_23839 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_23839 + ceil32(return_data.size) + 169] = 32
                                                        mem[_23839 + ceil32(return_data.size) + 201] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _23839 + ceil32(return_data.size) + 233] = mem[idx + _23839 + 132]
                                                            _20267 = mem[_5598]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_23839 + ceil32(return_data.size) + 233]
                                                    if not return_data.size:
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _31899 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < _22342:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _31899 - _22342
                                                    else:
                                                        require return_data.size >= 32
                                                        require mem[_23839 + 196] == bool(mem[_23839 + 196])
                                                        if not mem[_23839 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _32290 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < _22342:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _32290 - _22342
                                            else:
                                                mem[_24827 + _23839 + 164] = 0
                                                call address(_22697).mem[_23839 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_23839 + 168 len _24827 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_23839 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_23839 + 168] = 32
                                                        mem[_23839 + 200] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _23839 + 232] = mem[idx + _23839 + 132]
                                                            _20267 = mem[_5598]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_23839 + 232]
                                                    if not mem[96]:
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _31901 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < _22342:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _31901 - _22342
                                                    else:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _32292 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < _22342:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _32292 - _22342
                                                else:
                                                    mem[64] = _23839 + ceil32(return_data.size) + 165
                                                    mem[_23839 + 164] = return_data.size
                                                    mem[_23839 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_23839 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_23839 + ceil32(return_data.size) + 169] = 32
                                                        mem[_23839 + ceil32(return_data.size) + 201] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _23839 + ceil32(return_data.size) + 233] = mem[idx + _23839 + 132]
                                                            _20267 = mem[_5598]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_23839 + ceil32(return_data.size) + 233]
                                                    if not return_data.size:
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _31903 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < _22342:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _31903 - _22342
                                                    else:
                                                        require return_data.size >= 32
                                                        require mem[_23839 + 196] == bool(mem[_23839 + 196])
                                                        if not mem[_23839 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _32294 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < _22342:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _32294 - _22342
                                        else:
                                            if not mem[_23452]:
                                                if idx >= mem[_5598]:
                                                    revert with 0, 50
                                                _23979 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                if mem[mem[(32 * idx) + _5598 + 32] + 160] < 0:
                                                    revert with 0, 17
                                                mem[32] = 5
                                                if idx >= uint256(stor5[address(arg1)].field_0):
                                                    revert with 0, 50
                                                mem[0] = sha3(address(arg1), 5)
                                                uint256(stor5[address(arg1)][idx].field_768) = _23979
                                            else:
                                                _23934 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = _23543
                                                _24046 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_24046 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_24046 + 36 len 28]
                                                mem[64] = _23934 + 164
                                                mem[_23934 + 100] = 32
                                                mem[_23934 + 132] = 'SafeERC20: low-level call failed'
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_22697)):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(address(_22697)):
                                                    revert with 0, 'Address: call to non-contract'
                                                _24994 = mem[_24046]
                                                s = 0
                                                while s < _24994:
                                                    mem[s + _23934 + 164] = mem[s + _24046 + 32]
                                                    _20267 = mem[_5598]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_24994) <= _24994:
                                                    call address(_22697).mem[_23934 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_23934 + 168 len _24994 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96]:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_23934 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_23934 + 168] = 32
                                                            mem[_23934 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _23934 + 232] = mem[idx + _23934 + 132]
                                                                _20267 = mem[_5598]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_23934 + 232]
                                                        if not mem[96]:
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _31889 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23543:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _31889 - _23543
                                                        else:
                                                            require mem[96] >= 32
                                                            require mem[128] == bool(mem[128])
                                                            if not mem[128]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _32280 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23543:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _32280 - _23543
                                                    else:
                                                        mem[64] = _23934 + ceil32(return_data.size) + 165
                                                        mem[_23934 + 164] = return_data.size
                                                        mem[_23934 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_23934 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_23934 + ceil32(return_data.size) + 169] = 32
                                                            mem[_23934 + ceil32(return_data.size) + 201] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _23934 + ceil32(return_data.size) + 233] = mem[idx + _23934 + 132]
                                                                _20267 = mem[_5598]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_23934 + ceil32(return_data.size) + 233]
                                                        if not return_data.size:
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _31891 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23543:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _31891 - _23543
                                                        else:
                                                            require return_data.size >= 32
                                                            require mem[_23934 + 196] == bool(mem[_23934 + 196])
                                                            if not mem[_23934 + 196]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _32282 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23543:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _32282 - _23543
                                                else:
                                                    mem[_24994 + _23934 + 164] = 0
                                                    call address(_22697).mem[_23934 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_23934 + 168 len _24994 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96]:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_23934 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_23934 + 168] = 32
                                                            mem[_23934 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _23934 + 232] = mem[idx + _23934 + 132]
                                                                _20267 = mem[_5598]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_23934 + 232]
                                                        if not mem[96]:
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _31893 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23543:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _31893 - _23543
                                                        else:
                                                            require mem[96] >= 32
                                                            require mem[128] == bool(mem[128])
                                                            if not mem[128]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _32284 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23543:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _32284 - _23543
                                                    else:
                                                        mem[64] = _23934 + ceil32(return_data.size) + 165
                                                        mem[_23934 + 164] = return_data.size
                                                        mem[_23934 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_23934 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_23934 + ceil32(return_data.size) + 169] = 32
                                                            mem[_23934 + ceil32(return_data.size) + 201] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _23934 + ceil32(return_data.size) + 233] = mem[idx + _23934 + 132]
                                                                _20267 = mem[_5598]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_23934 + ceil32(return_data.size) + 233]
                                                        if not return_data.size:
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _31895 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23543:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _31895 - _23543
                                                        else:
                                                            require return_data.size >= 32
                                                            require mem[_23934 + 196] == bool(mem[_23934 + 196])
                                                            if not mem[_23934 + 196]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _32286 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23543:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _32286 - _23543
                            else:
                                if idx >= mem[mem[_5559 + 32]]:
                                    revert with 0, 50
                                _20480 = mem[(32 * idx) + mem[_5559 + 32] + 32]
                                if idx >= mem[_5598]:
                                    revert with 0, 50
                                _20699 = mem[mem[(32 * idx) + _5598 + 32] + 128]
                                _20700 = mem[_5559]
                                if mem[_5559] and mem[mem[(32 * idx) + _5598 + 32] + 128] > -1 / mem[_5559]:
                                    revert with 0, 17
                                if mem[_5559] * mem[mem[(32 * idx) + _5598 + 32] + 128] / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_5559 + 32] + 32]:
                                    revert with 0, 17
                                if idx >= mem[_5598]:
                                    revert with 0, 50
                                if mem[mem[(32 * idx) + _5598 + 32] + 160] >= (mem[_5559] * mem[mem[(32 * idx) + _5598 + 32] + 128] / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_5559 + 32] + 32]:
                                    if (mem[_5559] * mem[mem[(32 * idx) + _5598 + 32] + 128] / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_5559 + 32] + 32]:
                                        if idx >= mem[_5598]:
                                            revert with 0, 50
                                        _22701 = mem[mem[(32 * idx) + _5598 + 32]]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(_22701))
                                        staticcall address(_22701).balanceOf(address rg1) with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _23453 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _23544 = mem[_23453]
                                        if mem[_23453] > (_20700 * _20699 / 1000000000000 * 10^18) - _20480:
                                            _23842 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = (_20700 * _20699 / 1000000000000 * 10^18) - _20480
                                            _23989 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_23989 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_23989 + 36 len 28]
                                            mem[64] = _23842 + 164
                                            mem[_23842 + 100] = 32
                                            mem[_23842 + 132] = 'SafeERC20: low-level call failed'
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_22701)):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(_22701)):
                                                revert with 0, 'Address: call to non-contract'
                                            _24837 = mem[_23989]
                                            s = 0
                                            while s < _24837:
                                                mem[s + _23842 + 164] = mem[s + _23989 + 32]
                                                _20267 = mem[_5598]
                                                s = s + 32
                                                continue 
                                            if ceil32(_24837) <= _24837:
                                                call address(_22701).mem[_23842 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_23842 + 168 len _24837 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_23842 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_23842 + 168] = 32
                                                        mem[_23842 + 200] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _23842 + 232] = mem[idx + _23842 + 132]
                                                            _20267 = mem[_5598]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_23842 + 232]
                                                    if not mem[96]:
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _31945 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < (_20700 * _20699 / 1000000000000 * 10^18) - _20480:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _31945 - (_20700 * _20699 / 1000000000000 * 10^18) + _20480
                                                    else:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _32336 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < (_20700 * _20699 / 1000000000000 * 10^18) - _20480:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _32336 - (_20700 * _20699 / 1000000000000 * 10^18) + _20480
                                                else:
                                                    mem[64] = _23842 + ceil32(return_data.size) + 165
                                                    mem[_23842 + 164] = return_data.size
                                                    mem[_23842 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_23842 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_23842 + ceil32(return_data.size) + 169] = 32
                                                        mem[_23842 + ceil32(return_data.size) + 201] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _23842 + ceil32(return_data.size) + 233] = mem[idx + _23842 + 132]
                                                            _20267 = mem[_5598]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_23842 + ceil32(return_data.size) + 233]
                                                    if not return_data.size:
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _31947 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < (_20700 * _20699 / 1000000000000 * 10^18) - _20480:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _31947 - (_20700 * _20699 / 1000000000000 * 10^18) + _20480
                                                    else:
                                                        require return_data.size >= 32
                                                        require mem[_23842 + 196] == bool(mem[_23842 + 196])
                                                        if not mem[_23842 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _32338 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < (_20700 * _20699 / 1000000000000 * 10^18) - _20480:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _32338 - (_20700 * _20699 / 1000000000000 * 10^18) + _20480
                                            else:
                                                mem[_24837 + _23842 + 164] = 0
                                                call address(_22701).mem[_23842 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_23842 + 168 len _24837 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_23842 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_23842 + 168] = 32
                                                        mem[_23842 + 200] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _23842 + 232] = mem[idx + _23842 + 132]
                                                            _20267 = mem[_5598]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_23842 + 232]
                                                    if not mem[96]:
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _31949 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < (_20700 * _20699 / 1000000000000 * 10^18) - _20480:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _31949 - (_20700 * _20699 / 1000000000000 * 10^18) + _20480
                                                    else:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _32340 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < (_20700 * _20699 / 1000000000000 * 10^18) - _20480:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _32340 - (_20700 * _20699 / 1000000000000 * 10^18) + _20480
                                                else:
                                                    mem[64] = _23842 + ceil32(return_data.size) + 165
                                                    mem[_23842 + 164] = return_data.size
                                                    mem[_23842 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_23842 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_23842 + ceil32(return_data.size) + 169] = 32
                                                        mem[_23842 + ceil32(return_data.size) + 201] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _23842 + ceil32(return_data.size) + 233] = mem[idx + _23842 + 132]
                                                            _20267 = mem[_5598]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_23842 + ceil32(return_data.size) + 233]
                                                    if not return_data.size:
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _31951 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < (_20700 * _20699 / 1000000000000 * 10^18) - _20480:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _31951 - (_20700 * _20699 / 1000000000000 * 10^18) + _20480
                                                    else:
                                                        require return_data.size >= 32
                                                        require mem[_23842 + 196] == bool(mem[_23842 + 196])
                                                        if not mem[_23842 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _32342 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < (_20700 * _20699 / 1000000000000 * 10^18) - _20480:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _32342 - (_20700 * _20699 / 1000000000000 * 10^18) + _20480
                                        else:
                                            if not mem[_23453]:
                                                if idx >= mem[_5598]:
                                                    revert with 0, 50
                                                _23988 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                if mem[mem[(32 * idx) + _5598 + 32] + 160] < 0:
                                                    revert with 0, 17
                                                mem[32] = 5
                                                if idx >= uint256(stor5[address(arg1)].field_0):
                                                    revert with 0, 50
                                                mem[0] = sha3(address(arg1), 5)
                                                uint256(stor5[address(arg1)][idx].field_768) = _23988
                                            else:
                                                _23941 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = _23544
                                                _24054 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_24054 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_24054 + 36 len 28]
                                                mem[64] = _23941 + 164
                                                mem[_23941 + 100] = 32
                                                mem[_23941 + 132] = 'SafeERC20: low-level call failed'
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_22701)):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(address(_22701)):
                                                    revert with 0, 'Address: call to non-contract'
                                                _25003 = mem[_24054]
                                                s = 0
                                                while s < _25003:
                                                    mem[s + _23941 + 164] = mem[s + _24054 + 32]
                                                    _20267 = mem[_5598]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_25003) <= _25003:
                                                    call address(_22701).mem[_23941 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_23941 + 168 len _25003 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96]:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_23941 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_23941 + 168] = 32
                                                            mem[_23941 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _23941 + 232] = mem[idx + _23941 + 132]
                                                                _20267 = mem[_5598]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_23941 + 232]
                                                        if not mem[96]:
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _31937 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23544:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _31937 - _23544
                                                        else:
                                                            require mem[96] >= 32
                                                            require mem[128] == bool(mem[128])
                                                            if not mem[128]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _32328 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23544:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _32328 - _23544
                                                    else:
                                                        mem[64] = _23941 + ceil32(return_data.size) + 165
                                                        mem[_23941 + 164] = return_data.size
                                                        mem[_23941 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_23941 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_23941 + ceil32(return_data.size) + 169] = 32
                                                            mem[_23941 + ceil32(return_data.size) + 201] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _23941 + ceil32(return_data.size) + 233] = mem[idx + _23941 + 132]
                                                                _20267 = mem[_5598]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_23941 + ceil32(return_data.size) + 233]
                                                        if not return_data.size:
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _31939 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23544:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _31939 - _23544
                                                        else:
                                                            require return_data.size >= 32
                                                            require mem[_23941 + 196] == bool(mem[_23941 + 196])
                                                            if not mem[_23941 + 196]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _32330 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23544:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _32330 - _23544
                                                else:
                                                    mem[_25003 + _23941 + 164] = 0
                                                    call address(_22701).mem[_23941 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_23941 + 168 len _25003 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96]:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_23941 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_23941 + 168] = 32
                                                            mem[_23941 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _23941 + 232] = mem[idx + _23941 + 132]
                                                                _20267 = mem[_5598]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_23941 + 232]
                                                        if not mem[96]:
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _31941 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23544:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _31941 - _23544
                                                        else:
                                                            require mem[96] >= 32
                                                            require mem[128] == bool(mem[128])
                                                            if not mem[128]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _32332 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23544:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _32332 - _23544
                                                    else:
                                                        mem[64] = _23941 + ceil32(return_data.size) + 165
                                                        mem[_23941 + 164] = return_data.size
                                                        mem[_23941 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_23941 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_23941 + ceil32(return_data.size) + 169] = 32
                                                            mem[_23941 + ceil32(return_data.size) + 201] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _23941 + ceil32(return_data.size) + 233] = mem[idx + _23941 + 132]
                                                                _20267 = mem[_5598]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_23941 + ceil32(return_data.size) + 233]
                                                        if not return_data.size:
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _31943 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23544:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _31943 - _23544
                                                        else:
                                                            require return_data.size >= 32
                                                            require mem[_23941 + 196] == bool(mem[_23941 + 196])
                                                            if not mem[_23941 + 196]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _32334 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23544:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _32334 - _23544
                                else:
                                    if idx >= mem[_5598]:
                                        revert with 0, 50
                                    _22494 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                    if mem[mem[(32 * idx) + _5598 + 32] + 160]:
                                        if idx >= mem[_5598]:
                                            revert with 0, 50
                                        _22881 = mem[mem[(32 * idx) + _5598 + 32]]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(_22881))
                                        staticcall address(_22881).balanceOf(address rg1) with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _23487 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _23686 = mem[_23487]
                                        if mem[_23487] > _22494:
                                            _23939 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = _22494
                                            _24052 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_24052 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_24052 + 36 len 28]
                                            mem[64] = _23939 + 164
                                            mem[_23939 + 100] = 32
                                            mem[_23939 + 132] = 'SafeERC20: low-level call failed'
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_22881)):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(_22881)):
                                                revert with 0, 'Address: call to non-contract'
                                            _25002 = mem[_24052]
                                            s = 0
                                            while s < _25002:
                                                mem[s + _23939 + 164] = mem[s + _24052 + 32]
                                                _20267 = mem[_5598]
                                                s = s + 32
                                                continue 
                                            if ceil32(_25002) <= _25002:
                                                call address(_22881).mem[_23939 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_23939 + 168 len _25002 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_23939 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_23939 + 168] = 32
                                                        mem[_23939 + 200] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _23939 + 232] = mem[idx + _23939 + 132]
                                                            _20267 = mem[_5598]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_23939 + 232]
                                                    if not mem[96]:
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _31929 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < _22494:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _31929 - _22494
                                                    else:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _32320 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < _22494:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _32320 - _22494
                                                else:
                                                    mem[64] = _23939 + ceil32(return_data.size) + 165
                                                    mem[_23939 + 164] = return_data.size
                                                    mem[_23939 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_23939 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_23939 + ceil32(return_data.size) + 169] = 32
                                                        mem[_23939 + ceil32(return_data.size) + 201] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _23939 + ceil32(return_data.size) + 233] = mem[idx + _23939 + 132]
                                                            _20267 = mem[_5598]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_23939 + ceil32(return_data.size) + 233]
                                                    if not return_data.size:
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _31931 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < _22494:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _31931 - _22494
                                                    else:
                                                        require return_data.size >= 32
                                                        require mem[_23939 + 196] == bool(mem[_23939 + 196])
                                                        if not mem[_23939 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _32322 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < _22494:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _32322 - _22494
                                            else:
                                                mem[_25002 + _23939 + 164] = 0
                                                call address(_22881).mem[_23939 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_23939 + 168 len _25002 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_23939 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_23939 + 168] = 32
                                                        mem[_23939 + 200] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _23939 + 232] = mem[idx + _23939 + 132]
                                                            _20267 = mem[_5598]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_23939 + 232]
                                                    if not mem[96]:
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _31933 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < _22494:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _31933 - _22494
                                                    else:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _32324 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < _22494:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _32324 - _22494
                                                else:
                                                    mem[64] = _23939 + ceil32(return_data.size) + 165
                                                    mem[_23939 + 164] = return_data.size
                                                    mem[_23939 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_23939 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_23939 + ceil32(return_data.size) + 169] = 32
                                                        mem[_23939 + ceil32(return_data.size) + 201] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _23939 + ceil32(return_data.size) + 233] = mem[idx + _23939 + 132]
                                                            _20267 = mem[_5598]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_23939 + ceil32(return_data.size) + 233]
                                                    if not return_data.size:
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _31935 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < _22494:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _31935 - _22494
                                                    else:
                                                        require return_data.size >= 32
                                                        require mem[_23939 + 196] == bool(mem[_23939 + 196])
                                                        if not mem[_23939 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_5598]:
                                                            revert with 0, 50
                                                        _32326 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _5598 + 32] + 160] < _22494:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _32326 - _22494
                                        else:
                                            if not mem[_23487]:
                                                if idx >= mem[_5598]:
                                                    revert with 0, 50
                                                _24051 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                if mem[mem[(32 * idx) + _5598 + 32] + 160] < 0:
                                                    revert with 0, 17
                                                mem[32] = 5
                                                if idx >= uint256(stor5[address(arg1)].field_0):
                                                    revert with 0, 50
                                                mem[0] = sha3(address(arg1), 5)
                                                uint256(stor5[address(arg1)][idx].field_768) = _24051
                                            else:
                                                _23986 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = _23686
                                                _24201 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_24201 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_24201 + 36 len 28]
                                                mem[64] = _23986 + 164
                                                mem[_23986 + 100] = 32
                                                mem[_23986 + 132] = 'SafeERC20: low-level call failed'
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_22881)):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(address(_22881)):
                                                    revert with 0, 'Address: call to non-contract'
                                                _25166 = mem[_24201]
                                                s = 0
                                                while s < _25166:
                                                    mem[s + _23986 + 164] = mem[s + _24201 + 32]
                                                    _20267 = mem[_5598]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_25166) <= _25166:
                                                    call address(_22881).mem[_23986 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_23986 + 168 len _25166 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96]:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_23986 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_23986 + 168] = 32
                                                            mem[_23986 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _23986 + 232] = mem[idx + _23986 + 132]
                                                                _20267 = mem[_5598]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_23986 + 232]
                                                        if not mem[96]:
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _31921 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23686:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _31921 - _23686
                                                        else:
                                                            require mem[96] >= 32
                                                            require mem[128] == bool(mem[128])
                                                            if not mem[128]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _32312 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23686:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _32312 - _23686
                                                    else:
                                                        mem[64] = _23986 + ceil32(return_data.size) + 165
                                                        mem[_23986 + 164] = return_data.size
                                                        mem[_23986 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_23986 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_23986 + ceil32(return_data.size) + 169] = 32
                                                            mem[_23986 + ceil32(return_data.size) + 201] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _23986 + ceil32(return_data.size) + 233] = mem[idx + _23986 + 132]
                                                                _20267 = mem[_5598]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_23986 + ceil32(return_data.size) + 233]
                                                        if not return_data.size:
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _31923 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23686:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _31923 - _23686
                                                        else:
                                                            require return_data.size >= 32
                                                            require mem[_23986 + 196] == bool(mem[_23986 + 196])
                                                            if not mem[_23986 + 196]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _32314 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23686:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _32314 - _23686
                                                else:
                                                    mem[_25166 + _23986 + 164] = 0
                                                    call address(_22881).mem[_23986 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_23986 + 168 len _25166 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96]:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_23986 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_23986 + 168] = 32
                                                            mem[_23986 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _23986 + 232] = mem[idx + _23986 + 132]
                                                                _20267 = mem[_5598]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_23986 + 232]
                                                        if not mem[96]:
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _31925 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23686:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _31925 - _23686
                                                        else:
                                                            require mem[96] >= 32
                                                            require mem[128] == bool(mem[128])
                                                            if not mem[128]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _32316 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23686:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _32316 - _23686
                                                    else:
                                                        mem[64] = _23986 + ceil32(return_data.size) + 165
                                                        mem[_23986 + 164] = return_data.size
                                                        mem[_23986 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_23986 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_23986 + ceil32(return_data.size) + 169] = 32
                                                            mem[_23986 + ceil32(return_data.size) + 201] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _23986 + ceil32(return_data.size) + 233] = mem[idx + _23986 + 132]
                                                                _20267 = mem[_5598]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_23986 + ceil32(return_data.size) + 233]
                                                        if not return_data.size:
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _31927 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23686:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _31927 - _23686
                                                        else:
                                                            require return_data.size >= 32
                                                            require mem[_23986 + 196] == bool(mem[_23986 + 196])
                                                            if not mem[_23986 + 196]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_5598]:
                                                                revert with 0, 50
                                                            _32318 = mem[mem[(32 * idx) + _5598 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _5598 + 32] + 160] < _23686:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _32318 - _23686
                            if idx == -1:
                                revert with 0, 17
                            _20267 = mem[_5598]
                            idx = idx + 1
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(arg1)
                        staticcall arg1.balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _20845 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _21229 = mem[_20845]
                        _21522 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = this.address
                        mem[mem[64] + 100] = arg2
                        _21792 = mem[64]
                        mem[mem[64]] = 100
                        mem[mem[64] + 32 len 4] = transferFrom(address rg1, address rg2, uint256 rg3)
                        mem[64] = mem[64] + 196
                        mem[_21522 + 132] = 32
                        mem[_21522 + 164] = 'SafeERC20: low-level call failed'
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                            revert with 0, 'Address: call to non-contract'
                        if not ext_code.hash(arg1):
                            revert with 0, 'Address: call to non-contract'
                        _23060 = mem[_21792]
                        mem[_21522 + 196 len ceil32(mem[_21792])] = mem[_21792 + 32 len ceil32(mem[_21792])]
                        if ceil32(_23060) <= _23060:
                            call arg1 with:
                                 gas gas_remaining wei
                                args mem[_21522 + 200 len _23060 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if not mem[96]:
                                    mem[_21522 + 200] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_21522 + 196] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _21229:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _21229):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _21229
                                    mem[64] = _21522 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                    mem[_21522 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                    s = _21522 + ceil32(return_data.size) + 228
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _37058 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_37058] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_37058 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_37058 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_37058 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_37058 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_37058 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _37058
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                else:
                                    require mem[96] >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_21522 + 200] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_21522 + 196] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _21229:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _21229):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _21229
                                    mem[64] = _21522 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                    mem[_21522 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                    s = _21522 + ceil32(return_data.size) + 228
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _37062 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_37062] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_37062 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_37062 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_37062 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_37062 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_37062 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _37062
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                idx = 0
                                while idx < mem[_21522 + ceil32(return_data.size) + 196]:
                                    if idx >= mem[_21522 + ceil32(return_data.size) + 196]:
                                        revert with 0, 50
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _21522 + ceil32(return_data.size) + 228] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                        revert with 0, 17
                                    if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                        if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                            revert with 0, 50
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _21522 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                    else:
                                        uint256(stor6[address(arg1)][msg.sender].field_256)++
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _21522 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[_21522 + 196] = return_data.size
                                mem[_21522 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if not return_data.size:
                                    mem[_21522 + ceil32(return_data.size) + 201] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_21522 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _21229:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _21229):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _21229
                                    mem[64] = _21522 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                    mem[_21522 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                    s = _21522 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _37067 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_37067] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_37067 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_37067 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_37067 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_37067 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_37067 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _37067
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                else:
                                    require return_data.size >= 32
                                    require mem[_21522 + 228] == bool(mem[_21522 + 228])
                                    if not mem[_21522 + 228]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_21522 + ceil32(return_data.size) + 201] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_21522 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _21229:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _21229):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _21229
                                    mem[64] = _21522 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                    mem[_21522 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                    s = _21522 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _37071 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_37071] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_37071 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_37071 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_37071 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_37071 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_37071 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _37071
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                idx = 0
                                while idx < mem[_21522 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                    if idx >= mem[_21522 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                        revert with 0, 50
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _21522 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                        revert with 0, 17
                                    if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                        if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                            revert with 0, 50
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _21522 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                    else:
                                        uint256(stor6[address(arg1)][msg.sender].field_256)++
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _21522 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        else:
                            mem[_23060 + _21522 + 196] = 0
                            call arg1 with:
                                 gas gas_remaining wei
                                args mem[_21522 + 200 len _23060 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if not mem[96]:
                                    mem[_21522 + 200] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_21522 + 196] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _21229:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _21229):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _21229
                                    mem[64] = _21522 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                    mem[_21522 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                    s = _21522 + ceil32(return_data.size) + 228
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _37076 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_37076] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_37076 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_37076 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_37076 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_37076 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_37076 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _37076
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                else:
                                    require mem[96] >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_21522 + 200] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_21522 + 196] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _21229:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _21229):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _21229
                                    mem[64] = _21522 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                    mem[_21522 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                    s = _21522 + ceil32(return_data.size) + 228
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _37080 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_37080] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_37080 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_37080 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_37080 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_37080 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_37080 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _37080
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                idx = 0
                                while idx < mem[_21522 + ceil32(return_data.size) + 196]:
                                    if idx >= mem[_21522 + ceil32(return_data.size) + 196]:
                                        revert with 0, 50
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _21522 + ceil32(return_data.size) + 228] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                        revert with 0, 17
                                    if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                        if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                            revert with 0, 50
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _21522 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                    else:
                                        uint256(stor6[address(arg1)][msg.sender].field_256)++
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _21522 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[_21522 + 196] = return_data.size
                                mem[_21522 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if not return_data.size:
                                    mem[_21522 + ceil32(return_data.size) + 201] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_21522 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _21229:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _21229):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _21229
                                    mem[64] = _21522 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                    mem[_21522 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                    s = _21522 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _37085 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_37085] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_37085 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_37085 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_37085 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_37085 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_37085 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _37085
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                else:
                                    require return_data.size >= 32
                                    require mem[_21522 + 228] == bool(mem[_21522 + 228])
                                    if not mem[_21522 + 228]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_21522 + ceil32(return_data.size) + 201] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_21522 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _21229:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _21229):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _21229
                                    mem[64] = _21522 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                    mem[_21522 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                    s = _21522 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _37089 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_37089] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_37089 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_37089 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_37089 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_37089 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_37089 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _37089
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                idx = 0
                                while idx < mem[_21522 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                    if idx >= mem[_21522 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                        revert with 0, 50
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _21522 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                        revert with 0, 17
                                    if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                        if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                            revert with 0, 50
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _21522 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                    else:
                                        uint256(stor6[address(arg1)][msg.sender].field_256)++
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _21522 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        emit Deposit((ext_call.return_data[0] - _21229), msg.sender, arg1);
                else:
                    mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                    mem[_5560 + 32] = uint256(stor6[address(arg1)][msg.sender][1].field_0)
                    idx = _5560 + 32
                    s = 0
                    while _5560 + (32 * uint256(stor6[address(arg1)][msg.sender].field_256)) > idx:
                        mem[idx + 32] = uint256(stor6[address(arg1)][msg.sender][s + 1].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[_5559 + 32] = _5560
                    if not mem[_5559]:
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(arg1)
                        staticcall arg1.balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _21019 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _21384 = mem[_21019]
                        _21662 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = this.address
                        mem[mem[64] + 100] = arg2
                        _21898 = mem[64]
                        mem[mem[64]] = 100
                        mem[mem[64] + 32 len 4] = transferFrom(address rg1, address rg2, uint256 rg3)
                        mem[64] = mem[64] + 196
                        mem[_21662 + 132] = 32
                        mem[_21662 + 164] = 'SafeERC20: low-level call failed'
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                            revert with 0, 'Address: call to non-contract'
                        if not ext_code.hash(arg1):
                            revert with 0, 'Address: call to non-contract'
                        _23135 = mem[_21898]
                        mem[_21662 + 196 len ceil32(mem[_21898])] = mem[_21898 + 32 len ceil32(mem[_21898])]
                        if ceil32(_23135) <= _23135:
                            call arg1 with:
                                 gas gas_remaining wei
                                args mem[_21662 + 200 len _23135 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if not mem[96]:
                                    mem[_21662 + 200] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_21662 + 196] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _21384:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _21384):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _21384
                                    mem[64] = _21662 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                    mem[_21662 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                    s = _21662 + ceil32(return_data.size) + 228
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _37126 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_37126] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_37126 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_37126 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_37126 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_37126 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_37126 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _37126
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                else:
                                    require mem[96] >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_21662 + 200] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_21662 + 196] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _21384:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _21384):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _21384
                                    mem[64] = _21662 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                    mem[_21662 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                    s = _21662 + ceil32(return_data.size) + 228
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _37130 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_37130] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_37130 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_37130 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_37130 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_37130 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_37130 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _37130
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                idx = 0
                                while idx < mem[_21662 + ceil32(return_data.size) + 196]:
                                    if idx >= mem[_21662 + ceil32(return_data.size) + 196]:
                                        revert with 0, 50
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _21662 + ceil32(return_data.size) + 228] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                        revert with 0, 17
                                    if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                        if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                            revert with 0, 50
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _21662 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                    else:
                                        uint256(stor6[address(arg1)][msg.sender].field_256)++
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _21662 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[_21662 + 196] = return_data.size
                                mem[_21662 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if not return_data.size:
                                    mem[_21662 + ceil32(return_data.size) + 201] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_21662 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _21384:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _21384):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _21384
                                    mem[64] = _21662 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                    mem[_21662 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                    s = _21662 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _37135 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_37135] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_37135 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_37135 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_37135 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_37135 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_37135 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _37135
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                else:
                                    require return_data.size >= 32
                                    require mem[_21662 + 228] == bool(mem[_21662 + 228])
                                    if not mem[_21662 + 228]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_21662 + ceil32(return_data.size) + 201] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_21662 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _21384:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _21384):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _21384
                                    mem[64] = _21662 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                    mem[_21662 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                    s = _21662 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _37139 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_37139] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_37139 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_37139 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_37139 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_37139 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_37139 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _37139
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                idx = 0
                                while idx < mem[_21662 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                    if idx >= mem[_21662 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                        revert with 0, 50
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _21662 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                        revert with 0, 17
                                    if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                        if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                            revert with 0, 50
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _21662 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                    else:
                                        uint256(stor6[address(arg1)][msg.sender].field_256)++
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _21662 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        else:
                            mem[_23135 + _21662 + 196] = 0
                            call arg1 with:
                                 gas gas_remaining wei
                                args mem[_21662 + 200 len _23135 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if not mem[96]:
                                    mem[_21662 + 200] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_21662 + 196] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _21384:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _21384):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _21384
                                    mem[64] = _21662 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                    mem[_21662 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                    s = _21662 + ceil32(return_data.size) + 228
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _37144 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_37144] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_37144 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_37144 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_37144 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_37144 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_37144 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _37144
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                else:
                                    require mem[96] >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_21662 + 200] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_21662 + 196] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _21384:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _21384):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _21384
                                    mem[64] = _21662 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                    mem[_21662 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                    s = _21662 + ceil32(return_data.size) + 228
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _37148 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_37148] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_37148 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_37148 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_37148 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_37148 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_37148 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _37148
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                idx = 0
                                while idx < mem[_21662 + ceil32(return_data.size) + 196]:
                                    if idx >= mem[_21662 + ceil32(return_data.size) + 196]:
                                        revert with 0, 50
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _21662 + ceil32(return_data.size) + 228] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                        revert with 0, 17
                                    if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                        if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                            revert with 0, 50
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _21662 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                    else:
                                        uint256(stor6[address(arg1)][msg.sender].field_256)++
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _21662 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[_21662 + 196] = return_data.size
                                mem[_21662 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if not return_data.size:
                                    mem[_21662 + ceil32(return_data.size) + 201] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_21662 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _21384:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _21384):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _21384
                                    mem[64] = _21662 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                    mem[_21662 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                    s = _21662 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _37153 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_37153] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_37153 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_37153 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_37153 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_37153 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_37153 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _37153
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                else:
                                    require return_data.size >= 32
                                    require mem[_21662 + 228] == bool(mem[_21662 + 228])
                                    if not mem[_21662 + 228]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_21662 + ceil32(return_data.size) + 201] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_21662 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _21384:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _21384):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _21384
                                    mem[64] = _21662 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                    mem[_21662 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                    s = _21662 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _37157 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_37157] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_37157 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_37157 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_37157 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_37157 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_37157 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _37157
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                idx = 0
                                while idx < mem[_21662 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                    if idx >= mem[_21662 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                        revert with 0, 50
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _21662 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                        revert with 0, 17
                                    if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                        if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                            revert with 0, 50
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _21662 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                    else:
                                        uint256(stor6[address(arg1)][msg.sender].field_256)++
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _21662 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        emit Deposit((ext_call.return_data[0] - _21384), msg.sender, arg1);
                    else:
                        mem[0] = arg1
                        mem[32] = 5
                        _20395 = mem[64]
                        mem[64] = mem[64] + (32 * uint256(stor5[address(arg1)].field_0)) + 32
                        mem[_20395] = uint256(stor5[address(arg1)].field_0)
                        s = _20395 + 32
                        idx = 0
                        while idx < uint256(stor5[address(arg1)].field_0):
                            mem[0] = sha3(address(arg1), 5)
                            _30241 = mem[64]
                            mem[64] = mem[64] + 192
                            mem[_30241] = address(stor5[address(arg1)][idx].field_0)
                            mem[_30241 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                            mem[_30241 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                            mem[_30241 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                            mem[_30241 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                            mem[_30241 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                            mem[s] = _30241
                            s = s + 32
                            idx = idx + 1
                            continue 
                        _37012 = mem[_20395]
                        idx = 0
                        while idx < _37012:
                            if uint256(stor6[address(arg1)][msg.sender].field_256) <= idx:
                                if idx >= mem[_20395]:
                                    revert with 0, 50
                                _37664 = mem[mem[(32 * idx) + _20395 + 32] + 128]
                                _37665 = mem[_5559]
                                if mem[_5559] and mem[mem[(32 * idx) + _20395 + 32] + 128] > -1 / mem[_5559]:
                                    revert with 0, 17
                                if mem[_5559] * mem[mem[(32 * idx) + _20395 + 32] + 128] / 1000000000000 * 10^18 < 0:
                                    revert with 0, 17
                                if idx >= mem[_20395]:
                                    revert with 0, 50
                                if mem[mem[(32 * idx) + _20395 + 32] + 160] >= mem[_5559] * mem[mem[(32 * idx) + _20395 + 32] + 128] / 1000000000000 * 10^18:
                                    if mem[_5559] * mem[mem[(32 * idx) + _20395 + 32] + 128] / 1000000000000 * 10^18:
                                        if idx >= mem[_20395]:
                                            revert with 0, 50
                                        _39494 = mem[mem[(32 * idx) + _20395 + 32]]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(_39494))
                                        staticcall address(_39494).balanceOf(address rg1) with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _40084 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _40229 = mem[_40084]
                                        if mem[_40084] > _37665 * _37664 / 1000000000000 * 10^18:
                                            _40466 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = _37665 * _37664 / 1000000000000 * 10^18
                                            _40531 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_40531 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_40531 + 36 len 28]
                                            mem[64] = _40466 + 164
                                            mem[_40466 + 100] = 32
                                            mem[_40466 + 132] = 'SafeERC20: low-level call failed'
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_39494)):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(_39494)):
                                                revert with 0, 'Address: call to non-contract'
                                            _40815 = mem[_40531]
                                            s = 0
                                            while s < _40815:
                                                mem[s + _40466 + 164] = mem[s + _40531 + 32]
                                                _37012 = mem[_20395]
                                                s = s + 32
                                                continue 
                                            if ceil32(_40815) <= _40815:
                                                call address(_39494).mem[_40466 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40466 + 168 len _40815 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_40466 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_40466 + 168] = 32
                                                        mem[_40466 + 200] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _40466 + 232] = mem[idx + _40466 + 132]
                                                            _37012 = mem[_20395]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_40466 + 232]
                                                    if not mem[96]:
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43240 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < _37665 * _37664 / 1000000000000 * 10^18:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43240 - (_37665 * _37664 / 1000000000000 * 10^18)
                                                    else:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43488 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < _37665 * _37664 / 1000000000000 * 10^18:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43488 - (_37665 * _37664 / 1000000000000 * 10^18)
                                                else:
                                                    mem[64] = _40466 + ceil32(return_data.size) + 165
                                                    mem[_40466 + 164] = return_data.size
                                                    mem[_40466 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_40466 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_40466 + ceil32(return_data.size) + 169] = 32
                                                        mem[_40466 + ceil32(return_data.size) + 201] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _40466 + ceil32(return_data.size) + 233] = mem[idx + _40466 + 132]
                                                            _37012 = mem[_20395]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_40466 + ceil32(return_data.size) + 233]
                                                    if not return_data.size:
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43242 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < _37665 * _37664 / 1000000000000 * 10^18:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43242 - (_37665 * _37664 / 1000000000000 * 10^18)
                                                    else:
                                                        require return_data.size >= 32
                                                        require mem[_40466 + 196] == bool(mem[_40466 + 196])
                                                        if not mem[_40466 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43490 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < _37665 * _37664 / 1000000000000 * 10^18:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43490 - (_37665 * _37664 / 1000000000000 * 10^18)
                                            else:
                                                mem[_40815 + _40466 + 164] = 0
                                                call address(_39494).mem[_40466 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40466 + 168 len _40815 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_40466 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_40466 + 168] = 32
                                                        mem[_40466 + 200] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _40466 + 232] = mem[idx + _40466 + 132]
                                                            _37012 = mem[_20395]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_40466 + 232]
                                                    if not mem[96]:
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43244 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < _37665 * _37664 / 1000000000000 * 10^18:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43244 - (_37665 * _37664 / 1000000000000 * 10^18)
                                                    else:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43492 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < _37665 * _37664 / 1000000000000 * 10^18:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43492 - (_37665 * _37664 / 1000000000000 * 10^18)
                                                else:
                                                    mem[64] = _40466 + ceil32(return_data.size) + 165
                                                    mem[_40466 + 164] = return_data.size
                                                    mem[_40466 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_40466 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_40466 + ceil32(return_data.size) + 169] = 32
                                                        mem[_40466 + ceil32(return_data.size) + 201] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _40466 + ceil32(return_data.size) + 233] = mem[idx + _40466 + 132]
                                                            _37012 = mem[_20395]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_40466 + ceil32(return_data.size) + 233]
                                                    if not return_data.size:
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43246 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < _37665 * _37664 / 1000000000000 * 10^18:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43246 - (_37665 * _37664 / 1000000000000 * 10^18)
                                                    else:
                                                        require return_data.size >= 32
                                                        require mem[_40466 + 196] == bool(mem[_40466 + 196])
                                                        if not mem[_40466 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43494 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < _37665 * _37664 / 1000000000000 * 10^18:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43494 - (_37665 * _37664 / 1000000000000 * 10^18)
                                        else:
                                            if not mem[_40084]:
                                                if idx >= mem[_20395]:
                                                    revert with 0, 50
                                                _40530 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                if mem[mem[(32 * idx) + _20395 + 32] + 160] < 0:
                                                    revert with 0, 17
                                                mem[32] = 5
                                                if idx >= uint256(stor5[address(arg1)].field_0):
                                                    revert with 0, 50
                                                mem[0] = sha3(address(arg1), 5)
                                                uint256(stor5[address(arg1)][idx].field_768) = _40530
                                            else:
                                                _40485 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = _40229
                                                _40556 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_40556 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_40556 + 36 len 28]
                                                mem[64] = _40485 + 164
                                                mem[_40485 + 100] = 32
                                                mem[_40485 + 132] = 'SafeERC20: low-level call failed'
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_39494)):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(address(_39494)):
                                                    revert with 0, 'Address: call to non-contract'
                                                _40839 = mem[_40556]
                                                s = 0
                                                while s < _40839:
                                                    mem[s + _40485 + 164] = mem[s + _40556 + 32]
                                                    _37012 = mem[_20395]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_40839) <= _40839:
                                                    call address(_39494).mem[_40485 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_40485 + 168 len _40839 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96]:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_40485 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_40485 + 168] = 32
                                                            mem[_40485 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _40485 + 232] = mem[idx + _40485 + 132]
                                                                _37012 = mem[_20395]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_40485 + 232]
                                                        if not mem[96]:
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43232 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40229:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43232 - _40229
                                                        else:
                                                            require mem[96] >= 32
                                                            require mem[128] == bool(mem[128])
                                                            if not mem[128]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43480 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40229:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43480 - _40229
                                                    else:
                                                        mem[64] = _40485 + ceil32(return_data.size) + 165
                                                        mem[_40485 + 164] = return_data.size
                                                        mem[_40485 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_40485 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_40485 + ceil32(return_data.size) + 169] = 32
                                                            mem[_40485 + ceil32(return_data.size) + 201] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _40485 + ceil32(return_data.size) + 233] = mem[idx + _40485 + 132]
                                                                _37012 = mem[_20395]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_40485 + ceil32(return_data.size) + 233]
                                                        if not return_data.size:
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43234 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40229:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43234 - _40229
                                                        else:
                                                            require return_data.size >= 32
                                                            require mem[_40485 + 196] == bool(mem[_40485 + 196])
                                                            if not mem[_40485 + 196]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43482 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40229:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43482 - _40229
                                                else:
                                                    mem[_40839 + _40485 + 164] = 0
                                                    call address(_39494).mem[_40485 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_40485 + 168 len _40839 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96]:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_40485 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_40485 + 168] = 32
                                                            mem[_40485 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _40485 + 232] = mem[idx + _40485 + 132]
                                                                _37012 = mem[_20395]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_40485 + 232]
                                                        if not mem[96]:
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43236 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40229:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43236 - _40229
                                                        else:
                                                            require mem[96] >= 32
                                                            require mem[128] == bool(mem[128])
                                                            if not mem[128]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43484 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40229:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43484 - _40229
                                                    else:
                                                        mem[64] = _40485 + ceil32(return_data.size) + 165
                                                        mem[_40485 + 164] = return_data.size
                                                        mem[_40485 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_40485 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_40485 + ceil32(return_data.size) + 169] = 32
                                                            mem[_40485 + ceil32(return_data.size) + 201] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _40485 + ceil32(return_data.size) + 233] = mem[idx + _40485 + 132]
                                                                _37012 = mem[_20395]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_40485 + ceil32(return_data.size) + 233]
                                                        if not return_data.size:
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43238 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40229:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43238 - _40229
                                                        else:
                                                            require return_data.size >= 32
                                                            require mem[_40485 + 196] == bool(mem[_40485 + 196])
                                                            if not mem[_40485 + 196]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43486 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40229:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43486 - _40229
                                else:
                                    if idx >= mem[_20395]:
                                        revert with 0, 50
                                    _39311 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                    if mem[mem[(32 * idx) + _20395 + 32] + 160]:
                                        if idx >= mem[_20395]:
                                            revert with 0, 50
                                        _39605 = mem[mem[(32 * idx) + _20395 + 32]]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(_39605))
                                        staticcall address(_39605).balanceOf(address rg1) with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _40219 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _40267 = mem[_40219]
                                        if mem[_40219] > _39311:
                                            _40483 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = _39311
                                            _40554 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_40554 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_40554 + 36 len 28]
                                            mem[64] = _40483 + 164
                                            mem[_40483 + 100] = 32
                                            mem[_40483 + 132] = 'SafeERC20: low-level call failed'
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_39605)):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(_39605)):
                                                revert with 0, 'Address: call to non-contract'
                                            _40838 = mem[_40554]
                                            s = 0
                                            while s < _40838:
                                                mem[s + _40483 + 164] = mem[s + _40554 + 32]
                                                _37012 = mem[_20395]
                                                s = s + 32
                                                continue 
                                            if ceil32(_40838) <= _40838:
                                                call address(_39605).mem[_40483 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40483 + 168 len _40838 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_40483 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_40483 + 168] = 32
                                                        mem[_40483 + 200] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _40483 + 232] = mem[idx + _40483 + 132]
                                                            _37012 = mem[_20395]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_40483 + 232]
                                                    if not mem[96]:
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43224 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < _39311:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43224 - _39311
                                                    else:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43472 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < _39311:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43472 - _39311
                                                else:
                                                    mem[64] = _40483 + ceil32(return_data.size) + 165
                                                    mem[_40483 + 164] = return_data.size
                                                    mem[_40483 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_40483 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_40483 + ceil32(return_data.size) + 169] = 32
                                                        mem[_40483 + ceil32(return_data.size) + 201] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _40483 + ceil32(return_data.size) + 233] = mem[idx + _40483 + 132]
                                                            _37012 = mem[_20395]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_40483 + ceil32(return_data.size) + 233]
                                                    if not return_data.size:
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43226 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < _39311:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43226 - _39311
                                                    else:
                                                        require return_data.size >= 32
                                                        require mem[_40483 + 196] == bool(mem[_40483 + 196])
                                                        if not mem[_40483 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43474 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < _39311:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43474 - _39311
                                            else:
                                                mem[_40838 + _40483 + 164] = 0
                                                call address(_39605).mem[_40483 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40483 + 168 len _40838 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_40483 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_40483 + 168] = 32
                                                        mem[_40483 + 200] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _40483 + 232] = mem[idx + _40483 + 132]
                                                            _37012 = mem[_20395]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_40483 + 232]
                                                    if not mem[96]:
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43228 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < _39311:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43228 - _39311
                                                    else:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43476 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < _39311:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43476 - _39311
                                                else:
                                                    mem[64] = _40483 + ceil32(return_data.size) + 165
                                                    mem[_40483 + 164] = return_data.size
                                                    mem[_40483 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_40483 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_40483 + ceil32(return_data.size) + 169] = 32
                                                        mem[_40483 + ceil32(return_data.size) + 201] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _40483 + ceil32(return_data.size) + 233] = mem[idx + _40483 + 132]
                                                            _37012 = mem[_20395]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_40483 + ceil32(return_data.size) + 233]
                                                    if not return_data.size:
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43230 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < _39311:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43230 - _39311
                                                    else:
                                                        require return_data.size >= 32
                                                        require mem[_40483 + 196] == bool(mem[_40483 + 196])
                                                        if not mem[_40483 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43478 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < _39311:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43478 - _39311
                                        else:
                                            if not mem[_40219]:
                                                if idx >= mem[_20395]:
                                                    revert with 0, 50
                                                _40553 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                if mem[mem[(32 * idx) + _20395 + 32] + 160] < 0:
                                                    revert with 0, 17
                                                mem[32] = 5
                                                if idx >= uint256(stor5[address(arg1)].field_0):
                                                    revert with 0, 50
                                                mem[0] = sha3(address(arg1), 5)
                                                uint256(stor5[address(arg1)][idx].field_768) = _40553
                                            else:
                                                _40528 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = _40267
                                                _40581 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_40581 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_40581 + 36 len 28]
                                                mem[64] = _40528 + 164
                                                mem[_40528 + 100] = 32
                                                mem[_40528 + 132] = 'SafeERC20: low-level call failed'
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_39605)):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(address(_39605)):
                                                    revert with 0, 'Address: call to non-contract'
                                                _40905 = mem[_40581]
                                                s = 0
                                                while s < _40905:
                                                    mem[s + _40528 + 164] = mem[s + _40581 + 32]
                                                    _37012 = mem[_20395]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_40905) <= _40905:
                                                    call address(_39605).mem[_40528 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_40528 + 168 len _40905 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96]:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_40528 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_40528 + 168] = 32
                                                            mem[_40528 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _40528 + 232] = mem[idx + _40528 + 132]
                                                                _37012 = mem[_20395]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_40528 + 232]
                                                        if not mem[96]:
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43216 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40267:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43216 - _40267
                                                        else:
                                                            require mem[96] >= 32
                                                            require mem[128] == bool(mem[128])
                                                            if not mem[128]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43464 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40267:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43464 - _40267
                                                    else:
                                                        mem[64] = _40528 + ceil32(return_data.size) + 165
                                                        mem[_40528 + 164] = return_data.size
                                                        mem[_40528 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_40528 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_40528 + ceil32(return_data.size) + 169] = 32
                                                            mem[_40528 + ceil32(return_data.size) + 201] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _40528 + ceil32(return_data.size) + 233] = mem[idx + _40528 + 132]
                                                                _37012 = mem[_20395]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_40528 + ceil32(return_data.size) + 233]
                                                        if not return_data.size:
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43218 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40267:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43218 - _40267
                                                        else:
                                                            require return_data.size >= 32
                                                            require mem[_40528 + 196] == bool(mem[_40528 + 196])
                                                            if not mem[_40528 + 196]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43466 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40267:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43466 - _40267
                                                else:
                                                    mem[_40905 + _40528 + 164] = 0
                                                    call address(_39605).mem[_40528 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_40528 + 168 len _40905 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96]:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_40528 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_40528 + 168] = 32
                                                            mem[_40528 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _40528 + 232] = mem[idx + _40528 + 132]
                                                                _37012 = mem[_20395]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_40528 + 232]
                                                        if not mem[96]:
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43220 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40267:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43220 - _40267
                                                        else:
                                                            require mem[96] >= 32
                                                            require mem[128] == bool(mem[128])
                                                            if not mem[128]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43468 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40267:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43468 - _40267
                                                    else:
                                                        mem[64] = _40528 + ceil32(return_data.size) + 165
                                                        mem[_40528 + 164] = return_data.size
                                                        mem[_40528 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_40528 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_40528 + ceil32(return_data.size) + 169] = 32
                                                            mem[_40528 + ceil32(return_data.size) + 201] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _40528 + ceil32(return_data.size) + 233] = mem[idx + _40528 + 132]
                                                                _37012 = mem[_20395]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_40528 + ceil32(return_data.size) + 233]
                                                        if not return_data.size:
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43222 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40267:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43222 - _40267
                                                        else:
                                                            require return_data.size >= 32
                                                            require mem[_40528 + 196] == bool(mem[_40528 + 196])
                                                            if not mem[_40528 + 196]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43470 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40267:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43470 - _40267
                            else:
                                if idx >= mem[mem[_5559 + 32]]:
                                    revert with 0, 50
                                _37404 = mem[(32 * idx) + mem[_5559 + 32] + 32]
                                if idx >= mem[_20395]:
                                    revert with 0, 50
                                _37819 = mem[mem[(32 * idx) + _20395 + 32] + 128]
                                _37820 = mem[_5559]
                                if mem[_5559] and mem[mem[(32 * idx) + _20395 + 32] + 128] > -1 / mem[_5559]:
                                    revert with 0, 17
                                if mem[_5559] * mem[mem[(32 * idx) + _20395 + 32] + 128] / 1000000000000 * 10^18 < mem[(32 * idx) + mem[_5559 + 32] + 32]:
                                    revert with 0, 17
                                if idx >= mem[_20395]:
                                    revert with 0, 50
                                if mem[mem[(32 * idx) + _20395 + 32] + 160] >= (mem[_5559] * mem[mem[(32 * idx) + _20395 + 32] + 128] / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_5559 + 32] + 32]:
                                    if (mem[_5559] * mem[mem[(32 * idx) + _20395 + 32] + 128] / 1000000000000 * 10^18) - mem[(32 * idx) + mem[_5559 + 32] + 32]:
                                        if idx >= mem[_20395]:
                                            revert with 0, 50
                                        _39609 = mem[mem[(32 * idx) + _20395 + 32]]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(_39609))
                                        staticcall address(_39609).balanceOf(address rg1) with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _40220 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _40268 = mem[_40220]
                                        if mem[_40220] > (_37820 * _37819 / 1000000000000 * 10^18) - _37404:
                                            _40486 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = (_37820 * _37819 / 1000000000000 * 10^18) - _37404
                                            _40563 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_40563 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_40563 + 36 len 28]
                                            mem[64] = _40486 + 164
                                            mem[_40486 + 100] = 32
                                            mem[_40486 + 132] = 'SafeERC20: low-level call failed'
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_39609)):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(_39609)):
                                                revert with 0, 'Address: call to non-contract'
                                            _40848 = mem[_40563]
                                            s = 0
                                            while s < _40848:
                                                mem[s + _40486 + 164] = mem[s + _40563 + 32]
                                                _37012 = mem[_20395]
                                                s = s + 32
                                                continue 
                                            if ceil32(_40848) <= _40848:
                                                call address(_39609).mem[_40486 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40486 + 168 len _40848 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_40486 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_40486 + 168] = 32
                                                        mem[_40486 + 200] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _40486 + 232] = mem[idx + _40486 + 132]
                                                            _37012 = mem[_20395]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_40486 + 232]
                                                    if not mem[96]:
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43272 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < (_37820 * _37819 / 1000000000000 * 10^18) - _37404:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43272 - (_37820 * _37819 / 1000000000000 * 10^18) + _37404
                                                    else:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43520 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < (_37820 * _37819 / 1000000000000 * 10^18) - _37404:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43520 - (_37820 * _37819 / 1000000000000 * 10^18) + _37404
                                                else:
                                                    mem[64] = _40486 + ceil32(return_data.size) + 165
                                                    mem[_40486 + 164] = return_data.size
                                                    mem[_40486 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_40486 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_40486 + ceil32(return_data.size) + 169] = 32
                                                        mem[_40486 + ceil32(return_data.size) + 201] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _40486 + ceil32(return_data.size) + 233] = mem[idx + _40486 + 132]
                                                            _37012 = mem[_20395]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_40486 + ceil32(return_data.size) + 233]
                                                    if not return_data.size:
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43274 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < (_37820 * _37819 / 1000000000000 * 10^18) - _37404:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43274 - (_37820 * _37819 / 1000000000000 * 10^18) + _37404
                                                    else:
                                                        require return_data.size >= 32
                                                        require mem[_40486 + 196] == bool(mem[_40486 + 196])
                                                        if not mem[_40486 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43522 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < (_37820 * _37819 / 1000000000000 * 10^18) - _37404:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43522 - (_37820 * _37819 / 1000000000000 * 10^18) + _37404
                                            else:
                                                mem[_40848 + _40486 + 164] = 0
                                                call address(_39609).mem[_40486 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40486 + 168 len _40848 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_40486 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_40486 + 168] = 32
                                                        mem[_40486 + 200] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _40486 + 232] = mem[idx + _40486 + 132]
                                                            _37012 = mem[_20395]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_40486 + 232]
                                                    if not mem[96]:
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43276 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < (_37820 * _37819 / 1000000000000 * 10^18) - _37404:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43276 - (_37820 * _37819 / 1000000000000 * 10^18) + _37404
                                                    else:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43524 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < (_37820 * _37819 / 1000000000000 * 10^18) - _37404:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43524 - (_37820 * _37819 / 1000000000000 * 10^18) + _37404
                                                else:
                                                    mem[64] = _40486 + ceil32(return_data.size) + 165
                                                    mem[_40486 + 164] = return_data.size
                                                    mem[_40486 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_40486 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_40486 + ceil32(return_data.size) + 169] = 32
                                                        mem[_40486 + ceil32(return_data.size) + 201] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _40486 + ceil32(return_data.size) + 233] = mem[idx + _40486 + 132]
                                                            _37012 = mem[_20395]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_40486 + ceil32(return_data.size) + 233]
                                                    if not return_data.size:
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43278 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < (_37820 * _37819 / 1000000000000 * 10^18) - _37404:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43278 - (_37820 * _37819 / 1000000000000 * 10^18) + _37404
                                                    else:
                                                        require return_data.size >= 32
                                                        require mem[_40486 + 196] == bool(mem[_40486 + 196])
                                                        if not mem[_40486 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43526 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < (_37820 * _37819 / 1000000000000 * 10^18) - _37404:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43526 - (_37820 * _37819 / 1000000000000 * 10^18) + _37404
                                        else:
                                            if not mem[_40220]:
                                                if idx >= mem[_20395]:
                                                    revert with 0, 50
                                                _40562 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                if mem[mem[(32 * idx) + _20395 + 32] + 160] < 0:
                                                    revert with 0, 17
                                                mem[32] = 5
                                                if idx >= uint256(stor5[address(arg1)].field_0):
                                                    revert with 0, 50
                                                mem[0] = sha3(address(arg1), 5)
                                                uint256(stor5[address(arg1)][idx].field_768) = _40562
                                            else:
                                                _40535 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = _40268
                                                _40589 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_40589 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_40589 + 36 len 28]
                                                mem[64] = _40535 + 164
                                                mem[_40535 + 100] = 32
                                                mem[_40535 + 132] = 'SafeERC20: low-level call failed'
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_39609)):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(address(_39609)):
                                                    revert with 0, 'Address: call to non-contract'
                                                _40914 = mem[_40589]
                                                s = 0
                                                while s < _40914:
                                                    mem[s + _40535 + 164] = mem[s + _40589 + 32]
                                                    _37012 = mem[_20395]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_40914) <= _40914:
                                                    call address(_39609).mem[_40535 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_40535 + 168 len _40914 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96]:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_40535 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_40535 + 168] = 32
                                                            mem[_40535 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _40535 + 232] = mem[idx + _40535 + 132]
                                                                _37012 = mem[_20395]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_40535 + 232]
                                                        if not mem[96]:
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43264 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40268:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43264 - _40268
                                                        else:
                                                            require mem[96] >= 32
                                                            require mem[128] == bool(mem[128])
                                                            if not mem[128]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43512 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40268:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43512 - _40268
                                                    else:
                                                        mem[64] = _40535 + ceil32(return_data.size) + 165
                                                        mem[_40535 + 164] = return_data.size
                                                        mem[_40535 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_40535 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_40535 + ceil32(return_data.size) + 169] = 32
                                                            mem[_40535 + ceil32(return_data.size) + 201] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _40535 + ceil32(return_data.size) + 233] = mem[idx + _40535 + 132]
                                                                _37012 = mem[_20395]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_40535 + ceil32(return_data.size) + 233]
                                                        if not return_data.size:
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43266 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40268:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43266 - _40268
                                                        else:
                                                            require return_data.size >= 32
                                                            require mem[_40535 + 196] == bool(mem[_40535 + 196])
                                                            if not mem[_40535 + 196]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43514 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40268:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43514 - _40268
                                                else:
                                                    mem[_40914 + _40535 + 164] = 0
                                                    call address(_39609).mem[_40535 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_40535 + 168 len _40914 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96]:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_40535 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_40535 + 168] = 32
                                                            mem[_40535 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _40535 + 232] = mem[idx + _40535 + 132]
                                                                _37012 = mem[_20395]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_40535 + 232]
                                                        if not mem[96]:
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43268 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40268:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43268 - _40268
                                                        else:
                                                            require mem[96] >= 32
                                                            require mem[128] == bool(mem[128])
                                                            if not mem[128]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43516 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40268:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43516 - _40268
                                                    else:
                                                        mem[64] = _40535 + ceil32(return_data.size) + 165
                                                        mem[_40535 + 164] = return_data.size
                                                        mem[_40535 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_40535 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_40535 + ceil32(return_data.size) + 169] = 32
                                                            mem[_40535 + ceil32(return_data.size) + 201] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _40535 + ceil32(return_data.size) + 233] = mem[idx + _40535 + 132]
                                                                _37012 = mem[_20395]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_40535 + ceil32(return_data.size) + 233]
                                                        if not return_data.size:
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43270 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40268:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43270 - _40268
                                                        else:
                                                            require return_data.size >= 32
                                                            require mem[_40535 + 196] == bool(mem[_40535 + 196])
                                                            if not mem[_40535 + 196]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43518 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40268:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43518 - _40268
                                else:
                                    if idx >= mem[_20395]:
                                        revert with 0, 50
                                    _39447 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                    if mem[mem[(32 * idx) + _20395 + 32] + 160]:
                                        if idx >= mem[_20395]:
                                            revert with 0, 50
                                        _39759 = mem[mem[(32 * idx) + _20395 + 32]]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(_39759))
                                        staticcall address(_39759).balanceOf(address rg1) with:
                                                gas gas_remaining wei
                                               args address(this.address)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _40230 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _40383 = mem[_40230]
                                        if mem[_40230] > _39447:
                                            _40533 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = _39447
                                            _40587 = mem[64]
                                            mem[mem[64]] = 68
                                            mem[64] = mem[64] + 100
                                            mem[_40587 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_40587 + 36 len 28]
                                            mem[64] = _40533 + 164
                                            mem[_40533 + 100] = 32
                                            mem[_40533 + 132] = 'SafeERC20: low-level call failed'
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_39759)):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(address(_39759)):
                                                revert with 0, 'Address: call to non-contract'
                                            _40913 = mem[_40587]
                                            s = 0
                                            while s < _40913:
                                                mem[s + _40533 + 164] = mem[s + _40587 + 32]
                                                _37012 = mem[_20395]
                                                s = s + 32
                                                continue 
                                            if ceil32(_40913) <= _40913:
                                                call address(_39759).mem[_40533 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40533 + 168 len _40913 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_40533 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_40533 + 168] = 32
                                                        mem[_40533 + 200] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _40533 + 232] = mem[idx + _40533 + 132]
                                                            _37012 = mem[_20395]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_40533 + 232]
                                                    if not mem[96]:
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43256 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < _39447:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43256 - _39447
                                                    else:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43504 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < _39447:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43504 - _39447
                                                else:
                                                    mem[64] = _40533 + ceil32(return_data.size) + 165
                                                    mem[_40533 + 164] = return_data.size
                                                    mem[_40533 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_40533 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_40533 + ceil32(return_data.size) + 169] = 32
                                                        mem[_40533 + ceil32(return_data.size) + 201] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _40533 + ceil32(return_data.size) + 233] = mem[idx + _40533 + 132]
                                                            _37012 = mem[_20395]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_40533 + ceil32(return_data.size) + 233]
                                                    if not return_data.size:
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43258 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < _39447:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43258 - _39447
                                                    else:
                                                        require return_data.size >= 32
                                                        require mem[_40533 + 196] == bool(mem[_40533 + 196])
                                                        if not mem[_40533 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43506 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < _39447:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43506 - _39447
                                            else:
                                                mem[_40913 + _40533 + 164] = 0
                                                call address(_39759).mem[_40533 + 164 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40533 + 168 len _40913 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        if mem[96]:
                                                            revert with memory
                                                              from 128
                                                               len mem[96]
                                                        mem[_40533 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_40533 + 168] = 32
                                                        mem[_40533 + 200] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _40533 + 232] = mem[idx + _40533 + 132]
                                                            _37012 = mem[_20395]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_40533 + 232]
                                                    if not mem[96]:
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43260 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < _39447:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43260 - _39447
                                                    else:
                                                        require mem[96] >= 32
                                                        require mem[128] == bool(mem[128])
                                                        if not mem[128]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43508 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < _39447:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43508 - _39447
                                                else:
                                                    mem[64] = _40533 + ceil32(return_data.size) + 165
                                                    mem[_40533 + 164] = return_data.size
                                                    mem[_40533 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        if return_data.size:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_40533 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_40533 + ceil32(return_data.size) + 169] = 32
                                                        mem[_40533 + ceil32(return_data.size) + 201] = 32
                                                        idx = 0
                                                        while idx < 32:
                                                            mem[idx + _40533 + ceil32(return_data.size) + 233] = mem[idx + _40533 + 132]
                                                            _37012 = mem[_20395]
                                                            idx = idx + 32
                                                            continue 
                                                        revert with 0, 32, 32, mem[_40533 + ceil32(return_data.size) + 233]
                                                    if not return_data.size:
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43262 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < _39447:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43262 - _39447
                                                    else:
                                                        require return_data.size >= 32
                                                        require mem[_40533 + 196] == bool(mem[_40533 + 196])
                                                        if not mem[_40533 + 196]:
                                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                        if idx >= mem[_20395]:
                                                            revert with 0, 50
                                                        _43510 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                        if mem[mem[(32 * idx) + _20395 + 32] + 160] < _39447:
                                                            revert with 0, 17
                                                        mem[32] = 5
                                                        if idx >= uint256(stor5[address(arg1)].field_0):
                                                            revert with 0, 50
                                                        mem[0] = sha3(address(arg1), 5)
                                                        uint256(stor5[address(arg1)][idx].field_768) = _43510 - _39447
                                        else:
                                            if not mem[_40230]:
                                                if idx >= mem[_20395]:
                                                    revert with 0, 50
                                                _40586 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                if mem[mem[(32 * idx) + _20395 + 32] + 160] < 0:
                                                    revert with 0, 17
                                                mem[32] = 5
                                                if idx >= uint256(stor5[address(arg1)].field_0):
                                                    revert with 0, 50
                                                mem[0] = sha3(address(arg1), 5)
                                                uint256(stor5[address(arg1)][idx].field_768) = _40586
                                            else:
                                                _40560 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = _40383
                                                _40638 = mem[64]
                                                mem[mem[64]] = 68
                                                mem[64] = mem[64] + 100
                                                mem[_40638 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_40638 + 36 len 28]
                                                mem[64] = _40560 + 164
                                                mem[_40560 + 100] = 32
                                                mem[_40560 + 132] = 'SafeERC20: low-level call failed'
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_39759)):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(address(_39759)):
                                                    revert with 0, 'Address: call to non-contract'
                                                _40968 = mem[_40638]
                                                s = 0
                                                while s < _40968:
                                                    mem[s + _40560 + 164] = mem[s + _40638 + 32]
                                                    _37012 = mem[_20395]
                                                    s = s + 32
                                                    continue 
                                                if ceil32(_40968) <= _40968:
                                                    call address(_39759).mem[_40560 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_40560 + 168 len _40968 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96]:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_40560 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_40560 + 168] = 32
                                                            mem[_40560 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _40560 + 232] = mem[idx + _40560 + 132]
                                                                _37012 = mem[_20395]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_40560 + 232]
                                                        if not mem[96]:
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43248 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40383:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43248 - _40383
                                                        else:
                                                            require mem[96] >= 32
                                                            require mem[128] == bool(mem[128])
                                                            if not mem[128]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43496 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40383:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43496 - _40383
                                                    else:
                                                        mem[64] = _40560 + ceil32(return_data.size) + 165
                                                        mem[_40560 + 164] = return_data.size
                                                        mem[_40560 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_40560 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_40560 + ceil32(return_data.size) + 169] = 32
                                                            mem[_40560 + ceil32(return_data.size) + 201] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _40560 + ceil32(return_data.size) + 233] = mem[idx + _40560 + 132]
                                                                _37012 = mem[_20395]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_40560 + ceil32(return_data.size) + 233]
                                                        if not return_data.size:
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43250 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40383:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43250 - _40383
                                                        else:
                                                            require return_data.size >= 32
                                                            require mem[_40560 + 196] == bool(mem[_40560 + 196])
                                                            if not mem[_40560 + 196]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43498 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40383:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43498 - _40383
                                                else:
                                                    mem[_40968 + _40560 + 164] = 0
                                                    call address(_39759).mem[_40560 + 164 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_40560 + 168 len _40968 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            if mem[96]:
                                                                revert with memory
                                                                  from 128
                                                                   len mem[96]
                                                            mem[_40560 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_40560 + 168] = 32
                                                            mem[_40560 + 200] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _40560 + 232] = mem[idx + _40560 + 132]
                                                                _37012 = mem[_20395]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_40560 + 232]
                                                        if not mem[96]:
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43252 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40383:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43252 - _40383
                                                        else:
                                                            require mem[96] >= 32
                                                            require mem[128] == bool(mem[128])
                                                            if not mem[128]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43500 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40383:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43500 - _40383
                                                    else:
                                                        mem[64] = _40560 + ceil32(return_data.size) + 165
                                                        mem[_40560 + 164] = return_data.size
                                                        mem[_40560 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            if return_data.size:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[_40560 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_40560 + ceil32(return_data.size) + 169] = 32
                                                            mem[_40560 + ceil32(return_data.size) + 201] = 32
                                                            idx = 0
                                                            while idx < 32:
                                                                mem[idx + _40560 + ceil32(return_data.size) + 233] = mem[idx + _40560 + 132]
                                                                _37012 = mem[_20395]
                                                                idx = idx + 32
                                                                continue 
                                                            revert with 0, 32, 32, mem[_40560 + ceil32(return_data.size) + 233]
                                                        if not return_data.size:
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43254 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40383:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43254 - _40383
                                                        else:
                                                            require return_data.size >= 32
                                                            require mem[_40560 + 196] == bool(mem[_40560 + 196])
                                                            if not mem[_40560 + 196]:
                                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                                            if idx >= mem[_20395]:
                                                                revert with 0, 50
                                                            _43502 = mem[mem[(32 * idx) + _20395 + 32] + 160]
                                                            if mem[mem[(32 * idx) + _20395 + 32] + 160] < _40383:
                                                                revert with 0, 17
                                                            mem[32] = 5
                                                            if idx >= uint256(stor5[address(arg1)].field_0):
                                                                revert with 0, 50
                                                            mem[0] = sha3(address(arg1), 5)
                                                            uint256(stor5[address(arg1)][idx].field_768) = _43502 - _40383
                            if idx == -1:
                                revert with 0, 17
                            _37012 = mem[_20395]
                            idx = idx + 1
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(arg1)
                        staticcall arg1.balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _37941 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _38282 = mem[_37941]
                        _38587 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = this.address
                        mem[mem[64] + 100] = arg2
                        _38832 = mem[64]
                        mem[mem[64]] = 100
                        mem[mem[64] + 32 len 4] = transferFrom(address rg1, address rg2, uint256 rg3)
                        mem[64] = mem[64] + 196
                        mem[_38587 + 132] = 32
                        mem[_38587 + 164] = 'SafeERC20: low-level call failed'
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
                            revert with 0, 'Address: call to non-contract'
                        if not ext_code.hash(arg1):
                            revert with 0, 'Address: call to non-contract'
                        _39905 = mem[_38832]
                        mem[_38587 + 196 len ceil32(mem[_38832])] = mem[_38832 + 32 len ceil32(mem[_38832])]
                        if ceil32(_39905) <= _39905:
                            call arg1 with:
                                 gas gas_remaining wei
                                args mem[_38587 + 200 len _39905 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if not mem[96]:
                                    mem[_38587 + 200] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_38587 + 196] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _38282:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _38282):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _38282
                                    mem[64] = _38587 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                    mem[_38587 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                    s = _38587 + ceil32(return_data.size) + 228
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _43763 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_43763] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_43763 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_43763 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_43763 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_43763 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_43763 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _43763
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                else:
                                    require mem[96] >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_38587 + 200] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_38587 + 196] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _38282:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _38282):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _38282
                                    mem[64] = _38587 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                    mem[_38587 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                    s = _38587 + ceil32(return_data.size) + 228
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _43767 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_43767] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_43767 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_43767 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_43767 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_43767 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_43767 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _43767
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                idx = 0
                                while idx < mem[_38587 + ceil32(return_data.size) + 196]:
                                    if idx >= mem[_38587 + ceil32(return_data.size) + 196]:
                                        revert with 0, 50
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _38587 + ceil32(return_data.size) + 228] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                        revert with 0, 17
                                    if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                        if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                            revert with 0, 50
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _38587 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                    else:
                                        uint256(stor6[address(arg1)][msg.sender].field_256)++
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _38587 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[_38587 + 196] = return_data.size
                                mem[_38587 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if not return_data.size:
                                    mem[_38587 + ceil32(return_data.size) + 201] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_38587 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _38282:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _38282):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _38282
                                    mem[64] = _38587 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                    mem[_38587 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                    s = _38587 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _43772 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_43772] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_43772 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_43772 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_43772 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_43772 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_43772 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _43772
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                else:
                                    require return_data.size >= 32
                                    require mem[_38587 + 228] == bool(mem[_38587 + 228])
                                    if not mem[_38587 + 228]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_38587 + ceil32(return_data.size) + 201] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_38587 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _38282:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _38282):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _38282
                                    mem[64] = _38587 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                    mem[_38587 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                    s = _38587 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _43776 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_43776] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_43776 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_43776 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_43776 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_43776 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_43776 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _43776
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                idx = 0
                                while idx < mem[_38587 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                    if idx >= mem[_38587 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                        revert with 0, 50
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _38587 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                        revert with 0, 17
                                    if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                        if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                            revert with 0, 50
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _38587 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                    else:
                                        uint256(stor6[address(arg1)][msg.sender].field_256)++
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _38587 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        else:
                            mem[_39905 + _38587 + 196] = 0
                            call arg1 with:
                                 gas gas_remaining wei
                                args mem[_38587 + 200 len _39905 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if not mem[96]:
                                    mem[_38587 + 200] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_38587 + 196] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _38282:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _38282):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _38282
                                    mem[64] = _38587 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                    mem[_38587 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                    s = _38587 + ceil32(return_data.size) + 228
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _43781 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_43781] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_43781 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_43781 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_43781 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_43781 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_43781 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _43781
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                else:
                                    require mem[96] >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_38587 + 200] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_38587 + 196] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _38282:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _38282):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _38282
                                    mem[64] = _38587 + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 228
                                    mem[_38587 + ceil32(return_data.size) + 196] = uint256(stor5[address(arg1)].field_0)
                                    s = _38587 + ceil32(return_data.size) + 228
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _43785 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_43785] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_43785 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_43785 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_43785 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_43785 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_43785 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _43785
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                idx = 0
                                while idx < mem[_38587 + ceil32(return_data.size) + 196]:
                                    if idx >= mem[_38587 + ceil32(return_data.size) + 196]:
                                        revert with 0, 50
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _38587 + ceil32(return_data.size) + 228] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                        revert with 0, 17
                                    if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                        if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                            revert with 0, 50
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _38587 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                    else:
                                        uint256(stor6[address(arg1)][msg.sender].field_256)++
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _38587 + ceil32(return_data.size) + 228] + 128] / 1000000000000 * 10^18
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[_38587 + 196] = return_data.size
                                mem[_38587 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if not return_data.size:
                                    mem[_38587 + ceil32(return_data.size) + 201] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_38587 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _38282:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _38282):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _38282
                                    mem[64] = _38587 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                    mem[_38587 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                    s = _38587 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _43790 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_43790] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_43790 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_43790 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_43790 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_43790 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_43790 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _43790
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                else:
                                    require return_data.size >= 32
                                    require mem[_38587 + 228] == bool(mem[_38587 + 228])
                                    if not mem[_38587 + 228]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_38587 + ceil32(return_data.size) + 201] = this.address
                                    require ext_code.size(arg1)
                                    staticcall arg1.balanceOf(address rg1) with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_38587 + ceil32(return_data.size) + 197] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < _38282:
                                        revert with 0, 17
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) > !(ext_call.return_data[0] - _38282):
                                        revert with 0, 17
                                    uint256(stor6[address(arg1)][msg.sender].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) + ext_call.return_data[0] - _38282
                                    mem[64] = _38587 + ceil32(return_data.size) + ceil32(return_data.size) + (32 * uint256(stor5[address(arg1)].field_0)) + 229
                                    mem[_38587 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = uint256(stor5[address(arg1)].field_0)
                                    s = _38587 + ceil32(return_data.size) + ceil32(return_data.size) + 229
                                    idx = 0
                                    while idx < uint256(stor5[address(arg1)].field_0):
                                        mem[0] = sha3(address(arg1), 5)
                                        _43794 = mem[64]
                                        mem[64] = mem[64] + 192
                                        mem[_43794] = address(stor5[address(arg1)][idx].field_0)
                                        mem[_43794 + 32] = stor5[address(arg1)][idx].field_160 % 281474976710656
                                        mem[_43794 + 64] = stor5[address(arg1)][idx].field_208 % 281474976710656
                                        mem[_43794 + 96] = uint256(stor5[address(arg1)][idx].field_256)
                                        mem[_43794 + 128] = uint256(stor5[address(arg1)][idx].field_512)
                                        mem[_43794 + 160] = uint256(stor5[address(arg1)][idx].field_768)
                                        mem[s] = _43794
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                idx = 0
                                while idx < mem[_38587 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                    if idx >= mem[_38587 + ceil32(return_data.size) + ceil32(return_data.size) + 197]:
                                        revert with 0, 50
                                    if uint256(stor6[address(arg1)][msg.sender].field_0) and mem[mem[(32 * idx) + _38587 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] > -1 / uint256(stor6[address(arg1)][msg.sender].field_0):
                                        revert with 0, 17
                                    if idx != uint256(stor6[address(arg1)][msg.sender].field_256):
                                        if idx >= uint256(stor6[address(arg1)][msg.sender].field_256):
                                            revert with 0, 50
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor6[address(arg1)][msg.sender][idx + 1].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _38587 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                    else:
                                        uint256(stor6[address(arg1)][msg.sender].field_256)++
                                        mem[0] = sha3(msg.sender, sha3(address(arg1), 6)) + 1
                                        uint256(stor[uint256(stor6[address(arg1)][msg.sender].field_256) + ('array', 1, ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor6', 6))))].field_0) = uint256(stor6[address(arg1)][msg.sender].field_0) * mem[mem[(32 * idx) + _38587 + ceil32(return_data.size) + ceil32(return_data.size) + 229] + 128] / 1000000000000 * 10^18
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        emit Deposit((ext_call.return_data[0] - _38282), msg.sender, arg1);
    stor1 = 1
}



}
