contract main {




// =====================  Runtime code  =====================


#
#  - transferFrom(address arg1, address arg2, uint256 arg3)
#  - sub_a2a784a8(?)
#  - transfer(address arg1, uint256 arg2)
#  - sub_d0e36335(?)
#
const sub_070b93a7(?) = (Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[32]) + 1 / 10^9)


uint256 stor0;
uint8 stor1; offset 160
uint8 stor1; offset 168
uint8 stor1; offset 176
uint8 stor1; offset 184
address owner;
uint256 stor2;
uint256 sub_84f44adf;
address stor4;
address stor5;
address poolAddress;
uint256 stor6;
uint256 liquidityUnlock;
uint256 ethSent;
uint256 sub_49a6a335;
uint256 sub_42d70631;
uint256 lockedLiquidityAmount;
uint256 refundTime;
uint256 presaleTime;
uint256 sub_8a3be0b6;
uint256 presaleHardcap;
uint256 sub_1b2cabba;
uint256 timeBetweenRounds;
uint256 sub_be71ce9f;
mapping of uint256 sub_536c8c02;
uint256 sub_9907c215;
uint256 sub_d10c98f4;
uint256 sub_87359823;
uint256 sub_a19036da;
mapping of uint256 stor26;
mapping of uint256 stor27;
mapping of uint256 allowance;
mapping of uint8 stor29;
array of address stor30;
uint256 _tTotal;
uint256 stor32;
uint256 _tFeeTotal;
array of uint256 name;
array of uint256 symbol;
uint8 decimals;
uint256 _maxTxAmount;
array of address stor36516136433507714556481507284757523525550975291680945358964353894568634540880;

function lockedLiquidityAmount() {
    return lockedLiquidityAmount
}

function name() {
    return name[0 len name.length]
}

function liquidityUnlock() {
    return liquidityUnlock
}

function totalFees() {
    return _tFeeTotal
}

function pool() {
    return address(poolAddress)
}

function totalSupply() {
    return _tTotal
}

function sub_1b2cabba(?) {
    return sub_1b2cabba
}

function decimals() {
    return decimals
}

function moonMissionStarted() {
    return bool(uint8(stor1.field_176))
}

function sub_42d70631(?) {
    return sub_42d70631
}

function sub_49a6a335(?) {
    return sub_49a6a335
}

function sub_536c8c02(?) {
    require calldata.size - 4 >= 32
    return sub_536c8c02[address(arg1)]
}

function timeBetweenRounds() {
    return timeBetweenRounds
}

function _maxTxAmount() {
    return _maxTxAmount
}

function sub_84f44adf(?) {
    return sub_84f44adf
}

function sub_87359823(?) {
    return sub_87359823
}

function isRefundEnabled() {
    return bool(uint8(stor1.field_160))
}

function sub_8a3be0b6(?) {
    return sub_8a3be0b6
}

function owner() {
    return owner
}

function symbol() {
    return symbol[0 len symbol.length]
}

function sub_9907c215(?) {
    return sub_9907c215
}

function refundTime() {
    return refundTime
}

function sub_a19036da(?) {
    return sub_a19036da
}

function _tTotal() {
    return _tTotal
}

function sub_be71ce9f(?) {
    return sub_be71ce9f
}

function presaleTime() {
    return presaleTime
}

function isExcluded(address arg1) {
    require calldata.size - 4 >= 32
    return bool(stor29[address(arg1)])
}

function presaleHardcap() {
    return presaleHardcap
}

function sub_d10c98f4(?) {
    return sub_d10c98f4
}

function liquidityAdded() {
    return bool(uint8(stor1.field_168))
}

function allowance(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    return allowance[address(arg1)][address(arg2)]
}

function ethSent() {
    return ethSent
}

function _tFeeTotal() {
    return _tFeeTotal
}

function _fallback() payable {
    revert
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function sub_c29bf895(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    timeBetweenRounds = arg1
}

function setPresaleTime(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    presaleTime = arg1
}

function allowRefunds() {
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    if stor0 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    uint8(stor1.field_160) = 1
    presaleTime = 0
    stor0 = 1
}

function sub_043ce033(?) {
    if not sub_84f44adf:
        return 0
    if 2 * sub_84f44adf / sub_84f44adf != 2:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    return (2 * sub_84f44adf / 10^9)
}

function recoverToken(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    require block.timestamp >= liquidityUnlock
    require ext_code.size(arg1)
    call arg1.0xa9059cbb with:
         gas gas_remaining wei
        args stor4, arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
}

function sub_60605da2(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    if not uint8(stor1.field_184):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    49,
                    0x734c61756e636820636f756e74646f776e2074696d652063616e206f6e6c7920626520736574207768656e207061757365,
                    mem[213 len 15]
    stor2 = arg1
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0x734f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function sub_21b387b2(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    if presaleTime:
        if presaleTime <= block.timestamp:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        37,
                        0x7243616e6e6f74206368616e6765207768696c652070726573616c65206973206163746976,
                        mem[201 len 27]
    sub_49a6a335 = arg1
}

function getRefund() {
    if stor0 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor0 = 2
    require tx.origin == msg.sender
    require not uint8(stor1.field_176)
    if not uint8(stor1.field_160):
        if block.timestamp < refundTime:
            revert with 0, 'Cannot refund'
    sub_536c8c02[msg.sender] = 0
    call msg.sender with:
       value sub_536c8c02[msg.sender] wei
         gas 2300 * is_zero(value) wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    stor0 = 1
}

function setMaxTxPercent(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    if not _tTotal:
        _maxTxAmount = 0
    else:
        if arg1 * _tTotal / _tTotal != arg1:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        _maxTxAmount = arg1 * _tTotal / 100
}

function includeAccount(address arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    if not stor29[address(arg1)]:
        revert with 0, 'Account is already excluded'
    idx = 0
    while idx < stor30.length:
        mem[0] = 30
        if stor30[idx] != arg1:
            idx = idx + 1
            continue 
        require stor30.length - 1 < stor30.length
        require idx < stor30.length
        stor30[idx] = stor30[stor30.length]
        stor27[address(arg1)] = 0
        stor29[address(arg1)] = 0
        require stor30.length
        stor30[stor30.length] = 0
        stor30.length--
}

function approve(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    36,
                    0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573,
                    mem[200 len 28]
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    34,
                    0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573,
                    mem[198 len 30]
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function getTokenReserves(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require ext_code.size(0xef45d134b73241eda7703fa787148d9c9f4950b0)
    staticcall 0xef45d134b73241eda7703fa787148d9c9f4950b0.getPair(address arg1, address arg2) with:
            gas gas_remaining wei
           args address(arg1), arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).getReserves() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    return ext_call.return_data[18 len 14], ext_call.return_data[32] << 144
}

function decreaseAllowance(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    if arg2 > allowance[address(msg.sender)][address(arg1)]:
        revert with 0, 
                    32,
                    37,
                    0x6e45524332303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572,
                    mem[165 len 27],
                    mem[219 len 5]
    if not msg.sender:
        revert with 0, 32, 36, 0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573, mem[296 len 28]
    if not arg1:
        revert with 0, 32, 34, 0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573, mem[294 len 30]
    allowance[address(msg.sender)][address(arg1)] -= arg2
    emit Approval((allowance[address(msg.sender)][address(arg1)] - arg2), msg.sender, arg1);
    return 1
}

function createPool() {
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    require ext_code.size(0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52)
    staticcall 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52.WETH() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(0xef45d134b73241eda7703fa787148d9c9f4950b0)
    call 0xef45d134b73241eda7703fa787148d9c9f4950b0.createPair(address arg1, address arg2) with:
         gas gas_remaining wei
        args address(this.address), address(ext_call.return_data[0])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    uint256(stor6) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor6))
}

function increaseAllowance(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    if arg2 + allowance[address(msg.sender)][address(arg1)] < allowance[address(msg.sender)][address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    36,
                    0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573,
                    mem[200 len 28]
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    34,
                    0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573,
                    mem[198 len 30]
    allowance[address(msg.sender)][address(arg1)] += arg2
    emit Approval((arg2 + allowance[address(msg.sender)][address(arg1)]), msg.sender, arg1);
    return 1
}

function tokenFromReflection(uint256 arg1) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 32
    if arg1 > stor32:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    42,
                    0x73416d6f756e74206d757374206265206c657373207468616e20746f74616c207265666c656374696f6e,
                    mem[206 len 22]
    idx = 0
    s = _tTotal
    t = stor32
    while idx < stor30.length:
        mem[0] = stor30[idx]
        mem[32] = 26
        if stor26[stor30[idx]] > t:
            _156 = mem[64]
            mem[64] = mem[64] + 64
            mem[_156] = 26
            mem[_156 + 32] = 'SafeMath: division by zero'
            if not _tTotal:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero'
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _156 + 32]
                    idx = idx + 32
                    continue 
            else:
                _198 = mem[64]
                mem[64] = mem[64] + 64
                mem[_198] = 26
                mem[_198 + 32] = 'SafeMath: division by zero'
                if stor32 / _tTotal:
                    return (arg1 / stor32 / _tTotal)
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero'
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _198 + 32]
                    idx = idx + 32
                    continue 
            revert with 0, 'SafeMath: division by zero'
        require idx < stor30.length
        mem[0] = stor30[idx]
        mem[32] = 27
        if stor27[stor30[idx]] > s:
            _166 = mem[64]
            mem[64] = mem[64] + 64
            mem[_166] = 26
            mem[_166 + 32] = 'SafeMath: division by zero'
            if not _tTotal:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero'
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _166 + 32]
                    idx = idx + 32
                    continue 
            else:
                _220 = mem[64]
                mem[64] = mem[64] + 64
                mem[_220] = 26
                mem[_220 + 32] = 'SafeMath: division by zero'
                if stor32 / _tTotal:
                    return (arg1 / stor32 / _tTotal)
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero'
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _220 + 32]
                    idx = idx + 32
                    continue 
            revert with 0, 'SafeMath: division by zero'
        require idx < stor30.length
        mem[0] = stor30[idx]
        mem[32] = 26
        _161 = mem[64]
        mem[64] = mem[64] + 64
        mem[_161] = 30
        mem[_161 + 32] = 'SafeMath: subtraction overflow'
        if stor26[stor30[idx]] > t:
            _168 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _168 + 68] = mem[idx + _161 + 32]
                idx = idx + 32
                continue 
            mem[_168 + 68] = mem[_168 + 70 len 30]
            revert with memory
              from mem[64]
               len _168 + -mem[64] + 100
        require idx < stor30.length
        mem[0] = stor30[idx]
        mem[32] = 27
        _200 = mem[64]
        mem[64] = mem[64] + 64
        mem[_200] = 30
        mem[_200 + 32] = 'SafeMath: subtraction overflow'
        if stor27[stor30[idx]] <= s:
            idx = idx + 1
            s = s - stor27[stor30[idx]]
            t = t - stor26[stor30[idx]]
            continue 
        _217 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _217 + 68] = mem[idx + _200 + 32]
            idx = idx + 32
            continue 
        mem[_217 + 68] = mem[_217 + 70 len 30]
        revert with memory
          from mem[64]
           len _217 + -mem[64] + 100
    if not _tTotal:
        revert with 0, 'SafeMath: division by zero'
    if t >= stor32 / _tTotal:
        if not s:
            revert with 0, 'SafeMath: division by zero'
        if not t / s:
            revert with 0, 'SafeMath: division by zero'
        return (arg1 / t / s)
    if not _tTotal:
        revert with 0, 'SafeMath: division by zero'
    if not stor32 / _tTotal:
        revert with 0, 'SafeMath: division by zero'
    return (arg1 / stor32 / _tTotal)
}

function balanceOf(address arg1) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 32
    if stor29[address(arg1)]:
        return stor27[address(arg1)]
    mem[0] = arg1
    mem[32] = 26
    if stor26[address(arg1)] > stor32:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    42,
                    0x73416d6f756e74206d757374206265206c657373207468616e20746f74616c207265666c656374696f6e,
                    mem[206 len 22]
    idx = 0
    s = _tTotal
    t = stor32
    while idx < stor30.length:
        mem[0] = stor30[idx]
        mem[32] = 26
        if stor26[stor30[idx]] > t:
            _161 = mem[64]
            mem[64] = mem[64] + 64
            mem[_161] = 26
            mem[_161 + 32] = 'SafeMath: division by zero'
            if not _tTotal:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero'
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _161 + 32]
                    idx = idx + 32
                    continue 
            else:
                _203 = mem[64]
                mem[64] = mem[64] + 64
                mem[_203] = 26
                mem[_203 + 32] = 'SafeMath: division by zero'
                if stor32 / _tTotal:
                    return (stor26[address(arg1)] / stor32 / _tTotal)
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero'
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _203 + 32]
                    idx = idx + 32
                    continue 
            revert with 0, 'SafeMath: division by zero'
        require idx < stor30.length
        mem[0] = stor30[idx]
        mem[32] = 27
        if stor27[stor30[idx]] > s:
            _171 = mem[64]
            mem[64] = mem[64] + 64
            mem[_171] = 26
            mem[_171 + 32] = 'SafeMath: division by zero'
            if not _tTotal:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero'
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _171 + 32]
                    idx = idx + 32
                    continue 
            else:
                _225 = mem[64]
                mem[64] = mem[64] + 64
                mem[_225] = 26
                mem[_225 + 32] = 'SafeMath: division by zero'
                if stor32 / _tTotal:
                    return (stor26[address(arg1)] / stor32 / _tTotal)
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero'
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _225 + 32]
                    idx = idx + 32
                    continue 
            revert with 0, 'SafeMath: division by zero'
        require idx < stor30.length
        mem[0] = stor30[idx]
        mem[32] = 26
        _166 = mem[64]
        mem[64] = mem[64] + 64
        mem[_166] = 30
        mem[_166 + 32] = 'SafeMath: subtraction overflow'
        if stor26[stor30[idx]] > t:
            _173 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _173 + 68] = mem[idx + _166 + 32]
                idx = idx + 32
                continue 
            mem[_173 + 68] = mem[_173 + 70 len 30]
            revert with memory
              from mem[64]
               len _173 + -mem[64] + 100
        require idx < stor30.length
        mem[0] = stor30[idx]
        mem[32] = 27
        _205 = mem[64]
        mem[64] = mem[64] + 64
        mem[_205] = 30
        mem[_205 + 32] = 'SafeMath: subtraction overflow'
        if stor27[stor30[idx]] <= s:
            idx = idx + 1
            s = s - stor27[stor30[idx]]
            t = t - stor26[stor30[idx]]
            continue 
        _222 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _222 + 68] = mem[idx + _205 + 32]
            idx = idx + 32
            continue 
        mem[_222 + 68] = mem[_222 + 70 len 30]
        revert with memory
          from mem[64]
           len _222 + -mem[64] + 100
    if not _tTotal:
        revert with 0, 'SafeMath: division by zero'
    if t >= stor32 / _tTotal:
        if not s:
            revert with 0, 'SafeMath: division by zero'
        if not t / s:
            revert with 0, 'SafeMath: division by zero'
        return (stor26[address(arg1)] / t / s)
    if not _tTotal:
        revert with 0, 'SafeMath: division by zero'
    if not stor32 / _tTotal:
        revert with 0, 'SafeMath: division by zero'
    return (stor26[address(arg1)] / stor32 / _tTotal)
}

function excludeAccount(address arg1) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    if stor29[address(arg1)]:
        revert with 0, 'Account is already excluded'
    if stor26[address(arg1)]:
        mem[0] = arg1
        mem[32] = 26
        if stor26[address(arg1)] > stor32:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        42,
                        0x73416d6f756e74206d757374206265206c657373207468616e20746f74616c207265666c656374696f6e,
                        mem[206 len 22]
        idx = 0
        s = _tTotal
        t = stor32
        while idx < stor30.length:
            mem[0] = stor30[idx]
            mem[32] = 26
            if stor26[stor30[idx]] > t:
                _166 = mem[64]
                mem[64] = mem[64] + 64
                mem[_166] = 26
                mem[_166 + 32] = 'SafeMath: division by zero'
                if not _tTotal:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _166 + 32]
                        idx = idx + 32
                        continue 
                else:
                    _208 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_208] = 26
                    mem[_208 + 32] = 'SafeMath: division by zero'
                    if stor32 / _tTotal:
                        stor27[address(arg1)] = stor26[address(arg1)] / stor32 / _tTotal
                        stor29[address(arg1)] = 1
                        stor30.length++
                        stor50BB[stor30.length] = arg1
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _208 + 32]
                        idx = idx + 32
                        continue 
                revert with 0, 'SafeMath: division by zero'
            require idx < stor30.length
            mem[0] = stor30[idx]
            mem[32] = 27
            if stor27[stor30[idx]] > s:
                _176 = mem[64]
                mem[64] = mem[64] + 64
                mem[_176] = 26
                mem[_176 + 32] = 'SafeMath: division by zero'
                if not _tTotal:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _176 + 32]
                        idx = idx + 32
                        continue 
                else:
                    _230 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_230] = 26
                    mem[_230 + 32] = 'SafeMath: division by zero'
                    if stor32 / _tTotal:
                        stor27[address(arg1)] = stor26[address(arg1)] / stor32 / _tTotal
                        stor29[address(arg1)] = 1
                        stor30.length++
                        stor50BB[stor30.length] = arg1
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _230 + 32]
                        idx = idx + 32
                        continue 
                revert with 0, 'SafeMath: division by zero'
            require idx < stor30.length
            mem[0] = stor30[idx]
            mem[32] = 26
            _171 = mem[64]
            mem[64] = mem[64] + 64
            mem[_171] = 30
            mem[_171 + 32] = 'SafeMath: subtraction overflow'
            if stor26[stor30[idx]] > t:
                _178 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _178 + 68] = mem[idx + _171 + 32]
                    idx = idx + 32
                    continue 
                mem[_178 + 68] = mem[_178 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _178 + -mem[64] + 100
            require idx < stor30.length
            mem[0] = stor30[idx]
            mem[32] = 27
            _210 = mem[64]
            mem[64] = mem[64] + 64
            mem[_210] = 30
            mem[_210 + 32] = 'SafeMath: subtraction overflow'
            if stor27[stor30[idx]] <= s:
                idx = idx + 1
                s = s - stor27[stor30[idx]]
                t = t - stor26[stor30[idx]]
                continue 
            _227 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _227 + 68] = mem[idx + _210 + 32]
                idx = idx + 32
                continue 
            mem[_227 + 68] = mem[_227 + 70 len 30]
            revert with memory
              from mem[64]
               len _227 + -mem[64] + 100
        if not _tTotal:
            revert with 0, 'SafeMath: division by zero'
        if t >= stor32 / _tTotal:
            if not s:
                revert with 0, 'SafeMath: division by zero'
            if not t / s:
                revert with 0, 'SafeMath: division by zero'
            stor27[address(arg1)] = stor26[address(arg1)] / t / s
        else:
            if not _tTotal:
                revert with 0, 'SafeMath: division by zero'
            if not stor32 / _tTotal:
                revert with 0, 'SafeMath: division by zero'
            stor27[address(arg1)] = stor26[address(arg1)] / stor32 / _tTotal
    stor29[address(arg1)] = 1
    stor30.length++
    stor50BB[stor30.length] = arg1
}

function reflectionFromToken(uint256 arg1, bool arg2) {
    require calldata.size - 4 >= 64
    if arg1 > _tTotal:
        revert with 0, 'Amount must be less than supply'
    mem[96] = 26
    mem[128] = 'SafeMath: division by zero'
    if arg2:
        if not arg1 / 50:
            mem[64] = 224
            mem[160] = 30
            mem[192] = 'SafeMath: subtraction overflow'
            if 0 > arg1:
                revert with 0, 'SafeMath: subtraction overflow'
            idx = 0
            s = _tTotal
            t = stor32
            while idx < stor30.length:
                mem[0] = stor30[idx]
                mem[32] = 26
                if stor26[stor30[idx]] > t:
                    _876 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_876] = 26
                    mem[_876 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _876 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if not arg1:
                        return 0
                    if stor32 / _tTotal * arg1 / arg1 != stor32 / _tTotal:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _1209 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1209] = 30
                    mem[_1209 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor32 / _tTotal * arg1:
                        return (stor32 / _tTotal * arg1)
                    _1237 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1237 + 68] = mem[idx + _1209 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1237 + 68] = mem[_1237 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1237 + -mem[64] + 100
                require idx < stor30.length
                mem[0] = stor30[idx]
                mem[32] = 27
                if stor27[stor30[idx]] > s:
                    _910 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_910] = 26
                    mem[_910 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _910 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if not arg1:
                        return 0
                    if stor32 / _tTotal * arg1 / arg1 != stor32 / _tTotal:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _1240 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1240] = 30
                    mem[_1240 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor32 / _tTotal * arg1:
                        return (stor32 / _tTotal * arg1)
                    _1296 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1296 + 68] = mem[idx + _1240 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1296 + 68] = mem[_1296 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1296 + -mem[64] + 100
                require idx < stor30.length
                mem[0] = stor30[idx]
                mem[32] = 26
                _894 = mem[64]
                mem[64] = mem[64] + 64
                mem[_894] = 30
                mem[_894 + 32] = 'SafeMath: subtraction overflow'
                if stor26[stor30[idx]] > t:
                    _926 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _926 + 68] = mem[idx + _894 + 32]
                        idx = idx + 32
                        continue 
                    mem[_926 + 68] = mem[_926 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _926 + -mem[64] + 100
                require idx < stor30.length
                mem[0] = stor30[idx]
                mem[32] = 27
                _1047 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1047] = 30
                mem[_1047 + 32] = 'SafeMath: subtraction overflow'
                if stor27[stor30[idx]] <= s:
                    idx = idx + 1
                    s = s - stor27[stor30[idx]]
                    t = t - stor26[stor30[idx]]
                    continue 
                _1101 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1101 + 68] = mem[idx + _1047 + 32]
                    idx = idx + 32
                    continue 
                mem[_1101 + 68] = mem[_1101 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1101 + -mem[64] + 100
            _818 = mem[64]
            mem[64] = mem[64] + 64
            mem[_818] = 26
            mem[_818 + 32] = 'SafeMath: division by zero'
            if not _tTotal:
                revert with 0, 'SafeMath: division by zero'
            if t >= stor32 / _tTotal:
                _944 = mem[64]
                mem[64] = mem[64] + 64
                mem[_944] = 26
                mem[_944 + 32] = 'SafeMath: division by zero'
                if not s:
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    return 0
                if t / s * arg1 / arg1 != t / s:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if 0 > t / s * arg1:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (t / s * arg1)
            _945 = mem[64]
            mem[64] = mem[64] + 64
            mem[_945] = 26
            mem[_945 + 32] = 'SafeMath: division by zero'
            if not _tTotal:
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                return 0
            if stor32 / _tTotal * arg1 / arg1 != stor32 / _tTotal:
                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if 0 > stor32 / _tTotal * arg1:
                revert with 0, 'SafeMath: subtraction overflow'
            return (stor32 / _tTotal * arg1)
        if 2 * arg1 / 50 / arg1 / 50 != 2:
            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 2 * arg1 / 50 > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        idx = 0
        s = _tTotal
        t = stor32
        while idx < stor30.length:
            mem[0] = stor30[idx]
            mem[32] = 26
            if stor26[stor30[idx]] > t:
                _871 = mem[64]
                mem[64] = mem[64] + 64
                mem[_871] = 26
                mem[_871 + 32] = 'SafeMath: division by zero'
                if not _tTotal:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _871 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    if not 2 * arg1 / 50:
                        return 0
                    if stor32 / _tTotal * 2 * arg1 / 50 / 2 * arg1 / 50 != stor32 / _tTotal:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _1206 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1206] = 30
                    mem[_1206 + 32] = 'SafeMath: subtraction overflow'
                    if stor32 / _tTotal * 2 * arg1 / 50 <= 0:
                        return (-1 * stor32 / _tTotal * 2 * arg1 / 50)
                    _1232 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1232 + 68] = mem[idx + _1206 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1232 + 68] = mem[_1232 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1232 + -mem[64] + 100
                if stor32 / _tTotal * arg1 / arg1 != stor32 / _tTotal:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not 2 * arg1 / 50:
                    _1205 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1205] = 30
                    mem[_1205 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor32 / _tTotal * arg1:
                        return (stor32 / _tTotal * arg1)
                    _1229 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1229 + 68] = mem[idx + _1205 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1229 + 68] = mem[_1229 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1229 + -mem[64] + 100
                if stor32 / _tTotal * 2 * arg1 / 50 / 2 * arg1 / 50 != stor32 / _tTotal:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1215 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1215] = 30
                mem[_1215 + 32] = 'SafeMath: subtraction overflow'
                if stor32 / _tTotal * 2 * arg1 / 50 <= stor32 / _tTotal * arg1:
                    return ((stor32 / _tTotal * arg1) - (stor32 / _tTotal * 2 * arg1 / 50))
                _1263 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1263 + 68] = mem[idx + _1215 + 32]
                    idx = idx + 32
                    continue 
                mem[_1263 + 68] = mem[_1263 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1263 + -mem[64] + 100
            require idx < stor30.length
            mem[0] = stor30[idx]
            mem[32] = 27
            if stor27[stor30[idx]] > s:
                _905 = mem[64]
                mem[64] = mem[64] + 64
                mem[_905] = 26
                mem[_905 + 32] = 'SafeMath: division by zero'
                if not _tTotal:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _905 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    if not 2 * arg1 / 50:
                        return 0
                    if stor32 / _tTotal * 2 * arg1 / 50 / 2 * arg1 / 50 != stor32 / _tTotal:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _1236 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1236] = 30
                    mem[_1236 + 32] = 'SafeMath: subtraction overflow'
                    if stor32 / _tTotal * 2 * arg1 / 50 <= 0:
                        return (-1 * stor32 / _tTotal * 2 * arg1 / 50)
                    _1290 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1290 + 68] = mem[idx + _1236 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1290 + 68] = mem[_1290 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1290 + -mem[64] + 100
                if stor32 / _tTotal * arg1 / arg1 != stor32 / _tTotal:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not 2 * arg1 / 50:
                    _1235 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1235] = 30
                    mem[_1235 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor32 / _tTotal * arg1:
                        return (stor32 / _tTotal * arg1)
                    _1287 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1287 + 68] = mem[idx + _1235 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1287 + 68] = mem[_1287 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1287 + -mem[64] + 100
                if stor32 / _tTotal * 2 * arg1 / 50 / 2 * arg1 / 50 != stor32 / _tTotal:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1266 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1266] = 30
                mem[_1266 + 32] = 'SafeMath: subtraction overflow'
                if stor32 / _tTotal * 2 * arg1 / 50 <= stor32 / _tTotal * arg1:
                    return ((stor32 / _tTotal * arg1) - (stor32 / _tTotal * 2 * arg1 / 50))
                _1324 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1324 + 68] = mem[idx + _1266 + 32]
                    idx = idx + 32
                    continue 
                mem[_1324 + 68] = mem[_1324 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1324 + -mem[64] + 100
            require idx < stor30.length
            mem[0] = stor30[idx]
            mem[32] = 26
            _891 = mem[64]
            mem[64] = mem[64] + 64
            mem[_891] = 30
            mem[_891 + 32] = 'SafeMath: subtraction overflow'
            if stor26[stor30[idx]] > t:
                _922 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _922 + 68] = mem[idx + _891 + 32]
                    idx = idx + 32
                    continue 
                mem[_922 + 68] = mem[_922 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _922 + -mem[64] + 100
            require idx < stor30.length
            mem[0] = stor30[idx]
            mem[32] = 27
            _1040 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1040] = 30
            mem[_1040 + 32] = 'SafeMath: subtraction overflow'
            if stor27[stor30[idx]] <= s:
                idx = idx + 1
                s = s - stor27[stor30[idx]]
                t = t - stor26[stor30[idx]]
                continue 
            _1093 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _1093 + 68] = mem[idx + _1040 + 32]
                idx = idx + 32
                continue 
            mem[_1093 + 68] = mem[_1093 + 70 len 30]
            revert with memory
              from mem[64]
               len _1093 + -mem[64] + 100
        _813 = mem[64]
        mem[64] = mem[64] + 64
        mem[_813] = 26
        mem[_813 + 32] = 'SafeMath: division by zero'
        if not _tTotal:
            revert with 0, 'SafeMath: division by zero'
        if t >= stor32 / _tTotal:
            _937 = mem[64]
            mem[64] = mem[64] + 64
            mem[_937] = 26
            mem[_937 + 32] = 'SafeMath: division by zero'
            if not s:
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                if not 2 * arg1 / 50:
                    return 0
                if t / s * 2 * arg1 / 50 / 2 * arg1 / 50 != t / s:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if t / s * 2 * arg1 / 50 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (-1 * t / s * 2 * arg1 / 50)
            if t / s * arg1 / arg1 != t / s:
                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not 2 * arg1 / 50:
                if 0 > t / s * arg1:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (t / s * arg1)
            if t / s * 2 * arg1 / 50 / 2 * arg1 / 50 != t / s:
                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if t / s * 2 * arg1 / 50 > t / s * arg1:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((t / s * arg1) - (t / s * 2 * arg1 / 50))
        _938 = mem[64]
        mem[64] = mem[64] + 64
        mem[_938] = 26
        mem[_938 + 32] = 'SafeMath: division by zero'
        if not _tTotal:
            revert with 0, 'SafeMath: division by zero'
        if not arg1:
            if not 2 * arg1 / 50:
                return 0
            if stor32 / _tTotal * 2 * arg1 / 50 / 2 * arg1 / 50 != stor32 / _tTotal:
                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if stor32 / _tTotal * 2 * arg1 / 50 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return (-1 * stor32 / _tTotal * 2 * arg1 / 50)
        if stor32 / _tTotal * arg1 / arg1 != stor32 / _tTotal:
            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if not 2 * arg1 / 50:
            if 0 > stor32 / _tTotal * arg1:
                revert with 0, 'SafeMath: subtraction overflow'
            return (stor32 / _tTotal * arg1)
        if stor32 / _tTotal * 2 * arg1 / 50 / 2 * arg1 / 50 != stor32 / _tTotal:
            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if stor32 / _tTotal * 2 * arg1 / 50 > stor32 / _tTotal * arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((stor32 / _tTotal * arg1) - (stor32 / _tTotal * 2 * arg1 / 50))
    if not arg1 / 50:
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 0 > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        idx = 0
        s = _tTotal
        t = stor32
        while idx < stor30.length:
            mem[0] = stor30[idx]
            mem[32] = 26
            if stor26[stor30[idx]] > t:
                _886 = mem[64]
                mem[64] = mem[64] + 64
                mem[_886] = 26
                mem[_886 + 32] = 'SafeMath: division by zero'
                if not _tTotal:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _886 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    return 0
                if stor32 / _tTotal * arg1 / arg1 != stor32 / _tTotal:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1214 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1214] = 30
                mem[_1214 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= stor32 / _tTotal * arg1:
                    return (stor32 / _tTotal * arg1)
                _1253 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1253 + 68] = mem[idx + _1214 + 32]
                    idx = idx + 32
                    continue 
                mem[_1253 + 68] = mem[_1253 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1253 + -mem[64] + 100
            require idx < stor30.length
            mem[0] = stor30[idx]
            mem[32] = 27
            if stor27[stor30[idx]] > s:
                _920 = mem[64]
                mem[64] = mem[64] + 64
                mem[_920] = 26
                mem[_920 + 32] = 'SafeMath: division by zero'
                if not _tTotal:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _920 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    return 0
                if stor32 / _tTotal * arg1 / arg1 != stor32 / _tTotal:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1256 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1256] = 30
                mem[_1256 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= stor32 / _tTotal * arg1:
                    return (stor32 / _tTotal * arg1)
                _1314 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1314 + 68] = mem[idx + _1256 + 32]
                    idx = idx + 32
                    continue 
                mem[_1314 + 68] = mem[_1314 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1314 + -mem[64] + 100
            require idx < stor30.length
            mem[0] = stor30[idx]
            mem[32] = 26
            _900 = mem[64]
            mem[64] = mem[64] + 64
            mem[_900] = 30
            mem[_900 + 32] = 'SafeMath: subtraction overflow'
            if stor26[stor30[idx]] > t:
                _934 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _934 + 68] = mem[idx + _900 + 32]
                    idx = idx + 32
                    continue 
                mem[_934 + 68] = mem[_934 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _934 + -mem[64] + 100
            require idx < stor30.length
            mem[0] = stor30[idx]
            mem[32] = 27
            _1061 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1061] = 30
            mem[_1061 + 32] = 'SafeMath: subtraction overflow'
            if stor27[stor30[idx]] <= s:
                idx = idx + 1
                s = s - stor27[stor30[idx]]
                t = t - stor26[stor30[idx]]
                continue 
            _1117 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _1117 + 68] = mem[idx + _1061 + 32]
                idx = idx + 32
                continue 
            mem[_1117 + 68] = mem[_1117 + 70 len 30]
            revert with memory
              from mem[64]
               len _1117 + -mem[64] + 100
        _828 = mem[64]
        mem[64] = mem[64] + 64
        mem[_828] = 26
        mem[_828 + 32] = 'SafeMath: division by zero'
        if not _tTotal:
            revert with 0, 'SafeMath: division by zero'
        if t >= stor32 / _tTotal:
            _958 = mem[64]
            mem[64] = mem[64] + 64
            mem[_958] = 26
            mem[_958 + 32] = 'SafeMath: division by zero'
            if not s:
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                return 0
            if t / s * arg1 / arg1 != t / s:
                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if 0 > t / s * arg1:
                revert with 0, 'SafeMath: subtraction overflow'
            return (t / s * arg1)
        _959 = mem[64]
        mem[64] = mem[64] + 64
        mem[_959] = 26
        mem[_959 + 32] = 'SafeMath: division by zero'
        if not _tTotal:
            revert with 0, 'SafeMath: division by zero'
        if not arg1:
            return 0
        if stor32 / _tTotal * arg1 / arg1 != stor32 / _tTotal:
            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if 0 > stor32 / _tTotal * arg1:
            revert with 0, 'SafeMath: subtraction overflow'
    else:
        if 2 * arg1 / 50 / arg1 / 50 != 2:
            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 2 * arg1 / 50 > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        idx = 0
        s = _tTotal
        t = stor32
        while idx < stor30.length:
            mem[0] = stor30[idx]
            mem[32] = 26
            if stor26[stor30[idx]] > t:
                _881 = mem[64]
                mem[64] = mem[64] + 64
                mem[_881] = 26
                mem[_881 + 32] = 'SafeMath: division by zero'
                if not _tTotal:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _881 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    if not 2 * arg1 / 50:
                        return 0
                    if stor32 / _tTotal * 2 * arg1 / 50 / 2 * arg1 / 50 != stor32 / _tTotal:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _1211 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1211] = 30
                    mem[_1211 + 32] = 'SafeMath: subtraction overflow'
                    if stor32 / _tTotal * 2 * arg1 / 50 <= 0:
                        return 0
                    _1248 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1248 + 68] = mem[idx + _1211 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1248 + 68] = mem[_1248 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1248 + -mem[64] + 100
                if stor32 / _tTotal * arg1 / arg1 != stor32 / _tTotal:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not 2 * arg1 / 50:
                    _1210 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1210] = 30
                    mem[_1210 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor32 / _tTotal * arg1:
                        return (stor32 / _tTotal * arg1)
                    _1245 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1245 + 68] = mem[idx + _1210 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1245 + 68] = mem[_1245 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1245 + -mem[64] + 100
                if stor32 / _tTotal * 2 * arg1 / 50 / 2 * arg1 / 50 != stor32 / _tTotal:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1220 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1220] = 30
                mem[_1220 + 32] = 'SafeMath: subtraction overflow'
                if stor32 / _tTotal * 2 * arg1 / 50 <= stor32 / _tTotal * arg1:
                    return (stor32 / _tTotal * arg1)
                _1275 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1275 + 68] = mem[idx + _1220 + 32]
                    idx = idx + 32
                    continue 
                mem[_1275 + 68] = mem[_1275 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1275 + -mem[64] + 100
            require idx < stor30.length
            mem[0] = stor30[idx]
            mem[32] = 27
            if stor27[stor30[idx]] > s:
                _915 = mem[64]
                mem[64] = mem[64] + 64
                mem[_915] = 26
                mem[_915 + 32] = 'SafeMath: division by zero'
                if not _tTotal:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _915 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    if not 2 * arg1 / 50:
                        return 0
                    if stor32 / _tTotal * 2 * arg1 / 50 / 2 * arg1 / 50 != stor32 / _tTotal:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _1252 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1252] = 30
                    mem[_1252 + 32] = 'SafeMath: subtraction overflow'
                    if stor32 / _tTotal * 2 * arg1 / 50 <= 0:
                        return 0
                    _1308 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1308 + 68] = mem[idx + _1252 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1308 + 68] = mem[_1308 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1308 + -mem[64] + 100
                if stor32 / _tTotal * arg1 / arg1 != stor32 / _tTotal:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not 2 * arg1 / 50:
                    _1251 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1251] = 30
                    mem[_1251 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor32 / _tTotal * arg1:
                        return (stor32 / _tTotal * arg1)
                    _1305 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1305 + 68] = mem[idx + _1251 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1305 + 68] = mem[_1305 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1305 + -mem[64] + 100
                if stor32 / _tTotal * 2 * arg1 / 50 / 2 * arg1 / 50 != stor32 / _tTotal:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1278 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1278] = 30
                mem[_1278 + 32] = 'SafeMath: subtraction overflow'
                if stor32 / _tTotal * 2 * arg1 / 50 <= stor32 / _tTotal * arg1:
                    return (stor32 / _tTotal * arg1)
                _1336 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1336 + 68] = mem[idx + _1278 + 32]
                    idx = idx + 32
                    continue 
                mem[_1336 + 68] = mem[_1336 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1336 + -mem[64] + 100
            require idx < stor30.length
            mem[0] = stor30[idx]
            mem[32] = 26
            _897 = mem[64]
            mem[64] = mem[64] + 64
            mem[_897] = 30
            mem[_897 + 32] = 'SafeMath: subtraction overflow'
            if stor26[stor30[idx]] > t:
                _930 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _930 + 68] = mem[idx + _897 + 32]
                    idx = idx + 32
                    continue 
                mem[_930 + 68] = mem[_930 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _930 + -mem[64] + 100
            require idx < stor30.length
            mem[0] = stor30[idx]
            mem[32] = 27
            _1054 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1054] = 30
            mem[_1054 + 32] = 'SafeMath: subtraction overflow'
            if stor27[stor30[idx]] <= s:
                idx = idx + 1
                s = s - stor27[stor30[idx]]
                t = t - stor26[stor30[idx]]
                continue 
            _1109 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _1109 + 68] = mem[idx + _1054 + 32]
                idx = idx + 32
                continue 
            mem[_1109 + 68] = mem[_1109 + 70 len 30]
            revert with memory
              from mem[64]
               len _1109 + -mem[64] + 100
        _823 = mem[64]
        mem[64] = mem[64] + 64
        mem[_823] = 26
        mem[_823 + 32] = 'SafeMath: division by zero'
        if not _tTotal:
            revert with 0, 'SafeMath: division by zero'
        if t >= stor32 / _tTotal:
            _951 = mem[64]
            mem[64] = mem[64] + 64
            mem[_951] = 26
            mem[_951 + 32] = 'SafeMath: division by zero'
            if not s:
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                if 2 * arg1 / 50:
                    if t / s * 2 * arg1 / 50 / 2 * arg1 / 50 != t / s:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if t / s * 2 * arg1 / 50 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    else:
                        return 0
                else:
                    return 0
            if t / s * arg1 / arg1 != t / s:
                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not 2 * arg1 / 50:
                if 0 > t / s * arg1:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                if t / s * 2 * arg1 / 50 / 2 * arg1 / 50 != t / s:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if t / s * 2 * arg1 / 50 > t / s * arg1:
                    revert with 0, 'SafeMath: subtraction overflow'
            return (t / s * arg1)
        _952 = mem[64]
        mem[64] = mem[64] + 64
        mem[_952] = 26
        mem[_952 + 32] = 'SafeMath: division by zero'
        if not _tTotal:
            revert with 0, 'SafeMath: division by zero'
        if not arg1:
            if 2 * arg1 / 50:
                if stor32 / _tTotal * 2 * arg1 / 50 / 2 * arg1 / 50 != stor32 / _tTotal:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if stor32 / _tTotal * 2 * arg1 / 50 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                else:
                    return 0
            else:
                return 0
        if stor32 / _tTotal * arg1 / arg1 != stor32 / _tTotal:
            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if not 2 * arg1 / 50:
            if 0 > stor32 / _tTotal * arg1:
                revert with 0, 'SafeMath: subtraction overflow'
        else:
            if stor32 / _tTotal * 2 * arg1 / 50 / 2 * arg1 / 50 != stor32 / _tTotal:
                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if stor32 / _tTotal * 2 * arg1 / 50 > stor32 / _tTotal * arg1:
                revert with 0, 'SafeMath: subtraction overflow'
    return (stor32 / _tTotal * arg1)
}

function reflect(uint256 arg1) {
    require calldata.size - 4 >= 32
    mem[0] = msg.sender
    mem[32] = 29
    if stor29[address(msg.sender)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    44,
                    0x644578636c75646564206164647265737365732063616e6e6f742063616c6c20746869732066756e6374696f,
                    mem[208 len 20]
    mem[96] = 26
    mem[128] = 'SafeMath: division by zero'
    if not arg1 / 50:
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 0 > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        idx = 0
        s = _tTotal
        t = stor32
        while idx < stor30.length:
            mem[0] = stor30[idx]
            mem[32] = 26
            if stor26[stor30[idx]] > t:
                _876 = mem[64]
                mem[64] = mem[64] + 64
                mem[_876] = 26
                mem[_876 + 32] = 'SafeMath: division by zero'
                if not _tTotal:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _876 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    _1036 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1036] = 30
                    mem[_1036 + 32] = 'SafeMath: subtraction overflow'
                    mem[0] = msg.sender
                    mem[32] = 26
                    _1136 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1136] = 30
                    mem[_1136 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor26[address(msg.sender)]:
                        _1175 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1175 + 68] = mem[idx + _1136 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1175 + 68] = mem[_1175 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1175 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 26
                    _1272 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1272] = 30
                    mem[_1272 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor32:
                        if arg1 + _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        _tFeeTotal += arg1
                    _1346 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1346 + 68] = mem[idx + _1272 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1346 + 68] = mem[_1346 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1346 + -mem[64] + 100
                if stor32 / _tTotal * arg1 / arg1 != stor32 / _tTotal:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1041 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1041] = 30
                mem[_1041 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor32 / _tTotal * arg1:
                    _1059 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1059 + 68] = mem[idx + _1041 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1059 + 68] = mem[_1059 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1059 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 26
                _1154 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1154] = 30
                mem[_1154 + 32] = 'SafeMath: subtraction overflow'
                if stor32 / _tTotal * arg1 > stor26[address(msg.sender)]:
                    _1209 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1209 + 68] = mem[idx + _1154 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1209 + 68] = mem[_1209 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1209 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 26
                stor26[address(msg.sender)] += -1 * stor32 / _tTotal * arg1
                _1306 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1306] = 30
                mem[_1306 + 32] = 'SafeMath: subtraction overflow'
                if stor32 / _tTotal * arg1 <= stor32:
                    stor32 += -1 * stor32 / _tTotal * arg1
                    if arg1 + _tFeeTotal < _tFeeTotal:
                        revert with 0, 'SafeMath: addition overflow'
                    _tFeeTotal += arg1
                _1384 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1384 + 68] = mem[idx + _1306 + 32]
                    idx = idx + 32
                    continue 
                mem[_1384 + 68] = mem[_1384 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1384 + -mem[64] + 100
            require idx < stor30.length
            mem[0] = stor30[idx]
            mem[32] = 27
            if stor27[stor30[idx]] <= s:
                require idx < stor30.length
                mem[0] = stor30[idx]
                mem[32] = 26
                _884 = mem[64]
                mem[64] = mem[64] + 64
                mem[_884] = 30
                mem[_884 + 32] = 'SafeMath: subtraction overflow'
                if stor26[stor30[idx]] > t:
                    _900 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _900 + 68] = mem[idx + _884 + 32]
                        idx = idx + 32
                        continue 
                    mem[_900 + 68] = mem[_900 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _900 + -mem[64] + 100
                require idx < stor30.length
                mem[0] = stor30[idx]
                mem[32] = 27
                _963 = mem[64]
                mem[64] = mem[64] + 64
                mem[_963] = 30
                mem[_963 + 32] = 'SafeMath: subtraction overflow'
                if stor27[stor30[idx]] <= s:
                    idx = idx + 1
                    s = s - stor27[stor30[idx]]
                    t = t - stor26[stor30[idx]]
                    continue 
                _991 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _991 + 68] = mem[idx + _963 + 32]
                    idx = idx + 32
                    continue 
                mem[_991 + 68] = mem[_991 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _991 + -mem[64] + 100
            _894 = mem[64]
            mem[64] = mem[64] + 64
            mem[_894] = 26
            mem[_894 + 32] = 'SafeMath: division by zero'
            if not _tTotal:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero'
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _894 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                _1046 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1046] = 30
                mem[_1046 + 32] = 'SafeMath: subtraction overflow'
                mem[0] = msg.sender
                mem[32] = 26
                _1180 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1180] = 30
                mem[_1180 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor26[address(msg.sender)]:
                    _1244 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1244 + 68] = mem[idx + _1180 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1244 + 68] = mem[_1244 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1244 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 26
                _1351 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1351] = 30
                mem[_1351 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= stor32:
                    if arg1 + _tFeeTotal < _tFeeTotal:
                        revert with 0, 'SafeMath: addition overflow'
                    _tFeeTotal += arg1
                _1429 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1429 + 68] = mem[idx + _1351 + 32]
                    idx = idx + 32
                    continue 
                mem[_1429 + 68] = mem[_1429 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1429 + -mem[64] + 100
            if stor32 / _tTotal * arg1 / arg1 != stor32 / _tTotal:
                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _1062 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1062] = 30
            mem[_1062 + 32] = 'SafeMath: subtraction overflow'
            if 0 > stor32 / _tTotal * arg1:
                _1090 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1090 + 68] = mem[idx + _1062 + 32]
                    idx = idx + 32
                    continue 
                mem[_1090 + 68] = mem[_1090 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1090 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 26
            _1212 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1212] = 30
            mem[_1212 + 32] = 'SafeMath: subtraction overflow'
            if stor32 / _tTotal * arg1 > stor26[address(msg.sender)]:
                _1275 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1275 + 68] = mem[idx + _1212 + 32]
                    idx = idx + 32
                    continue 
                mem[_1275 + 68] = mem[_1275 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1275 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 26
            stor26[address(msg.sender)] += -1 * stor32 / _tTotal * arg1
            _1387 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1387] = 30
            mem[_1387 + 32] = 'SafeMath: subtraction overflow'
            if stor32 / _tTotal * arg1 <= stor32:
                stor32 += -1 * stor32 / _tTotal * arg1
                if arg1 + _tFeeTotal < _tFeeTotal:
                    revert with 0, 'SafeMath: addition overflow'
                _tFeeTotal += arg1
            _1472 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _1472 + 68] = mem[idx + _1387 + 32]
                idx = idx + 32
                continue 
            mem[_1472 + 68] = mem[_1472 + 70 len 30]
            revert with memory
              from mem[64]
               len _1472 + -mem[64] + 100
        _846 = mem[64]
        mem[64] = mem[64] + 64
        mem[_846] = 26
        mem[_846 + 32] = 'SafeMath: division by zero'
        if not _tTotal:
            revert with 0, 'SafeMath: division by zero'
        if t >= stor32 / _tTotal:
            _910 = mem[64]
            mem[64] = mem[64] + 64
            mem[_910] = 26
            mem[_910 + 32] = 'SafeMath: division by zero'
            if not s:
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                if 0 > stor26[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor32:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                if t / s * arg1 / arg1 != t / s:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if 0 > t / s * arg1:
                    revert with 0, 'SafeMath: subtraction overflow'
                if t / s * arg1 > stor26[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor26[address(msg.sender)] += -1 * t / s * arg1
                if t / s * arg1 > stor32:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor32 += -1 * t / s * arg1
        else:
            _911 = mem[64]
            mem[64] = mem[64] + 64
            mem[_911] = 26
            mem[_911 + 32] = 'SafeMath: division by zero'
            if not _tTotal:
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                if 0 > stor26[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor32:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                if stor32 / _tTotal * arg1 / arg1 != stor32 / _tTotal:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if 0 > stor32 / _tTotal * arg1:
                    revert with 0, 'SafeMath: subtraction overflow'
                if stor32 / _tTotal * arg1 > stor26[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor26[address(msg.sender)] += -1 * stor32 / _tTotal * arg1
                if stor32 / _tTotal * arg1 > stor32:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor32 += -1 * stor32 / _tTotal * arg1
    else:
        if 2 * arg1 / 50 / arg1 / 50 != 2:
            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 2 * arg1 / 50 > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        idx = 0
        s = _tTotal
        t = stor32
        while idx < stor30.length:
            mem[0] = stor30[idx]
            mem[32] = 26
            if stor26[stor30[idx]] > t:
                _871 = mem[64]
                mem[64] = mem[64] + 64
                mem[_871] = 26
                mem[_871 + 32] = 'SafeMath: division by zero'
                if not _tTotal:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _871 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    if not 2 * arg1 / 50:
                        _1035 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1035] = 30
                        mem[_1035 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        _1125 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1125] = 30
                        mem[_1125 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor26[address(msg.sender)]:
                            _1163 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1163 + 68] = mem[idx + _1125 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1163 + 68] = mem[_1163 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _1163 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 26
                        _1259 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1259] = 30
                        mem[_1259 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor32:
                            if arg1 + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += arg1
                        _1329 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1329 + 68] = mem[idx + _1259 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1329 + 68] = mem[_1329 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1329 + -mem[64] + 100
                    if stor32 / _tTotal * 2 * arg1 / 50 / 2 * arg1 / 50 != stor32 / _tTotal:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _1038 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1038] = 30
                    mem[_1038 + 32] = 'SafeMath: subtraction overflow'
                    if stor32 / _tTotal * 2 * arg1 / 50 > 0:
                        _1054 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1054 + 68] = mem[idx + _1038 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1054 + 68] = mem[_1054 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1054 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 26
                    _1147 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1147] = 30
                    mem[_1147 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor26[address(msg.sender)]:
                        _1196 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1196 + 68] = mem[idx + _1147 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1196 + 68] = mem[_1196 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1196 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 26
                    _1291 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1291] = 30
                    mem[_1291 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor32:
                        if arg1 + _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        _tFeeTotal += arg1
                    _1368 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1368 + 68] = mem[idx + _1291 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1368 + 68] = mem[_1368 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1368 + -mem[64] + 100
                if stor32 / _tTotal * arg1 / arg1 != stor32 / _tTotal:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not 2 * arg1 / 50:
                    _1037 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1037] = 30
                    mem[_1037 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor32 / _tTotal * arg1:
                        _1051 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1051 + 68] = mem[idx + _1037 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1051 + 68] = mem[_1051 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1051 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 26
                    _1146 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1146] = 30
                    mem[_1146 + 32] = 'SafeMath: subtraction overflow'
                    if stor32 / _tTotal * arg1 > stor26[address(msg.sender)]:
                        _1193 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1193 + 68] = mem[idx + _1146 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1193 + 68] = mem[_1193 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1193 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 26
                    stor26[address(msg.sender)] += -1 * stor32 / _tTotal * arg1
                    _1288 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1288] = 30
                    mem[_1288 + 32] = 'SafeMath: subtraction overflow'
                    if stor32 / _tTotal * arg1 <= stor32:
                        stor32 += -1 * stor32 / _tTotal * arg1
                        if arg1 + _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        _tFeeTotal += arg1
                    _1365 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1365 + 68] = mem[idx + _1288 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1365 + 68] = mem[_1365 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1365 + -mem[64] + 100
                if stor32 / _tTotal * 2 * arg1 / 50 / 2 * arg1 / 50 != stor32 / _tTotal:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1042 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1042] = 30
                mem[_1042 + 32] = 'SafeMath: subtraction overflow'
                if stor32 / _tTotal * 2 * arg1 / 50 > stor32 / _tTotal * arg1:
                    _1069 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1069 + 68] = mem[idx + _1042 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1069 + 68] = mem[_1069 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1069 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 26
                _1162 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1162] = 30
                mem[_1162 + 32] = 'SafeMath: subtraction overflow'
                if stor32 / _tTotal * arg1 > stor26[address(msg.sender)]:
                    _1227 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1227 + 68] = mem[idx + _1162 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1227 + 68] = mem[_1227 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1227 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 26
                stor26[address(msg.sender)] += -1 * stor32 / _tTotal * arg1
                _1324 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1324] = 30
                mem[_1324 + 32] = 'SafeMath: subtraction overflow'
                if stor32 / _tTotal * arg1 <= stor32:
                    stor32 += -1 * stor32 / _tTotal * arg1
                    if arg1 + _tFeeTotal < _tFeeTotal:
                        revert with 0, 'SafeMath: addition overflow'
                    _tFeeTotal += arg1
                _1405 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1405 + 68] = mem[idx + _1324 + 32]
                    idx = idx + 32
                    continue 
                mem[_1405 + 68] = mem[_1405 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1405 + -mem[64] + 100
            require idx < stor30.length
            mem[0] = stor30[idx]
            mem[32] = 27
            if stor27[stor30[idx]] <= s:
                require idx < stor30.length
                mem[0] = stor30[idx]
                mem[32] = 26
                _881 = mem[64]
                mem[64] = mem[64] + 64
                mem[_881] = 30
                mem[_881 + 32] = 'SafeMath: subtraction overflow'
                if stor26[stor30[idx]] > t:
                    _896 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _896 + 68] = mem[idx + _881 + 32]
                        idx = idx + 32
                        continue 
                    mem[_896 + 68] = mem[_896 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _896 + -mem[64] + 100
                require idx < stor30.length
                mem[0] = stor30[idx]
                mem[32] = 27
                _956 = mem[64]
                mem[64] = mem[64] + 64
                mem[_956] = 30
                mem[_956 + 32] = 'SafeMath: subtraction overflow'
                if stor27[stor30[idx]] <= s:
                    idx = idx + 1
                    s = s - stor27[stor30[idx]]
                    t = t - stor26[stor30[idx]]
                    continue 
                _983 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _983 + 68] = mem[idx + _956 + 32]
                    idx = idx + 32
                    continue 
                mem[_983 + 68] = mem[_983 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _983 + -mem[64] + 100
            _889 = mem[64]
            mem[64] = mem[64] + 64
            mem[_889] = 26
            mem[_889 + 32] = 'SafeMath: division by zero'
            if not _tTotal:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero'
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _889 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                if not 2 * arg1 / 50:
                    _1045 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1045] = 30
                    mem[_1045 + 32] = 'SafeMath: subtraction overflow'
                    mem[0] = msg.sender
                    mem[32] = 26
                    _1172 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1172] = 30
                    mem[_1172 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor26[address(msg.sender)]:
                        _1233 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1233 + 68] = mem[idx + _1172 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1233 + 68] = mem[_1233 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1233 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 26
                    _1336 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1336] = 30
                    mem[_1336 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor32:
                        if arg1 + _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        _tFeeTotal += arg1
                    _1414 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1414 + 68] = mem[idx + _1336 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1414 + 68] = mem[_1414 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1414 + -mem[64] + 100
                if stor32 / _tTotal * 2 * arg1 / 50 / 2 * arg1 / 50 != stor32 / _tTotal:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1058 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1058] = 30
                mem[_1058 + 32] = 'SafeMath: subtraction overflow'
                if stor32 / _tTotal * 2 * arg1 / 50 > 0:
                    _1084 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1084 + 68] = mem[idx + _1058 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1084 + 68] = mem[_1084 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1084 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 26
                _1202 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1202] = 30
                mem[_1202 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor26[address(msg.sender)]:
                    _1265 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1265 + 68] = mem[idx + _1202 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1265 + 68] = mem[_1265 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1265 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 26
                _1376 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1376] = 30
                mem[_1376 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= stor32:
                    if arg1 + _tFeeTotal < _tFeeTotal:
                        revert with 0, 'SafeMath: addition overflow'
                    _tFeeTotal += arg1
                _1458 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1458 + 68] = mem[idx + _1376 + 32]
                    idx = idx + 32
                    continue 
                mem[_1458 + 68] = mem[_1458 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1458 + -mem[64] + 100
            if stor32 / _tTotal * arg1 / arg1 != stor32 / _tTotal:
                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not 2 * arg1 / 50:
                _1057 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1057] = 30
                mem[_1057 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor32 / _tTotal * arg1:
                    _1081 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1081 + 68] = mem[idx + _1057 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1081 + 68] = mem[_1081 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1081 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 26
                _1201 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1201] = 30
                mem[_1201 + 32] = 'SafeMath: subtraction overflow'
                if stor32 / _tTotal * arg1 > stor26[address(msg.sender)]:
                    _1262 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1262 + 68] = mem[idx + _1201 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1262 + 68] = mem[_1262 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1262 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 26
                stor26[address(msg.sender)] += -1 * stor32 / _tTotal * arg1
                _1373 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1373] = 30
                mem[_1373 + 32] = 'SafeMath: subtraction overflow'
                if stor32 / _tTotal * arg1 <= stor32:
                    stor32 += -1 * stor32 / _tTotal * arg1
                    if arg1 + _tFeeTotal < _tFeeTotal:
                        revert with 0, 'SafeMath: addition overflow'
                    _tFeeTotal += arg1
                _1455 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1455 + 68] = mem[idx + _1373 + 32]
                    idx = idx + 32
                    continue 
                mem[_1455 + 68] = mem[_1455 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1455 + -mem[64] + 100
            if stor32 / _tTotal * 2 * arg1 / 50 / 2 * arg1 / 50 != stor32 / _tTotal:
                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _1072 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1072] = 30
            mem[_1072 + 32] = 'SafeMath: subtraction overflow'
            if stor32 / _tTotal * 2 * arg1 / 50 > stor32 / _tTotal * arg1:
                _1101 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1101 + 68] = mem[idx + _1072 + 32]
                    idx = idx + 32
                    continue 
                mem[_1101 + 68] = mem[_1101 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1101 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 26
            _1232 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1232] = 30
            mem[_1232 + 32] = 'SafeMath: subtraction overflow'
            if stor32 / _tTotal * arg1 > stor26[address(msg.sender)]:
                _1295 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1295 + 68] = mem[idx + _1232 + 32]
                    idx = idx + 32
                    continue 
                mem[_1295 + 68] = mem[_1295 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1295 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 26
            stor26[address(msg.sender)] += -1 * stor32 / _tTotal * arg1
            _1409 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1409] = 30
            mem[_1409 + 32] = 'SafeMath: subtraction overflow'
            if stor32 / _tTotal * arg1 <= stor32:
                stor32 += -1 * stor32 / _tTotal * arg1
                if arg1 + _tFeeTotal < _tFeeTotal:
                    revert with 0, 'SafeMath: addition overflow'
                _tFeeTotal += arg1
            _1499 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _1499 + 68] = mem[idx + _1409 + 32]
                idx = idx + 32
                continue 
            mem[_1499 + 68] = mem[_1499 + 70 len 30]
            revert with memory
              from mem[64]
               len _1499 + -mem[64] + 100
        _841 = mem[64]
        mem[64] = mem[64] + 64
        mem[_841] = 26
        mem[_841 + 32] = 'SafeMath: division by zero'
        if not _tTotal:
            revert with 0, 'SafeMath: division by zero'
        if t >= stor32 / _tTotal:
            _903 = mem[64]
            mem[64] = mem[64] + 64
            mem[_903] = 26
            mem[_903 + 32] = 'SafeMath: division by zero'
            if not s:
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                if 2 * arg1 / 50:
                    if t / s * 2 * arg1 / 50 / 2 * arg1 / 50 != t / s:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if t / s * 2 * arg1 / 50 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor26[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor32:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                if t / s * arg1 / arg1 != t / s:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not 2 * arg1 / 50:
                    if 0 > t / s * arg1:
                        revert with 0, 'SafeMath: subtraction overflow'
                else:
                    if t / s * 2 * arg1 / 50 / 2 * arg1 / 50 != t / s:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if t / s * 2 * arg1 / 50 > t / s * arg1:
                        revert with 0, 'SafeMath: subtraction overflow'
                if t / s * arg1 > stor26[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor26[address(msg.sender)] += -1 * t / s * arg1
                if t / s * arg1 > stor32:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor32 += -1 * t / s * arg1
        else:
            _904 = mem[64]
            mem[64] = mem[64] + 64
            mem[_904] = 26
            mem[_904 + 32] = 'SafeMath: division by zero'
            if not _tTotal:
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                if 2 * arg1 / 50:
                    if stor32 / _tTotal * 2 * arg1 / 50 / 2 * arg1 / 50 != stor32 / _tTotal:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if stor32 / _tTotal * 2 * arg1 / 50 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor26[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor32:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                if stor32 / _tTotal * arg1 / arg1 != stor32 / _tTotal:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not 2 * arg1 / 50:
                    if 0 > stor32 / _tTotal * arg1:
                        revert with 0, 'SafeMath: subtraction overflow'
                else:
                    if stor32 / _tTotal * 2 * arg1 / 50 / 2 * arg1 / 50 != stor32 / _tTotal:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if stor32 / _tTotal * 2 * arg1 / 50 > stor32 / _tTotal * arg1:
                        revert with 0, 'SafeMath: subtraction overflow'
                if stor32 / _tTotal * arg1 > stor26[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor26[address(msg.sender)] += -1 * stor32 / _tTotal * arg1
                if stor32 / _tTotal * arg1 > stor32:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor32 += -1 * stor32 / _tTotal * arg1
    if arg1 + _tFeeTotal < _tFeeTotal:
        revert with 0, 'SafeMath: addition overflow'
    _tFeeTotal += arg1
}

function addLiquidity() {
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    require not uint8(stor1.field_168)
    if not eth.balance(this.address):
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not eth.balance(this.address):
            mem[64] = 224
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            call stor4 with:
                 gas 2300 wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            call stor5 with:
                 gas 2300 wei
            uint8(stor1.field_168) = 1
            require not uint8(stor1.field_176)
            if stor29[address(this.address)]:
                if sub_84f44adf > stor27[address(this.address)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                require ext_code.size(this.address)
                call this.address.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52, sub_84f44adf
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                uint8(stor1.field_184) = 0
                require ext_code.size(0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52)
                call 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                   value eth.balance(this.address) wei
                     gas gas_remaining wei
                    args this.address, sub_84f44adf, sub_84f44adf, eth.balance(this.address), this.address, block.timestamp + 300
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                stor2 += block.timestamp
                if stor27[address(this.address)] - sub_84f44adf:
                    if stor27[address(this.address)] - sub_84f44adf > stor26[this.address]:
                        revert with 0, 'Burn amount exceeds balance'
                    stor26[this.address] = stor26[this.address] - stor27[address(this.address)] + sub_84f44adf
                    if stor27[address(this.address)] - sub_84f44adf > _tTotal:
                        revert with 0, 'SafeMath: subtraction overflow'
                    _tTotal = _tTotal - stor27[address(this.address)] + sub_84f44adf
                    emit Transfer((stor27[address(this.address)] - sub_84f44adf), this.address, 0);
            else:
                mem[0] = this.address
                mem[32] = 26
                if stor26[address(this.address)] > stor32:
                    revert with 0, 32, 42, 0x73416d6f756e74206d757374206265206c657373207468616e20746f74616c207265666c656374696f6e, mem[334 len 22]
                idx = 0
                s = _tTotal
                t = stor32
                while idx < stor30.length:
                    mem[0] = stor30[idx]
                    mem[32] = 26
                    if stor26[stor30[idx]] > t:
                        _1362 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1362] = 26
                        mem[_1362 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _1362 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _1539 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1539] = 26
                        mem[_1539 + 32] = 'SafeMath: division by zero'
                        if not stor32 / _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _1539 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _1807 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1807] = 30
                        mem[_1807 + 32] = 'SafeMath: subtraction overflow'
                        if sub_84f44adf > stor26[address(this.address)] / stor32 / _tTotal:
                            _1845 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1845 + 68] = mem[idx + _1807 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1845 + 68] = mem[_1845 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _1845 + -mem[64] + 100
                        require ext_code.size(this.address)
                        call this.address.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52, sub_84f44adf
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        uint8(stor1.field_184) = 0
                        mem[mem[64] + 68] = sub_84f44adf
                        mem[mem[64] + 100] = eth.balance(this.address)
                        mem[mem[64] + 132] = this.address
                        mem[mem[64] + 164] = block.timestamp + 300
                        require ext_code.size(0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52)
                        call 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                           value eth.balance(this.address) wei
                             gas gas_remaining wei
                            args this.address, sub_84f44adf, sub_84f44adf, eth.balance(this.address), this.address, block.timestamp + 300
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 96
                        stor2 += block.timestamp
                        if not (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf:
                            presaleTime = 0
                            uint8(stor1.field_176) = 1
                        _2050 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2050] = 27
                        mem[_2050 + 32] = 'Burn amount exceeds balance'
                        mem[32] = 26
                        if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf > stor26[this.address]:
                            _2076 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 27
                            idx = 0
                            while idx < 27:
                                mem[idx + _2076 + 68] = mem[idx + _2050 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2076 + 68] = mem[_2076 + 73 len 27]
                            revert with memory
                              from mem[64]
                               len _2076 + -mem[64] + 100
                        mem[0] = this.address
                        mem[32] = 26
                        stor26[this.address] = stor26[this.address] - (stor26[address(this.address)] / stor32 / _tTotal) + sub_84f44adf
                        _2116 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2116] = 30
                        mem[_2116 + 32] = 'SafeMath: subtraction overflow'
                        if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf <= _tTotal:
                            _tTotal = _tTotal - (stor26[address(this.address)] / stor32 / _tTotal) + sub_84f44adf
                            emit Transfer(((stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf), this.address, 0);
                            presaleTime = 0
                            uint8(stor1.field_176) = 1
                        _2175 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2175 + 68] = mem[idx + _2116 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2175 + 68] = mem[_2175 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _2175 + -mem[64] + 100
                    require idx < stor30.length
                    mem[0] = stor30[idx]
                    mem[32] = 27
                    if stor27[stor30[idx]] <= s:
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 26
                        _1376 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1376] = 30
                        mem[_1376 + 32] = 'SafeMath: subtraction overflow'
                        if stor26[stor30[idx]] > t:
                            _1410 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1410 + 68] = mem[idx + _1376 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1410 + 68] = mem[_1410 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _1410 + -mem[64] + 100
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 27
                        _1541 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1541] = 30
                        mem[_1541 + 32] = 'SafeMath: subtraction overflow'
                        if stor27[stor30[idx]] <= s:
                            idx = idx + 1
                            s = s - stor27[stor30[idx]]
                            t = t - stor26[stor30[idx]]
                            continue 
                        _1612 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1612 + 68] = mem[idx + _1541 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1612 + 68] = mem[_1612 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1612 + -mem[64] + 100
                    _1396 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1396] = 26
                    mem[_1396 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _1396 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    _1615 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1615] = 26
                    mem[_1615 + 32] = 'SafeMath: division by zero'
                    if not stor32 / _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _1615 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    _1848 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1848] = 30
                    mem[_1848 + 32] = 'SafeMath: subtraction overflow'
                    if sub_84f44adf > stor26[address(this.address)] / stor32 / _tTotal:
                        _1878 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1878 + 68] = mem[idx + _1848 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1878 + 68] = mem[_1878 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1878 + -mem[64] + 100
                    require ext_code.size(this.address)
                    call this.address.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52, sub_84f44adf
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    uint8(stor1.field_184) = 0
                    mem[mem[64] + 68] = sub_84f44adf
                    mem[mem[64] + 100] = eth.balance(this.address)
                    mem[mem[64] + 132] = this.address
                    mem[mem[64] + 164] = block.timestamp + 300
                    require ext_code.size(0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52)
                    call 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                       value eth.balance(this.address) wei
                         gas gas_remaining wei
                        args this.address, sub_84f44adf, sub_84f44adf, eth.balance(this.address), this.address, block.timestamp + 300
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    stor2 += block.timestamp
                    if not (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf:
                        presaleTime = 0
                        uint8(stor1.field_176) = 1
                    _2079 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2079] = 27
                    mem[_2079 + 32] = 'Burn amount exceeds balance'
                    mem[32] = 26
                    if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf > stor26[this.address]:
                        _2118 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 27
                        idx = 0
                        while idx < 27:
                            mem[idx + _2118 + 68] = mem[idx + _2079 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2118 + 68] = mem[_2118 + 73 len 27]
                        revert with memory
                          from mem[64]
                           len _2118 + -mem[64] + 100
                    mem[0] = this.address
                    mem[32] = 26
                    stor26[this.address] = stor26[this.address] - (stor26[address(this.address)] / stor32 / _tTotal) + sub_84f44adf
                    _2179 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2179] = 30
                    mem[_2179 + 32] = 'SafeMath: subtraction overflow'
                    if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf <= _tTotal:
                        _tTotal = _tTotal - (stor26[address(this.address)] / stor32 / _tTotal) + sub_84f44adf
                        emit Transfer(((stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf), this.address, 0);
                        presaleTime = 0
                        uint8(stor1.field_176) = 1
                    _2237 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _2237 + 68] = mem[idx + _2179 + 32]
                        idx = idx + 32
                        continue 
                    mem[_2237 + 68] = mem[_2237 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _2237 + -mem[64] + 100
                if not _tTotal:
                    revert with 0, 'SafeMath: division by zero'
                if t >= stor32 / _tTotal:
                    if not s:
                        revert with 0, 'SafeMath: division by zero'
                    if not t / s:
                        revert with 0, 'SafeMath: division by zero'
                    if sub_84f44adf > stor26[address(this.address)] / t / s:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require ext_code.size(this.address)
                    call this.address.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52, sub_84f44adf
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    uint8(stor1.field_184) = 0
                    require ext_code.size(0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52)
                    call 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                       value eth.balance(this.address) wei
                         gas gas_remaining wei
                        args this.address, sub_84f44adf, sub_84f44adf, eth.balance(this.address), this.address, block.timestamp + 300
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    stor2 += block.timestamp
                    if (stor26[address(this.address)] / t / s) - sub_84f44adf:
                        if (stor26[address(this.address)] / t / s) - sub_84f44adf > stor26[this.address]:
                            revert with 0, 'Burn amount exceeds balance'
                        stor26[this.address] = stor26[this.address] - (stor26[address(this.address)] / t / s) + sub_84f44adf
                        if (stor26[address(this.address)] / t / s) - sub_84f44adf > _tTotal:
                            revert with 0, 'SafeMath: subtraction overflow'
                        _tTotal = _tTotal - (stor26[address(this.address)] / t / s) + sub_84f44adf
                        emit Transfer(((stor26[address(this.address)] / t / s) - sub_84f44adf), this.address, 0);
                else:
                    if not _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    if not stor32 / _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    if sub_84f44adf > stor26[address(this.address)] / stor32 / _tTotal:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require ext_code.size(this.address)
                    call this.address.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52, sub_84f44adf
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    uint8(stor1.field_184) = 0
                    require ext_code.size(0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52)
                    call 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                       value eth.balance(this.address) wei
                         gas gas_remaining wei
                        args this.address, sub_84f44adf, sub_84f44adf, eth.balance(this.address), this.address, block.timestamp + 300
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    stor2 += block.timestamp
                    if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf:
                        if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf > stor26[this.address]:
                            revert with 0, 'Burn amount exceeds balance'
                        stor26[this.address] = stor26[this.address] - (stor26[address(this.address)] / stor32 / _tTotal) + sub_84f44adf
                        if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf > _tTotal:
                            revert with 0, 'SafeMath: subtraction overflow'
                        _tTotal = _tTotal - (stor26[address(this.address)] / stor32 / _tTotal) + sub_84f44adf
                        emit Transfer(((stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf), this.address, 0);
        else:
            if 20 * eth.balance(this.address) / eth.balance(this.address) != 20:
                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            mem[64] = 224
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            call stor4 with:
                 gas 2300 wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            call stor5 with:
               value 20 * eth.balance(this.address) / 100 wei
                 gas 2300 * is_zero(value) wei
            uint8(stor1.field_168) = 1
            require not uint8(stor1.field_176)
            if stor29[address(this.address)]:
                if sub_84f44adf > stor27[address(this.address)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                require ext_code.size(this.address)
                call this.address.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52, sub_84f44adf
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                uint8(stor1.field_184) = 0
                require ext_code.size(0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52)
                call 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                   value eth.balance(this.address) wei
                     gas gas_remaining wei
                    args this.address, sub_84f44adf, sub_84f44adf, eth.balance(this.address), this.address, block.timestamp + 300
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                stor2 += block.timestamp
                if stor27[address(this.address)] - sub_84f44adf:
                    if stor27[address(this.address)] - sub_84f44adf > stor26[this.address]:
                        revert with 0, 'Burn amount exceeds balance'
                    stor26[this.address] = stor26[this.address] - stor27[address(this.address)] + sub_84f44adf
                    if stor27[address(this.address)] - sub_84f44adf > _tTotal:
                        revert with 0, 'SafeMath: subtraction overflow'
                    _tTotal = _tTotal - stor27[address(this.address)] + sub_84f44adf
                    emit Transfer((stor27[address(this.address)] - sub_84f44adf), this.address, 0);
            else:
                mem[0] = this.address
                mem[32] = 26
                if stor26[address(this.address)] > stor32:
                    revert with 0, 32, 42, 0x73416d6f756e74206d757374206265206c657373207468616e20746f74616c207265666c656374696f6e, mem[334 len 22]
                idx = 0
                s = _tTotal
                t = stor32
                while idx < stor30.length:
                    mem[0] = stor30[idx]
                    mem[32] = 26
                    if stor26[stor30[idx]] > t:
                        _1357 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1357] = 26
                        mem[_1357 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _1357 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _1531 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1531] = 26
                        mem[_1531 + 32] = 'SafeMath: division by zero'
                        if not stor32 / _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _1531 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _1801 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1801] = 30
                        mem[_1801 + 32] = 'SafeMath: subtraction overflow'
                        if sub_84f44adf > stor26[address(this.address)] / stor32 / _tTotal:
                            _1839 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1839 + 68] = mem[idx + _1801 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1839 + 68] = mem[_1839 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _1839 + -mem[64] + 100
                        require ext_code.size(this.address)
                        call this.address.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52, sub_84f44adf
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        uint8(stor1.field_184) = 0
                        mem[mem[64] + 68] = sub_84f44adf
                        mem[mem[64] + 100] = eth.balance(this.address)
                        mem[mem[64] + 132] = this.address
                        mem[mem[64] + 164] = block.timestamp + 300
                        require ext_code.size(0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52)
                        call 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                           value eth.balance(this.address) wei
                             gas gas_remaining wei
                            args this.address, sub_84f44adf, sub_84f44adf, eth.balance(this.address), this.address, block.timestamp + 300
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 96
                        stor2 += block.timestamp
                        if not (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf:
                            presaleTime = 0
                            uint8(stor1.field_176) = 1
                        _2043 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2043] = 27
                        mem[_2043 + 32] = 'Burn amount exceeds balance'
                        mem[32] = 26
                        if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf > stor26[this.address]:
                            _2069 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 27
                            idx = 0
                            while idx < 27:
                                mem[idx + _2069 + 68] = mem[idx + _2043 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2069 + 68] = mem[_2069 + 73 len 27]
                            revert with memory
                              from mem[64]
                               len _2069 + -mem[64] + 100
                        mem[0] = this.address
                        mem[32] = 26
                        stor26[this.address] = stor26[this.address] - (stor26[address(this.address)] / stor32 / _tTotal) + sub_84f44adf
                        _2107 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2107] = 30
                        mem[_2107 + 32] = 'SafeMath: subtraction overflow'
                        if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf <= _tTotal:
                            _tTotal = _tTotal - (stor26[address(this.address)] / stor32 / _tTotal) + sub_84f44adf
                            emit Transfer(((stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf), this.address, 0);
                            presaleTime = 0
                            uint8(stor1.field_176) = 1
                        _2163 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2163 + 68] = mem[idx + _2107 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2163 + 68] = mem[_2163 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _2163 + -mem[64] + 100
                    require idx < stor30.length
                    mem[0] = stor30[idx]
                    mem[32] = 27
                    if stor27[stor30[idx]] <= s:
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 26
                        _1373 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1373] = 30
                        mem[_1373 + 32] = 'SafeMath: subtraction overflow'
                        if stor26[stor30[idx]] > t:
                            _1406 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1406 + 68] = mem[idx + _1373 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1406 + 68] = mem[_1406 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _1406 + -mem[64] + 100
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 27
                        _1533 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1533] = 30
                        mem[_1533 + 32] = 'SafeMath: subtraction overflow'
                        if stor27[stor30[idx]] <= s:
                            idx = idx + 1
                            s = s - stor27[stor30[idx]]
                            t = t - stor26[stor30[idx]]
                            continue 
                        _1600 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1600 + 68] = mem[idx + _1533 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1600 + 68] = mem[_1600 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1600 + -mem[64] + 100
                    _1391 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1391] = 26
                    mem[_1391 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _1391 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    _1603 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1603] = 26
                    mem[_1603 + 32] = 'SafeMath: division by zero'
                    if not stor32 / _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _1603 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    _1842 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1842] = 30
                    mem[_1842 + 32] = 'SafeMath: subtraction overflow'
                    if sub_84f44adf > stor26[address(this.address)] / stor32 / _tTotal:
                        _1870 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1870 + 68] = mem[idx + _1842 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1870 + 68] = mem[_1870 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1870 + -mem[64] + 100
                    require ext_code.size(this.address)
                    call this.address.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52, sub_84f44adf
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    uint8(stor1.field_184) = 0
                    mem[mem[64] + 68] = sub_84f44adf
                    mem[mem[64] + 100] = eth.balance(this.address)
                    mem[mem[64] + 132] = this.address
                    mem[mem[64] + 164] = block.timestamp + 300
                    require ext_code.size(0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52)
                    call 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                       value eth.balance(this.address) wei
                         gas gas_remaining wei
                        args this.address, sub_84f44adf, sub_84f44adf, eth.balance(this.address), this.address, block.timestamp + 300
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    stor2 += block.timestamp
                    if not (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf:
                        presaleTime = 0
                        uint8(stor1.field_176) = 1
                    _2072 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2072] = 27
                    mem[_2072 + 32] = 'Burn amount exceeds balance'
                    mem[32] = 26
                    if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf > stor26[this.address]:
                        _2109 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 27
                        idx = 0
                        while idx < 27:
                            mem[idx + _2109 + 68] = mem[idx + _2072 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2109 + 68] = mem[_2109 + 73 len 27]
                        revert with memory
                          from mem[64]
                           len _2109 + -mem[64] + 100
                    mem[0] = this.address
                    mem[32] = 26
                    stor26[this.address] = stor26[this.address] - (stor26[address(this.address)] / stor32 / _tTotal) + sub_84f44adf
                    _2167 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2167] = 30
                    mem[_2167 + 32] = 'SafeMath: subtraction overflow'
                    if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf <= _tTotal:
                        _tTotal = _tTotal - (stor26[address(this.address)] / stor32 / _tTotal) + sub_84f44adf
                        emit Transfer(((stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf), this.address, 0);
                        presaleTime = 0
                        uint8(stor1.field_176) = 1
                    _2226 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _2226 + 68] = mem[idx + _2167 + 32]
                        idx = idx + 32
                        continue 
                    mem[_2226 + 68] = mem[_2226 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _2226 + -mem[64] + 100
                if not _tTotal:
                    revert with 0, 'SafeMath: division by zero'
                if t >= stor32 / _tTotal:
                    if not s:
                        revert with 0, 'SafeMath: division by zero'
                    if not t / s:
                        revert with 0, 'SafeMath: division by zero'
                    if sub_84f44adf > stor26[address(this.address)] / t / s:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require ext_code.size(this.address)
                    call this.address.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52, sub_84f44adf
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    uint8(stor1.field_184) = 0
                    require ext_code.size(0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52)
                    call 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                       value eth.balance(this.address) wei
                         gas gas_remaining wei
                        args this.address, sub_84f44adf, sub_84f44adf, eth.balance(this.address), this.address, block.timestamp + 300
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    stor2 += block.timestamp
                    if (stor26[address(this.address)] / t / s) - sub_84f44adf:
                        if (stor26[address(this.address)] / t / s) - sub_84f44adf > stor26[this.address]:
                            revert with 0, 'Burn amount exceeds balance'
                        stor26[this.address] = stor26[this.address] - (stor26[address(this.address)] / t / s) + sub_84f44adf
                        if (stor26[address(this.address)] / t / s) - sub_84f44adf > _tTotal:
                            revert with 0, 'SafeMath: subtraction overflow'
                        _tTotal = _tTotal - (stor26[address(this.address)] / t / s) + sub_84f44adf
                        emit Transfer(((stor26[address(this.address)] / t / s) - sub_84f44adf), this.address, 0);
                else:
                    if not _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    if not stor32 / _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    if sub_84f44adf > stor26[address(this.address)] / stor32 / _tTotal:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require ext_code.size(this.address)
                    call this.address.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52, sub_84f44adf
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    uint8(stor1.field_184) = 0
                    require ext_code.size(0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52)
                    call 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                       value eth.balance(this.address) wei
                         gas gas_remaining wei
                        args this.address, sub_84f44adf, sub_84f44adf, eth.balance(this.address), this.address, block.timestamp + 300
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    stor2 += block.timestamp
                    if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf:
                        if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf > stor26[this.address]:
                            revert with 0, 'Burn amount exceeds balance'
                        stor26[this.address] = stor26[this.address] - (stor26[address(this.address)] / stor32 / _tTotal) + sub_84f44adf
                        if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf > _tTotal:
                            revert with 0, 'SafeMath: subtraction overflow'
                        _tTotal = _tTotal - (stor26[address(this.address)] / stor32 / _tTotal) + sub_84f44adf
                        emit Transfer(((stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf), this.address, 0);
    else:
        if 30 * eth.balance(this.address) / eth.balance(this.address) != 30:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not eth.balance(this.address):
            mem[64] = 224
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            call stor4 with:
               value 30 * eth.balance(this.address) / 100 wei
                 gas 2300 * is_zero(value) wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            call stor5 with:
                 gas 2300 wei
            uint8(stor1.field_168) = 1
            require not uint8(stor1.field_176)
            if stor29[address(this.address)]:
                if sub_84f44adf > stor27[address(this.address)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                require ext_code.size(this.address)
                call this.address.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52, sub_84f44adf
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                uint8(stor1.field_184) = 0
                require ext_code.size(0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52)
                call 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                   value eth.balance(this.address) wei
                     gas gas_remaining wei
                    args this.address, sub_84f44adf, sub_84f44adf, eth.balance(this.address), this.address, block.timestamp + 300
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                stor2 += block.timestamp
                if stor27[address(this.address)] - sub_84f44adf:
                    if stor27[address(this.address)] - sub_84f44adf > stor26[this.address]:
                        revert with 0, 'Burn amount exceeds balance'
                    stor26[this.address] = stor26[this.address] - stor27[address(this.address)] + sub_84f44adf
                    if stor27[address(this.address)] - sub_84f44adf > _tTotal:
                        revert with 0, 'SafeMath: subtraction overflow'
                    _tTotal = _tTotal - stor27[address(this.address)] + sub_84f44adf
                    emit Transfer((stor27[address(this.address)] - sub_84f44adf), this.address, 0);
            else:
                mem[0] = this.address
                mem[32] = 26
                if stor26[address(this.address)] > stor32:
                    revert with 0, 32, 42, 0x73416d6f756e74206d757374206265206c657373207468616e20746f74616c207265666c656374696f6e, mem[334 len 22]
                idx = 0
                s = _tTotal
                t = stor32
                while idx < stor30.length:
                    mem[0] = stor30[idx]
                    mem[32] = 26
                    if stor26[stor30[idx]] > t:
                        _1352 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1352] = 26
                        mem[_1352 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _1352 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _1523 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1523] = 26
                        mem[_1523 + 32] = 'SafeMath: division by zero'
                        if not stor32 / _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _1523 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _1795 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1795] = 30
                        mem[_1795 + 32] = 'SafeMath: subtraction overflow'
                        if sub_84f44adf > stor26[address(this.address)] / stor32 / _tTotal:
                            _1833 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1833 + 68] = mem[idx + _1795 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1833 + 68] = mem[_1833 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _1833 + -mem[64] + 100
                        require ext_code.size(this.address)
                        call this.address.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52, sub_84f44adf
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        uint8(stor1.field_184) = 0
                        mem[mem[64] + 68] = sub_84f44adf
                        mem[mem[64] + 100] = eth.balance(this.address)
                        mem[mem[64] + 132] = this.address
                        mem[mem[64] + 164] = block.timestamp + 300
                        require ext_code.size(0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52)
                        call 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                           value eth.balance(this.address) wei
                             gas gas_remaining wei
                            args this.address, sub_84f44adf, sub_84f44adf, eth.balance(this.address), this.address, block.timestamp + 300
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 96
                        stor2 += block.timestamp
                        if not (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf:
                            presaleTime = 0
                            uint8(stor1.field_176) = 1
                        _2036 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2036] = 27
                        mem[_2036 + 32] = 'Burn amount exceeds balance'
                        mem[32] = 26
                        if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf > stor26[this.address]:
                            _2062 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 27
                            idx = 0
                            while idx < 27:
                                mem[idx + _2062 + 68] = mem[idx + _2036 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2062 + 68] = mem[_2062 + 73 len 27]
                            revert with memory
                              from mem[64]
                               len _2062 + -mem[64] + 100
                        mem[0] = this.address
                        mem[32] = 26
                        stor26[this.address] = stor26[this.address] - (stor26[address(this.address)] / stor32 / _tTotal) + sub_84f44adf
                        _2098 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2098] = 30
                        mem[_2098 + 32] = 'SafeMath: subtraction overflow'
                        if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf <= _tTotal:
                            _tTotal = _tTotal - (stor26[address(this.address)] / stor32 / _tTotal) + sub_84f44adf
                            emit Transfer(((stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf), this.address, 0);
                            presaleTime = 0
                            uint8(stor1.field_176) = 1
                        _2151 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2151 + 68] = mem[idx + _2098 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2151 + 68] = mem[_2151 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _2151 + -mem[64] + 100
                    require idx < stor30.length
                    mem[0] = stor30[idx]
                    mem[32] = 27
                    if stor27[stor30[idx]] <= s:
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 26
                        _1370 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1370] = 30
                        mem[_1370 + 32] = 'SafeMath: subtraction overflow'
                        if stor26[stor30[idx]] > t:
                            _1402 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1402 + 68] = mem[idx + _1370 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1402 + 68] = mem[_1402 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _1402 + -mem[64] + 100
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 27
                        _1525 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1525] = 30
                        mem[_1525 + 32] = 'SafeMath: subtraction overflow'
                        if stor27[stor30[idx]] <= s:
                            idx = idx + 1
                            s = s - stor27[stor30[idx]]
                            t = t - stor26[stor30[idx]]
                            continue 
                        _1588 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1588 + 68] = mem[idx + _1525 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1588 + 68] = mem[_1588 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1588 + -mem[64] + 100
                    _1386 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1386] = 26
                    mem[_1386 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _1386 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    _1591 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1591] = 26
                    mem[_1591 + 32] = 'SafeMath: division by zero'
                    if not stor32 / _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _1591 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    _1836 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1836] = 30
                    mem[_1836 + 32] = 'SafeMath: subtraction overflow'
                    if sub_84f44adf > stor26[address(this.address)] / stor32 / _tTotal:
                        _1862 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1862 + 68] = mem[idx + _1836 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1862 + 68] = mem[_1862 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1862 + -mem[64] + 100
                    require ext_code.size(this.address)
                    call this.address.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52, sub_84f44adf
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    uint8(stor1.field_184) = 0
                    mem[mem[64] + 68] = sub_84f44adf
                    mem[mem[64] + 100] = eth.balance(this.address)
                    mem[mem[64] + 132] = this.address
                    mem[mem[64] + 164] = block.timestamp + 300
                    require ext_code.size(0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52)
                    call 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                       value eth.balance(this.address) wei
                         gas gas_remaining wei
                        args this.address, sub_84f44adf, sub_84f44adf, eth.balance(this.address), this.address, block.timestamp + 300
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    stor2 += block.timestamp
                    if not (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf:
                        presaleTime = 0
                        uint8(stor1.field_176) = 1
                    _2065 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2065] = 27
                    mem[_2065 + 32] = 'Burn amount exceeds balance'
                    mem[32] = 26
                    if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf > stor26[this.address]:
                        _2100 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 27
                        idx = 0
                        while idx < 27:
                            mem[idx + _2100 + 68] = mem[idx + _2065 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2100 + 68] = mem[_2100 + 73 len 27]
                        revert with memory
                          from mem[64]
                           len _2100 + -mem[64] + 100
                    mem[0] = this.address
                    mem[32] = 26
                    stor26[this.address] = stor26[this.address] - (stor26[address(this.address)] / stor32 / _tTotal) + sub_84f44adf
                    _2155 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2155] = 30
                    mem[_2155 + 32] = 'SafeMath: subtraction overflow'
                    if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf <= _tTotal:
                        _tTotal = _tTotal - (stor26[address(this.address)] / stor32 / _tTotal) + sub_84f44adf
                        emit Transfer(((stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf), this.address, 0);
                        presaleTime = 0
                        uint8(stor1.field_176) = 1
                    _2215 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _2215 + 68] = mem[idx + _2155 + 32]
                        idx = idx + 32
                        continue 
                    mem[_2215 + 68] = mem[_2215 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _2215 + -mem[64] + 100
                if not _tTotal:
                    revert with 0, 'SafeMath: division by zero'
                if t >= stor32 / _tTotal:
                    if not s:
                        revert with 0, 'SafeMath: division by zero'
                    if not t / s:
                        revert with 0, 'SafeMath: division by zero'
                    if sub_84f44adf > stor26[address(this.address)] / t / s:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require ext_code.size(this.address)
                    call this.address.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52, sub_84f44adf
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    uint8(stor1.field_184) = 0
                    require ext_code.size(0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52)
                    call 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                       value eth.balance(this.address) wei
                         gas gas_remaining wei
                        args this.address, sub_84f44adf, sub_84f44adf, eth.balance(this.address), this.address, block.timestamp + 300
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    stor2 += block.timestamp
                    if (stor26[address(this.address)] / t / s) - sub_84f44adf:
                        if (stor26[address(this.address)] / t / s) - sub_84f44adf > stor26[this.address]:
                            revert with 0, 'Burn amount exceeds balance'
                        stor26[this.address] = stor26[this.address] - (stor26[address(this.address)] / t / s) + sub_84f44adf
                        if (stor26[address(this.address)] / t / s) - sub_84f44adf > _tTotal:
                            revert with 0, 'SafeMath: subtraction overflow'
                        _tTotal = _tTotal - (stor26[address(this.address)] / t / s) + sub_84f44adf
                        emit Transfer(((stor26[address(this.address)] / t / s) - sub_84f44adf), this.address, 0);
                else:
                    if not _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    if not stor32 / _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    if sub_84f44adf > stor26[address(this.address)] / stor32 / _tTotal:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require ext_code.size(this.address)
                    call this.address.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52, sub_84f44adf
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    uint8(stor1.field_184) = 0
                    require ext_code.size(0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52)
                    call 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                       value eth.balance(this.address) wei
                         gas gas_remaining wei
                        args this.address, sub_84f44adf, sub_84f44adf, eth.balance(this.address), this.address, block.timestamp + 300
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    stor2 += block.timestamp
                    if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf:
                        if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf > stor26[this.address]:
                            revert with 0, 'Burn amount exceeds balance'
                        stor26[this.address] = stor26[this.address] - (stor26[address(this.address)] / stor32 / _tTotal) + sub_84f44adf
                        if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf > _tTotal:
                            revert with 0, 'SafeMath: subtraction overflow'
                        _tTotal = _tTotal - (stor26[address(this.address)] / stor32 / _tTotal) + sub_84f44adf
                        emit Transfer(((stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf), this.address, 0);
        else:
            if 20 * eth.balance(this.address) / eth.balance(this.address) != 20:
                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            mem[64] = 224
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            call stor4 with:
               value 30 * eth.balance(this.address) / 100 wei
                 gas 2300 * is_zero(value) wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            call stor5 with:
               value 20 * eth.balance(this.address) / 100 wei
                 gas 2300 * is_zero(value) wei
            uint8(stor1.field_168) = 1
            require not uint8(stor1.field_176)
            if stor29[address(this.address)]:
                if sub_84f44adf > stor27[address(this.address)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                require ext_code.size(this.address)
                call this.address.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52, sub_84f44adf
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                uint8(stor1.field_184) = 0
                require ext_code.size(0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52)
                call 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                   value eth.balance(this.address) wei
                     gas gas_remaining wei
                    args this.address, sub_84f44adf, sub_84f44adf, eth.balance(this.address), this.address, block.timestamp + 300
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                stor2 += block.timestamp
                if stor27[address(this.address)] - sub_84f44adf:
                    if stor27[address(this.address)] - sub_84f44adf > stor26[this.address]:
                        revert with 0, 'Burn amount exceeds balance'
                    stor26[this.address] = stor26[this.address] - stor27[address(this.address)] + sub_84f44adf
                    if stor27[address(this.address)] - sub_84f44adf > _tTotal:
                        revert with 0, 'SafeMath: subtraction overflow'
                    _tTotal = _tTotal - stor27[address(this.address)] + sub_84f44adf
                    emit Transfer((stor27[address(this.address)] - sub_84f44adf), this.address, 0);
            else:
                mem[0] = this.address
                mem[32] = 26
                if stor26[address(this.address)] > stor32:
                    revert with 0, 32, 42, 0x73416d6f756e74206d757374206265206c657373207468616e20746f74616c207265666c656374696f6e, mem[334 len 22]
                idx = 0
                s = _tTotal
                t = stor32
                while idx < stor30.length:
                    mem[0] = stor30[idx]
                    mem[32] = 26
                    if stor26[stor30[idx]] > t:
                        _1347 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1347] = 26
                        mem[_1347 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _1347 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _1515 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1515] = 26
                        mem[_1515 + 32] = 'SafeMath: division by zero'
                        if not stor32 / _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _1515 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _1789 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1789] = 30
                        mem[_1789 + 32] = 'SafeMath: subtraction overflow'
                        if sub_84f44adf > stor26[address(this.address)] / stor32 / _tTotal:
                            _1827 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1827 + 68] = mem[idx + _1789 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1827 + 68] = mem[_1827 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _1827 + -mem[64] + 100
                        require ext_code.size(this.address)
                        call this.address.approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52, sub_84f44adf
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        uint8(stor1.field_184) = 0
                        mem[mem[64] + 68] = sub_84f44adf
                        mem[mem[64] + 100] = eth.balance(this.address)
                        mem[mem[64] + 132] = this.address
                        mem[mem[64] + 164] = block.timestamp + 300
                        require ext_code.size(0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52)
                        call 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                           value eth.balance(this.address) wei
                             gas gas_remaining wei
                            args this.address, sub_84f44adf, sub_84f44adf, eth.balance(this.address), this.address, block.timestamp + 300
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 96
                        stor2 += block.timestamp
                        if not (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf:
                            presaleTime = 0
                            uint8(stor1.field_176) = 1
                        _2029 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2029] = 27
                        mem[_2029 + 32] = 'Burn amount exceeds balance'
                        mem[32] = 26
                        if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf > stor26[this.address]:
                            _2055 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 27
                            idx = 0
                            while idx < 27:
                                mem[idx + _2055 + 68] = mem[idx + _2029 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2055 + 68] = mem[_2055 + 73 len 27]
                            revert with memory
                              from mem[64]
                               len _2055 + -mem[64] + 100
                        mem[0] = this.address
                        mem[32] = 26
                        stor26[this.address] = stor26[this.address] - (stor26[address(this.address)] / stor32 / _tTotal) + sub_84f44adf
                        _2089 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2089] = 30
                        mem[_2089 + 32] = 'SafeMath: subtraction overflow'
                        if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf <= _tTotal:
                            _tTotal = _tTotal - (stor26[address(this.address)] / stor32 / _tTotal) + sub_84f44adf
                            emit Transfer(((stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf), this.address, 0);
                            presaleTime = 0
                            uint8(stor1.field_176) = 1
                        _2139 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2139 + 68] = mem[idx + _2089 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2139 + 68] = mem[_2139 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _2139 + -mem[64] + 100
                    require idx < stor30.length
                    mem[0] = stor30[idx]
                    mem[32] = 27
                    if stor27[stor30[idx]] <= s:
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 26
                        _1367 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1367] = 30
                        mem[_1367 + 32] = 'SafeMath: subtraction overflow'
                        if stor26[stor30[idx]] > t:
                            _1398 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1398 + 68] = mem[idx + _1367 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1398 + 68] = mem[_1398 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _1398 + -mem[64] + 100
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 27
                        _1517 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1517] = 30
                        mem[_1517 + 32] = 'SafeMath: subtraction overflow'
                        if stor27[stor30[idx]] <= s:
                            idx = idx + 1
                            s = s - stor27[stor30[idx]]
                            t = t - stor26[stor30[idx]]
                            continue 
                        _1576 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1576 + 68] = mem[idx + _1517 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1576 + 68] = mem[_1576 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1576 + -mem[64] + 100
                    _1381 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1381] = 26
                    mem[_1381 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _1381 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    _1579 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1579] = 26
                    mem[_1579 + 32] = 'SafeMath: division by zero'
                    if not stor32 / _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _1579 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    _1830 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1830] = 30
                    mem[_1830 + 32] = 'SafeMath: subtraction overflow'
                    if sub_84f44adf > stor26[address(this.address)] / stor32 / _tTotal:
                        _1854 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1854 + 68] = mem[idx + _1830 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1854 + 68] = mem[_1854 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1854 + -mem[64] + 100
                    require ext_code.size(this.address)
                    call this.address.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52, sub_84f44adf
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    uint8(stor1.field_184) = 0
                    mem[mem[64] + 68] = sub_84f44adf
                    mem[mem[64] + 100] = eth.balance(this.address)
                    mem[mem[64] + 132] = this.address
                    mem[mem[64] + 164] = block.timestamp + 300
                    require ext_code.size(0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52)
                    call 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                       value eth.balance(this.address) wei
                         gas gas_remaining wei
                        args this.address, sub_84f44adf, sub_84f44adf, eth.balance(this.address), this.address, block.timestamp + 300
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    stor2 += block.timestamp
                    if not (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf:
                        presaleTime = 0
                        uint8(stor1.field_176) = 1
                    _2058 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2058] = 27
                    mem[_2058 + 32] = 'Burn amount exceeds balance'
                    mem[32] = 26
                    if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf > stor26[this.address]:
                        _2091 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 27
                        idx = 0
                        while idx < 27:
                            mem[idx + _2091 + 68] = mem[idx + _2058 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2091 + 68] = mem[_2091 + 73 len 27]
                        revert with memory
                          from mem[64]
                           len _2091 + -mem[64] + 100
                    mem[0] = this.address
                    mem[32] = 26
                    stor26[this.address] = stor26[this.address] - (stor26[address(this.address)] / stor32 / _tTotal) + sub_84f44adf
                    _2143 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2143] = 30
                    mem[_2143 + 32] = 'SafeMath: subtraction overflow'
                    if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf <= _tTotal:
                        _tTotal = _tTotal - (stor26[address(this.address)] / stor32 / _tTotal) + sub_84f44adf
                        emit Transfer(((stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf), this.address, 0);
                        presaleTime = 0
                        uint8(stor1.field_176) = 1
                    _2204 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _2204 + 68] = mem[idx + _2143 + 32]
                        idx = idx + 32
                        continue 
                    mem[_2204 + 68] = mem[_2204 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _2204 + -mem[64] + 100
                if not _tTotal:
                    revert with 0, 'SafeMath: division by zero'
                if t >= stor32 / _tTotal:
                    if not s:
                        revert with 0, 'SafeMath: division by zero'
                    if not t / s:
                        revert with 0, 'SafeMath: division by zero'
                    if sub_84f44adf > stor26[address(this.address)] / t / s:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require ext_code.size(this.address)
                    call this.address.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52, sub_84f44adf
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    uint8(stor1.field_184) = 0
                    require ext_code.size(0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52)
                    call 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                       value eth.balance(this.address) wei
                         gas gas_remaining wei
                        args this.address, sub_84f44adf, sub_84f44adf, eth.balance(this.address), this.address, block.timestamp + 300
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    stor2 += block.timestamp
                    if (stor26[address(this.address)] / t / s) - sub_84f44adf:
                        if (stor26[address(this.address)] / t / s) - sub_84f44adf > stor26[this.address]:
                            revert with 0, 'Burn amount exceeds balance'
                        stor26[this.address] = stor26[this.address] - (stor26[address(this.address)] / t / s) + sub_84f44adf
                        if (stor26[address(this.address)] / t / s) - sub_84f44adf > _tTotal:
                            revert with 0, 'SafeMath: subtraction overflow'
                        _tTotal = _tTotal - (stor26[address(this.address)] / t / s) + sub_84f44adf
                        emit Transfer(((stor26[address(this.address)] / t / s) - sub_84f44adf), this.address, 0);
                else:
                    if not _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    if not stor32 / _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    if sub_84f44adf > stor26[address(this.address)] / stor32 / _tTotal:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require ext_code.size(this.address)
                    call this.address.approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52, sub_84f44adf
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    uint8(stor1.field_184) = 0
                    require ext_code.size(0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52)
                    call 0x16327e3fbdaca3bcf7e38f5af2599d2ddc33ae52.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                       value eth.balance(this.address) wei
                         gas gas_remaining wei
                        args this.address, sub_84f44adf, sub_84f44adf, eth.balance(this.address), this.address, block.timestamp + 300
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    stor2 += block.timestamp
                    if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf:
                        if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf > stor26[this.address]:
                            revert with 0, 'Burn amount exceeds balance'
                        stor26[this.address] = stor26[this.address] - (stor26[address(this.address)] / stor32 / _tTotal) + sub_84f44adf
                        if (stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf > _tTotal:
                            revert with 0, 'SafeMath: subtraction overflow'
                        _tTotal = _tTotal - (stor26[address(this.address)] / stor32 / _tTotal) + sub_84f44adf
                        emit Transfer(((stor26[address(this.address)] / stor32 / _tTotal) - sub_84f44adf), this.address, 0);
    presaleTime = 0
    uint8(stor1.field_176) = 1
}

function buyTokens() payable {
    if stor0 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor0 = 2
    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(msg.sender):
        if presaleTime <= 0:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        34,
                        0x6f50726573616c65206e6f74206163746976652c2063616e6e6f7420627579207965,
                        mem[198 len 30]
        if presaleTime > block.timestamp:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        34,
                        0x6f50726573616c65206e6f74206163746976652c2063616e6e6f7420627579207965,
                        mem[198 len 30]
        if msg.value < 10^18:
            revert with 0, 'You sent less than 1 FTM'
        if msg.value > 1000 * 10^18:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        44,
                        0x73596f752073656e74206d6f7265207468616e20746865206d617820313030302046544d2070657220757365,
                        mem[208 len 20]
        if ethSent >= 10^18 * presaleHardcap:
            revert with 0, 'Hard cap reached'
        if ethSent + msg.value < msg.value:
            revert with 0, 'SafeMath: addition overflow'
        if ethSent + msg.value >= 10^18 * presaleHardcap:
            revert with 0, 'Hardcap will be breached'
        if msg.value + sub_536c8c02[msg.sender] < sub_536c8c02[msg.sender]:
            revert with 0, 'SafeMath: addition overflow'
        if msg.value + sub_536c8c02[msg.sender] > 1000 * 10^18:
            revert with 0, 'You cannot buy that much more'
        if not msg.value:
            mem[96] = 26
            mem[128] = 'SafeMath: division by zero'
            mem[64] = 224
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if stor29[address(this.address)]:
                if stor27[address(this.address)] < 0:
                    revert with 0, 32, 33, 0x774e6f7420656e6f75676820746f6b656e7320696e2074686520636f6e74726163, mem[325 len 31]
                if msg.value + sub_536c8c02[msg.sender] < sub_536c8c02[msg.sender]:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = msg.sender
                mem[32] = 20
                sub_536c8c02[msg.sender] += msg.value
                if msg.value + ethSent < ethSent:
                    revert with 0, 'SafeMath: addition overflow'
                ethSent += msg.value
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[64] = 352
                mem[288] = 30
                mem[320] = 'SafeMath: subtraction overflow'
                idx = 0
                s = _tTotal
                t = stor32
                while idx < stor30.length:
                    mem[0] = stor30[idx]
                    mem[32] = 26
                    if stor26[stor30[idx]] > t:
                        _28881 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28881] = 26
                        mem[_28881 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _28881 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _29793 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29793] = 30
                        mem[_29793 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = this.address
                        mem[32] = 26
                        _30110 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30110] = 30
                        mem[_30110 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor26[address(this.address)]:
                            _30224 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30224 + 68] = mem[idx + _30110 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30224 + 68] = mem[_30224 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _30224 + -mem[64] + 100
                        if stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = stor26[msg.sender]
                        _30839 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30839] = 30
                        mem[_30839 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            _31017 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31017 + 68] = mem[idx + _30839 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31017 + 68] = mem[_31017 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _31017 + -mem[64] + 100
                        if _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(0, this.address, msg.sender);
                        _31636 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31636] = 26
                        mem[_31636 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _31636 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _34338 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34338] = 30
                            mem[_34338 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _34927 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _34927 + 68] = mem[idx + _34338 + 32]
                                idx = idx + 32
                                continue 
                            mem[_34927 + 68] = mem[_34927 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _34927 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _34654 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34654] = 30
                            mem[_34654 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _35181 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _35181 + 68] = mem[idx + _34654 + 32]
                                idx = idx + 32
                                continue 
                            mem[_35181 + 68] = mem[_35181 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _35181 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _34926 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34926] = 30
                        mem[_34926 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        _35424 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35424 + 68] = mem[idx + _34926 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35424 + 68] = mem[_35424 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _35424 + -mem[64] + 100
                    require idx < stor30.length
                    mem[0] = stor30[idx]
                    mem[32] = 27
                    if stor27[stor30[idx]] <= s:
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 26
                        _28923 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28923] = 30
                        mem[_28923 + 32] = 'SafeMath: subtraction overflow'
                        if stor26[stor30[idx]] > t:
                            _29006 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29006 + 68] = mem[idx + _28923 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29006 + 68] = mem[_29006 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _29006 + -mem[64] + 100
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 27
                        _29312 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29312] = 30
                        mem[_29312 + 32] = 'SafeMath: subtraction overflow'
                        if stor27[stor30[idx]] <= s:
                            idx = idx + 1
                            s = s - stor27[stor30[idx]]
                            t = t - stor26[stor30[idx]]
                            continue 
                        _29457 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29457 + 68] = mem[idx + _29312 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29457 + 68] = mem[_29457 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _29457 + -mem[64] + 100
                    _28963 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28963] = 26
                    mem[_28963 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _28963 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    _29860 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29860] = 30
                    mem[_29860 + 32] = 'SafeMath: subtraction overflow'
                    mem[0] = this.address
                    mem[32] = 26
                    _30227 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30227] = 30
                    mem[_30227 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor26[address(this.address)]:
                        _30376 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30376 + 68] = mem[idx + _30227 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30376 + 68] = mem[_30376 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _30376 + -mem[64] + 100
                    if stor26[msg.sender] < stor26[msg.sender]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = msg.sender
                    mem[32] = 26
                    stor26[address(msg.sender)] = stor26[msg.sender]
                    _31020 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31020] = 30
                    mem[_31020 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor32:
                        _31138 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _31138 + 68] = mem[idx + _31020 + 32]
                            idx = idx + 32
                            continue 
                        mem[_31138 + 68] = mem[_31138 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _31138 + -mem[64] + 100
                    if _tFeeTotal < _tFeeTotal:
                        revert with 0, 'SafeMath: addition overflow'
                    emit Transfer(0, this.address, msg.sender);
                    _31814 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31814] = 26
                    mem[_31814 + 32] = 'SafeMath: division by zero'
                    if not sub_1b2cabba:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _31814 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if not sub_8a3be0b6:
                        if ethSent <= 0:
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _34932 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34932] = 30
                        mem[_34932 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        _35429 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35429 + 68] = mem[idx + _34932 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35429 + 68] = mem[_35429 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _35429 + -mem[64] + 100
                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                        if ethSent <= 0:
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _35184 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35184] = 30
                        mem[_35184 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        _35664 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35664 + 68] = mem[idx + _35184 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35664 + 68] = mem[_35664 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _35664 + -mem[64] + 100
                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                        emit Transfer(0, this.address, msg.sender);
                        stor0 = 1
                    if timeBetweenRounds + block.timestamp < block.timestamp:
                        revert with 0, 'SafeMath: addition overflow'
                    presaleTime = timeBetweenRounds + block.timestamp
                    sub_8a3be0b6++
                    _35428 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35428] = 30
                    mem[_35428 + 32] = 'SafeMath: subtraction overflow'
                    if sub_be71ce9f <= sub_49a6a335:
                        sub_49a6a335 -= sub_be71ce9f
                        emit Transfer(0, this.address, msg.sender);
                        stor0 = 1
                    _35904 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35904 + 68] = mem[idx + _35428 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35904 + 68] = mem[_35904 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _35904 + -mem[64] + 100
                _28753 = mem[64]
                mem[64] = mem[64] + 64
                mem[_28753] = 26
                mem[_28753 + 32] = 'SafeMath: division by zero'
                if not _tTotal:
                    revert with 0, 'SafeMath: division by zero'
                if t >= stor32 / _tTotal:
                    _29057 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29057] = 26
                    mem[_29057 + 32] = 'SafeMath: division by zero'
                    if not s:
                        revert with 0, 'SafeMath: division by zero'
                    _29945 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29945] = 30
                    mem[_29945 + 32] = 'SafeMath: subtraction overflow'
                    mem[0] = this.address
                    mem[32] = 26
                    _30371 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30371] = 30
                    mem[_30371 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor26[address(this.address)]:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if stor26[msg.sender] < stor26[msg.sender]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = msg.sender
                    mem[32] = 26
                    stor26[address(msg.sender)] = stor26[msg.sender]
                    _31135 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31135] = 30
                    mem[_31135 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor32:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if _tFeeTotal < _tFeeTotal:
                        revert with 0, 'SafeMath: addition overflow'
                    emit Transfer(0, this.address, msg.sender);
                    _31958 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31958] = 26
                    mem[_31958 + 32] = 'SafeMath: division by zero'
                else:
                    _29058 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29058] = 26
                    mem[_29058 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    _29946 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29946] = 30
                    mem[_29946 + 32] = 'SafeMath: subtraction overflow'
                    mem[0] = this.address
                    mem[32] = 26
                    _30372 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30372] = 30
                    mem[_30372 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor26[address(this.address)]:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if stor26[msg.sender] < stor26[msg.sender]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = msg.sender
                    mem[32] = 26
                    stor26[address(msg.sender)] = stor26[msg.sender]
                    _31136 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31136] = 30
                    mem[_31136 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor32:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if _tFeeTotal < _tFeeTotal:
                        revert with 0, 'SafeMath: addition overflow'
                    emit Transfer(0, this.address, msg.sender);
                    _31959 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31959] = 26
                    mem[_31959 + 32] = 'SafeMath: division by zero'
            else:
                mem[0] = this.address
                mem[32] = 26
                if stor26[address(this.address)] > stor32:
                    revert with 0, 32, 42, 0x73416d6f756e74206d757374206265206c657373207468616e20746f74616c207265666c656374696f6e, mem[334 len 22]
                idx = 0
                s = _tTotal
                t = stor32
                while idx < stor30.length:
                    mem[0] = stor30[idx]
                    mem[32] = 26
                    if stor26[stor30[idx]] > t:
                        _28876 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28876] = 26
                        mem[_28876 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _28876 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _29303 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29303] = 26
                        mem[_29303 + 32] = 'SafeMath: division by zero'
                        if not stor32 / _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _29303 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if stor26[address(this.address)] / stor32 / _tTotal < 0:
                            revert with 0, 32, 33, 0x774e6f7420656e6f75676820746f6b656e7320696e2074686520636f6e74726163, mem[mem[64] + 101 len 31]
                        if msg.value + sub_536c8c02[msg.sender] < sub_536c8c02[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 20
                        sub_536c8c02[msg.sender] += msg.value
                        if msg.value + ethSent < ethSent:
                            revert with 0, 'SafeMath: addition overflow'
                        ethSent += msg.value
                        _30296 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30296] = 26
                        mem[_30296 + 32] = 'SafeMath: division by zero'
                        _31134 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31134] = 30
                        mem[_31134 + 32] = 'SafeMath: subtraction overflow'
                        idx = 0
                        s = _tTotal
                        t = stor32
                        while idx < stor30.length:
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            if stor26[stor30[idx]] > t:
                                _59529 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59529] = 26
                                mem[_59529 + 32] = 'SafeMath: division by zero'
                                if not _tTotal:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _59529 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                _61391 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61391] = 30
                                mem[_61391 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _62131 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62131] = 30
                                mem[_62131 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _62529 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62529 + 68] = mem[idx + _62131 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62529 + 68] = mem[_62529 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62529 + -mem[64] + 100
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _64885 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_64885] = 30
                                mem[_64885 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _65603 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _65603 + 68] = mem[idx + _64885 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_65603 + 68] = mem[_65603 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _65603 + -mem[64] + 100
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(0, this.address, msg.sender);
                                _67745 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_67745] = 26
                                mem[_67745 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _67745 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer(0, this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _72973 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_72973] = 30
                                    mem[_72973 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer(0, this.address, msg.sender);
                                        stor0 = 1
                                    _73968 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _73968 + 68] = mem[idx + _72973 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_73968 + 68] = mem[_73968 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _73968 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer(0, this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73483 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73483] = 30
                                    mem[_73483 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer(0, this.address, msg.sender);
                                        stor0 = 1
                                    _74481 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74481 + 68] = mem[idx + _73483 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74481 + 68] = mem[_74481 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74481 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _73967 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_73967] = 30
                                mem[_73967 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                _75035 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75035 + 68] = mem[idx + _73967 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75035 + 68] = mem[_75035 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75035 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            if stor27[stor30[idx]] <= s:
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 26
                                _59629 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59629] = 30
                                mem[_59629 + 32] = 'SafeMath: subtraction overflow'
                                if stor26[stor30[idx]] > t:
                                    _59830 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _59830 + 68] = mem[idx + _59629 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59830 + 68] = mem[_59830 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59830 + -mem[64] + 100
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 27
                                _60558 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_60558] = 30
                                mem[_60558 + 32] = 'SafeMath: subtraction overflow'
                                if stor27[stor30[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor27[stor30[idx]]
                                    t = t - stor26[stor30[idx]]
                                    continue 
                                _60881 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _60881 + 68] = mem[idx + _60558 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_60881 + 68] = mem[_60881 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _60881 + -mem[64] + 100
                            _59723 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59723] = 26
                            mem[_59723 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59723 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            _61475 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61475] = 30
                            mem[_61475 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = this.address
                            mem[32] = 26
                            _62532 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_62532] = 30
                            mem[_62532 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                _63082 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63082 + 68] = mem[idx + _62532 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63082 + 68] = mem[_63082 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63082 + -mem[64] + 100
                            if stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = stor26[msg.sender]
                            _65606 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_65606] = 30
                            mem[_65606 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _66060 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66060 + 68] = mem[idx + _65606 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66060 + 68] = mem[_66060 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66060 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(0, this.address, msg.sender);
                            _68312 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68312] = 26
                            mem[_68312 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68312 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _73973 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_73973] = 30
                                mem[_73973 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                _75040 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75040 + 68] = mem[idx + _73973 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75040 + 68] = mem[_75040 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75040 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74484 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74484] = 30
                                mem[_74484 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                _75672 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75672 + 68] = mem[idx + _74484 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75672 + 68] = mem[_75672 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75672 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75039 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75039] = 30
                            mem[_75039 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _76375 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _76375 + 68] = mem[idx + _75039 + 32]
                                idx = idx + 32
                                continue 
                            mem[_76375 + 68] = mem[_76375 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _76375 + -mem[64] + 100
                        _58229 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_58229] = 26
                        mem[_58229 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _58229 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor32 / _tTotal:
                            _59955 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59955] = 26
                            mem[_59955 + 32] = 'SafeMath: division by zero'
                            if not s:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59955 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            _61681 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61681] = 30
                            mem[_61681 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = this.address
                            mem[32] = 26
                            _63077 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_63077] = 30
                            mem[_63077 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                _63717 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63717 + 68] = mem[idx + _63077 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63717 + 68] = mem[_63717 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63717 + -mem[64] + 100
                            if stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = stor26[msg.sender]
                            _66057 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_66057] = 30
                            mem[_66057 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _66505 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66505 + 68] = mem[idx + _66057 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66505 + 68] = mem[_66505 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66505 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(0, this.address, msg.sender);
                            _68783 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68783] = 26
                            mem[_68783 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68783 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75031 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75031] = 30
                                mem[_75031 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                _76362 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76362 + 68] = mem[idx + _75031 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76362 + 68] = mem[_76362 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76362 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75665 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75665] = 30
                                mem[_75665 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                _77205 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77205 + 68] = mem[idx + _75665 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77205 + 68] = mem[_77205 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77205 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _76361 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_76361] = 30
                            mem[_76361 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _78099 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _78099 + 68] = mem[idx + _76361 + 32]
                                idx = idx + 32
                                continue 
                            mem[_78099 + 68] = mem[_78099 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _78099 + -mem[64] + 100
                        _59956 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_59956] = 26
                        mem[_59956 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _59956 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _61682 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61682] = 30
                        mem[_61682 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = this.address
                        mem[32] = 26
                        _63078 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_63078] = 30
                        mem[_63078 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor26[address(this.address)]:
                            _63720 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _63720 + 68] = mem[idx + _63078 + 32]
                                idx = idx + 32
                                continue 
                            mem[_63720 + 68] = mem[_63720 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _63720 + -mem[64] + 100
                        if stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = stor26[msg.sender]
                        _66058 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_66058] = 30
                        mem[_66058 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            _66508 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _66508 + 68] = mem[idx + _66058 + 32]
                                idx = idx + 32
                                continue 
                            mem[_66508 + 68] = mem[_66508 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _66508 + -mem[64] + 100
                        if _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(0, this.address, msg.sender);
                        _68784 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_68784] = 26
                        mem[_68784 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _68784 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75034 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75034] = 30
                            mem[_75034 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _76366 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _76366 + 68] = mem[idx + _75034 + 32]
                                idx = idx + 32
                                continue 
                            mem[_76366 + 68] = mem[_76366 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _76366 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75666 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75666] = 30
                            mem[_75666 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _77208 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77208 + 68] = mem[idx + _75666 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77208 + 68] = mem[_77208 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77208 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _76365 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_76365] = 30
                        mem[_76365 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        _78103 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _78103 + 68] = mem[idx + _76365 + 32]
                            idx = idx + 32
                            continue 
                        mem[_78103 + 68] = mem[_78103 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _78103 + -mem[64] + 100
                    require idx < stor30.length
                    mem[0] = stor30[idx]
                    mem[32] = 27
                    if stor27[stor30[idx]] <= s:
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 26
                        _28920 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28920] = 30
                        mem[_28920 + 32] = 'SafeMath: subtraction overflow'
                        if stor26[stor30[idx]] > t:
                            _29002 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29002 + 68] = mem[idx + _28920 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29002 + 68] = mem[_29002 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _29002 + -mem[64] + 100
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 27
                        _29305 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29305] = 30
                        mem[_29305 + 32] = 'SafeMath: subtraction overflow'
                        if stor27[stor30[idx]] <= s:
                            idx = idx + 1
                            s = s - stor27[stor30[idx]]
                            t = t - stor26[stor30[idx]]
                            continue 
                        _29448 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29448 + 68] = mem[idx + _29305 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29448 + 68] = mem[_29448 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _29448 + -mem[64] + 100
                    _28958 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28958] = 26
                    mem[_28958 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _28958 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    _29451 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29451] = 26
                    mem[_29451 + 32] = 'SafeMath: division by zero'
                    if not stor32 / _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _29451 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if stor26[address(this.address)] / stor32 / _tTotal < 0:
                        revert with 0, 32, 33, 0x774e6f7420656e6f75676820746f6b656e7320696e2074686520636f6e74726163, mem[mem[64] + 101 len 31]
                    if msg.value + sub_536c8c02[msg.sender] < sub_536c8c02[msg.sender]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = msg.sender
                    mem[32] = 20
                    sub_536c8c02[msg.sender] += msg.value
                    if msg.value + ethSent < ethSent:
                        revert with 0, 'SafeMath: addition overflow'
                    ethSent += msg.value
                    _30456 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30456] = 26
                    mem[_30456 + 32] = 'SafeMath: division by zero'
                    _31257 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31257] = 30
                    mem[_31257 + 32] = 'SafeMath: subtraction overflow'
                    idx = 0
                    s = _tTotal
                    t = stor32
                    while idx < stor30.length:
                        mem[0] = stor30[idx]
                        mem[32] = 26
                        if stor26[stor30[idx]] > t:
                            _59534 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59534] = 26
                            mem[_59534 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59534 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            _61392 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61392] = 30
                            mem[_61392 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = this.address
                            mem[32] = 26
                            _62132 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_62132] = 30
                            mem[_62132 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                _62533 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _62533 + 68] = mem[idx + _62132 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_62533 + 68] = mem[_62533 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _62533 + -mem[64] + 100
                            if stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = stor26[msg.sender]
                            _64891 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_64891] = 30
                            mem[_64891 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _65609 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _65609 + 68] = mem[idx + _64891 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_65609 + 68] = mem[_65609 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _65609 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(0, this.address, msg.sender);
                            _67754 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_67754] = 26
                            mem[_67754 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _67754 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _72982 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_72982] = 30
                                mem[_72982 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                _73979 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _73979 + 68] = mem[idx + _72982 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_73979 + 68] = mem[_73979 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _73979 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _73490 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_73490] = 30
                                mem[_73490 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                _74489 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _74489 + 68] = mem[idx + _73490 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_74489 + 68] = mem[_74489 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _74489 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _73978 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_73978] = 30
                            mem[_73978 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _75049 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _75049 + 68] = mem[idx + _73978 + 32]
                                idx = idx + 32
                                continue 
                            mem[_75049 + 68] = mem[_75049 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _75049 + -mem[64] + 100
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 27
                        if stor27[stor30[idx]] <= s:
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            _59632 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59632] = 30
                            mem[_59632 + 32] = 'SafeMath: subtraction overflow'
                            if stor26[stor30[idx]] > t:
                                _59834 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _59834 + 68] = mem[idx + _59632 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_59834 + 68] = mem[_59834 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _59834 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            _60565 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_60565] = 30
                            mem[_60565 + 32] = 'SafeMath: subtraction overflow'
                            if stor27[stor30[idx]] <= s:
                                idx = idx + 1
                                s = s - stor27[stor30[idx]]
                                t = t - stor26[stor30[idx]]
                                continue 
                            _60889 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _60889 + 68] = mem[idx + _60565 + 32]
                                idx = idx + 32
                                continue 
                            mem[_60889 + 68] = mem[_60889 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _60889 + -mem[64] + 100
                        _59728 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_59728] = 26
                        mem[_59728 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _59728 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _61476 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61476] = 30
                        mem[_61476 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = this.address
                        mem[32] = 26
                        _62536 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_62536] = 30
                        mem[_62536 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor26[address(this.address)]:
                            _63090 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _63090 + 68] = mem[idx + _62536 + 32]
                                idx = idx + 32
                                continue 
                            mem[_63090 + 68] = mem[_63090 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _63090 + -mem[64] + 100
                        if stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = stor26[msg.sender]
                        _65612 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_65612] = 30
                        mem[_65612 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            _66066 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _66066 + 68] = mem[idx + _65612 + 32]
                                idx = idx + 32
                                continue 
                            mem[_66066 + 68] = mem[_66066 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _66066 + -mem[64] + 100
                        if _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(0, this.address, msg.sender);
                        _68320 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_68320] = 26
                        mem[_68320 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _68320 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _73984 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_73984] = 30
                            mem[_73984 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _75054 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _75054 + 68] = mem[idx + _73984 + 32]
                                idx = idx + 32
                                continue 
                            mem[_75054 + 68] = mem[_75054 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _75054 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _74492 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_74492] = 30
                            mem[_74492 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _75682 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _75682 + 68] = mem[idx + _74492 + 32]
                                idx = idx + 32
                                continue 
                            mem[_75682 + 68] = mem[_75682 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _75682 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _75053 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_75053] = 30
                        mem[_75053 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        _76393 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _76393 + 68] = mem[idx + _75053 + 32]
                            idx = idx + 32
                            continue 
                        mem[_76393 + 68] = mem[_76393 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _76393 + -mem[64] + 100
                    _58240 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_58240] = 26
                    mem[_58240 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _58240 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if t >= stor32 / _tTotal:
                        _59962 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_59962] = 26
                        mem[_59962 + 32] = 'SafeMath: division by zero'
                        if not s:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _59962 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _61683 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61683] = 30
                        mem[_61683 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = this.address
                        mem[32] = 26
                        _63085 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_63085] = 30
                        mem[_63085 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor26[address(this.address)]:
                            _63729 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _63729 + 68] = mem[idx + _63085 + 32]
                                idx = idx + 32
                                continue 
                            mem[_63729 + 68] = mem[_63729 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _63729 + -mem[64] + 100
                        if stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = stor26[msg.sender]
                        _66063 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_66063] = 30
                        mem[_66063 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            _66515 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _66515 + 68] = mem[idx + _66063 + 32]
                                idx = idx + 32
                                continue 
                            mem[_66515 + 68] = mem[_66515 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _66515 + -mem[64] + 100
                        if _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(0, this.address, msg.sender);
                        _68790 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_68790] = 26
                        mem[_68790 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _68790 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75045 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75045] = 30
                            mem[_75045 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _76380 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _76380 + 68] = mem[idx + _75045 + 32]
                                idx = idx + 32
                                continue 
                            mem[_76380 + 68] = mem[_76380 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _76380 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75675 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75675] = 30
                            mem[_75675 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _77221 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77221 + 68] = mem[idx + _75675 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77221 + 68] = mem[_77221 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77221 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _76379 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_76379] = 30
                        mem[_76379 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        _78114 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _78114 + 68] = mem[idx + _76379 + 32]
                            idx = idx + 32
                            continue 
                        mem[_78114 + 68] = mem[_78114 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _78114 + -mem[64] + 100
                    _59963 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_59963] = 26
                    mem[_59963 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _59963 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    _61684 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_61684] = 30
                    mem[_61684 + 32] = 'SafeMath: subtraction overflow'
                    mem[0] = this.address
                    mem[32] = 26
                    _63086 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_63086] = 30
                    mem[_63086 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor26[address(this.address)]:
                        _63732 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _63732 + 68] = mem[idx + _63086 + 32]
                            idx = idx + 32
                            continue 
                        mem[_63732 + 68] = mem[_63732 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _63732 + -mem[64] + 100
                    if stor26[msg.sender] < stor26[msg.sender]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = msg.sender
                    mem[32] = 26
                    stor26[address(msg.sender)] = stor26[msg.sender]
                    _66064 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_66064] = 30
                    mem[_66064 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor32:
                        _66518 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _66518 + 68] = mem[idx + _66064 + 32]
                            idx = idx + 32
                            continue 
                        mem[_66518 + 68] = mem[_66518 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _66518 + -mem[64] + 100
                    if _tFeeTotal < _tFeeTotal:
                        revert with 0, 'SafeMath: addition overflow'
                    emit Transfer(0, this.address, msg.sender);
                    _68791 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_68791] = 26
                    mem[_68791 + 32] = 'SafeMath: division by zero'
                    if not sub_1b2cabba:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _68791 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if not sub_8a3be0b6:
                        if ethSent <= 0:
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _75048 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_75048] = 30
                        mem[_75048 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        _76384 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _76384 + 68] = mem[idx + _75048 + 32]
                            idx = idx + 32
                            continue 
                        mem[_76384 + 68] = mem[_76384 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _76384 + -mem[64] + 100
                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                        if ethSent <= 0:
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _75676 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_75676] = 30
                        mem[_75676 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        _77224 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _77224 + 68] = mem[idx + _75676 + 32]
                            idx = idx + 32
                            continue 
                        mem[_77224 + 68] = mem[_77224 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _77224 + -mem[64] + 100
                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                        emit Transfer(0, this.address, msg.sender);
                        stor0 = 1
                    if timeBetweenRounds + block.timestamp < block.timestamp:
                        revert with 0, 'SafeMath: addition overflow'
                    presaleTime = timeBetweenRounds + block.timestamp
                    sub_8a3be0b6++
                    _76383 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_76383] = 30
                    mem[_76383 + 32] = 'SafeMath: subtraction overflow'
                    if sub_be71ce9f <= sub_49a6a335:
                        sub_49a6a335 -= sub_be71ce9f
                        emit Transfer(0, this.address, msg.sender);
                        stor0 = 1
                    _78118 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _78118 + 68] = mem[idx + _76383 + 32]
                        idx = idx + 32
                        continue 
                    mem[_78118 + 68] = mem[_78118 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _78118 + -mem[64] + 100
                _28750 = mem[64]
                mem[64] = mem[64] + 64
                mem[_28750] = 26
                mem[_28750 + 32] = 'SafeMath: division by zero'
                if not _tTotal:
                    revert with 0, 'SafeMath: division by zero'
                if t >= stor32 / _tTotal:
                    _29050 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29050] = 26
                    mem[_29050 + 32] = 'SafeMath: division by zero'
                    if not s:
                        revert with 0, 'SafeMath: division by zero'
                    _29573 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29573] = 26
                    mem[_29573 + 32] = 'SafeMath: division by zero'
                    if not t / s:
                        revert with 0, 'SafeMath: division by zero'
                    if stor26[address(this.address)] / t / s < 0:
                        revert with 0, 32, 33, 0x774e6f7420656e6f75676820746f6b656e7320696e2074686520636f6e74726163, mem[mem[64] + 101 len 31]
                    if msg.value + sub_536c8c02[msg.sender] < sub_536c8c02[msg.sender]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = msg.sender
                    mem[32] = 20
                    sub_536c8c02[msg.sender] += msg.value
                    if msg.value + ethSent < ethSent:
                        revert with 0, 'SafeMath: addition overflow'
                    ethSent += msg.value
                    _30641 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30641] = 26
                    mem[_30641 + 32] = 'SafeMath: division by zero'
                    _31443 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31443] = 30
                    mem[_31443 + 32] = 'SafeMath: subtraction overflow'
                    idx = 0
                    s = _tTotal
                    t = stor32
                    while idx < stor30.length:
                        mem[0] = stor30[idx]
                        mem[32] = 26
                        if stor26[stor30[idx]] > t:
                            _59519 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59519] = 26
                            mem[_59519 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59519 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            _61389 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61389] = 30
                            mem[_61389 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = this.address
                            mem[32] = 26
                            _62129 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_62129] = 30
                            mem[_62129 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                _62521 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _62521 + 68] = mem[idx + _62129 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_62521 + 68] = mem[_62521 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _62521 + -mem[64] + 100
                            if stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = stor26[msg.sender]
                            _64873 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_64873] = 30
                            mem[_64873 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _65591 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _65591 + 68] = mem[idx + _64873 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_65591 + 68] = mem[_65591 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _65591 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(0, this.address, msg.sender);
                            _67727 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_67727] = 26
                            mem[_67727 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _67727 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _72955 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_72955] = 30
                                mem[_72955 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                _73946 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _73946 + 68] = mem[idx + _72955 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_73946 + 68] = mem[_73946 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _73946 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _73469 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_73469] = 30
                                mem[_73469 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                _74465 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _74465 + 68] = mem[idx + _73469 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_74465 + 68] = mem[_74465 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _74465 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _73945 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_73945] = 30
                            mem[_73945 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _75007 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _75007 + 68] = mem[idx + _73945 + 32]
                                idx = idx + 32
                                continue 
                            mem[_75007 + 68] = mem[_75007 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _75007 + -mem[64] + 100
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 27
                        if stor27[stor30[idx]] <= s:
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            _59623 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59623] = 30
                            mem[_59623 + 32] = 'SafeMath: subtraction overflow'
                            if stor26[stor30[idx]] > t:
                                _59822 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _59822 + 68] = mem[idx + _59623 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_59822 + 68] = mem[_59822 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _59822 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            _60544 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_60544] = 30
                            mem[_60544 + 32] = 'SafeMath: subtraction overflow'
                            if stor27[stor30[idx]] <= s:
                                idx = idx + 1
                                s = s - stor27[stor30[idx]]
                                t = t - stor26[stor30[idx]]
                                continue 
                            _60865 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _60865 + 68] = mem[idx + _60544 + 32]
                                idx = idx + 32
                                continue 
                            mem[_60865 + 68] = mem[_60865 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _60865 + -mem[64] + 100
                        _59713 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_59713] = 26
                        mem[_59713 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _59713 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _61473 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61473] = 30
                        mem[_61473 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = this.address
                        mem[32] = 26
                        _62524 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_62524] = 30
                        mem[_62524 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor26[address(this.address)]:
                            _63066 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _63066 + 68] = mem[idx + _62524 + 32]
                                idx = idx + 32
                                continue 
                            mem[_63066 + 68] = mem[_63066 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _63066 + -mem[64] + 100
                        if stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = stor26[msg.sender]
                        _65594 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_65594] = 30
                        mem[_65594 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            _66048 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _66048 + 68] = mem[idx + _65594 + 32]
                                idx = idx + 32
                                continue 
                            mem[_66048 + 68] = mem[_66048 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _66048 + -mem[64] + 100
                        if _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(0, this.address, msg.sender);
                        _68296 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_68296] = 26
                        mem[_68296 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _68296 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _73951 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_73951] = 30
                            mem[_73951 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _75012 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _75012 + 68] = mem[idx + _73951 + 32]
                                idx = idx + 32
                                continue 
                            mem[_75012 + 68] = mem[_75012 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _75012 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _74468 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_74468] = 30
                            mem[_74468 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _75652 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _75652 + 68] = mem[idx + _74468 + 32]
                                idx = idx + 32
                                continue 
                            mem[_75652 + 68] = mem[_75652 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _75652 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _75011 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_75011] = 30
                        mem[_75011 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        _76339 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _76339 + 68] = mem[idx + _75011 + 32]
                            idx = idx + 32
                            continue 
                        mem[_76339 + 68] = mem[_76339 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _76339 + -mem[64] + 100
                    _58213 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_58213] = 26
                    mem[_58213 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    if t >= stor32 / _tTotal:
                        _59941 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_59941] = 26
                        mem[_59941 + 32] = 'SafeMath: division by zero'
                        if not s:
                            revert with 0, 'SafeMath: division by zero'
                        _61677 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61677] = 30
                        mem[_61677 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = this.address
                        mem[32] = 26
                        _63061 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_63061] = 30
                        mem[_63061 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor26[address(this.address)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = stor26[msg.sender]
                        _66045 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_66045] = 30
                        mem[_66045 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(0, this.address, msg.sender);
                        _68769 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_68769] = 26
                        mem[_68769 + 32] = 'SafeMath: division by zero'
                    else:
                        _59942 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_59942] = 26
                        mem[_59942 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            revert with 0, 'SafeMath: division by zero'
                        _61678 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61678] = 30
                        mem[_61678 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = this.address
                        mem[32] = 26
                        _63062 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_63062] = 30
                        mem[_63062 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor26[address(this.address)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = stor26[msg.sender]
                        _66046 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_66046] = 30
                        mem[_66046 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(0, this.address, msg.sender);
                        _68770 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_68770] = 26
                        mem[_68770 + 32] = 'SafeMath: division by zero'
                else:
                    _29051 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29051] = 26
                    mem[_29051 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    _29575 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29575] = 26
                    mem[_29575 + 32] = 'SafeMath: division by zero'
                    if not stor32 / _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    if stor26[address(this.address)] / stor32 / _tTotal < 0:
                        revert with 0, 32, 33, 0x774e6f7420656e6f75676820746f6b656e7320696e2074686520636f6e74726163, mem[mem[64] + 101 len 31]
                    if msg.value + sub_536c8c02[msg.sender] < sub_536c8c02[msg.sender]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = msg.sender
                    mem[32] = 20
                    sub_536c8c02[msg.sender] += msg.value
                    if msg.value + ethSent < ethSent:
                        revert with 0, 'SafeMath: addition overflow'
                    ethSent += msg.value
                    _30642 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30642] = 26
                    mem[_30642 + 32] = 'SafeMath: division by zero'
                    _31444 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31444] = 30
                    mem[_31444 + 32] = 'SafeMath: subtraction overflow'
                    idx = 0
                    s = _tTotal
                    t = stor32
                    while idx < stor30.length:
                        mem[0] = stor30[idx]
                        mem[32] = 26
                        if stor26[stor30[idx]] > t:
                            _59524 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59524] = 26
                            mem[_59524 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59524 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            _61390 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61390] = 30
                            mem[_61390 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = this.address
                            mem[32] = 26
                            _62130 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_62130] = 30
                            mem[_62130 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                _62525 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _62525 + 68] = mem[idx + _62130 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_62525 + 68] = mem[_62525 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _62525 + -mem[64] + 100
                            if stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = stor26[msg.sender]
                            _64879 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_64879] = 30
                            mem[_64879 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _65597 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _65597 + 68] = mem[idx + _64879 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_65597 + 68] = mem[_65597 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _65597 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(0, this.address, msg.sender);
                            _67736 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_67736] = 26
                            mem[_67736 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _67736 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _72964 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_72964] = 30
                                mem[_72964 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                _73957 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _73957 + 68] = mem[idx + _72964 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_73957 + 68] = mem[_73957 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _73957 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _73476 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_73476] = 30
                                mem[_73476 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                _74473 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _74473 + 68] = mem[idx + _73476 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_74473 + 68] = mem[_74473 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _74473 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _73956 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_73956] = 30
                            mem[_73956 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _75021 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _75021 + 68] = mem[idx + _73956 + 32]
                                idx = idx + 32
                                continue 
                            mem[_75021 + 68] = mem[_75021 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _75021 + -mem[64] + 100
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 27
                        if stor27[stor30[idx]] <= s:
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            _59626 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59626] = 30
                            mem[_59626 + 32] = 'SafeMath: subtraction overflow'
                            if stor26[stor30[idx]] > t:
                                _59826 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _59826 + 68] = mem[idx + _59626 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_59826 + 68] = mem[_59826 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _59826 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            _60551 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_60551] = 30
                            mem[_60551 + 32] = 'SafeMath: subtraction overflow'
                            if stor27[stor30[idx]] <= s:
                                idx = idx + 1
                                s = s - stor27[stor30[idx]]
                                t = t - stor26[stor30[idx]]
                                continue 
                            _60873 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _60873 + 68] = mem[idx + _60551 + 32]
                                idx = idx + 32
                                continue 
                            mem[_60873 + 68] = mem[_60873 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _60873 + -mem[64] + 100
                        _59718 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_59718] = 26
                        mem[_59718 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _59718 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _61474 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61474] = 30
                        mem[_61474 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = this.address
                        mem[32] = 26
                        _62528 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_62528] = 30
                        mem[_62528 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor26[address(this.address)]:
                            _63074 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _63074 + 68] = mem[idx + _62528 + 32]
                                idx = idx + 32
                                continue 
                            mem[_63074 + 68] = mem[_63074 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _63074 + -mem[64] + 100
                        if stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = stor26[msg.sender]
                        _65600 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_65600] = 30
                        mem[_65600 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            _66054 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _66054 + 68] = mem[idx + _65600 + 32]
                                idx = idx + 32
                                continue 
                            mem[_66054 + 68] = mem[_66054 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _66054 + -mem[64] + 100
                        if _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(0, this.address, msg.sender);
                        _68304 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_68304] = 26
                        mem[_68304 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _68304 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _73962 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_73962] = 30
                            mem[_73962 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _75026 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _75026 + 68] = mem[idx + _73962 + 32]
                                idx = idx + 32
                                continue 
                            mem[_75026 + 68] = mem[_75026 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _75026 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _74476 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_74476] = 30
                            mem[_74476 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _75662 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _75662 + 68] = mem[idx + _74476 + 32]
                                idx = idx + 32
                                continue 
                            mem[_75662 + 68] = mem[_75662 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _75662 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _75025 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_75025] = 30
                        mem[_75025 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        _76357 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _76357 + 68] = mem[idx + _75025 + 32]
                            idx = idx + 32
                            continue 
                        mem[_76357 + 68] = mem[_76357 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _76357 + -mem[64] + 100
                    _58220 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_58220] = 26
                    mem[_58220 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    if t >= stor32 / _tTotal:
                        _59948 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_59948] = 26
                        mem[_59948 + 32] = 'SafeMath: division by zero'
                        if not s:
                            revert with 0, 'SafeMath: division by zero'
                        _61679 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61679] = 30
                        mem[_61679 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = this.address
                        mem[32] = 26
                        _63069 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_63069] = 30
                        mem[_63069 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor26[address(this.address)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = stor26[msg.sender]
                        _66051 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_66051] = 30
                        mem[_66051 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(0, this.address, msg.sender);
                        _68776 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_68776] = 26
                        mem[_68776 + 32] = 'SafeMath: division by zero'
                    else:
                        _59949 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_59949] = 26
                        mem[_59949 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            revert with 0, 'SafeMath: division by zero'
                        _61680 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61680] = 30
                        mem[_61680 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = this.address
                        mem[32] = 26
                        _63070 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_63070] = 30
                        mem[_63070 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor26[address(this.address)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = stor26[msg.sender]
                        _66052 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_66052] = 30
                        mem[_66052 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(0, this.address, msg.sender);
                        _68777 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_68777] = 26
                        mem[_68777 + 32] = 'SafeMath: division by zero'
            if not sub_1b2cabba:
                revert with 0, 'SafeMath: division by zero'
            if not sub_8a3be0b6:
                if ethSent > 0:
                    if timeBetweenRounds + block.timestamp < block.timestamp:
                        revert with 0, 'SafeMath: addition overflow'
                    presaleTime = timeBetweenRounds + block.timestamp
                    sub_8a3be0b6++
                    if sub_be71ce9f > sub_49a6a335:
                        revert with 0, 'SafeMath: subtraction overflow'
                    sub_49a6a335 -= sub_be71ce9f
            else:
                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                    if ethSent > 0:
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        if sub_be71ce9f > sub_49a6a335:
                            revert with 0, 'SafeMath: subtraction overflow'
                        sub_49a6a335 -= sub_be71ce9f
                else:
                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if ethSent > 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        if sub_be71ce9f > sub_49a6a335:
                            revert with 0, 'SafeMath: subtraction overflow'
                        sub_49a6a335 -= sub_be71ce9f
            emit Transfer(0, this.address, msg.sender);
        else:
            if sub_49a6a335 * msg.value / msg.value != sub_49a6a335:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            mem[96] = 26
            mem[128] = 'SafeMath: division by zero'
            mem[64] = 224
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            sub_84f44adf += sub_49a6a335 * msg.value / 10^9 / 2
            if stor29[address(this.address)]:
                if stor27[address(this.address)] < sub_49a6a335 * msg.value / 10^9:
                    revert with 0, 32, 33, 0x774e6f7420656e6f75676820746f6b656e7320696e2074686520636f6e74726163, mem[325 len 31]
                if msg.value + sub_536c8c02[msg.sender] < sub_536c8c02[msg.sender]:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = msg.sender
                mem[32] = 20
                sub_536c8c02[msg.sender] += msg.value
                if msg.value + ethSent < ethSent:
                    revert with 0, 'SafeMath: addition overflow'
                ethSent += msg.value
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                if not sub_49a6a335 * msg.value / 10^9 / 50:
                    mem[64] = 352
                    mem[288] = 30
                    mem[320] = 'SafeMath: subtraction overflow'
                    if 0 > sub_49a6a335 * msg.value / 10^9:
                        revert with 0, 'SafeMath: subtraction overflow'
                    idx = 0
                    s = _tTotal
                    t = stor32
                    while idx < stor30.length:
                        mem[0] = stor30[idx]
                        mem[32] = 26
                        if stor26[stor30[idx]] > t:
                            _28871 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28871] = 26
                            mem[_28871 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _28871 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                _29784 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29784] = 30
                                mem[_29784 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _30104 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30104] = 30
                                mem[_30104 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _30214 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _30214 + 68] = mem[idx + _30104 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_30214 + 68] = mem[_30214 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _30214 + -mem[64] + 100
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _30830 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30830] = 30
                                mem[_30830 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _31011 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _31011 + 68] = mem[idx + _30830 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_31011 + 68] = mem[_31011 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _31011 + -mem[64] + 100
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _31627 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31627] = 26
                                mem[_31627 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _31627 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _34289 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34289] = 30
                                    mem[_34289 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _34896 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _34896 + 68] = mem[idx + _34289 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34896 + 68] = mem[_34896 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _34896 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _34620 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34620] = 30
                                    mem[_34620 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _35150 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _35150 + 68] = mem[idx + _34620 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35150 + 68] = mem[_35150 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35150 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _34895 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34895] = 30
                                mem[_34895 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35399 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35399 + 68] = mem[idx + _34895 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35399 + 68] = mem[_35399 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35399 + -mem[64] + 100
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _29823 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29823] = 30
                            mem[_29823 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _29894 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29894 + 68] = mem[idx + _29823 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29894 + 68] = mem[_29894 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _29894 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _30167 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30167] = 30
                            mem[_30167 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _30292 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _30292 + 68] = mem[idx + _30167 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_30292 + 68] = mem[_30292 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _30292 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                            _30926 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30926] = 30
                            mem[_30926 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _31085 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _31085 + 68] = mem[idx + _30926 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_31085 + 68] = mem[_31085 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _31085 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            _31733 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31733] = 26
                            mem[_31733 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _31733 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _34619 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34619] = 30
                                mem[_34619 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35147 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35147 + 68] = mem[idx + _34619 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35147 + 68] = mem[_35147 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35147 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _34894 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34894] = 30
                                mem[_34894 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35396 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35396 + 68] = mem[idx + _34894 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35396 + 68] = mem[_35396 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35396 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _35146 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35146] = 30
                            mem[_35146 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _35634 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _35634 + 68] = mem[idx + _35146 + 32]
                                idx = idx + 32
                                continue 
                            mem[_35634 + 68] = mem[_35634 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _35634 + -mem[64] + 100
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 27
                        if stor27[stor30[idx]] <= s:
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            _28917 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28917] = 30
                            mem[_28917 + 32] = 'SafeMath: subtraction overflow'
                            if stor26[stor30[idx]] > t:
                                _28998 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28998 + 68] = mem[idx + _28917 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28998 + 68] = mem[_28998 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _28998 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            _29297 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29297] = 30
                            mem[_29297 + 32] = 'SafeMath: subtraction overflow'
                            if stor27[stor30[idx]] <= s:
                                idx = idx + 1
                                s = s - stor27[stor30[idx]]
                                t = t - stor26[stor30[idx]]
                                continue 
                            _29437 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29437 + 68] = mem[idx + _29297 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29437 + 68] = mem[_29437 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _29437 + -mem[64] + 100
                        _28953 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28953] = 26
                        mem[_28953 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _28953 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_49a6a335 * msg.value / 10^9:
                            _29852 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29852] = 30
                            mem[_29852 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = this.address
                            mem[32] = 26
                            _30219 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30219] = 30
                            mem[_30219 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                _30368 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _30368 + 68] = mem[idx + _30219 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_30368 + 68] = mem[_30368 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _30368 + -mem[64] + 100
                            if stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = stor26[msg.sender]
                            _31014 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31014] = 30
                            mem[_31014 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _31131 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _31131 + 68] = mem[idx + _31014 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_31131 + 68] = mem[_31131 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _31131 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            _31806 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31806] = 26
                            mem[_31806 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _31806 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _34903 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34903] = 30
                                mem[_34903 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35405 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35405 + 68] = mem[idx + _34903 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35405 + 68] = mem[_35405 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35405 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _35156 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35156] = 30
                                mem[_35156 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35647 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35647 + 68] = mem[idx + _35156 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35647 + 68] = mem[_35647 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35647 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _35404 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35404] = 30
                            mem[_35404 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _35881 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _35881 + 68] = mem[idx + _35404 + 32]
                                idx = idx + 32
                                continue 
                            mem[_35881 + 68] = mem[_35881 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _35881 + -mem[64] + 100
                        if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _29897 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29897] = 30
                        mem[_29897 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                            _29995 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29995 + 68] = mem[idx + _29897 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29995 + 68] = mem[_29995 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _29995 + -mem[64] + 100
                        mem[0] = this.address
                        mem[32] = 26
                        _30295 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30295] = 30
                        mem[_30295 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                            _30453 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30453 + 68] = mem[idx + _30295 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30453 + 68] = mem[_30453 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _30453 + -mem[64] + 100
                        stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                        if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                        _31088 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31088] = 30
                        mem[_31088 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            _31189 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31189 + 68] = mem[idx + _31088 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31189 + 68] = mem[_31189 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _31189 + -mem[64] + 100
                        if _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                        _31885 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31885] = 26
                        mem[_31885 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _31885 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _35155 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35155] = 30
                            mem[_35155 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _35644 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _35644 + 68] = mem[idx + _35155 + 32]
                                idx = idx + 32
                                continue 
                            mem[_35644 + 68] = mem[_35644 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _35644 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _35403 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35403] = 30
                            mem[_35403 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _35878 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _35878 + 68] = mem[idx + _35403 + 32]
                                idx = idx + 32
                                continue 
                            mem[_35878 + 68] = mem[_35878 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _35878 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _35643 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35643] = 30
                        mem[_35643 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        _36140 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _36140 + 68] = mem[idx + _35643 + 32]
                            idx = idx + 32
                            continue 
                        mem[_36140 + 68] = mem[_36140 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _36140 + -mem[64] + 100
                    _28745 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28745] = 26
                    mem[_28745 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    if t >= stor32 / _tTotal:
                        _29043 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29043] = 26
                        mem[_29043 + 32] = 'SafeMath: division by zero'
                        if not s:
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_49a6a335 * msg.value / 10^9:
                            _29935 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29935] = 30
                            mem[_29935 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = this.address
                            mem[32] = 26
                            _30361 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30361] = 30
                            mem[_30361 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = stor26[msg.sender]
                            _31128 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31128] = 30
                            mem[_31128 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            _31947 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31947] = 26
                            mem[_31947 + 32] = 'SafeMath: division by zero'
                        else:
                            if t / s * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != t / s:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _29992 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29992] = 30
                            mem[_29992 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > t / s * sub_49a6a335 * msg.value / 10^9:
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[0] = this.address
                            mem[32] = 26
                            _30446 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30446] = 30
                            mem[_30446 + 32] = 'SafeMath: subtraction overflow'
                            if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                            if (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                            _31184 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31184] = 30
                            mem[_31184 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            _32032 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32032] = 26
                            mem[_32032 + 32] = 'SafeMath: division by zero'
                    else:
                        _29044 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29044] = 26
                        mem[_29044 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_49a6a335 * msg.value / 10^9:
                            _29936 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29936] = 30
                            mem[_29936 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = this.address
                            mem[32] = 26
                            _30364 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30364] = 30
                            mem[_30364 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = stor26[msg.sender]
                            _31129 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31129] = 30
                            mem[_31129 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            _31948 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31948] = 26
                            mem[_31948 + 32] = 'SafeMath: division by zero'
                        else:
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _29993 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29993] = 30
                            mem[_29993 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[0] = this.address
                            mem[32] = 26
                            _30447 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30447] = 30
                            mem[_30447 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                            _31185 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31185] = 30
                            mem[_31185 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            _32033 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32033] = 26
                            mem[_32033 + 32] = 'SafeMath: division by zero'
                else:
                    if 2 * sub_49a6a335 * msg.value / 10^9 / 50 / sub_49a6a335 * msg.value / 10^9 / 50 != 2:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    mem[64] = 352
                    mem[288] = 30
                    mem[320] = 'SafeMath: subtraction overflow'
                    if 2 * sub_49a6a335 * msg.value / 10^9 / 50 > sub_49a6a335 * msg.value / 10^9:
                        revert with 0, 'SafeMath: subtraction overflow'
                    idx = 0
                    s = _tTotal
                    t = stor32
                    while idx < stor30.length:
                        mem[0] = stor30[idx]
                        mem[32] = 26
                        if stor26[stor30[idx]] > t:
                            _28866 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28866] = 26
                            mem[_28866 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _28866 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _29783 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29783] = 30
                                    mem[_29783 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _30093 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30093] = 30
                                    mem[_30093 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _30202 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _30202 + 68] = mem[idx + _30093 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_30202 + 68] = mem[_30202 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _30202 + -mem[64] + 100
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _30810 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30810] = 30
                                    mem[_30810 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _30998 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _30998 + 68] = mem[idx + _30810 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_30998 + 68] = mem[_30998 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _30998 + -mem[64] + 100
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _31611 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31611] = 26
                                    mem[_31611 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _31611 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _34264 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34264] = 30
                                        mem[_34264 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _34874 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _34874 + 68] = mem[idx + _34264 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34874 + 68] = mem[_34874 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _34874 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _34600 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34600] = 30
                                        mem[_34600 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _35126 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _35126 + 68] = mem[idx + _34600 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35126 + 68] = mem[_35126 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35126 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _34873 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34873] = 30
                                    mem[_34873 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _35373 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _35373 + 68] = mem[idx + _34873 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35373 + 68] = mem[_35373 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35373 + -mem[64] + 100
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _29820 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29820] = 30
                                mem[_29820 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                    _29889 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _29889 + 68] = mem[idx + _29820 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29889 + 68] = mem[_29889 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _29889 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _30160 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30160] = 30
                                mem[_30160 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _30279 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _30279 + 68] = mem[idx + _30160 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_30279 + 68] = mem[_30279 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _30279 + -mem[64] + 100
                                if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _30910 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30910] = 30
                                mem[_30910 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    _31078 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _31078 + 68] = mem[idx + _30910 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_31078 + 68] = mem[_31078 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _31078 + -mem[64] + 100
                                stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _31722 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31722] = 26
                                mem[_31722 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _31722 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _34599 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34599] = 30
                                    mem[_34599 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _35123 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _35123 + 68] = mem[idx + _34599 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35123 + 68] = mem[_35123 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35123 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _34872 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34872] = 30
                                    mem[_34872 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _35370 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _35370 + 68] = mem[idx + _34872 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35370 + 68] = mem[_35370 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35370 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _35122 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35122] = 30
                                mem[_35122 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35605 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35605 + 68] = mem[idx + _35122 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35605 + 68] = mem[_35605 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35605 + -mem[64] + 100
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _29819 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29819] = 30
                                mem[_29819 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    _29886 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _29886 + 68] = mem[idx + _29819 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29886 + 68] = mem[_29886 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _29886 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _30159 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30159] = 30
                                mem[_30159 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _30276 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _30276 + 68] = mem[idx + _30159 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_30276 + 68] = mem[_30276 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _30276 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _30909 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30909] = 30
                                mem[_30909 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _31075 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _31075 + 68] = mem[idx + _30909 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_31075 + 68] = mem[_31075 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _31075 + -mem[64] + 100
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _31721 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31721] = 26
                                mem[_31721 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _31721 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _34596 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34596] = 30
                                    mem[_34596 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _35119 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _35119 + 68] = mem[idx + _34596 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35119 + 68] = mem[_35119 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35119 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _34871 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34871] = 30
                                    mem[_34871 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _35367 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _35367 + 68] = mem[idx + _34871 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35367 + 68] = mem[_35367 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35367 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _35118 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35118] = 30
                                mem[_35118 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35601 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35601 + 68] = mem[idx + _35118 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35601 + 68] = mem[_35601 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35601 + -mem[64] + 100
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _29848 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29848] = 30
                            mem[_29848 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _29931 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29931 + 68] = mem[idx + _29848 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29931 + 68] = mem[_29931 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _29931 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _30201 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30201] = 30
                            mem[_30201 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _30349 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _30349 + 68] = mem[idx + _30201 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_30349 + 68] = mem[_30349 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _30349 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                            _30997 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30997] = 30
                            mem[_30997 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                _31120 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _31120 + 68] = mem[idx + _30997 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_31120 + 68] = mem[_31120 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _31120 + -mem[64] + 100
                            stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _31792 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31792] = 26
                            mem[_31792 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _31792 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _34870 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34870] = 30
                                mem[_34870 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35364 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35364 + 68] = mem[idx + _34870 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35364 + 68] = mem[_35364 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35364 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _35117 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35117] = 30
                                mem[_35117 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35598 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35598 + 68] = mem[idx + _35117 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35598 + 68] = mem[_35598 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35598 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _35363 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35363] = 30
                            mem[_35363 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _35823 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _35823 + 68] = mem[idx + _35363 + 32]
                                idx = idx + 32
                                continue 
                            mem[_35823 + 68] = mem[_35823 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _35823 + -mem[64] + 100
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 27
                        if stor27[stor30[idx]] <= s:
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            _28914 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28914] = 30
                            mem[_28914 + 32] = 'SafeMath: subtraction overflow'
                            if stor26[stor30[idx]] > t:
                                _28994 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28994 + 68] = mem[idx + _28914 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28994 + 68] = mem[_28994 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _28994 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            _29290 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29290] = 30
                            mem[_29290 + 32] = 'SafeMath: subtraction overflow'
                            if stor27[stor30[idx]] <= s:
                                idx = idx + 1
                                s = s - stor27[stor30[idx]]
                                t = t - stor26[stor30[idx]]
                                continue 
                            _29429 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29429 + 68] = mem[idx + _29290 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29429 + 68] = mem[_29429 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _29429 + -mem[64] + 100
                        _28948 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28948] = 26
                        mem[_28948 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _28948 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_49a6a335 * msg.value / 10^9:
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _29851 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29851] = 30
                                mem[_29851 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _30211 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30211] = 30
                                mem[_30211 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _30356 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _30356 + 68] = mem[idx + _30211 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_30356 + 68] = mem[_30356 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _30356 + -mem[64] + 100
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _31002 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31002] = 30
                                mem[_31002 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _31125 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _31125 + 68] = mem[idx + _31002 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_31125 + 68] = mem[_31125 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _31125 + -mem[64] + 100
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _31798 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31798] = 26
                                mem[_31798 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _31798 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _34885 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34885] = 30
                                    mem[_34885 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _35383 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _35383 + 68] = mem[idx + _34885 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35383 + 68] = mem[_35383 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35383 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _35137 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35137] = 30
                                    mem[_35137 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _35623 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _35623 + 68] = mem[idx + _35137 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35623 + 68] = mem[_35623 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35623 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _35382 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35382] = 30
                                mem[_35382 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35853 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35853 + 68] = mem[idx + _35382 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35853 + 68] = mem[_35853 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35853 + -mem[64] + 100
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _29893 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29893] = 30
                            mem[_29893 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                _29989 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29989 + 68] = mem[idx + _29893 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29989 + 68] = mem[_29989 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _29989 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _30285 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30285] = 30
                            mem[_30285 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                _30443 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _30443 + 68] = mem[idx + _30285 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_30443 + 68] = mem[_30443 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _30443 + -mem[64] + 100
                            if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                            _31082 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31082] = 30
                            mem[_31082 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                _31181 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _31181 + 68] = mem[idx + _31082 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_31181 + 68] = mem[_31181 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _31181 + -mem[64] + 100
                            stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _31876 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31876] = 26
                            mem[_31876 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _31876 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _35136 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35136] = 30
                                mem[_35136 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35620 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35620 + 68] = mem[idx + _35136 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35620 + 68] = mem[_35620 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35620 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _35381 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35381] = 30
                                mem[_35381 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35850 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35850 + 68] = mem[idx + _35381 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35850 + 68] = mem[_35850 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35850 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _35619 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35619] = 30
                            mem[_35619 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _36106 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _36106 + 68] = mem[idx + _35619 + 32]
                                idx = idx + 32
                                continue 
                            mem[_36106 + 68] = mem[_36106 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _36106 + -mem[64] + 100
                        if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                            _29892 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29892] = 30
                            mem[_29892 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _29986 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29986 + 68] = mem[idx + _29892 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29986 + 68] = mem[_29986 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _29986 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _30284 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30284] = 30
                            mem[_30284 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _30440 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _30440 + 68] = mem[idx + _30284 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_30440 + 68] = mem[_30440 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _30440 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                            _31081 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31081] = 30
                            mem[_31081 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _31178 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _31178 + 68] = mem[idx + _31081 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_31178 + 68] = mem[_31178 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _31178 + -mem[64] + 100
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _31875 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31875] = 26
                            mem[_31875 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _31875 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _35133 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35133] = 30
                                mem[_35133 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35616 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35616 + 68] = mem[idx + _35133 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35616 + 68] = mem[_35616 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35616 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _35380 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35380] = 30
                                mem[_35380 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35847 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35847 + 68] = mem[idx + _35380 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35847 + 68] = mem[_35847 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35847 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _35615 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35615] = 30
                            mem[_35615 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _36102 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _36102 + 68] = mem[idx + _35615 + 32]
                                idx = idx + 32
                                continue 
                            mem[_36102 + 68] = mem[_36102 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _36102 + -mem[64] + 100
                        if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _29934 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29934] = 30
                        mem[_29934 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                            _30037 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30037 + 68] = mem[idx + _29934 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30037 + 68] = mem[_30037 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _30037 + -mem[64] + 100
                        mem[0] = this.address
                        mem[32] = 26
                        _30355 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30355] = 30
                        mem[_30355 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                            _30513 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30513 + 68] = mem[idx + _30355 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30513 + 68] = mem[_30513 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _30513 + -mem[64] + 100
                        stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                        if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                        _31124 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31124] = 30
                        mem[_31124 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                            _31241 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31241 + 68] = mem[idx + _31124 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31241 + 68] = mem[_31241 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _31241 + -mem[64] + 100
                        stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                        if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                        emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                        _31943 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31943] = 26
                        mem[_31943 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _31943 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _35379 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35379] = 30
                            mem[_35379 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _35844 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _35844 + 68] = mem[idx + _35379 + 32]
                                idx = idx + 32
                                continue 
                            mem[_35844 + 68] = mem[_35844 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _35844 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _35614 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35614] = 30
                            mem[_35614 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _36099 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _36099 + 68] = mem[idx + _35614 + 32]
                                idx = idx + 32
                                continue 
                            mem[_36099 + 68] = mem[_36099 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _36099 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _35843 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35843] = 30
                        mem[_35843 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        _36362 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _36362 + 68] = mem[idx + _35843 + 32]
                            idx = idx + 32
                            continue 
                        mem[_36362 + 68] = mem[_36362 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _36362 + -mem[64] + 100
                    _28740 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28740] = 26
                    mem[_28740 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    if t >= stor32 / _tTotal:
                        _29036 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29036] = 26
                        mem[_29036 + 32] = 'SafeMath: division by zero'
                        if not s:
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_49a6a335 * msg.value / 10^9:
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _29927 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29927] = 30
                                mem[_29927 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _30341 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30341] = 30
                                mem[_30341 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _31117 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31117] = 30
                                mem[_31117 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _31932 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31932] = 26
                                mem[_31932 + 32] = 'SafeMath: division by zero'
                            else:
                                if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != t / s:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _29981 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29981] = 30
                                mem[_29981 + 32] = 'SafeMath: subtraction overflow'
                                if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _30427 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30427] = 30
                                mem[_30427 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if (-1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (-1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _31171 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31171] = 30
                                mem[_31171 + 32] = 'SafeMath: subtraction overflow'
                                if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor32 += -1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _32015 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32015] = 26
                                mem[_32015 + 32] = 'SafeMath: division by zero'
                        else:
                            if t / s * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != t / s:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _29980 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29980] = 30
                                mem[_29980 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > t / s * sub_49a6a335 * msg.value / 10^9:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _30426 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30426] = 30
                                mem[_30426 + 32] = 'SafeMath: subtraction overflow'
                                if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                                if (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _31170 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31170] = 30
                                mem[_31170 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _32014 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32014] = 26
                                mem[_32014 + 32] = 'SafeMath: division by zero'
                            else:
                                if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != t / s:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _30029 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30029] = 30
                                mem[_30029 + 32] = 'SafeMath: subtraction overflow'
                                if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > t / s * sub_49a6a335 * msg.value / 10^9:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _30495 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30495] = 30
                                mem[_30495 + 32] = 'SafeMath: subtraction overflow'
                                if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                                if (t / s * sub_49a6a335 * msg.value / 10^9) - (t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) - (t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _31225 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31225] = 30
                                mem[_31225 + 32] = 'SafeMath: subtraction overflow'
                                if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor32 += -1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _32089 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32089] = 26
                                mem[_32089 + 32] = 'SafeMath: division by zero'
                    else:
                        _29037 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29037] = 26
                        mem[_29037 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_49a6a335 * msg.value / 10^9:
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _29930 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29930] = 30
                                mem[_29930 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _30348 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30348] = 30
                                mem[_30348 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _31119 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31119] = 30
                                mem[_31119 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _31935 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31935] = 26
                                mem[_31935 + 32] = 'SafeMath: division by zero'
                            else:
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _29983 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29983] = 30
                                mem[_29983 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _30431 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30431] = 30
                                mem[_30431 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _31173 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31173] = 30
                                mem[_31173 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _32017 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32017] = 26
                                mem[_32017 + 32] = 'SafeMath: division by zero'
                        else:
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _29982 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29982] = 30
                                mem[_29982 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _30430 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30430] = 30
                                mem[_30430 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _31172 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31172] = 30
                                mem[_31172 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _32016 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32016] = 26
                                mem[_32016 + 32] = 'SafeMath: division by zero'
                            else:
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _30030 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30030] = 30
                                mem[_30030 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _30499 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30499] = 30
                                mem[_30499 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _31229 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31229] = 30
                                mem[_31229 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _32093 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32093] = 26
                                mem[_32093 + 32] = 'SafeMath: division by zero'
            else:
                mem[0] = this.address
                mem[32] = 26
                if stor26[address(this.address)] > stor32:
                    revert with 0, 32, 42, 0x73416d6f756e74206d757374206265206c657373207468616e20746f74616c207265666c656374696f6e, mem[334 len 22]
                idx = 0
                s = _tTotal
                t = stor32
                while idx < stor30.length:
                    mem[0] = stor30[idx]
                    mem[32] = 26
                    if stor26[stor30[idx]] > t:
                        _28861 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28861] = 26
                        mem[_28861 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _28861 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _29281 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29281] = 26
                        mem[_29281 + 32] = 'SafeMath: division by zero'
                        if not stor32 / _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _29281 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if stor26[address(this.address)] / stor32 / _tTotal < sub_49a6a335 * msg.value / 10^9:
                            revert with 0, 32, 33, 0x774e6f7420656e6f75676820746f6b656e7320696e2074686520636f6e74726163, mem[mem[64] + 101 len 31]
                        if msg.value + sub_536c8c02[msg.sender] < sub_536c8c02[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 20
                        sub_536c8c02[msg.sender] += msg.value
                        if msg.value + ethSent < ethSent:
                            revert with 0, 'SafeMath: addition overflow'
                        ethSent += msg.value
                        _30263 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30263] = 26
                        mem[_30263 + 32] = 'SafeMath: division by zero'
                        if not sub_49a6a335 * msg.value / 10^9 / 50:
                            _31115 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31115] = 30
                            mem[_31115 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > sub_49a6a335 * msg.value / 10^9:
                                _31221 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _31221 + 68] = mem[idx + _31115 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_31221 + 68] = mem[_31221 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _31221 + -mem[64] + 100
                            idx = 0
                            s = _tTotal
                            t = stor32
                            while idx < stor30.length:
                                mem[0] = stor30[idx]
                                mem[32] = 26
                                if stor26[stor30[idx]] > t:
                                    _59504 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_59504] = 26
                                    mem[_59504 + 32] = 'SafeMath: division by zero'
                                    if not _tTotal:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _59504 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_49a6a335 * msg.value / 10^9:
                                        _61384 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_61384] = 30
                                        mem[_61384 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = this.address
                                        mem[32] = 26
                                        _62096 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_62096] = 30
                                        mem[_62096 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor26[address(this.address)]:
                                            _62492 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _62492 + 68] = mem[idx + _62096 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_62492 + 68] = mem[_62492 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _62492 + -mem[64] + 100
                                        if stor26[msg.sender] < stor26[msg.sender]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 26
                                        stor26[address(msg.sender)] = stor26[msg.sender]
                                        _64822 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_64822] = 30
                                        mem[_64822 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor32:
                                            _65549 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _65549 + 68] = mem[idx + _64822 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_65549 + 68] = mem[_65549 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _65549 + -mem[64] + 100
                                        if _tFeeTotal < _tFeeTotal:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        _67681 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_67681] = 26
                                        mem[_67681 + 32] = 'SafeMath: division by zero'
                                        if not sub_1b2cabba:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _67681 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not sub_8a3be0b6:
                                            if ethSent <= 0:
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            presaleTime = timeBetweenRounds + block.timestamp
                                            sub_8a3be0b6++
                                            _72886 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_72886] = 30
                                            mem[_72886 + 32] = 'SafeMath: subtraction overflow'
                                            if sub_be71ce9f <= sub_49a6a335:
                                                sub_49a6a335 -= sub_be71ce9f
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            _73881 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _73881 + 68] = mem[idx + _72886 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_73881 + 68] = mem[_73881 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _73881 + -mem[64] + 100
                                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                            if ethSent <= 0:
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            presaleTime = timeBetweenRounds + block.timestamp
                                            sub_8a3be0b6++
                                            _73407 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_73407] = 30
                                            mem[_73407 + 32] = 'SafeMath: subtraction overflow'
                                            if sub_be71ce9f <= sub_49a6a335:
                                                sub_49a6a335 -= sub_be71ce9f
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            _74398 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _74398 + 68] = mem[idx + _73407 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_74398 + 68] = mem[_74398 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _74398 + -mem[64] + 100
                                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73880 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73880] = 30
                                        mem[_73880 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74929 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74929 + 68] = mem[idx + _73880 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74929 + 68] = mem[_74929 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74929 + -mem[64] + 100
                                    if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _61427 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61427] = 30
                                    mem[_61427 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                        _61545 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _61545 + 68] = mem[idx + _61427 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_61545 + 68] = mem[_61545 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _61545 + -mem[64] + 100
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62317 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62317] = 30
                                    mem[_62317 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                        _62737 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62737 + 68] = mem[idx + _62317 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62737 + 68] = mem[_62737 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62737 + -mem[64] + 100
                                    stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                    if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                    _65200 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65200] = 30
                                    mem[_65200 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _65849 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _65849 + 68] = mem[idx + _65200 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_65849 + 68] = mem[_65849 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _65849 + -mem[64] + 100
                                    if _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    _68031 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68031] = 26
                                    mem[_68031 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _68031 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73406 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73406] = 30
                                        mem[_73406 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74395 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74395 + 68] = mem[idx + _73406 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74395 + 68] = mem[_74395 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74395 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73879 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73879] = 30
                                        mem[_73879 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74926 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74926 + 68] = mem[idx + _73879 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74926 + 68] = mem[_74926 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74926 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74394 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74394] = 30
                                    mem[_74394 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75559 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75559 + 68] = mem[idx + _74394 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75559 + 68] = mem[_75559 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75559 + -mem[64] + 100
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 27
                                if stor27[stor30[idx]] <= s:
                                    require idx < stor30.length
                                    mem[0] = stor30[idx]
                                    mem[32] = 26
                                    _59614 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_59614] = 30
                                    mem[_59614 + 32] = 'SafeMath: subtraction overflow'
                                    if stor26[stor30[idx]] > t:
                                        _59810 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _59810 + 68] = mem[idx + _59614 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_59810 + 68] = mem[_59810 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _59810 + -mem[64] + 100
                                    require idx < stor30.length
                                    mem[0] = stor30[idx]
                                    mem[32] = 27
                                    _60523 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_60523] = 30
                                    mem[_60523 + 32] = 'SafeMath: subtraction overflow'
                                    if stor27[stor30[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor27[stor30[idx]]
                                        t = t - stor26[stor30[idx]]
                                        continue 
                                    _60841 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _60841 + 68] = mem[idx + _60523 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_60841 + 68] = mem[_60841 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _60841 + -mem[64] + 100
                                _59698 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59698] = 26
                                mem[_59698 + 32] = 'SafeMath: division by zero'
                                if not _tTotal:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _59698 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_49a6a335 * msg.value / 10^9:
                                    _61467 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61467] = 30
                                    mem[_61467 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62497 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62497] = 30
                                    mem[_62497 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _63022 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _63022 + 68] = mem[idx + _62497 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_63022 + 68] = mem[_63022 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _63022 + -mem[64] + 100
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _65552 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65552] = 30
                                    mem[_65552 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _66024 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _66024 + 68] = mem[idx + _65552 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_66024 + 68] = mem[_66024 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _66024 + -mem[64] + 100
                                    if _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    _68263 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68263] = 26
                                    mem[_68263 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _68263 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73888 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73888] = 30
                                        mem[_73888 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74935 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74935 + 68] = mem[idx + _73888 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74935 + 68] = mem[_74935 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74935 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _74404 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_74404] = 30
                                        mem[_74404 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _75572 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _75572 + 68] = mem[idx + _74404 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_75572 + 68] = mem[_75572 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _75572 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74934 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74934] = 30
                                    mem[_74934 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76241 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76241 + 68] = mem[idx + _74934 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76241 + 68] = mem[_76241 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76241 + -mem[64] + 100
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61548 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61548] = 30
                                mem[_61548 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    _61792 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61792 + 68] = mem[idx + _61548 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61792 + 68] = mem[_61792 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61792 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62740 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62740] = 30
                                mem[_62740 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _63362 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63362 + 68] = mem[idx + _62740 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63362 + 68] = mem[_63362 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63362 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _65852 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65852] = 30
                                mem[_65852 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66228 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66228 + 68] = mem[idx + _65852 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66228 + 68] = mem[_66228 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66228 + -mem[64] + 100
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68530 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68530] = 26
                                mem[_68530 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68530 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74403 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74403] = 30
                                    mem[_74403 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75569 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75569 + 68] = mem[idx + _74403 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75569 + 68] = mem[_75569 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75569 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74933 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74933] = 30
                                    mem[_74933 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76238 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76238 + 68] = mem[idx + _74933 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76238 + 68] = mem[_76238 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76238 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75568 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75568] = 30
                                mem[_75568 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77068 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77068 + 68] = mem[idx + _75568 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77068 + 68] = mem[_77068 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77068 + -mem[64] + 100
                            _57838 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_57838] = 26
                            mem[_57838 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _57838 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor32 / _tTotal:
                                _59920 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59920] = 26
                                mem[_59920 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _59920 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_49a6a335 * msg.value / 10^9:
                                    _61663 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61663] = 30
                                    mem[_61663 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63015 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63015] = 30
                                    mem[_63015 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _63641 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _63641 + 68] = mem[idx + _63015 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_63641 + 68] = mem[_63641 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _63641 + -mem[64] + 100
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _66021 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66021] = 30
                                    mem[_66021 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _66441 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _66441 + 68] = mem[idx + _66021 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_66441 + 68] = mem[_66441 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _66441 + -mem[64] + 100
                                    if _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    _68736 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68736] = 26
                                    mem[_68736 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _68736 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _74920 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_74920] = 30
                                        mem[_74920 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _76219 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _76219 + 68] = mem[idx + _74920 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_76219 + 68] = mem[_76219 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _76219 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _75554 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_75554] = 30
                                        mem[_75554 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _77047 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _77047 + 68] = mem[idx + _75554 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_77047 + 68] = mem[_77047 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _77047 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _76218 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_76218] = 30
                                    mem[_76218 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _77945 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _77945 + 68] = mem[idx + _76218 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_77945 + 68] = mem[_77945 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _77945 + -mem[64] + 100
                                if t / s * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != t / s:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61789 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61789] = 30
                                mem[_61789 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > t / s * sub_49a6a335 * msg.value / 10^9:
                                    _62088 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62088 + 68] = mem[idx + _61789 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62088 + 68] = mem[_62088 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62088 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _63355 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63355] = 30
                                mem[_63355 + 32] = 'SafeMath: subtraction overflow'
                                if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _64058 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _64058 + 68] = mem[idx + _63355 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_64058 + 68] = mem[_64058 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _64058 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                                if (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _66223 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66223] = 30
                                mem[_66223 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66789 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66789 + 68] = mem[idx + _66223 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66789 + 68] = mem[_66789 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66789 + -mem[64] + 100
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68999 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68999] = 26
                                mem[_68999 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68999 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75553 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75553] = 30
                                    mem[_75553 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _77044 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _77044 + 68] = mem[idx + _75553 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_77044 + 68] = mem[_77044 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _77044 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _76217 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_76217] = 30
                                    mem[_76217 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _77942 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _77942 + 68] = mem[idx + _76217 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_77942 + 68] = mem[_77942 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _77942 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _77043 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_77043] = 30
                                mem[_77043 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _78816 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _78816 + 68] = mem[idx + _77043 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_78816 + 68] = mem[_78816 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _78816 + -mem[64] + 100
                            _59921 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59921] = 26
                            mem[_59921 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59921 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                _61664 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61664] = 30
                                mem[_61664 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _63018 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63018] = 30
                                mem[_63018 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _63644 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63644 + 68] = mem[idx + _63018 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63644 + 68] = mem[_63644 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63644 + -mem[64] + 100
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _66022 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66022] = 30
                                mem[_66022 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66444 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66444 + 68] = mem[idx + _66022 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66444 + 68] = mem[_66444 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66444 + -mem[64] + 100
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68737 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68737] = 26
                                mem[_68737 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68737 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74925 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74925] = 30
                                    mem[_74925 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76224 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76224 + 68] = mem[idx + _74925 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76224 + 68] = mem[_76224 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76224 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75558 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75558] = 30
                                    mem[_75558 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _77054 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _77054 + 68] = mem[idx + _75558 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_77054 + 68] = mem[_77054 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _77054 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _76223 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_76223] = 30
                                mem[_76223 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77952 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77952 + 68] = mem[idx + _76223 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77952 + 68] = mem[_77952 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77952 + -mem[64] + 100
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61790 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61790] = 30
                            mem[_61790 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _62091 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _62091 + 68] = mem[idx + _61790 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_62091 + 68] = mem[_62091 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _62091 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _63356 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_63356] = 30
                            mem[_63356 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _64061 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _64061 + 68] = mem[idx + _63356 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_64061 + 68] = mem[_64061 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _64061 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                            _66224 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_66224] = 30
                            mem[_66224 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _66792 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66792 + 68] = mem[idx + _66224 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66792 + 68] = mem[_66792 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66792 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            _69000 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_69000] = 26
                            mem[_69000 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _69000 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75557 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75557] = 30
                                mem[_75557 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77051 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77051 + 68] = mem[idx + _75557 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77051 + 68] = mem[_77051 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77051 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _76222 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_76222] = 30
                                mem[_76222 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77949 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77949 + 68] = mem[idx + _76222 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77949 + 68] = mem[_77949 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77949 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _77050 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_77050] = 30
                            mem[_77050 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _78825 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _78825 + 68] = mem[idx + _77050 + 32]
                                idx = idx + 32
                                continue 
                            mem[_78825 + 68] = mem[_78825 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _78825 + -mem[64] + 100
                        if 2 * sub_49a6a335 * msg.value / 10^9 / 50 / sub_49a6a335 * msg.value / 10^9 / 50 != 2:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _31167 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31167] = 30
                        mem[_31167 + 32] = 'SafeMath: subtraction overflow'
                        if 2 * sub_49a6a335 * msg.value / 10^9 / 50 > sub_49a6a335 * msg.value / 10^9:
                            _31319 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31319 + 68] = mem[idx + _31167 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31319 + 68] = mem[_31319 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _31319 + -mem[64] + 100
                        idx = 0
                        s = _tTotal
                        t = stor32
                        while idx < stor30.length:
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            if stor26[stor30[idx]] > t:
                                _59499 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59499] = 26
                                mem[_59499 + 32] = 'SafeMath: division by zero'
                                if not _tTotal:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _59499 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_49a6a335 * msg.value / 10^9:
                                    if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                        _61383 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_61383] = 30
                                        mem[_61383 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = this.address
                                        mem[32] = 26
                                        _62085 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_62085] = 30
                                        mem[_62085 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor26[address(this.address)]:
                                            _62480 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _62480 + 68] = mem[idx + _62085 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_62480 + 68] = mem[_62480 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _62480 + -mem[64] + 100
                                        if stor26[msg.sender] < stor26[msg.sender]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 26
                                        stor26[address(msg.sender)] = stor26[msg.sender]
                                        _64802 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_64802] = 30
                                        mem[_64802 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor32:
                                            _65536 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _65536 + 68] = mem[idx + _64802 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_65536 + 68] = mem[_65536 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _65536 + -mem[64] + 100
                                        if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                        emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                        _67665 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_67665] = 26
                                        mem[_67665 + 32] = 'SafeMath: division by zero'
                                        if not sub_1b2cabba:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _67665 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not sub_8a3be0b6:
                                            if ethSent <= 0:
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            presaleTime = timeBetweenRounds + block.timestamp
                                            sub_8a3be0b6++
                                            _72861 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_72861] = 30
                                            mem[_72861 + 32] = 'SafeMath: subtraction overflow'
                                            if sub_be71ce9f <= sub_49a6a335:
                                                sub_49a6a335 -= sub_be71ce9f
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            _73859 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _73859 + 68] = mem[idx + _72861 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_73859 + 68] = mem[_73859 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _73859 + -mem[64] + 100
                                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                            if ethSent <= 0:
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            presaleTime = timeBetweenRounds + block.timestamp
                                            sub_8a3be0b6++
                                            _73387 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_73387] = 30
                                            mem[_73387 + 32] = 'SafeMath: subtraction overflow'
                                            if sub_be71ce9f <= sub_49a6a335:
                                                sub_49a6a335 -= sub_be71ce9f
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            _74374 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _74374 + 68] = mem[idx + _73387 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_74374 + 68] = mem[_74374 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _74374 + -mem[64] + 100
                                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73858 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73858] = 30
                                        mem[_73858 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74903 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74903 + 68] = mem[idx + _73858 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74903 + 68] = mem[_74903 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74903 + -mem[64] + 100
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _61424 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61424] = 30
                                    mem[_61424 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                        _61540 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _61540 + 68] = mem[idx + _61424 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_61540 + 68] = mem[_61540 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _61540 + -mem[64] + 100
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62310 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62310] = 30
                                    mem[_62310 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _62724 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62724 + 68] = mem[idx + _62310 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62724 + 68] = mem[_62724 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62724 + -mem[64] + 100
                                    if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                    _65184 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65184] = 30
                                    mem[_65184 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                        _65842 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _65842 + 68] = mem[idx + _65184 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_65842 + 68] = mem[_65842 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _65842 + -mem[64] + 100
                                    stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68020 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68020] = 26
                                    mem[_68020 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _68020 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73386 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73386] = 30
                                        mem[_73386 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74371 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74371 + 68] = mem[idx + _73386 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74371 + 68] = mem[_74371 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74371 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73857 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73857] = 30
                                        mem[_73857 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74900 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74900 + 68] = mem[idx + _73857 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74900 + 68] = mem[_74900 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74900 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74370 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74370] = 30
                                    mem[_74370 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75530 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75530 + 68] = mem[idx + _74370 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75530 + 68] = mem[_75530 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75530 + -mem[64] + 100
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61423 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61423] = 30
                                    mem[_61423 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                        _61537 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _61537 + 68] = mem[idx + _61423 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_61537 + 68] = mem[_61537 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _61537 + -mem[64] + 100
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62309 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62309] = 30
                                    mem[_62309 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                        _62721 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62721 + 68] = mem[idx + _62309 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62721 + 68] = mem[_62721 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62721 + -mem[64] + 100
                                    stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                    if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                    _65183 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65183] = 30
                                    mem[_65183 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _65839 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _65839 + 68] = mem[idx + _65183 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_65839 + 68] = mem[_65839 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _65839 + -mem[64] + 100
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68019 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68019] = 26
                                    mem[_68019 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _68019 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73383 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73383] = 30
                                        mem[_73383 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74367 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74367 + 68] = mem[idx + _73383 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74367 + 68] = mem[_74367 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74367 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73856 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73856] = 30
                                        mem[_73856 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74897 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74897 + 68] = mem[idx + _73856 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74897 + 68] = mem[_74897 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74897 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74366 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74366] = 30
                                    mem[_74366 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75526 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75526 + 68] = mem[idx + _74366 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75526 + 68] = mem[_75526 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75526 + -mem[64] + 100
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61463 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61463] = 30
                                mem[_61463 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    _61659 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61659 + 68] = mem[idx + _61463 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61659 + 68] = mem[_61659 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61659 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62479 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62479] = 30
                                mem[_62479 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _63003 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63003 + 68] = mem[idx + _62479 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63003 + 68] = mem[_63003 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63003 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _65535 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65535] = 30
                                mem[_65535 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    _66013 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66013 + 68] = mem[idx + _65535 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66013 + 68] = mem[_66013 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66013 + -mem[64] + 100
                                stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68249 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68249] = 26
                                mem[_68249 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68249 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73855 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73855] = 30
                                    mem[_73855 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74894 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74894 + 68] = mem[idx + _73855 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74894 + 68] = mem[_74894 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74894 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74365 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74365] = 30
                                    mem[_74365 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75523 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75523 + 68] = mem[idx + _74365 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75523 + 68] = mem[_75523 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75523 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74893 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74893] = 30
                                mem[_74893 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76183 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76183 + 68] = mem[idx + _74893 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76183 + 68] = mem[_76183 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76183 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            if stor27[stor30[idx]] <= s:
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 26
                                _59611 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59611] = 30
                                mem[_59611 + 32] = 'SafeMath: subtraction overflow'
                                if stor26[stor30[idx]] > t:
                                    _59806 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _59806 + 68] = mem[idx + _59611 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59806 + 68] = mem[_59806 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59806 + -mem[64] + 100
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 27
                                _60516 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_60516] = 30
                                mem[_60516 + 32] = 'SafeMath: subtraction overflow'
                                if stor27[stor30[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor27[stor30[idx]]
                                    t = t - stor26[stor30[idx]]
                                    continue 
                                _60833 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _60833 + 68] = mem[idx + _60516 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_60833 + 68] = mem[_60833 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _60833 + -mem[64] + 100
                            _59693 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59693] = 26
                            mem[_59693 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59693 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61466 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61466] = 30
                                    mem[_61466 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62489 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62489] = 30
                                    mem[_62489 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _63010 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _63010 + 68] = mem[idx + _62489 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_63010 + 68] = mem[_63010 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _63010 + -mem[64] + 100
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _65540 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65540] = 30
                                    mem[_65540 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _66018 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _66018 + 68] = mem[idx + _65540 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_66018 + 68] = mem[_66018 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _66018 + -mem[64] + 100
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68255 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68255] = 26
                                    mem[_68255 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _68255 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73870 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73870] = 30
                                        mem[_73870 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74913 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74913 + 68] = mem[idx + _73870 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74913 + 68] = mem[_74913 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74913 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _74385 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_74385] = 30
                                        mem[_74385 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _75548 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _75548 + 68] = mem[idx + _74385 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_75548 + 68] = mem[_75548 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _75548 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74912 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74912] = 30
                                    mem[_74912 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76213 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76213 + 68] = mem[idx + _74912 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76213 + 68] = mem[_76213 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76213 + -mem[64] + 100
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61544 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61544] = 30
                                mem[_61544 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                    _61786 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61786 + 68] = mem[idx + _61544 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61786 + 68] = mem[_61786 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61786 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62730 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62730] = 30
                                mem[_62730 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _63352 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63352 + 68] = mem[idx + _62730 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63352 + 68] = mem[_63352 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63352 + -mem[64] + 100
                                if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _65846 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65846] = 30
                                mem[_65846 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    _66220 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66220 + 68] = mem[idx + _65846 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66220 + 68] = mem[_66220 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66220 + -mem[64] + 100
                                stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68521 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68521] = 26
                                mem[_68521 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68521 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74384 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74384] = 30
                                    mem[_74384 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75545 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75545 + 68] = mem[idx + _74384 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75545 + 68] = mem[_75545 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75545 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74911 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74911] = 30
                                    mem[_74911 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76210 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76210 + 68] = mem[idx + _74911 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76210 + 68] = mem[_76210 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76210 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75544 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75544] = 30
                                mem[_75544 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77034 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77034 + 68] = mem[idx + _75544 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77034 + 68] = mem[_77034 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77034 + -mem[64] + 100
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _61543 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61543] = 30
                                mem[_61543 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    _61783 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61783 + 68] = mem[idx + _61543 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61783 + 68] = mem[_61783 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61783 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62729 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62729] = 30
                                mem[_62729 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _63349 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63349 + 68] = mem[idx + _62729 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63349 + 68] = mem[_63349 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63349 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _65845 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65845] = 30
                                mem[_65845 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66217 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66217 + 68] = mem[idx + _65845 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66217 + 68] = mem[_66217 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66217 + -mem[64] + 100
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68520 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68520] = 26
                                mem[_68520 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68520 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74381 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74381] = 30
                                    mem[_74381 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75541 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75541 + 68] = mem[idx + _74381 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75541 + 68] = mem[_75541 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75541 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74910 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74910] = 30
                                    mem[_74910 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76207 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76207 + 68] = mem[idx + _74910 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76207 + 68] = mem[_76207 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76207 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75540 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75540] = 30
                                mem[_75540 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77030 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77030 + 68] = mem[idx + _75540 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77030 + 68] = mem[_77030 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77030 + -mem[64] + 100
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61662 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61662] = 30
                            mem[_61662 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _61921 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _61921 + 68] = mem[idx + _61662 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_61921 + 68] = mem[_61921 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _61921 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _63009 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_63009] = 30
                            mem[_63009 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _63635 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63635 + 68] = mem[idx + _63009 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63635 + 68] = mem[_63635 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63635 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                            _66017 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_66017] = 30
                            mem[_66017 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                _66437 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66437 + 68] = mem[idx + _66017 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66437 + 68] = mem[_66437 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66437 + -mem[64] + 100
                            stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _68732 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68732] = 26
                            mem[_68732 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68732 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74909 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74909] = 30
                                mem[_74909 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76204 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76204 + 68] = mem[idx + _74909 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76204 + 68] = mem[_76204 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76204 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75539 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75539] = 30
                                mem[_75539 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77027 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77027 + 68] = mem[idx + _75539 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77027 + 68] = mem[_77027 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77027 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _76203 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_76203] = 30
                            mem[_76203 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _77922 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77922 + 68] = mem[idx + _76203 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77922 + 68] = mem[_77922 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77922 + -mem[64] + 100
                        _57833 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_57833] = 26
                        mem[_57833 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _57833 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor32 / _tTotal:
                            _59913 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59913] = 26
                            mem[_59913 + 32] = 'SafeMath: division by zero'
                            if not s:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59913 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61655 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61655] = 30
                                    mem[_61655 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62995 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62995] = 30
                                    mem[_62995 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _63618 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _63618 + 68] = mem[idx + _62995 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_63618 + 68] = mem[_63618 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _63618 + -mem[64] + 100
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _66010 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66010] = 30
                                    mem[_66010 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _66422 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _66422 + 68] = mem[idx + _66010 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_66422 + 68] = mem[_66422 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _66422 + -mem[64] + 100
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68721 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68721] = 26
                                    mem[_68721 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _68721 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _74883 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_74883] = 30
                                        mem[_74883 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _76171 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _76171 + 68] = mem[idx + _74883 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_76171 + 68] = mem[_76171 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _76171 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _75513 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_75513] = 30
                                        mem[_75513 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _76990 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _76990 + 68] = mem[idx + _75513 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_76990 + 68] = mem[_76990 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _76990 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _76170 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_76170] = 30
                                    mem[_76170 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _77887 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _77887 + 68] = mem[idx + _76170 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_77887 + 68] = mem[_77887 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _77887 + -mem[64] + 100
                                if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != t / s:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61778 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61778] = 30
                                mem[_61778 + 32] = 'SafeMath: subtraction overflow'
                                if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                    _62070 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62070 + 68] = mem[idx + _61778 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62070 + 68] = mem[_62070 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62070 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _63336 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63336] = 30
                                mem[_63336 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _64032 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _64032 + 68] = mem[idx + _63336 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_64032 + 68] = mem[_64032 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _64032 + -mem[64] + 100
                                if (-1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (-1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _66210 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66210] = 30
                                mem[_66210 + 32] = 'SafeMath: subtraction overflow'
                                if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    _66768 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66768 + 68] = mem[idx + _66210 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66768 + 68] = mem[_66768 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66768 + -mem[64] + 100
                                stor32 += -1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68982 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68982] = 26
                                mem[_68982 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68982 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75512 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75512] = 30
                                    mem[_75512 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76987 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76987 + 68] = mem[idx + _75512 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76987 + 68] = mem[_76987 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76987 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _76169 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_76169] = 30
                                    mem[_76169 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _77884 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _77884 + 68] = mem[idx + _76169 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_77884 + 68] = mem[_77884 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _77884 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _76986 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_76986] = 30
                                mem[_76986 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _78762 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _78762 + 68] = mem[idx + _76986 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_78762 + 68] = mem[_78762 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _78762 + -mem[64] + 100
                            if t / s * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != t / s:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _61777 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61777] = 30
                                mem[_61777 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > t / s * sub_49a6a335 * msg.value / 10^9:
                                    _62067 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62067 + 68] = mem[idx + _61777 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62067 + 68] = mem[_62067 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62067 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _63335 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63335] = 30
                                mem[_63335 + 32] = 'SafeMath: subtraction overflow'
                                if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _64029 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _64029 + 68] = mem[idx + _63335 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_64029 + 68] = mem[_64029 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _64029 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                                if (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _66209 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66209] = 30
                                mem[_66209 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66765 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66765 + 68] = mem[idx + _66209 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66765 + 68] = mem[_66765 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66765 + -mem[64] + 100
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68981 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68981] = 26
                                mem[_68981 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68981 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75509 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75509] = 30
                                    mem[_75509 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76983 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76983 + 68] = mem[idx + _75509 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76983 + 68] = mem[_76983 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76983 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _76168 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_76168] = 30
                                    mem[_76168 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _77881 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _77881 + 68] = mem[idx + _76168 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_77881 + 68] = mem[_77881 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _77881 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _76982 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_76982] = 30
                                mem[_76982 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _78758 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _78758 + 68] = mem[idx + _76982 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_78758 + 68] = mem[_78758 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _78758 + -mem[64] + 100
                            if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != t / s:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61913 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61913] = 30
                            mem[_61913 + 32] = 'SafeMath: subtraction overflow'
                            if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > t / s * sub_49a6a335 * msg.value / 10^9:
                                _62301 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _62301 + 68] = mem[idx + _61913 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_62301 + 68] = mem[_62301 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _62301 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _63617 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_63617] = 30
                            mem[_63617 + 32] = 'SafeMath: subtraction overflow'
                            if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _64395 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _64395 + 68] = mem[idx + _63617 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_64395 + 68] = mem[_64395 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _64395 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                            if (t / s * sub_49a6a335 * msg.value / 10^9) - (t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) - (t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                            _66421 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_66421] = 30
                            mem[_66421 + 32] = 'SafeMath: subtraction overflow'
                            if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                _67057 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _67057 + 68] = mem[idx + _66421 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_67057 + 68] = mem[_67057 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _67057 + -mem[64] + 100
                            stor32 += -1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _69245 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_69245] = 26
                            mem[_69245 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _69245 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _76167 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_76167] = 30
                                mem[_76167 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77878 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77878 + 68] = mem[idx + _76167 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77878 + 68] = mem[_77878 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77878 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _76981 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_76981] = 30
                                mem[_76981 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _78755 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _78755 + 68] = mem[idx + _76981 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_78755 + 68] = mem[_78755 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _78755 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _77877 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_77877] = 30
                            mem[_77877 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _79593 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _79593 + 68] = mem[idx + _77877 + 32]
                                idx = idx + 32
                                continue 
                            mem[_79593 + 68] = mem[_79593 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _79593 + -mem[64] + 100
                        _59914 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_59914] = 26
                        mem[_59914 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _59914 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_49a6a335 * msg.value / 10^9:
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _61658 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61658] = 30
                                mem[_61658 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _63002 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63002] = 30
                                mem[_63002 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _63622 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63622 + 68] = mem[idx + _63002 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63622 + 68] = mem[_63622 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63622 + -mem[64] + 100
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _66012 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66012] = 30
                                mem[_66012 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66426 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66426 + 68] = mem[idx + _66012 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66426 + 68] = mem[_66426 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66426 + -mem[64] + 100
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68724 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68724] = 26
                                mem[_68724 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68724 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74892 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74892] = 30
                                    mem[_74892 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76180 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76180 + 68] = mem[idx + _74892 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76180 + 68] = mem[_76180 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76180 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75522 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75522] = 30
                                    mem[_75522 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _77002 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _77002 + 68] = mem[idx + _75522 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_77002 + 68] = mem[_77002 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _77002 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _76179 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_76179] = 30
                                mem[_76179 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77901 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77901 + 68] = mem[idx + _76179 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77901 + 68] = mem[_77901 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77901 + -mem[64] + 100
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61780 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61780] = 30
                            mem[_61780 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                _62076 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _62076 + 68] = mem[idx + _61780 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_62076 + 68] = mem[_62076 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _62076 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _63340 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_63340] = 30
                            mem[_63340 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                _64038 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _64038 + 68] = mem[idx + _63340 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_64038 + 68] = mem[_64038 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _64038 + -mem[64] + 100
                            if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                            _66212 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_66212] = 30
                            mem[_66212 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                _66774 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66774 + 68] = mem[idx + _66212 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66774 + 68] = mem[_66774 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66774 + -mem[64] + 100
                            stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _68984 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68984] = 26
                            mem[_68984 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68984 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75521 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75521] = 30
                                mem[_75521 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76999 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76999 + 68] = mem[idx + _75521 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76999 + 68] = mem[_76999 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76999 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _76178 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_76178] = 30
                                mem[_76178 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77898 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77898 + 68] = mem[idx + _76178 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77898 + 68] = mem[_77898 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77898 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _76998 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_76998] = 30
                            mem[_76998 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _78778 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _78778 + 68] = mem[idx + _76998 + 32]
                                idx = idx + 32
                                continue 
                            mem[_78778 + 68] = mem[_78778 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _78778 + -mem[64] + 100
                        if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                            _61779 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61779] = 30
                            mem[_61779 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _62073 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _62073 + 68] = mem[idx + _61779 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_62073 + 68] = mem[_62073 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _62073 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _63339 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_63339] = 30
                            mem[_63339 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _64035 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _64035 + 68] = mem[idx + _63339 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_64035 + 68] = mem[_64035 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _64035 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                            _66211 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_66211] = 30
                            mem[_66211 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _66771 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66771 + 68] = mem[idx + _66211 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66771 + 68] = mem[_66771 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66771 + -mem[64] + 100
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _68983 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68983] = 26
                            mem[_68983 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68983 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75518 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75518] = 30
                                mem[_75518 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76995 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76995 + 68] = mem[idx + _75518 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76995 + 68] = mem[_76995 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76995 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _76177 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_76177] = 30
                                mem[_76177 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77895 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77895 + 68] = mem[idx + _76177 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77895 + 68] = mem[_77895 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77895 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _76994 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_76994] = 30
                            mem[_76994 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _78774 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _78774 + 68] = mem[idx + _76994 + 32]
                                idx = idx + 32
                                continue 
                            mem[_78774 + 68] = mem[_78774 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _78774 + -mem[64] + 100
                        if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _61914 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61914] = 30
                        mem[_61914 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                            _62304 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _62304 + 68] = mem[idx + _61914 + 32]
                                idx = idx + 32
                                continue 
                            mem[_62304 + 68] = mem[_62304 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _62304 + -mem[64] + 100
                        mem[0] = this.address
                        mem[32] = 26
                        _63621 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_63621] = 30
                        mem[_63621 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                            _64401 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _64401 + 68] = mem[idx + _63621 + 32]
                                idx = idx + 32
                                continue 
                            mem[_64401 + 68] = mem[_64401 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _64401 + -mem[64] + 100
                        stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                        if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                        _66425 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_66425] = 30
                        mem[_66425 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                            _67061 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _67061 + 68] = mem[idx + _66425 + 32]
                                idx = idx + 32
                                continue 
                            mem[_67061 + 68] = mem[_67061 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _67061 + -mem[64] + 100
                        stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                        if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                        emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                        _69249 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_69249] = 26
                        mem[_69249 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _69249 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _76176 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_76176] = 30
                            mem[_76176 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _77892 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77892 + 68] = mem[idx + _76176 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77892 + 68] = mem[_77892 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77892 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _76993 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_76993] = 30
                            mem[_76993 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _78771 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _78771 + 68] = mem[idx + _76993 + 32]
                                idx = idx + 32
                                continue 
                            mem[_78771 + 68] = mem[_78771 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _78771 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _77891 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_77891] = 30
                        mem[_77891 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        _79613 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _79613 + 68] = mem[idx + _77891 + 32]
                            idx = idx + 32
                            continue 
                        mem[_79613 + 68] = mem[_79613 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _79613 + -mem[64] + 100
                    require idx < stor30.length
                    mem[0] = stor30[idx]
                    mem[32] = 27
                    if stor27[stor30[idx]] <= s:
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 26
                        _28911 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28911] = 30
                        mem[_28911 + 32] = 'SafeMath: subtraction overflow'
                        if stor26[stor30[idx]] > t:
                            _28990 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28990 + 68] = mem[idx + _28911 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28990 + 68] = mem[_28990 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _28990 + -mem[64] + 100
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 27
                        _29283 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29283] = 30
                        mem[_29283 + 32] = 'SafeMath: subtraction overflow'
                        if stor27[stor30[idx]] <= s:
                            idx = idx + 1
                            s = s - stor27[stor30[idx]]
                            t = t - stor26[stor30[idx]]
                            continue 
                        _29420 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29420 + 68] = mem[idx + _29283 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29420 + 68] = mem[_29420 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _29420 + -mem[64] + 100
                    _28943 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28943] = 26
                    mem[_28943 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _28943 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    _29423 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29423] = 26
                    mem[_29423 + 32] = 'SafeMath: division by zero'
                    if not stor32 / _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _29423 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if stor26[address(this.address)] / stor32 / _tTotal < sub_49a6a335 * msg.value / 10^9:
                        revert with 0, 32, 33, 0x774e6f7420656e6f75676820746f6b656e7320696e2074686520636f6e74726163, mem[mem[64] + 101 len 31]
                    if msg.value + sub_536c8c02[msg.sender] < sub_536c8c02[msg.sender]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = msg.sender
                    mem[32] = 20
                    sub_536c8c02[msg.sender] += msg.value
                    if msg.value + ethSent < ethSent:
                        revert with 0, 'SafeMath: addition overflow'
                    ethSent += msg.value
                    _30423 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30423] = 26
                    mem[_30423 + 32] = 'SafeMath: division by zero'
                    if not sub_49a6a335 * msg.value / 10^9 / 50:
                        _31224 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31224] = 30
                        mem[_31224 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > sub_49a6a335 * msg.value / 10^9:
                            _31410 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31410 + 68] = mem[idx + _31224 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31410 + 68] = mem[_31410 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _31410 + -mem[64] + 100
                        idx = 0
                        s = _tTotal
                        t = stor32
                        while idx < stor30.length:
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            if stor26[stor30[idx]] > t:
                                _59514 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59514] = 26
                                mem[_59514 + 32] = 'SafeMath: division by zero'
                                if not _tTotal:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _59514 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_49a6a335 * msg.value / 10^9:
                                    _61388 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61388] = 30
                                    mem[_61388 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62127 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62127] = 30
                                    mem[_62127 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _62515 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62515 + 68] = mem[idx + _62127 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62515 + 68] = mem[_62515 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62515 + -mem[64] + 100
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _64864 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_64864] = 30
                                    mem[_64864 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _65585 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _65585 + 68] = mem[idx + _64864 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_65585 + 68] = mem[_65585 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _65585 + -mem[64] + 100
                                    if _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    _67718 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_67718] = 26
                                    mem[_67718 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _67718 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _72944 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_72944] = 30
                                        mem[_72944 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _73933 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _73933 + 68] = mem[idx + _72944 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_73933 + 68] = mem[_73933 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _73933 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73460 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73460] = 30
                                        mem[_73460 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74454 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74454 + 68] = mem[idx + _73460 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74454 + 68] = mem[_74454 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74454 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73932 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73932] = 30
                                    mem[_73932 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74992 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74992 + 68] = mem[idx + _73932 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74992 + 68] = mem[_74992 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74992 + -mem[64] + 100
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61432 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61432] = 30
                                mem[_61432 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    _61561 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61561 + 68] = mem[idx + _61432 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61561 + 68] = mem[_61561 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61561 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62337 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62337] = 30
                                mem[_62337 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _62769 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62769 + 68] = mem[idx + _62337 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62769 + 68] = mem[_62769 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62769 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _65239 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65239] = 30
                                mem[_65239 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _65873 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _65873 + 68] = mem[idx + _65239 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_65873 + 68] = mem[_65873 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _65873 + -mem[64] + 100
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68062 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68062] = 26
                                mem[_68062 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68062 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73459 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73459] = 30
                                    mem[_73459 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74451 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74451 + 68] = mem[idx + _73459 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74451 + 68] = mem[_74451 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74451 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73931 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73931] = 30
                                    mem[_73931 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74989 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74989 + 68] = mem[idx + _73931 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74989 + 68] = mem[_74989 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74989 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74450 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74450] = 30
                                mem[_74450 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _75629 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75629 + 68] = mem[idx + _74450 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75629 + 68] = mem[_75629 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75629 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            if stor27[stor30[idx]] <= s:
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 26
                                _59620 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59620] = 30
                                mem[_59620 + 32] = 'SafeMath: subtraction overflow'
                                if stor26[stor30[idx]] > t:
                                    _59818 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _59818 + 68] = mem[idx + _59620 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59818 + 68] = mem[_59818 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59818 + -mem[64] + 100
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 27
                                _60537 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_60537] = 30
                                mem[_60537 + 32] = 'SafeMath: subtraction overflow'
                                if stor27[stor30[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor27[stor30[idx]]
                                    t = t - stor26[stor30[idx]]
                                    continue 
                                _60857 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _60857 + 68] = mem[idx + _60537 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_60857 + 68] = mem[_60857 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _60857 + -mem[64] + 100
                            _59708 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59708] = 26
                            mem[_59708 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59708 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                _61472 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61472] = 30
                                mem[_61472 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _62520 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62520] = 30
                                mem[_62520 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _63058 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63058 + 68] = mem[idx + _62520 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63058 + 68] = mem[_63058 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63058 + -mem[64] + 100
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _65588 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65588] = 30
                                mem[_65588 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66042 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66042 + 68] = mem[idx + _65588 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66042 + 68] = mem[_66042 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66042 + -mem[64] + 100
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68288 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68288] = 26
                                mem[_68288 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68288 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73940 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73940] = 30
                                    mem[_73940 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74998 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74998 + 68] = mem[idx + _73940 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74998 + 68] = mem[_74998 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74998 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74460 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74460] = 30
                                    mem[_74460 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75642 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75642 + 68] = mem[idx + _74460 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75642 + 68] = mem[_75642 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75642 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74997 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74997] = 30
                                mem[_74997 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76321 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76321 + 68] = mem[idx + _74997 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76321 + 68] = mem[_76321 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76321 + -mem[64] + 100
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61564 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61564] = 30
                            mem[_61564 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _61810 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _61810 + 68] = mem[idx + _61564 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_61810 + 68] = mem[_61810 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _61810 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _62772 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_62772] = 30
                            mem[_62772 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _63394 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63394 + 68] = mem[idx + _62772 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63394 + 68] = mem[_63394 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63394 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                            _65876 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_65876] = 30
                            mem[_65876 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _66250 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66250 + 68] = mem[idx + _65876 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66250 + 68] = mem[_66250 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66250 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            _68556 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68556] = 26
                            mem[_68556 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68556 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74459 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74459] = 30
                                mem[_74459 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _75639 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75639 + 68] = mem[idx + _74459 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75639 + 68] = mem[_75639 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75639 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74996 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74996] = 30
                                mem[_74996 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76318 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76318 + 68] = mem[idx + _74996 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76318 + 68] = mem[_76318 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76318 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75638 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75638] = 30
                            mem[_75638 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _77164 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77164 + 68] = mem[idx + _75638 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77164 + 68] = mem[_77164 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77164 + -mem[64] + 100
                        _57856 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_57856] = 26
                        mem[_57856 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _57856 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor32 / _tTotal:
                            _59934 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59934] = 26
                            mem[_59934 + 32] = 'SafeMath: division by zero'
                            if not s:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59934 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                _61675 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61675] = 30
                                mem[_61675 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _63051 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63051] = 30
                                mem[_63051 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _63679 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63679 + 68] = mem[idx + _63051 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63679 + 68] = mem[_63679 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63679 + -mem[64] + 100
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _66039 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66039] = 30
                                mem[_66039 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66473 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66473 + 68] = mem[idx + _66039 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66473 + 68] = mem[_66473 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66473 + -mem[64] + 100
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68761 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68761] = 26
                                mem[_68761 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68761 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74983 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74983] = 30
                                    mem[_74983 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76299 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76299 + 68] = mem[idx + _74983 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76299 + 68] = mem[_76299 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76299 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75624 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75624] = 30
                                    mem[_75624 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _77143 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _77143 + 68] = mem[idx + _75624 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_77143 + 68] = mem[_77143 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _77143 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _76298 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_76298] = 30
                                mem[_76298 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _78041 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _78041 + 68] = mem[idx + _76298 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_78041 + 68] = mem[_78041 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _78041 + -mem[64] + 100
                            if t / s * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != t / s:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61807 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61807] = 30
                            mem[_61807 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > t / s * sub_49a6a335 * msg.value / 10^9:
                                _62119 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _62119 + 68] = mem[idx + _61807 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_62119 + 68] = mem[_62119 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _62119 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _63387 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_63387] = 30
                            mem[_63387 + 32] = 'SafeMath: subtraction overflow'
                            if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _64102 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _64102 + 68] = mem[idx + _63387 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_64102 + 68] = mem[_64102 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _64102 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                            if (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                            _66245 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_66245] = 30
                            mem[_66245 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _66825 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66825 + 68] = mem[idx + _66245 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66825 + 68] = mem[_66825 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66825 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            _69027 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_69027] = 26
                            mem[_69027 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _69027 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75623 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75623] = 30
                                mem[_75623 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77140 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77140 + 68] = mem[idx + _75623 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77140 + 68] = mem[_77140 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77140 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _76297 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_76297] = 30
                                mem[_76297 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _78038 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _78038 + 68] = mem[idx + _76297 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_78038 + 68] = mem[_78038 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _78038 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _77139 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_77139] = 30
                            mem[_77139 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _78907 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _78907 + 68] = mem[idx + _77139 + 32]
                                idx = idx + 32
                                continue 
                            mem[_78907 + 68] = mem[_78907 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _78907 + -mem[64] + 100
                        _59935 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_59935] = 26
                        mem[_59935 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _59935 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_49a6a335 * msg.value / 10^9:
                            _61676 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61676] = 30
                            mem[_61676 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = this.address
                            mem[32] = 26
                            _63054 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_63054] = 30
                            mem[_63054 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                _63682 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63682 + 68] = mem[idx + _63054 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63682 + 68] = mem[_63682 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63682 + -mem[64] + 100
                            if stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = stor26[msg.sender]
                            _66040 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_66040] = 30
                            mem[_66040 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _66476 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66476 + 68] = mem[idx + _66040 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66476 + 68] = mem[_66476 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66476 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            _68762 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68762] = 26
                            mem[_68762 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68762 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74988 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74988] = 30
                                mem[_74988 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76304 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76304 + 68] = mem[idx + _74988 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76304 + 68] = mem[_76304 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76304 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75628 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75628] = 30
                                mem[_75628 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77150 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77150 + 68] = mem[idx + _75628 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77150 + 68] = mem[_77150 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77150 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _76303 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_76303] = 30
                            mem[_76303 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _78048 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _78048 + 68] = mem[idx + _76303 + 32]
                                idx = idx + 32
                                continue 
                            mem[_78048 + 68] = mem[_78048 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _78048 + -mem[64] + 100
                        if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _61808 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61808] = 30
                        mem[_61808 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                            _62122 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _62122 + 68] = mem[idx + _61808 + 32]
                                idx = idx + 32
                                continue 
                            mem[_62122 + 68] = mem[_62122 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _62122 + -mem[64] + 100
                        mem[0] = this.address
                        mem[32] = 26
                        _63388 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_63388] = 30
                        mem[_63388 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                            _64105 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _64105 + 68] = mem[idx + _63388 + 32]
                                idx = idx + 32
                                continue 
                            mem[_64105 + 68] = mem[_64105 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _64105 + -mem[64] + 100
                        stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                        if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                        _66246 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_66246] = 30
                        mem[_66246 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            _66828 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _66828 + 68] = mem[idx + _66246 + 32]
                                idx = idx + 32
                                continue 
                            mem[_66828 + 68] = mem[_66828 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _66828 + -mem[64] + 100
                        if _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                        _69028 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_69028] = 26
                        mem[_69028 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _69028 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75627 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75627] = 30
                            mem[_75627 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _77147 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77147 + 68] = mem[idx + _75627 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77147 + 68] = mem[_77147 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77147 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _76302 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_76302] = 30
                            mem[_76302 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _78045 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _78045 + 68] = mem[idx + _76302 + 32]
                                idx = idx + 32
                                continue 
                            mem[_78045 + 68] = mem[_78045 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _78045 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _77146 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_77146] = 30
                        mem[_77146 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        _78916 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _78916 + 68] = mem[idx + _77146 + 32]
                            idx = idx + 32
                            continue 
                        mem[_78916 + 68] = mem[_78916 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _78916 + -mem[64] + 100
                    if 2 * sub_49a6a335 * msg.value / 10^9 / 50 / sub_49a6a335 * msg.value / 10^9 / 50 != 2:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _31322 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31322] = 30
                    mem[_31322 + 32] = 'SafeMath: subtraction overflow'
                    if 2 * sub_49a6a335 * msg.value / 10^9 / 50 > sub_49a6a335 * msg.value / 10^9:
                        _31502 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _31502 + 68] = mem[idx + _31322 + 32]
                            idx = idx + 32
                            continue 
                        mem[_31502 + 68] = mem[_31502 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _31502 + -mem[64] + 100
                    idx = 0
                    s = _tTotal
                    t = stor32
                    while idx < stor30.length:
                        mem[0] = stor30[idx]
                        mem[32] = 26
                        if stor26[stor30[idx]] > t:
                            _59509 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59509] = 26
                            mem[_59509 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59509 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61387 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61387] = 30
                                    mem[_61387 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62116 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62116] = 30
                                    mem[_62116 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _62503 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62503 + 68] = mem[idx + _62116 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62503 + 68] = mem[_62503 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62503 + -mem[64] + 100
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _64844 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_64844] = 30
                                    mem[_64844 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _65572 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _65572 + 68] = mem[idx + _64844 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_65572 + 68] = mem[_65572 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _65572 + -mem[64] + 100
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _67702 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_67702] = 26
                                    mem[_67702 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _67702 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _72919 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_72919] = 30
                                        mem[_72919 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _73911 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _73911 + 68] = mem[idx + _72919 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_73911 + 68] = mem[_73911 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _73911 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73440 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73440] = 30
                                        mem[_73440 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74430 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74430 + 68] = mem[idx + _73440 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74430 + 68] = mem[_74430 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74430 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73910 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73910] = 30
                                    mem[_73910 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74966 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74966 + 68] = mem[idx + _73910 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74966 + 68] = mem[_74966 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74966 + -mem[64] + 100
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61429 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61429] = 30
                                mem[_61429 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                    _61556 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61556 + 68] = mem[idx + _61429 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61556 + 68] = mem[_61556 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61556 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62330 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62330] = 30
                                mem[_62330 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _62756 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62756 + 68] = mem[idx + _62330 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62756 + 68] = mem[_62756 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62756 + -mem[64] + 100
                                if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _65223 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65223] = 30
                                mem[_65223 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    _65866 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _65866 + 68] = mem[idx + _65223 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_65866 + 68] = mem[_65866 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _65866 + -mem[64] + 100
                                stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68051 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68051] = 26
                                mem[_68051 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68051 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73439 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73439] = 30
                                    mem[_73439 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74427 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74427 + 68] = mem[idx + _73439 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74427 + 68] = mem[_74427 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74427 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73909 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73909] = 30
                                    mem[_73909 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74963 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74963 + 68] = mem[idx + _73909 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74963 + 68] = mem[_74963 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74963 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74426 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74426] = 30
                                mem[_74426 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _75600 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75600 + 68] = mem[idx + _74426 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75600 + 68] = mem[_75600 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75600 + -mem[64] + 100
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _61428 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61428] = 30
                                mem[_61428 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    _61553 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61553 + 68] = mem[idx + _61428 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61553 + 68] = mem[_61553 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61553 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62329 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62329] = 30
                                mem[_62329 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _62753 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62753 + 68] = mem[idx + _62329 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62753 + 68] = mem[_62753 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62753 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _65222 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65222] = 30
                                mem[_65222 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _65863 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _65863 + 68] = mem[idx + _65222 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_65863 + 68] = mem[_65863 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _65863 + -mem[64] + 100
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68050 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68050] = 26
                                mem[_68050 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68050 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73436 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73436] = 30
                                    mem[_73436 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74423 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74423 + 68] = mem[idx + _73436 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74423 + 68] = mem[_74423 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74423 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73908 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73908] = 30
                                    mem[_73908 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74960 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74960 + 68] = mem[idx + _73908 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74960 + 68] = mem[_74960 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74960 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74422 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74422] = 30
                                mem[_74422 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _75596 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75596 + 68] = mem[idx + _74422 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75596 + 68] = mem[_75596 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75596 + -mem[64] + 100
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61468 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61468] = 30
                            mem[_61468 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _61671 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _61671 + 68] = mem[idx + _61468 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_61671 + 68] = mem[_61671 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _61671 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _62502 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_62502] = 30
                            mem[_62502 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _63039 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63039 + 68] = mem[idx + _62502 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63039 + 68] = mem[_63039 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63039 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                            _65571 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_65571] = 30
                            mem[_65571 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                _66031 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66031 + 68] = mem[idx + _65571 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66031 + 68] = mem[_66031 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66031 + -mem[64] + 100
                            stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _68274 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68274] = 26
                            mem[_68274 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68274 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _73907 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_73907] = 30
                                mem[_73907 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _74957 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _74957 + 68] = mem[idx + _73907 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_74957 + 68] = mem[_74957 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _74957 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74421 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74421] = 30
                                mem[_74421 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _75593 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75593 + 68] = mem[idx + _74421 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75593 + 68] = mem[_75593 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75593 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _74956 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_74956] = 30
                            mem[_74956 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _76263 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _76263 + 68] = mem[idx + _74956 + 32]
                                idx = idx + 32
                                continue 
                            mem[_76263 + 68] = mem[_76263 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _76263 + -mem[64] + 100
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 27
                        if stor27[stor30[idx]] <= s:
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            _59617 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59617] = 30
                            mem[_59617 + 32] = 'SafeMath: subtraction overflow'
                            if stor26[stor30[idx]] > t:
                                _59814 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _59814 + 68] = mem[idx + _59617 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_59814 + 68] = mem[_59814 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _59814 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            _60530 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_60530] = 30
                            mem[_60530 + 32] = 'SafeMath: subtraction overflow'
                            if stor27[stor30[idx]] <= s:
                                idx = idx + 1
                                s = s - stor27[stor30[idx]]
                                t = t - stor26[stor30[idx]]
                                continue 
                            _60849 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _60849 + 68] = mem[idx + _60530 + 32]
                                idx = idx + 32
                                continue 
                            mem[_60849 + 68] = mem[_60849 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _60849 + -mem[64] + 100
                        _59703 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_59703] = 26
                        mem[_59703 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _59703 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_49a6a335 * msg.value / 10^9:
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _61471 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61471] = 30
                                mem[_61471 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _62512 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62512] = 30
                                mem[_62512 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _63046 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63046 + 68] = mem[idx + _62512 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63046 + 68] = mem[_63046 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63046 + -mem[64] + 100
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _65576 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65576] = 30
                                mem[_65576 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66036 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66036 + 68] = mem[idx + _65576 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66036 + 68] = mem[_66036 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66036 + -mem[64] + 100
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68280 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68280] = 26
                                mem[_68280 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68280 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73922 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73922] = 30
                                    mem[_73922 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74976 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74976 + 68] = mem[idx + _73922 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74976 + 68] = mem[_74976 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74976 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74441 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74441] = 30
                                    mem[_74441 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75618 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75618 + 68] = mem[idx + _74441 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75618 + 68] = mem[_75618 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75618 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74975 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74975] = 30
                                mem[_74975 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76293 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76293 + 68] = mem[idx + _74975 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76293 + 68] = mem[_76293 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76293 + -mem[64] + 100
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61560 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61560] = 30
                            mem[_61560 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                _61804 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _61804 + 68] = mem[idx + _61560 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_61804 + 68] = mem[_61804 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _61804 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _62762 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_62762] = 30
                            mem[_62762 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                _63384 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63384 + 68] = mem[idx + _62762 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63384 + 68] = mem[_63384 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63384 + -mem[64] + 100
                            if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                            _65870 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_65870] = 30
                            mem[_65870 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                _66242 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66242 + 68] = mem[idx + _65870 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66242 + 68] = mem[_66242 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66242 + -mem[64] + 100
                            stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _68547 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68547] = 26
                            mem[_68547 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68547 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74440 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74440] = 30
                                mem[_74440 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _75615 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75615 + 68] = mem[idx + _74440 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75615 + 68] = mem[_75615 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75615 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74974 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74974] = 30
                                mem[_74974 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76290 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76290 + 68] = mem[idx + _74974 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76290 + 68] = mem[_76290 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76290 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75614 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75614] = 30
                            mem[_75614 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _77130 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77130 + 68] = mem[idx + _75614 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77130 + 68] = mem[_77130 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77130 + -mem[64] + 100
                        if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                            _61559 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61559] = 30
                            mem[_61559 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _61801 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _61801 + 68] = mem[idx + _61559 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_61801 + 68] = mem[_61801 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _61801 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _62761 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_62761] = 30
                            mem[_62761 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _63381 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63381 + 68] = mem[idx + _62761 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63381 + 68] = mem[_63381 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63381 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                            _65869 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_65869] = 30
                            mem[_65869 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _66239 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66239 + 68] = mem[idx + _65869 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66239 + 68] = mem[_66239 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66239 + -mem[64] + 100
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _68546 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68546] = 26
                            mem[_68546 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68546 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74437 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74437] = 30
                                mem[_74437 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _75611 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75611 + 68] = mem[idx + _74437 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75611 + 68] = mem[_75611 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75611 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74973 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74973] = 30
                                mem[_74973 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76287 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76287 + 68] = mem[idx + _74973 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76287 + 68] = mem[_76287 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76287 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75610 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75610] = 30
                            mem[_75610 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _77126 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77126 + 68] = mem[idx + _75610 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77126 + 68] = mem[_77126 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77126 + -mem[64] + 100
                        if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _61674 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61674] = 30
                        mem[_61674 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                            _61935 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _61935 + 68] = mem[idx + _61674 + 32]
                                idx = idx + 32
                                continue 
                            mem[_61935 + 68] = mem[_61935 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _61935 + -mem[64] + 100
                        mem[0] = this.address
                        mem[32] = 26
                        _63045 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_63045] = 30
                        mem[_63045 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                            _63673 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _63673 + 68] = mem[idx + _63045 + 32]
                                idx = idx + 32
                                continue 
                            mem[_63673 + 68] = mem[_63673 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _63673 + -mem[64] + 100
                        stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                        if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                        _66035 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_66035] = 30
                        mem[_66035 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                            _66469 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _66469 + 68] = mem[idx + _66035 + 32]
                                idx = idx + 32
                                continue 
                            mem[_66469 + 68] = mem[_66469 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _66469 + -mem[64] + 100
                        stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                        if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                        emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                        _68757 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_68757] = 26
                        mem[_68757 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _68757 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _74972 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_74972] = 30
                            mem[_74972 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _76284 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _76284 + 68] = mem[idx + _74972 + 32]
                                idx = idx + 32
                                continue 
                            mem[_76284 + 68] = mem[_76284 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _76284 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75609 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75609] = 30
                            mem[_75609 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _77123 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77123 + 68] = mem[idx + _75609 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77123 + 68] = mem[_77123 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77123 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _76283 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_76283] = 30
                        mem[_76283 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        _78018 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _78018 + 68] = mem[idx + _76283 + 32]
                            idx = idx + 32
                            continue 
                        mem[_78018 + 68] = mem[_78018 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _78018 + -mem[64] + 100
                    _57851 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_57851] = 26
                    mem[_57851 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _57851 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if t >= stor32 / _tTotal:
                        _59927 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_59927] = 26
                        mem[_59927 + 32] = 'SafeMath: division by zero'
                        if not s:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _59927 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_49a6a335 * msg.value / 10^9:
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _61667 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61667] = 30
                                mem[_61667 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _63031 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63031] = 30
                                mem[_63031 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _63656 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63656 + 68] = mem[idx + _63031 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63656 + 68] = mem[_63656 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63656 + -mem[64] + 100
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _66028 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66028] = 30
                                mem[_66028 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66454 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66454 + 68] = mem[idx + _66028 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66454 + 68] = mem[_66454 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66454 + -mem[64] + 100
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68746 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68746] = 26
                                mem[_68746 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68746 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74946 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74946] = 30
                                    mem[_74946 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76251 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76251 + 68] = mem[idx + _74946 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76251 + 68] = mem[_76251 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76251 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75583 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75583] = 30
                                    mem[_75583 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _77086 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _77086 + 68] = mem[idx + _75583 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_77086 + 68] = mem[_77086 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _77086 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _76250 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_76250] = 30
                                mem[_76250 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77983 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77983 + 68] = mem[idx + _76250 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77983 + 68] = mem[_77983 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77983 + -mem[64] + 100
                            if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != t / s:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61796 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61796] = 30
                            mem[_61796 + 32] = 'SafeMath: subtraction overflow'
                            if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                _62101 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _62101 + 68] = mem[idx + _61796 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_62101 + 68] = mem[_62101 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _62101 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _63368 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_63368] = 30
                            mem[_63368 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                _64076 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _64076 + 68] = mem[idx + _63368 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_64076 + 68] = mem[_64076 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _64076 + -mem[64] + 100
                            if (-1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (-1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                            _66232 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_66232] = 30
                            mem[_66232 + 32] = 'SafeMath: subtraction overflow'
                            if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                _66804 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66804 + 68] = mem[idx + _66232 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66804 + 68] = mem[_66804 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66804 + -mem[64] + 100
                            stor32 += -1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _69010 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_69010] = 26
                            mem[_69010 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _69010 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75582 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75582] = 30
                                mem[_75582 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77083 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77083 + 68] = mem[idx + _75582 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77083 + 68] = mem[_77083 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77083 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _76249 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_76249] = 30
                                mem[_76249 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77980 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77980 + 68] = mem[idx + _76249 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77980 + 68] = mem[_77980 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77980 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _77082 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_77082] = 30
                            mem[_77082 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _78853 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _78853 + 68] = mem[idx + _77082 + 32]
                                idx = idx + 32
                                continue 
                            mem[_78853 + 68] = mem[_78853 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _78853 + -mem[64] + 100
                        if t / s * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != t / s:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                            _61795 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61795] = 30
                            mem[_61795 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > t / s * sub_49a6a335 * msg.value / 10^9:
                                _62098 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _62098 + 68] = mem[idx + _61795 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_62098 + 68] = mem[_62098 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _62098 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _63367 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_63367] = 30
                            mem[_63367 + 32] = 'SafeMath: subtraction overflow'
                            if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _64073 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _64073 + 68] = mem[idx + _63367 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_64073 + 68] = mem[_64073 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _64073 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                            if (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                            _66231 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_66231] = 30
                            mem[_66231 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _66801 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66801 + 68] = mem[idx + _66231 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66801 + 68] = mem[_66801 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66801 + -mem[64] + 100
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _69009 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_69009] = 26
                            mem[_69009 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _69009 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75579 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75579] = 30
                                mem[_75579 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77079 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77079 + 68] = mem[idx + _75579 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77079 + 68] = mem[_77079 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77079 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _76248 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_76248] = 30
                                mem[_76248 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77977 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77977 + 68] = mem[idx + _76248 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77977 + 68] = mem[_77977 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77977 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _77078 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_77078] = 30
                            mem[_77078 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _78849 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _78849 + 68] = mem[idx + _77078 + 32]
                                idx = idx + 32
                                continue 
                            mem[_78849 + 68] = mem[_78849 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _78849 + -mem[64] + 100
                        if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != t / s:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _61927 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61927] = 30
                        mem[_61927 + 32] = 'SafeMath: subtraction overflow'
                        if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > t / s * sub_49a6a335 * msg.value / 10^9:
                            _62321 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _62321 + 68] = mem[idx + _61927 + 32]
                                idx = idx + 32
                                continue 
                            mem[_62321 + 68] = mem[_62321 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _62321 + -mem[64] + 100
                        mem[0] = this.address
                        mem[32] = 26
                        _63655 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_63655] = 30
                        mem[_63655 + 32] = 'SafeMath: subtraction overflow'
                        if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                            _64434 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _64434 + 68] = mem[idx + _63655 + 32]
                                idx = idx + 32
                                continue 
                            mem[_64434 + 68] = mem[_64434 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _64434 + -mem[64] + 100
                        stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                        if (t / s * sub_49a6a335 * msg.value / 10^9) - (t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) - (t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                        _66453 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_66453] = 30
                        mem[_66453 + 32] = 'SafeMath: subtraction overflow'
                        if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                            _67087 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _67087 + 68] = mem[idx + _66453 + 32]
                                idx = idx + 32
                                continue 
                            mem[_67087 + 68] = mem[_67087 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _67087 + -mem[64] + 100
                        stor32 += -1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                        if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                        emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                        _69281 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_69281] = 26
                        mem[_69281 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _69281 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _76247 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_76247] = 30
                            mem[_76247 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _77974 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77974 + 68] = mem[idx + _76247 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77974 + 68] = mem[_77974 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77974 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _77077 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_77077] = 30
                            mem[_77077 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _78846 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _78846 + 68] = mem[idx + _77077 + 32]
                                idx = idx + 32
                                continue 
                            mem[_78846 + 68] = mem[_78846 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _78846 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _77973 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_77973] = 30
                        mem[_77973 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        _79679 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _79679 + 68] = mem[idx + _77973 + 32]
                            idx = idx + 32
                            continue 
                        mem[_79679 + 68] = mem[_79679 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _79679 + -mem[64] + 100
                    _59928 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_59928] = 26
                    mem[_59928 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _59928 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if not sub_49a6a335 * msg.value / 10^9:
                        if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                            _61670 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61670] = 30
                            mem[_61670 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = this.address
                            mem[32] = 26
                            _63038 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_63038] = 30
                            mem[_63038 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                _63660 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63660 + 68] = mem[idx + _63038 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63660 + 68] = mem[_63660 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63660 + -mem[64] + 100
                            if stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = stor26[msg.sender]
                            _66030 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_66030] = 30
                            mem[_66030 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _66458 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66458 + 68] = mem[idx + _66030 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66458 + 68] = mem[_66458 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66458 + -mem[64] + 100
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _68749 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68749] = 26
                            mem[_68749 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68749 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74955 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74955] = 30
                                mem[_74955 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76260 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76260 + 68] = mem[idx + _74955 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76260 + 68] = mem[_76260 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76260 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75592 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75592] = 30
                                mem[_75592 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77098 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77098 + 68] = mem[idx + _75592 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77098 + 68] = mem[_77098 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77098 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _76259 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_76259] = 30
                            mem[_76259 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _77997 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77997 + 68] = mem[idx + _76259 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77997 + 68] = mem[_77997 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77997 + -mem[64] + 100
                        if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _61798 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61798] = 30
                        mem[_61798 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                            _62107 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _62107 + 68] = mem[idx + _61798 + 32]
                                idx = idx + 32
                                continue 
                            mem[_62107 + 68] = mem[_62107 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _62107 + -mem[64] + 100
                        mem[0] = this.address
                        mem[32] = 26
                        _63372 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_63372] = 30
                        mem[_63372 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor26[address(this.address)]:
                            _64082 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _64082 + 68] = mem[idx + _63372 + 32]
                                idx = idx + 32
                                continue 
                            mem[_64082 + 68] = mem[_64082 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _64082 + -mem[64] + 100
                        if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                        _66234 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_66234] = 30
                        mem[_66234 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                            _66810 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _66810 + 68] = mem[idx + _66234 + 32]
                                idx = idx + 32
                                continue 
                            mem[_66810 + 68] = mem[_66810 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _66810 + -mem[64] + 100
                        stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                        if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                        emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                        _69012 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_69012] = 26
                        mem[_69012 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _69012 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75591 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75591] = 30
                            mem[_75591 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _77095 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77095 + 68] = mem[idx + _75591 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77095 + 68] = mem[_77095 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77095 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _76258 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_76258] = 30
                            mem[_76258 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _77994 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77994 + 68] = mem[idx + _76258 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77994 + 68] = mem[_77994 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77994 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _77094 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_77094] = 30
                        mem[_77094 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        _78869 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _78869 + 68] = mem[idx + _77094 + 32]
                            idx = idx + 32
                            continue 
                        mem[_78869 + 68] = mem[_78869 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _78869 + -mem[64] + 100
                    if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                        _61797 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61797] = 30
                        mem[_61797 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                            _62104 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _62104 + 68] = mem[idx + _61797 + 32]
                                idx = idx + 32
                                continue 
                            mem[_62104 + 68] = mem[_62104 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _62104 + -mem[64] + 100
                        mem[0] = this.address
                        mem[32] = 26
                        _63371 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_63371] = 30
                        mem[_63371 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                            _64079 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _64079 + 68] = mem[idx + _63371 + 32]
                                idx = idx + 32
                                continue 
                            mem[_64079 + 68] = mem[_64079 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _64079 + -mem[64] + 100
                        stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                        if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                        _66233 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_66233] = 30
                        mem[_66233 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            _66807 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _66807 + 68] = mem[idx + _66233 + 32]
                                idx = idx + 32
                                continue 
                            mem[_66807 + 68] = mem[_66807 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _66807 + -mem[64] + 100
                        if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                        emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                        _69011 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_69011] = 26
                        mem[_69011 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _69011 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75588 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75588] = 30
                            mem[_75588 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _77091 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77091 + 68] = mem[idx + _75588 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77091 + 68] = mem[_77091 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77091 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _76257 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_76257] = 30
                            mem[_76257 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _77991 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77991 + 68] = mem[idx + _76257 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77991 + 68] = mem[_77991 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77991 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _77090 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_77090] = 30
                        mem[_77090 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        _78865 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _78865 + 68] = mem[idx + _77090 + 32]
                            idx = idx + 32
                            continue 
                        mem[_78865 + 68] = mem[_78865 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _78865 + -mem[64] + 100
                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _61928 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_61928] = 30
                    mem[_61928 + 32] = 'SafeMath: subtraction overflow'
                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                        _62324 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _62324 + 68] = mem[idx + _61928 + 32]
                            idx = idx + 32
                            continue 
                        mem[_62324 + 68] = mem[_62324 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _62324 + -mem[64] + 100
                    mem[0] = this.address
                    mem[32] = 26
                    _63659 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_63659] = 30
                    mem[_63659 + 32] = 'SafeMath: subtraction overflow'
                    if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                        _64440 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _64440 + 68] = mem[idx + _63659 + 32]
                            idx = idx + 32
                            continue 
                        mem[_64440 + 68] = mem[_64440 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _64440 + -mem[64] + 100
                    stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                    if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = msg.sender
                    mem[32] = 26
                    stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                    _66457 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_66457] = 30
                    mem[_66457 + 32] = 'SafeMath: subtraction overflow'
                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                        _67091 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _67091 + 68] = mem[idx + _66457 + 32]
                            idx = idx + 32
                            continue 
                        mem[_67091 + 68] = mem[_67091 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _67091 + -mem[64] + 100
                    stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                        revert with 0, 'SafeMath: addition overflow'
                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                    _69285 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_69285] = 26
                    mem[_69285 + 32] = 'SafeMath: division by zero'
                    if not sub_1b2cabba:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _69285 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if not sub_8a3be0b6:
                        if ethSent <= 0:
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _76256 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_76256] = 30
                        mem[_76256 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        _77988 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _77988 + 68] = mem[idx + _76256 + 32]
                            idx = idx + 32
                            continue 
                        mem[_77988 + 68] = mem[_77988 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _77988 + -mem[64] + 100
                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                        if ethSent <= 0:
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _77089 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_77089] = 30
                        mem[_77089 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        _78862 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _78862 + 68] = mem[idx + _77089 + 32]
                            idx = idx + 32
                            continue 
                        mem[_78862 + 68] = mem[_78862 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _78862 + -mem[64] + 100
                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                        stor0 = 1
                    if timeBetweenRounds + block.timestamp < block.timestamp:
                        revert with 0, 'SafeMath: addition overflow'
                    presaleTime = timeBetweenRounds + block.timestamp
                    sub_8a3be0b6++
                    _77987 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_77987] = 30
                    mem[_77987 + 32] = 'SafeMath: subtraction overflow'
                    if sub_be71ce9f <= sub_49a6a335:
                        sub_49a6a335 -= sub_be71ce9f
                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                        stor0 = 1
                    _79699 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _79699 + 68] = mem[idx + _77987 + 32]
                        idx = idx + 32
                        continue 
                    mem[_79699 + 68] = mem[_79699 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _79699 + -mem[64] + 100
                _28737 = mem[64]
                mem[64] = mem[64] + 64
                mem[_28737] = 26
                mem[_28737 + 32] = 'SafeMath: division by zero'
                if not _tTotal:
                    revert with 0, 'SafeMath: division by zero'
                if t >= stor32 / _tTotal:
                    _29029 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29029] = 26
                    mem[_29029 + 32] = 'SafeMath: division by zero'
                    if not s:
                        revert with 0, 'SafeMath: division by zero'
                    _29553 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29553] = 26
                    mem[_29553 + 32] = 'SafeMath: division by zero'
                    if not t / s:
                        revert with 0, 'SafeMath: division by zero'
                    if stor26[address(this.address)] / t / s < sub_49a6a335 * msg.value / 10^9:
                        revert with 0, 32, 33, 0x774e6f7420656e6f75676820746f6b656e7320696e2074686520636f6e74726163, mem[mem[64] + 101 len 31]
                    if msg.value + sub_536c8c02[msg.sender] < sub_536c8c02[msg.sender]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = msg.sender
                    mem[32] = 20
                    sub_536c8c02[msg.sender] += msg.value
                    if msg.value + ethSent < ethSent:
                        revert with 0, 'SafeMath: addition overflow'
                    ethSent += msg.value
                    _30595 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30595] = 26
                    mem[_30595 + 32] = 'SafeMath: division by zero'
                    if not sub_49a6a335 * msg.value / 10^9 / 50:
                        _31407 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31407] = 30
                        mem[_31407 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > sub_49a6a335 * msg.value / 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = _tTotal
                        t = stor32
                        while idx < stor30.length:
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            if stor26[stor30[idx]] > t:
                                _59484 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59484] = 26
                                mem[_59484 + 32] = 'SafeMath: division by zero'
                                if not _tTotal:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _59484 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_49a6a335 * msg.value / 10^9:
                                    _61376 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61376] = 30
                                    mem[_61376 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62034 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62034] = 30
                                    mem[_62034 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _62446 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62446 + 68] = mem[idx + _62034 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62446 + 68] = mem[_62446 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62446 + -mem[64] + 100
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _64738 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_64738] = 30
                                    mem[_64738 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _65477 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _65477 + 68] = mem[idx + _64738 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_65477 + 68] = mem[_65477 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _65477 + -mem[64] + 100
                                    if _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    _67607 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_67607] = 26
                                    mem[_67607 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _67607 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _72770 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_72770] = 30
                                        mem[_72770 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _73777 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _73777 + 68] = mem[idx + _72770 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_73777 + 68] = mem[_73777 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _73777 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73301 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73301] = 30
                                        mem[_73301 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74286 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74286 + 68] = mem[idx + _73301 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74286 + 68] = mem[_74286 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74286 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73776 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73776] = 30
                                    mem[_73776 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74803 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74803 + 68] = mem[idx + _73776 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74803 + 68] = mem[_74803 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74803 + -mem[64] + 100
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61417 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61417] = 30
                                mem[_61417 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    _61513 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61513 + 68] = mem[idx + _61417 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61513 + 68] = mem[_61513 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61513 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62277 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62277] = 30
                                mem[_62277 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _62673 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62673 + 68] = mem[idx + _62277 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62673 + 68] = mem[_62673 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62673 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _65122 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65122] = 30
                                mem[_65122 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _65801 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _65801 + 68] = mem[idx + _65122 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_65801 + 68] = mem[_65801 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _65801 + -mem[64] + 100
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _67969 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_67969] = 26
                                mem[_67969 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _67969 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73300 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73300] = 30
                                    mem[_73300 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74283 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74283 + 68] = mem[idx + _73300 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74283 + 68] = mem[_74283 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74283 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73775 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73775] = 30
                                    mem[_73775 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74800 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74800 + 68] = mem[idx + _73775 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74800 + 68] = mem[_74800 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74800 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74282 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74282] = 30
                                mem[_74282 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _75419 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75419 + 68] = mem[idx + _74282 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75419 + 68] = mem[_75419 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75419 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            if stor27[stor30[idx]] <= s:
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 26
                                _59602 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59602] = 30
                                mem[_59602 + 32] = 'SafeMath: subtraction overflow'
                                if stor26[stor30[idx]] > t:
                                    _59794 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _59794 + 68] = mem[idx + _59602 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59794 + 68] = mem[_59794 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59794 + -mem[64] + 100
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 27
                                _60495 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_60495] = 30
                                mem[_60495 + 32] = 'SafeMath: subtraction overflow'
                                if stor27[stor30[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor27[stor30[idx]]
                                    t = t - stor26[stor30[idx]]
                                    continue 
                                _60809 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _60809 + 68] = mem[idx + _60495 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_60809 + 68] = mem[_60809 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _60809 + -mem[64] + 100
                            _59678 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59678] = 26
                            mem[_59678 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59678 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                _61457 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61457] = 30
                                mem[_61457 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _62451 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62451] = 30
                                mem[_62451 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _62950 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62950 + 68] = mem[idx + _62451 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62950 + 68] = mem[_62950 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62950 + -mem[64] + 100
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _65480 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65480] = 30
                                mem[_65480 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _65988 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _65988 + 68] = mem[idx + _65480 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_65988 + 68] = mem[_65988 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _65988 + -mem[64] + 100
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68213 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68213] = 26
                                mem[_68213 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68213 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73784 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73784] = 30
                                    mem[_73784 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74809 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74809 + 68] = mem[idx + _73784 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74809 + 68] = mem[_74809 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74809 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74292 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74292] = 30
                                    mem[_74292 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75432 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75432 + 68] = mem[idx + _74292 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75432 + 68] = mem[_75432 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75432 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74808 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74808] = 30
                                mem[_74808 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76081 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76081 + 68] = mem[idx + _74808 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76081 + 68] = mem[_76081 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76081 + -mem[64] + 100
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61516 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61516] = 30
                            mem[_61516 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _61756 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _61756 + 68] = mem[idx + _61516 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_61756 + 68] = mem[_61756 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _61756 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _62676 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_62676] = 30
                            mem[_62676 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _63298 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63298 + 68] = mem[idx + _62676 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63298 + 68] = mem[_63298 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63298 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                            _65804 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_65804] = 30
                            mem[_65804 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _66184 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66184 + 68] = mem[idx + _65804 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66184 + 68] = mem[_66184 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66184 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            _68478 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68478] = 26
                            mem[_68478 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68478 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74291 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74291] = 30
                                mem[_74291 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _75429 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75429 + 68] = mem[idx + _74291 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75429 + 68] = mem[_75429 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75429 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74807 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74807] = 30
                                mem[_74807 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76078 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76078 + 68] = mem[idx + _74807 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76078 + 68] = mem[_76078 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76078 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75428 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75428] = 30
                            mem[_75428 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _76876 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _76876 + 68] = mem[idx + _75428 + 32]
                                idx = idx + 32
                                continue 
                            mem[_76876 + 68] = mem[_76876 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _76876 + -mem[64] + 100
                        _57808 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_57808] = 26
                        mem[_57808 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor32 / _tTotal:
                            _59892 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59892] = 26
                            mem[_59892 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                _61639 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61639] = 30
                                mem[_61639 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _62943 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62943] = 30
                                mem[_62943 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _65985 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65985] = 30
                                mem[_65985 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68686 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68686] = 26
                                mem[_68686 + 32] = 'SafeMath: division by zero'
                            else:
                                if t / s * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != t / s:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61753 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61753] = 30
                                mem[_61753 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > t / s * sub_49a6a335 * msg.value / 10^9:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _63291 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63291] = 30
                                mem[_63291 + 32] = 'SafeMath: subtraction overflow'
                                if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                                if (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _66179 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66179] = 30
                                mem[_66179 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68943 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68943] = 26
                                mem[_68943 + 32] = 'SafeMath: division by zero'
                        else:
                            _59893 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59893] = 26
                            mem[_59893 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                _61640 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61640] = 30
                                mem[_61640 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _62946 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62946] = 30
                                mem[_62946 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _65986 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65986] = 30
                                mem[_65986 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68687 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68687] = 26
                                mem[_68687 + 32] = 'SafeMath: division by zero'
                            else:
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61754 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61754] = 30
                                mem[_61754 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _63292 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63292] = 30
                                mem[_63292 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _66180 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66180] = 30
                                mem[_66180 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68944 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68944] = 26
                                mem[_68944 + 32] = 'SafeMath: division by zero'
                    else:
                        if 2 * sub_49a6a335 * msg.value / 10^9 / 50 / sub_49a6a335 * msg.value / 10^9 / 50 != 2:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _31497 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31497] = 30
                        mem[_31497 + 32] = 'SafeMath: subtraction overflow'
                        if 2 * sub_49a6a335 * msg.value / 10^9 / 50 > sub_49a6a335 * msg.value / 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = _tTotal
                        t = stor32
                        while idx < stor30.length:
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            if stor26[stor30[idx]] > t:
                                _59479 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59479] = 26
                                mem[_59479 + 32] = 'SafeMath: division by zero'
                                if not _tTotal:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _59479 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_49a6a335 * msg.value / 10^9:
                                    if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                        _61375 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_61375] = 30
                                        mem[_61375 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = this.address
                                        mem[32] = 26
                                        _62023 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_62023] = 30
                                        mem[_62023 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor26[address(this.address)]:
                                            _62434 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _62434 + 68] = mem[idx + _62023 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_62434 + 68] = mem[_62434 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _62434 + -mem[64] + 100
                                        if stor26[msg.sender] < stor26[msg.sender]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 26
                                        stor26[address(msg.sender)] = stor26[msg.sender]
                                        _64718 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_64718] = 30
                                        mem[_64718 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor32:
                                            _65464 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _65464 + 68] = mem[idx + _64718 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_65464 + 68] = mem[_65464 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _65464 + -mem[64] + 100
                                        if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                        emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                        _67591 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_67591] = 26
                                        mem[_67591 + 32] = 'SafeMath: division by zero'
                                        if not sub_1b2cabba:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _67591 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not sub_8a3be0b6:
                                            if ethSent <= 0:
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            presaleTime = timeBetweenRounds + block.timestamp
                                            sub_8a3be0b6++
                                            _72745 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_72745] = 30
                                            mem[_72745 + 32] = 'SafeMath: subtraction overflow'
                                            if sub_be71ce9f <= sub_49a6a335:
                                                sub_49a6a335 -= sub_be71ce9f
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            _73755 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _73755 + 68] = mem[idx + _72745 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_73755 + 68] = mem[_73755 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _73755 + -mem[64] + 100
                                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                            if ethSent <= 0:
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            presaleTime = timeBetweenRounds + block.timestamp
                                            sub_8a3be0b6++
                                            _73281 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_73281] = 30
                                            mem[_73281 + 32] = 'SafeMath: subtraction overflow'
                                            if sub_be71ce9f <= sub_49a6a335:
                                                sub_49a6a335 -= sub_be71ce9f
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            _74262 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _74262 + 68] = mem[idx + _73281 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_74262 + 68] = mem[_74262 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _74262 + -mem[64] + 100
                                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73754 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73754] = 30
                                        mem[_73754 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74777 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74777 + 68] = mem[idx + _73754 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74777 + 68] = mem[_74777 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74777 + -mem[64] + 100
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _61414 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61414] = 30
                                    mem[_61414 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                        _61508 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _61508 + 68] = mem[idx + _61414 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_61508 + 68] = mem[_61508 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _61508 + -mem[64] + 100
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62270 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62270] = 30
                                    mem[_62270 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _62660 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62660 + 68] = mem[idx + _62270 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62660 + 68] = mem[_62660 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62660 + -mem[64] + 100
                                    if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                    _65106 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65106] = 30
                                    mem[_65106 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                        _65794 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _65794 + 68] = mem[idx + _65106 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_65794 + 68] = mem[_65794 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _65794 + -mem[64] + 100
                                    stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _67958 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_67958] = 26
                                    mem[_67958 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _67958 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73280 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73280] = 30
                                        mem[_73280 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74259 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74259 + 68] = mem[idx + _73280 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74259 + 68] = mem[_74259 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74259 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73753 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73753] = 30
                                        mem[_73753 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74774 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74774 + 68] = mem[idx + _73753 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74774 + 68] = mem[_74774 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74774 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74258 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74258] = 30
                                    mem[_74258 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75390 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75390 + 68] = mem[idx + _74258 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75390 + 68] = mem[_75390 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75390 + -mem[64] + 100
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61413 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61413] = 30
                                    mem[_61413 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                        _61505 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _61505 + 68] = mem[idx + _61413 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_61505 + 68] = mem[_61505 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _61505 + -mem[64] + 100
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62269 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62269] = 30
                                    mem[_62269 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                        _62657 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62657 + 68] = mem[idx + _62269 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62657 + 68] = mem[_62657 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62657 + -mem[64] + 100
                                    stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                    if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                    _65105 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65105] = 30
                                    mem[_65105 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _65791 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _65791 + 68] = mem[idx + _65105 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_65791 + 68] = mem[_65791 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _65791 + -mem[64] + 100
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _67957 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_67957] = 26
                                    mem[_67957 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _67957 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73277 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73277] = 30
                                        mem[_73277 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74255 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74255 + 68] = mem[idx + _73277 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74255 + 68] = mem[_74255 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74255 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73752 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73752] = 30
                                        mem[_73752 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74771 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74771 + 68] = mem[idx + _73752 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74771 + 68] = mem[_74771 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74771 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74254 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74254] = 30
                                    mem[_74254 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75386 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75386 + 68] = mem[idx + _74254 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75386 + 68] = mem[_75386 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75386 + -mem[64] + 100
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61453 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61453] = 30
                                mem[_61453 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    _61635 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61635 + 68] = mem[idx + _61453 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61635 + 68] = mem[_61635 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61635 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62433 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62433] = 30
                                mem[_62433 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _62931 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62931 + 68] = mem[idx + _62433 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62931 + 68] = mem[_62931 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62931 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _65463 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65463] = 30
                                mem[_65463 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    _65977 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _65977 + 68] = mem[idx + _65463 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_65977 + 68] = mem[_65977 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _65977 + -mem[64] + 100
                                stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68199 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68199] = 26
                                mem[_68199 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68199 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73751 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73751] = 30
                                    mem[_73751 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74768 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74768 + 68] = mem[idx + _73751 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74768 + 68] = mem[_74768 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74768 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74253 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74253] = 30
                                    mem[_74253 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75383 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75383 + 68] = mem[idx + _74253 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75383 + 68] = mem[_75383 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75383 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74767 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74767] = 30
                                mem[_74767 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76023 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76023 + 68] = mem[idx + _74767 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76023 + 68] = mem[_76023 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76023 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            if stor27[stor30[idx]] <= s:
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 26
                                _59599 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59599] = 30
                                mem[_59599 + 32] = 'SafeMath: subtraction overflow'
                                if stor26[stor30[idx]] > t:
                                    _59790 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _59790 + 68] = mem[idx + _59599 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59790 + 68] = mem[_59790 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59790 + -mem[64] + 100
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 27
                                _60488 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_60488] = 30
                                mem[_60488 + 32] = 'SafeMath: subtraction overflow'
                                if stor27[stor30[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor27[stor30[idx]]
                                    t = t - stor26[stor30[idx]]
                                    continue 
                                _60801 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _60801 + 68] = mem[idx + _60488 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_60801 + 68] = mem[_60801 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _60801 + -mem[64] + 100
                            _59673 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59673] = 26
                            mem[_59673 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59673 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61456 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61456] = 30
                                    mem[_61456 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62443 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62443] = 30
                                    mem[_62443 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _62938 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62938 + 68] = mem[idx + _62443 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62938 + 68] = mem[_62938 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62938 + -mem[64] + 100
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _65468 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65468] = 30
                                    mem[_65468 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _65982 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _65982 + 68] = mem[idx + _65468 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_65982 + 68] = mem[_65982 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _65982 + -mem[64] + 100
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68205 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68205] = 26
                                    mem[_68205 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _68205 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73766 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73766] = 30
                                        mem[_73766 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74787 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74787 + 68] = mem[idx + _73766 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74787 + 68] = mem[_74787 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74787 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _74273 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_74273] = 30
                                        mem[_74273 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _75408 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _75408 + 68] = mem[idx + _74273 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_75408 + 68] = mem[_75408 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _75408 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74786 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74786] = 30
                                    mem[_74786 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76053 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76053 + 68] = mem[idx + _74786 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76053 + 68] = mem[_76053 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76053 + -mem[64] + 100
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61512 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61512] = 30
                                mem[_61512 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                    _61750 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61750 + 68] = mem[idx + _61512 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61750 + 68] = mem[_61750 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61750 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62666 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62666] = 30
                                mem[_62666 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _63288 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63288 + 68] = mem[idx + _62666 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63288 + 68] = mem[_63288 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63288 + -mem[64] + 100
                                if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _65798 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65798] = 30
                                mem[_65798 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    _66176 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66176 + 68] = mem[idx + _65798 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66176 + 68] = mem[_66176 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66176 + -mem[64] + 100
                                stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68469 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68469] = 26
                                mem[_68469 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68469 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74272 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74272] = 30
                                    mem[_74272 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75405 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75405 + 68] = mem[idx + _74272 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75405 + 68] = mem[_75405 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75405 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74785 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74785] = 30
                                    mem[_74785 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76050 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76050 + 68] = mem[idx + _74785 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76050 + 68] = mem[_76050 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76050 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75404 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75404] = 30
                                mem[_75404 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76842 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76842 + 68] = mem[idx + _75404 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76842 + 68] = mem[_76842 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76842 + -mem[64] + 100
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _61511 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61511] = 30
                                mem[_61511 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    _61747 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61747 + 68] = mem[idx + _61511 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61747 + 68] = mem[_61747 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61747 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62665 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62665] = 30
                                mem[_62665 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _63285 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63285 + 68] = mem[idx + _62665 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63285 + 68] = mem[_63285 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63285 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _65797 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65797] = 30
                                mem[_65797 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66173 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66173 + 68] = mem[idx + _65797 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66173 + 68] = mem[_66173 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66173 + -mem[64] + 100
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68468 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68468] = 26
                                mem[_68468 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68468 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74269 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74269] = 30
                                    mem[_74269 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75401 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75401 + 68] = mem[idx + _74269 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75401 + 68] = mem[_75401 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75401 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74784 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74784] = 30
                                    mem[_74784 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76047 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76047 + 68] = mem[idx + _74784 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76047 + 68] = mem[_76047 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76047 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75400 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75400] = 30
                                mem[_75400 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76838 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76838 + 68] = mem[idx + _75400 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76838 + 68] = mem[_76838 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76838 + -mem[64] + 100
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61638 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61638] = 30
                            mem[_61638 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _61893 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _61893 + 68] = mem[idx + _61638 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_61893 + 68] = mem[_61893 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _61893 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _62937 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_62937] = 30
                            mem[_62937 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _63559 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63559 + 68] = mem[idx + _62937 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63559 + 68] = mem[_63559 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63559 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                            _65981 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_65981] = 30
                            mem[_65981 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                _66373 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66373 + 68] = mem[idx + _65981 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66373 + 68] = mem[_66373 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66373 + -mem[64] + 100
                            stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _68682 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68682] = 26
                            mem[_68682 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68682 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74783 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74783] = 30
                                mem[_74783 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76044 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76044 + 68] = mem[idx + _74783 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76044 + 68] = mem[_76044 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76044 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75399 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75399] = 30
                                mem[_75399 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76835 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76835 + 68] = mem[idx + _75399 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76835 + 68] = mem[_76835 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76835 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _76043 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_76043] = 30
                            mem[_76043 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _77730 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77730 + 68] = mem[idx + _76043 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77730 + 68] = mem[_77730 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77730 + -mem[64] + 100
                        _57803 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_57803] = 26
                        mem[_57803 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor32 / _tTotal:
                            _59885 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59885] = 26
                            mem[_59885 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61631 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61631] = 30
                                    mem[_61631 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62923 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62923] = 30
                                    mem[_62923 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _65974 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65974] = 30
                                    mem[_65974 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68671 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68671] = 26
                                    mem[_68671 + 32] = 'SafeMath: division by zero'
                                else:
                                    if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != t / s:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _61742 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61742] = 30
                                    mem[_61742 + 32] = 'SafeMath: subtraction overflow'
                                    if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63272 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63272] = 30
                                    mem[_63272 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (-1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (-1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                    _66166 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66166] = 30
                                    mem[_66166 + 32] = 'SafeMath: subtraction overflow'
                                    if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor32 += -1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68926 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68926] = 26
                                    mem[_68926 + 32] = 'SafeMath: division by zero'
                            else:
                                if t / s * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != t / s:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61741 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61741] = 30
                                    mem[_61741 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > t / s * sub_49a6a335 * msg.value / 10^9:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63271 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63271] = 30
                                    mem[_63271 + 32] = 'SafeMath: subtraction overflow'
                                    if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                                    if (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                    _66165 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66165] = 30
                                    mem[_66165 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68925 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68925] = 26
                                    mem[_68925 + 32] = 'SafeMath: division by zero'
                                else:
                                    if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != t / s:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _61885 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61885] = 30
                                    mem[_61885 + 32] = 'SafeMath: subtraction overflow'
                                    if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > t / s * sub_49a6a335 * msg.value / 10^9:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63541 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63541] = 30
                                    mem[_63541 + 32] = 'SafeMath: subtraction overflow'
                                    if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                                    if (t / s * sub_49a6a335 * msg.value / 10^9) - (t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) - (t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                    _66357 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66357] = 30
                                    mem[_66357 + 32] = 'SafeMath: subtraction overflow'
                                    if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor32 += -1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _69173 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_69173] = 26
                                    mem[_69173 + 32] = 'SafeMath: division by zero'
                        else:
                            _59886 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59886] = 26
                            mem[_59886 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61634 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61634] = 30
                                    mem[_61634 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62930 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62930] = 30
                                    mem[_62930 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _65976 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65976] = 30
                                    mem[_65976 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68674 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68674] = 26
                                    mem[_68674 + 32] = 'SafeMath: division by zero'
                                else:
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _61744 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61744] = 30
                                    mem[_61744 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63276 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63276] = 30
                                    mem[_63276 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                    _66168 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66168] = 30
                                    mem[_66168 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68928 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68928] = 26
                                    mem[_68928 + 32] = 'SafeMath: division by zero'
                            else:
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61743 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61743] = 30
                                    mem[_61743 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63275 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63275] = 30
                                    mem[_63275 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                    if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                    _66167 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66167] = 30
                                    mem[_66167 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68927 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68927] = 26
                                    mem[_68927 + 32] = 'SafeMath: division by zero'
                                else:
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _61886 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61886] = 30
                                    mem[_61886 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63545 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63545] = 30
                                    mem[_63545 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                    if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                    _66361 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66361] = 30
                                    mem[_66361 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _69177 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_69177] = 26
                                    mem[_69177 + 32] = 'SafeMath: division by zero'
                else:
                    _29030 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29030] = 26
                    mem[_29030 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    _29555 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29555] = 26
                    mem[_29555 + 32] = 'SafeMath: division by zero'
                    if not stor32 / _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    if stor26[address(this.address)] / stor32 / _tTotal < sub_49a6a335 * msg.value / 10^9:
                        revert with 0, 32, 33, 0x774e6f7420656e6f75676820746f6b656e7320696e2074686520636f6e74726163, mem[mem[64] + 101 len 31]
                    if msg.value + sub_536c8c02[msg.sender] < sub_536c8c02[msg.sender]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = msg.sender
                    mem[32] = 20
                    sub_536c8c02[msg.sender] += msg.value
                    if msg.value + ethSent < ethSent:
                        revert with 0, 'SafeMath: addition overflow'
                    ethSent += msg.value
                    _30596 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30596] = 26
                    mem[_30596 + 32] = 'SafeMath: division by zero'
                    if not sub_49a6a335 * msg.value / 10^9 / 50:
                        _31408 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31408] = 30
                        mem[_31408 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > sub_49a6a335 * msg.value / 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = _tTotal
                        t = stor32
                        while idx < stor30.length:
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            if stor26[stor30[idx]] > t:
                                _59494 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59494] = 26
                                mem[_59494 + 32] = 'SafeMath: division by zero'
                                if not _tTotal:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _59494 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_49a6a335 * msg.value / 10^9:
                                    _61380 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61380] = 30
                                    mem[_61380 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62065 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62065] = 30
                                    mem[_62065 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _62469 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62469 + 68] = mem[idx + _62065 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62469 + 68] = mem[_62469 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62469 + -mem[64] + 100
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _64780 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_64780] = 30
                                    mem[_64780 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _65513 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _65513 + 68] = mem[idx + _64780 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_65513 + 68] = mem[_65513 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _65513 + -mem[64] + 100
                                    if _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    _67644 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_67644] = 26
                                    mem[_67644 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _67644 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _72828 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_72828] = 30
                                        mem[_72828 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _73829 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _73829 + 68] = mem[idx + _72828 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_73829 + 68] = mem[_73829 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _73829 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73354 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73354] = 30
                                        mem[_73354 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74342 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74342 + 68] = mem[idx + _73354 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74342 + 68] = mem[_74342 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74342 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73828 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73828] = 30
                                    mem[_73828 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74866 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74866 + 68] = mem[idx + _73828 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74866 + 68] = mem[_74866 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74866 + -mem[64] + 100
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61422 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61422] = 30
                                mem[_61422 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    _61529 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61529 + 68] = mem[idx + _61422 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61529 + 68] = mem[_61529 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61529 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62297 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62297] = 30
                                mem[_62297 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _62705 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62705 + 68] = mem[idx + _62297 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62705 + 68] = mem[_62705 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62705 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _65161 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65161] = 30
                                mem[_65161 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _65825 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _65825 + 68] = mem[idx + _65161 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_65825 + 68] = mem[_65825 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _65825 + -mem[64] + 100
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68000 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68000] = 26
                                mem[_68000 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68000 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73353 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73353] = 30
                                    mem[_73353 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74339 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74339 + 68] = mem[idx + _73353 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74339 + 68] = mem[_74339 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74339 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73827 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73827] = 30
                                    mem[_73827 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74863 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74863 + 68] = mem[idx + _73827 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74863 + 68] = mem[_74863 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74863 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74338 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74338] = 30
                                mem[_74338 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _75489 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75489 + 68] = mem[idx + _74338 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75489 + 68] = mem[_75489 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75489 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            if stor27[stor30[idx]] <= s:
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 26
                                _59608 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59608] = 30
                                mem[_59608 + 32] = 'SafeMath: subtraction overflow'
                                if stor26[stor30[idx]] > t:
                                    _59802 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _59802 + 68] = mem[idx + _59608 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59802 + 68] = mem[_59802 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59802 + -mem[64] + 100
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 27
                                _60509 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_60509] = 30
                                mem[_60509 + 32] = 'SafeMath: subtraction overflow'
                                if stor27[stor30[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor27[stor30[idx]]
                                    t = t - stor26[stor30[idx]]
                                    continue 
                                _60825 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _60825 + 68] = mem[idx + _60509 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_60825 + 68] = mem[_60825 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _60825 + -mem[64] + 100
                            _59688 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59688] = 26
                            mem[_59688 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59688 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                _61462 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61462] = 30
                                mem[_61462 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _62474 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62474] = 30
                                mem[_62474 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _62986 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62986 + 68] = mem[idx + _62474 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62986 + 68] = mem[_62986 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62986 + -mem[64] + 100
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _65516 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65516] = 30
                                mem[_65516 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66006 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66006 + 68] = mem[idx + _65516 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66006 + 68] = mem[_66006 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66006 + -mem[64] + 100
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68238 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68238] = 26
                                mem[_68238 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68238 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73836 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73836] = 30
                                    mem[_73836 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74872 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74872 + 68] = mem[idx + _73836 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74872 + 68] = mem[_74872 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74872 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74348 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74348] = 30
                                    mem[_74348 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75502 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75502 + 68] = mem[idx + _74348 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75502 + 68] = mem[_75502 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75502 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74871 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74871] = 30
                                mem[_74871 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76161 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76161 + 68] = mem[idx + _74871 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76161 + 68] = mem[_76161 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76161 + -mem[64] + 100
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61532 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61532] = 30
                            mem[_61532 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _61774 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _61774 + 68] = mem[idx + _61532 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_61774 + 68] = mem[_61774 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _61774 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _62708 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_62708] = 30
                            mem[_62708 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _63330 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63330 + 68] = mem[idx + _62708 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63330 + 68] = mem[_63330 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63330 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                            _65828 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_65828] = 30
                            mem[_65828 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _66206 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66206 + 68] = mem[idx + _65828 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66206 + 68] = mem[_66206 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66206 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            _68504 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68504] = 26
                            mem[_68504 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68504 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74347 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74347] = 30
                                mem[_74347 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _75499 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75499 + 68] = mem[idx + _74347 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75499 + 68] = mem[_75499 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75499 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74870 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74870] = 30
                                mem[_74870 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76158 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76158 + 68] = mem[idx + _74870 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76158 + 68] = mem[_76158 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76158 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75498 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75498] = 30
                            mem[_75498 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _76972 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _76972 + 68] = mem[idx + _75498 + 32]
                                idx = idx + 32
                                continue 
                            mem[_76972 + 68] = mem[_76972 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _76972 + -mem[64] + 100
                        _57822 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_57822] = 26
                        mem[_57822 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor32 / _tTotal:
                            _59906 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59906] = 26
                            mem[_59906 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                _61651 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61651] = 30
                                mem[_61651 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _62979 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62979] = 30
                                mem[_62979 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _66003 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66003] = 30
                                mem[_66003 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68711 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68711] = 26
                                mem[_68711 + 32] = 'SafeMath: division by zero'
                            else:
                                if t / s * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != t / s:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61771 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61771] = 30
                                mem[_61771 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > t / s * sub_49a6a335 * msg.value / 10^9:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _63323 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63323] = 30
                                mem[_63323 + 32] = 'SafeMath: subtraction overflow'
                                if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                                if (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _66201 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66201] = 30
                                mem[_66201 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68971 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68971] = 26
                                mem[_68971 + 32] = 'SafeMath: division by zero'
                        else:
                            _59907 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59907] = 26
                            mem[_59907 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                _61652 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61652] = 30
                                mem[_61652 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _62982 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62982] = 30
                                mem[_62982 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _66004 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66004] = 30
                                mem[_66004 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68712 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68712] = 26
                                mem[_68712 + 32] = 'SafeMath: division by zero'
                            else:
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61772 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61772] = 30
                                mem[_61772 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _63324 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63324] = 30
                                mem[_63324 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _66202 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66202] = 30
                                mem[_66202 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68972 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68972] = 26
                                mem[_68972 + 32] = 'SafeMath: division by zero'
                    else:
                        if 2 * sub_49a6a335 * msg.value / 10^9 / 50 / sub_49a6a335 * msg.value / 10^9 / 50 != 2:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _31498 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31498] = 30
                        mem[_31498 + 32] = 'SafeMath: subtraction overflow'
                        if 2 * sub_49a6a335 * msg.value / 10^9 / 50 > sub_49a6a335 * msg.value / 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = _tTotal
                        t = stor32
                        while idx < stor30.length:
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            if stor26[stor30[idx]] > t:
                                _59489 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59489] = 26
                                mem[_59489 + 32] = 'SafeMath: division by zero'
                                if not _tTotal:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _59489 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_49a6a335 * msg.value / 10^9:
                                    if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                        _61379 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_61379] = 30
                                        mem[_61379 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = this.address
                                        mem[32] = 26
                                        _62054 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_62054] = 30
                                        mem[_62054 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor26[address(this.address)]:
                                            _62457 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _62457 + 68] = mem[idx + _62054 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_62457 + 68] = mem[_62457 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _62457 + -mem[64] + 100
                                        if stor26[msg.sender] < stor26[msg.sender]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 26
                                        stor26[address(msg.sender)] = stor26[msg.sender]
                                        _64760 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_64760] = 30
                                        mem[_64760 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor32:
                                            _65500 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _65500 + 68] = mem[idx + _64760 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_65500 + 68] = mem[_65500 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _65500 + -mem[64] + 100
                                        if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                        emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                        _67628 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_67628] = 26
                                        mem[_67628 + 32] = 'SafeMath: division by zero'
                                        if not sub_1b2cabba:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _67628 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not sub_8a3be0b6:
                                            if ethSent <= 0:
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            presaleTime = timeBetweenRounds + block.timestamp
                                            sub_8a3be0b6++
                                            _72803 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_72803] = 30
                                            mem[_72803 + 32] = 'SafeMath: subtraction overflow'
                                            if sub_be71ce9f <= sub_49a6a335:
                                                sub_49a6a335 -= sub_be71ce9f
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            _73807 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _73807 + 68] = mem[idx + _72803 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_73807 + 68] = mem[_73807 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _73807 + -mem[64] + 100
                                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                            if ethSent <= 0:
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            presaleTime = timeBetweenRounds + block.timestamp
                                            sub_8a3be0b6++
                                            _73334 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_73334] = 30
                                            mem[_73334 + 32] = 'SafeMath: subtraction overflow'
                                            if sub_be71ce9f <= sub_49a6a335:
                                                sub_49a6a335 -= sub_be71ce9f
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            _74318 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _74318 + 68] = mem[idx + _73334 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_74318 + 68] = mem[_74318 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _74318 + -mem[64] + 100
                                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73806 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73806] = 30
                                        mem[_73806 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74840 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74840 + 68] = mem[idx + _73806 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74840 + 68] = mem[_74840 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74840 + -mem[64] + 100
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _61419 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61419] = 30
                                    mem[_61419 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                        _61524 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _61524 + 68] = mem[idx + _61419 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_61524 + 68] = mem[_61524 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _61524 + -mem[64] + 100
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62290 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62290] = 30
                                    mem[_62290 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _62692 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62692 + 68] = mem[idx + _62290 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62692 + 68] = mem[_62692 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62692 + -mem[64] + 100
                                    if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                    _65145 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65145] = 30
                                    mem[_65145 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                        _65818 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _65818 + 68] = mem[idx + _65145 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_65818 + 68] = mem[_65818 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _65818 + -mem[64] + 100
                                    stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _67989 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_67989] = 26
                                    mem[_67989 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _67989 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73333 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73333] = 30
                                        mem[_73333 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74315 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74315 + 68] = mem[idx + _73333 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74315 + 68] = mem[_74315 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74315 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73805 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73805] = 30
                                        mem[_73805 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74837 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74837 + 68] = mem[idx + _73805 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74837 + 68] = mem[_74837 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74837 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74314 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74314] = 30
                                    mem[_74314 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75460 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75460 + 68] = mem[idx + _74314 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75460 + 68] = mem[_75460 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75460 + -mem[64] + 100
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61418 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61418] = 30
                                    mem[_61418 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                        _61521 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _61521 + 68] = mem[idx + _61418 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_61521 + 68] = mem[_61521 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _61521 + -mem[64] + 100
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62289 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62289] = 30
                                    mem[_62289 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                        _62689 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62689 + 68] = mem[idx + _62289 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62689 + 68] = mem[_62689 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62689 + -mem[64] + 100
                                    stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                    if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                    _65144 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65144] = 30
                                    mem[_65144 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _65815 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _65815 + 68] = mem[idx + _65144 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_65815 + 68] = mem[_65815 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _65815 + -mem[64] + 100
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _67988 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_67988] = 26
                                    mem[_67988 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _67988 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73330 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73330] = 30
                                        mem[_73330 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74311 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74311 + 68] = mem[idx + _73330 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74311 + 68] = mem[_74311 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74311 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73804 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73804] = 30
                                        mem[_73804 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74834 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74834 + 68] = mem[idx + _73804 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74834 + 68] = mem[_74834 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74834 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74310 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74310] = 30
                                    mem[_74310 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75456 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75456 + 68] = mem[idx + _74310 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75456 + 68] = mem[_75456 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75456 + -mem[64] + 100
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61458 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61458] = 30
                                mem[_61458 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    _61647 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61647 + 68] = mem[idx + _61458 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61647 + 68] = mem[_61647 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61647 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62456 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62456] = 30
                                mem[_62456 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _62967 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62967 + 68] = mem[idx + _62456 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62967 + 68] = mem[_62967 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62967 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _65499 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65499] = 30
                                mem[_65499 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    _65995 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _65995 + 68] = mem[idx + _65499 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_65995 + 68] = mem[_65995 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _65995 + -mem[64] + 100
                                stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68224 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68224] = 26
                                mem[_68224 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68224 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73803 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73803] = 30
                                    mem[_73803 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74831 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74831 + 68] = mem[idx + _73803 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74831 + 68] = mem[_74831 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74831 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74309 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74309] = 30
                                    mem[_74309 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75453 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75453 + 68] = mem[idx + _74309 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75453 + 68] = mem[_75453 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75453 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74830 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74830] = 30
                                mem[_74830 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76103 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76103 + 68] = mem[idx + _74830 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76103 + 68] = mem[_76103 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76103 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            if stor27[stor30[idx]] <= s:
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 26
                                _59605 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59605] = 30
                                mem[_59605 + 32] = 'SafeMath: subtraction overflow'
                                if stor26[stor30[idx]] > t:
                                    _59798 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _59798 + 68] = mem[idx + _59605 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59798 + 68] = mem[_59798 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59798 + -mem[64] + 100
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 27
                                _60502 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_60502] = 30
                                mem[_60502 + 32] = 'SafeMath: subtraction overflow'
                                if stor27[stor30[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor27[stor30[idx]]
                                    t = t - stor26[stor30[idx]]
                                    continue 
                                _60817 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _60817 + 68] = mem[idx + _60502 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_60817 + 68] = mem[_60817 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _60817 + -mem[64] + 100
                            _59683 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59683] = 26
                            mem[_59683 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59683 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61461 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61461] = 30
                                    mem[_61461 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62466 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62466] = 30
                                    mem[_62466 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _62974 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62974 + 68] = mem[idx + _62466 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62974 + 68] = mem[_62974 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62974 + -mem[64] + 100
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _65504 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65504] = 30
                                    mem[_65504 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _66000 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _66000 + 68] = mem[idx + _65504 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_66000 + 68] = mem[_66000 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _66000 + -mem[64] + 100
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68230 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68230] = 26
                                    mem[_68230 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _68230 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73818 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73818] = 30
                                        mem[_73818 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74850 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74850 + 68] = mem[idx + _73818 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74850 + 68] = mem[_74850 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74850 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _74329 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_74329] = 30
                                        mem[_74329 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _75478 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _75478 + 68] = mem[idx + _74329 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_75478 + 68] = mem[_75478 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _75478 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74849 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74849] = 30
                                    mem[_74849 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76133 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76133 + 68] = mem[idx + _74849 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76133 + 68] = mem[_76133 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76133 + -mem[64] + 100
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61528 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61528] = 30
                                mem[_61528 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                    _61768 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61768 + 68] = mem[idx + _61528 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61768 + 68] = mem[_61768 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61768 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62698 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62698] = 30
                                mem[_62698 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _63320 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63320 + 68] = mem[idx + _62698 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63320 + 68] = mem[_63320 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63320 + -mem[64] + 100
                                if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _65822 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65822] = 30
                                mem[_65822 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    _66198 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66198 + 68] = mem[idx + _65822 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66198 + 68] = mem[_66198 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66198 + -mem[64] + 100
                                stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68495 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68495] = 26
                                mem[_68495 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68495 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74328 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74328] = 30
                                    mem[_74328 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75475 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75475 + 68] = mem[idx + _74328 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75475 + 68] = mem[_75475 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75475 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74848 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74848] = 30
                                    mem[_74848 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76130 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76130 + 68] = mem[idx + _74848 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76130 + 68] = mem[_76130 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76130 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75474 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75474] = 30
                                mem[_75474 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76938 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76938 + 68] = mem[idx + _75474 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76938 + 68] = mem[_76938 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76938 + -mem[64] + 100
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _61527 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61527] = 30
                                mem[_61527 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    _61765 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61765 + 68] = mem[idx + _61527 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61765 + 68] = mem[_61765 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61765 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62697 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62697] = 30
                                mem[_62697 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _63317 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63317 + 68] = mem[idx + _62697 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63317 + 68] = mem[_63317 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63317 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _65821 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65821] = 30
                                mem[_65821 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66195 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66195 + 68] = mem[idx + _65821 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66195 + 68] = mem[_66195 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66195 + -mem[64] + 100
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68494 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68494] = 26
                                mem[_68494 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68494 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74325 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74325] = 30
                                    mem[_74325 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75471 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75471 + 68] = mem[idx + _74325 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75471 + 68] = mem[_75471 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75471 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74847 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74847] = 30
                                    mem[_74847 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76127 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76127 + 68] = mem[idx + _74847 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76127 + 68] = mem[_76127 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76127 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75470 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75470] = 30
                                mem[_75470 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76934 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76934 + 68] = mem[idx + _75470 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76934 + 68] = mem[_76934 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76934 + -mem[64] + 100
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61650 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61650] = 30
                            mem[_61650 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _61907 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _61907 + 68] = mem[idx + _61650 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_61907 + 68] = mem[_61907 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _61907 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _62973 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_62973] = 30
                            mem[_62973 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _63597 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63597 + 68] = mem[idx + _62973 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63597 + 68] = mem[_63597 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63597 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                            _65999 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_65999] = 30
                            mem[_65999 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                _66405 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66405 + 68] = mem[idx + _65999 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66405 + 68] = mem[_66405 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66405 + -mem[64] + 100
                            stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _68707 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68707] = 26
                            mem[_68707 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68707 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74846 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74846] = 30
                                mem[_74846 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76124 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76124 + 68] = mem[idx + _74846 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76124 + 68] = mem[_76124 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76124 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75469 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75469] = 30
                                mem[_75469 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76931 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76931 + 68] = mem[idx + _75469 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76931 + 68] = mem[_76931 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76931 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _76123 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_76123] = 30
                            mem[_76123 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _77826 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77826 + 68] = mem[idx + _76123 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77826 + 68] = mem[_77826 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77826 + -mem[64] + 100
                        _57817 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_57817] = 26
                        mem[_57817 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor32 / _tTotal:
                            _59899 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59899] = 26
                            mem[_59899 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61643 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61643] = 30
                                    mem[_61643 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62959 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62959] = 30
                                    mem[_62959 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _65992 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65992] = 30
                                    mem[_65992 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68696 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68696] = 26
                                    mem[_68696 + 32] = 'SafeMath: division by zero'
                                else:
                                    if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != t / s:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _61760 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61760] = 30
                                    mem[_61760 + 32] = 'SafeMath: subtraction overflow'
                                    if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63304 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63304] = 30
                                    mem[_63304 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (-1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (-1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                    _66188 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66188] = 30
                                    mem[_66188 + 32] = 'SafeMath: subtraction overflow'
                                    if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor32 += -1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68954 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68954] = 26
                                    mem[_68954 + 32] = 'SafeMath: division by zero'
                            else:
                                if t / s * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != t / s:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61759 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61759] = 30
                                    mem[_61759 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > t / s * sub_49a6a335 * msg.value / 10^9:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63303 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63303] = 30
                                    mem[_63303 + 32] = 'SafeMath: subtraction overflow'
                                    if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                                    if (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                    _66187 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66187] = 30
                                    mem[_66187 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68953 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68953] = 26
                                    mem[_68953 + 32] = 'SafeMath: division by zero'
                                else:
                                    if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != t / s:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _61899 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61899] = 30
                                    mem[_61899 + 32] = 'SafeMath: subtraction overflow'
                                    if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > t / s * sub_49a6a335 * msg.value / 10^9:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63579 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63579] = 30
                                    mem[_63579 + 32] = 'SafeMath: subtraction overflow'
                                    if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                                    if (t / s * sub_49a6a335 * msg.value / 10^9) - (t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) - (t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                    _66389 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66389] = 30
                                    mem[_66389 + 32] = 'SafeMath: subtraction overflow'
                                    if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor32 += -1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _69209 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_69209] = 26
                                    mem[_69209 + 32] = 'SafeMath: division by zero'
                        else:
                            _59900 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59900] = 26
                            mem[_59900 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61646 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61646] = 30
                                    mem[_61646 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62966 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62966] = 30
                                    mem[_62966 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _65994 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65994] = 30
                                    mem[_65994 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68699 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68699] = 26
                                    mem[_68699 + 32] = 'SafeMath: division by zero'
                                else:
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _61762 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61762] = 30
                                    mem[_61762 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63308 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63308] = 30
                                    mem[_63308 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                    _66190 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66190] = 30
                                    mem[_66190 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68956 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68956] = 26
                                    mem[_68956 + 32] = 'SafeMath: division by zero'
                            else:
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61761 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61761] = 30
                                    mem[_61761 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63307 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63307] = 30
                                    mem[_63307 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                    if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                    _66189 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66189] = 30
                                    mem[_66189 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68955 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68955] = 26
                                    mem[_68955 + 32] = 'SafeMath: division by zero'
                                else:
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _61900 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61900] = 30
                                    mem[_61900 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63583 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63583] = 30
                                    mem[_63583 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                    if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                    _66393 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66393] = 30
                                    mem[_66393 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _69213 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_69213] = 26
                                    mem[_69213 + 32] = 'SafeMath: division by zero'
            if not sub_1b2cabba:
                revert with 0, 'SafeMath: division by zero'
            if not sub_8a3be0b6:
                if ethSent > 0:
                    if timeBetweenRounds + block.timestamp < block.timestamp:
                        revert with 0, 'SafeMath: addition overflow'
                    presaleTime = timeBetweenRounds + block.timestamp
                    sub_8a3be0b6++
                    if sub_be71ce9f > sub_49a6a335:
                        revert with 0, 'SafeMath: subtraction overflow'
                    sub_49a6a335 -= sub_be71ce9f
            else:
                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                    if ethSent > 0:
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        if sub_be71ce9f > sub_49a6a335:
                            revert with 0, 'SafeMath: subtraction overflow'
                        sub_49a6a335 -= sub_be71ce9f
                else:
                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if ethSent > 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        if sub_be71ce9f > sub_49a6a335:
                            revert with 0, 'SafeMath: subtraction overflow'
                        sub_49a6a335 -= sub_be71ce9f
            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
    else:
        if ext_code.hash(msg.sender):
            revert with 0, 'Contracts not allowed'
        if presaleTime <= 0:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        34,
                        0x6f50726573616c65206e6f74206163746976652c2063616e6e6f7420627579207965,
                        mem[198 len 30]
        if presaleTime > block.timestamp:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        34,
                        0x6f50726573616c65206e6f74206163746976652c2063616e6e6f7420627579207965,
                        mem[198 len 30]
        if msg.value < 10^18:
            revert with 0, 'You sent less than 1 FTM'
        if msg.value > 1000 * 10^18:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        44,
                        0x73596f752073656e74206d6f7265207468616e20746865206d617820313030302046544d2070657220757365,
                        mem[208 len 20]
        if ethSent >= 10^18 * presaleHardcap:
            revert with 0, 'Hard cap reached'
        if ethSent + msg.value < msg.value:
            revert with 0, 'SafeMath: addition overflow'
        if ethSent + msg.value >= 10^18 * presaleHardcap:
            revert with 0, 'Hardcap will be breached'
        if msg.value + sub_536c8c02[msg.sender] < sub_536c8c02[msg.sender]:
            revert with 0, 'SafeMath: addition overflow'
        if msg.value + sub_536c8c02[msg.sender] > 1000 * 10^18:
            revert with 0, 'You cannot buy that much more'
        if not msg.value:
            mem[96] = 26
            mem[128] = 'SafeMath: division by zero'
            mem[64] = 224
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if stor29[address(this.address)]:
                if stor27[address(this.address)] < 0:
                    revert with 0, 32, 33, 0x774e6f7420656e6f75676820746f6b656e7320696e2074686520636f6e74726163, mem[325 len 31]
                if msg.value + sub_536c8c02[msg.sender] < sub_536c8c02[msg.sender]:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = msg.sender
                mem[32] = 20
                sub_536c8c02[msg.sender] += msg.value
                if msg.value + ethSent < ethSent:
                    revert with 0, 'SafeMath: addition overflow'
                ethSent += msg.value
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[64] = 352
                mem[288] = 30
                mem[320] = 'SafeMath: subtraction overflow'
                idx = 0
                s = _tTotal
                t = stor32
                while idx < stor30.length:
                    mem[0] = stor30[idx]
                    mem[32] = 26
                    if stor26[stor30[idx]] > t:
                        _28906 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28906] = 26
                        mem[_28906 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _28906 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _29814 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29814] = 30
                        mem[_29814 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = this.address
                        mem[32] = 26
                        _30150 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30150] = 30
                        mem[_30150 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor26[address(this.address)]:
                            _30259 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30259 + 68] = mem[idx + _30150 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30259 + 68] = mem[_30259 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _30259 + -mem[64] + 100
                        if stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = stor26[msg.sender]
                        _30887 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30887] = 30
                        mem[_30887 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            _31059 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31059 + 68] = mem[idx + _30887 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31059 + 68] = mem[_31059 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _31059 + -mem[64] + 100
                        if _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(0, this.address, msg.sender);
                        _31692 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31692] = 26
                        mem[_31692 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _31692 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _34504 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34504] = 30
                            mem[_34504 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _35053 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _35053 + 68] = mem[idx + _34504 + 32]
                                idx = idx + 32
                                continue 
                            mem[_35053 + 68] = mem[_35053 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _35053 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _34804 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34804] = 30
                            mem[_34804 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _35307 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _35307 + 68] = mem[idx + _34804 + 32]
                                idx = idx + 32
                                continue 
                            mem[_35307 + 68] = mem[_35307 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _35307 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _35052 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35052] = 30
                        mem[_35052 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        _35545 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35545 + 68] = mem[idx + _35052 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35545 + 68] = mem[_35545 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _35545 + -mem[64] + 100
                    require idx < stor30.length
                    mem[0] = stor30[idx]
                    mem[32] = 27
                    if stor27[stor30[idx]] <= s:
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 26
                        _28938 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28938] = 30
                        mem[_28938 + 32] = 'SafeMath: subtraction overflow'
                        if stor26[stor30[idx]] > t:
                            _29026 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29026 + 68] = mem[idx + _28938 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29026 + 68] = mem[_29026 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _29026 + -mem[64] + 100
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 27
                        _29349 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29349] = 30
                        mem[_29349 + 32] = 'SafeMath: subtraction overflow'
                        if stor27[stor30[idx]] <= s:
                            idx = idx + 1
                            s = s - stor27[stor30[idx]]
                            t = t - stor26[stor30[idx]]
                            continue 
                        _29505 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29505 + 68] = mem[idx + _29349 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29505 + 68] = mem[_29505 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _29505 + -mem[64] + 100
                    _28988 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28988] = 26
                    mem[_28988 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _28988 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    _29880 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29880] = 30
                    mem[_29880 + 32] = 'SafeMath: subtraction overflow'
                    mem[0] = this.address
                    mem[32] = 26
                    _30262 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30262] = 30
                    mem[_30262 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor26[address(this.address)]:
                        _30420 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30420 + 68] = mem[idx + _30262 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30420 + 68] = mem[_30420 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _30420 + -mem[64] + 100
                    if stor26[msg.sender] < stor26[msg.sender]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = msg.sender
                    mem[32] = 26
                    stor26[address(msg.sender)] = stor26[msg.sender]
                    _31062 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31062] = 30
                    mem[_31062 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor32:
                        _31164 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _31164 + 68] = mem[idx + _31062 + 32]
                            idx = idx + 32
                            continue 
                        mem[_31164 + 68] = mem[_31164 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _31164 + -mem[64] + 100
                    if _tFeeTotal < _tFeeTotal:
                        revert with 0, 'SafeMath: addition overflow'
                    emit Transfer(0, this.address, msg.sender);
                    _31852 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31852] = 26
                    mem[_31852 + 32] = 'SafeMath: division by zero'
                    if not sub_1b2cabba:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _31852 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if not sub_8a3be0b6:
                        if ethSent <= 0:
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _35058 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35058] = 30
                        mem[_35058 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        _35550 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35550 + 68] = mem[idx + _35058 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35550 + 68] = mem[_35550 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _35550 + -mem[64] + 100
                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                        if ethSent <= 0:
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _35310 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35310] = 30
                        mem[_35310 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        _35778 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35778 + 68] = mem[idx + _35310 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35778 + 68] = mem[_35778 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _35778 + -mem[64] + 100
                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                        emit Transfer(0, this.address, msg.sender);
                        stor0 = 1
                    if timeBetweenRounds + block.timestamp < block.timestamp:
                        revert with 0, 'SafeMath: addition overflow'
                    presaleTime = timeBetweenRounds + block.timestamp
                    sub_8a3be0b6++
                    _35549 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35549] = 30
                    mem[_35549 + 32] = 'SafeMath: subtraction overflow'
                    if sub_be71ce9f <= sub_49a6a335:
                        sub_49a6a335 -= sub_be71ce9f
                        emit Transfer(0, this.address, msg.sender);
                        stor0 = 1
                    _36031 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _36031 + 68] = mem[idx + _35549 + 32]
                        idx = idx + 32
                        continue 
                    mem[_36031 + 68] = mem[_36031 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _36031 + -mem[64] + 100
                _28772 = mem[64]
                mem[64] = mem[64] + 64
                mem[_28772] = 26
                mem[_28772 + 32] = 'SafeMath: division by zero'
                if not _tTotal:
                    revert with 0, 'SafeMath: division by zero'
                if t >= stor32 / _tTotal:
                    _29092 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29092] = 26
                    mem[_29092 + 32] = 'SafeMath: division by zero'
                    if not s:
                        revert with 0, 'SafeMath: division by zero'
                    _29975 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29975] = 30
                    mem[_29975 + 32] = 'SafeMath: subtraction overflow'
                    mem[0] = this.address
                    mem[32] = 26
                    _30415 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30415] = 30
                    mem[_30415 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor26[address(this.address)]:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if stor26[msg.sender] < stor26[msg.sender]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = msg.sender
                    mem[32] = 26
                    stor26[address(msg.sender)] = stor26[msg.sender]
                    _31161 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31161] = 30
                    mem[_31161 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor32:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if _tFeeTotal < _tFeeTotal:
                        revert with 0, 'SafeMath: addition overflow'
                    emit Transfer(0, this.address, msg.sender);
                    _32002 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32002] = 26
                    mem[_32002 + 32] = 'SafeMath: division by zero'
                else:
                    _29093 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29093] = 26
                    mem[_29093 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    _29976 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29976] = 30
                    mem[_29976 + 32] = 'SafeMath: subtraction overflow'
                    mem[0] = this.address
                    mem[32] = 26
                    _30416 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30416] = 30
                    mem[_30416 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor26[address(this.address)]:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if stor26[msg.sender] < stor26[msg.sender]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = msg.sender
                    mem[32] = 26
                    stor26[address(msg.sender)] = stor26[msg.sender]
                    _31162 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31162] = 30
                    mem[_31162 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor32:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if _tFeeTotal < _tFeeTotal:
                        revert with 0, 'SafeMath: addition overflow'
                    emit Transfer(0, this.address, msg.sender);
                    _32003 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32003] = 26
                    mem[_32003 + 32] = 'SafeMath: division by zero'
            else:
                mem[0] = this.address
                mem[32] = 26
                if stor26[address(this.address)] > stor32:
                    revert with 0, 32, 42, 0x73416d6f756e74206d757374206265206c657373207468616e20746f74616c207265666c656374696f6e, mem[334 len 22]
                idx = 0
                s = _tTotal
                t = stor32
                while idx < stor30.length:
                    mem[0] = stor30[idx]
                    mem[32] = 26
                    if stor26[stor30[idx]] > t:
                        _28901 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28901] = 26
                        mem[_28901 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _28901 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _29340 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29340] = 26
                        mem[_29340 + 32] = 'SafeMath: division by zero'
                        if not stor32 / _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _29340 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if stor26[address(this.address)] / stor32 / _tTotal < 0:
                            revert with 0, 32, 33, 0x774e6f7420656e6f75676820746f6b656e7320696e2074686520636f6e74726163, mem[mem[64] + 101 len 31]
                        if msg.value + sub_536c8c02[msg.sender] < sub_536c8c02[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 20
                        sub_536c8c02[msg.sender] += msg.value
                        if msg.value + ethSent < ethSent:
                            revert with 0, 'SafeMath: addition overflow'
                        ethSent += msg.value
                        _30332 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30332] = 26
                        mem[_30332 + 32] = 'SafeMath: division by zero'
                        _31160 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31160] = 30
                        mem[_31160 + 32] = 'SafeMath: subtraction overflow'
                        idx = 0
                        s = _tTotal
                        t = stor32
                        while idx < stor30.length:
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            if stor26[stor30[idx]] > t:
                                _59589 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59589] = 26
                                mem[_59589 + 32] = 'SafeMath: division by zero'
                                if not _tTotal:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _59589 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                _61411 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61411] = 30
                                mem[_61411 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _62259 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62259] = 30
                                mem[_62259 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _62637 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62637 + 68] = mem[idx + _62259 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62637 + 68] = mem[_62637 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62637 + -mem[64] + 100
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _65077 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65077] = 30
                                mem[_65077 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _65771 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _65771 + 68] = mem[idx + _65077 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_65771 + 68] = mem[_65771 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _65771 + -mem[64] + 100
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(0, this.address, msg.sender);
                                _67929 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_67929] = 26
                                mem[_67929 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _67929 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer(0, this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73241 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73241] = 30
                                    mem[_73241 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer(0, this.address, msg.sender);
                                        stor0 = 1
                                    _74220 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74220 + 68] = mem[idx + _73241 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74220 + 68] = mem[_74220 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74220 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer(0, this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73723 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73723] = 30
                                    mem[_73723 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer(0, this.address, msg.sender);
                                        stor0 = 1
                                    _74737 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74737 + 68] = mem[idx + _73723 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74737 + 68] = mem[_74737 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74737 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74219 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74219] = 30
                                mem[_74219 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                _75343 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75343 + 68] = mem[idx + _74219 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75343 + 68] = mem[_75343 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75343 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            if stor27[stor30[idx]] <= s:
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 26
                                _59665 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59665] = 30
                                mem[_59665 + 32] = 'SafeMath: subtraction overflow'
                                if stor26[stor30[idx]] > t:
                                    _59878 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _59878 + 68] = mem[idx + _59665 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59878 + 68] = mem[_59878 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59878 + -mem[64] + 100
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 27
                                _60642 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_60642] = 30
                                mem[_60642 + 32] = 'SafeMath: subtraction overflow'
                                if stor27[stor30[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor27[stor30[idx]]
                                    t = t - stor26[stor30[idx]]
                                    continue 
                                _60977 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _60977 + 68] = mem[idx + _60642 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_60977 + 68] = mem[_60977 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _60977 + -mem[64] + 100
                            _59783 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59783] = 26
                            mem[_59783 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59783 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            _61499 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61499] = 30
                            mem[_61499 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = this.address
                            mem[32] = 26
                            _62640 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_62640] = 30
                            mem[_62640 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                _63258 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63258 + 68] = mem[idx + _62640 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63258 + 68] = mem[_63258 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63258 + -mem[64] + 100
                            if stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = stor26[msg.sender]
                            _65774 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_65774] = 30
                            mem[_65774 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _66156 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66156 + 68] = mem[idx + _65774 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66156 + 68] = mem[_66156 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66156 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(0, this.address, msg.sender);
                            _68444 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68444] = 26
                            mem[_68444 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68444 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74225 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74225] = 30
                                mem[_74225 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                _75348 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75348 + 68] = mem[idx + _74225 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75348 + 68] = mem[_75348 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75348 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74740 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74740] = 30
                                mem[_74740 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                _75992 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75992 + 68] = mem[idx + _74740 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75992 + 68] = mem[_75992 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75992 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75347 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75347] = 30
                            mem[_75347 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _76767 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _76767 + 68] = mem[idx + _75347 + 32]
                                idx = idx + 32
                                continue 
                            mem[_76767 + 68] = mem[_76767 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _76767 + -mem[64] + 100
                        _58735 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_58735] = 26
                        mem[_58735 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _58735 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor32 / _tTotal:
                            _60039 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_60039] = 26
                            mem[_60039 + 32] = 'SafeMath: division by zero'
                            if not s:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _60039 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            _61737 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61737] = 30
                            mem[_61737 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = this.address
                            mem[32] = 26
                            _63253 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_63253] = 30
                            mem[_63253 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                _63917 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63917 + 68] = mem[idx + _63253 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63917 + 68] = mem[_63917 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63917 + -mem[64] + 100
                            if stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = stor26[msg.sender]
                            _66153 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_66153] = 30
                            mem[_66153 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _66673 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66673 + 68] = mem[idx + _66153 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66673 + 68] = mem[_66673 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66673 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(0, this.address, msg.sender);
                            _68911 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68911] = 26
                            mem[_68911 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68911 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75339 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75339] = 30
                                mem[_75339 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                _76754 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76754 + 68] = mem[idx + _75339 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76754 + 68] = mem[_76754 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76754 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75985 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75985] = 30
                                mem[_75985 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                _77653 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77653 + 68] = mem[idx + _75985 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77653 + 68] = mem[_77653 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77653 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _76753 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_76753] = 30
                            mem[_76753 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _78543 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _78543 + 68] = mem[idx + _76753 + 32]
                                idx = idx + 32
                                continue 
                            mem[_78543 + 68] = mem[_78543 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _78543 + -mem[64] + 100
                        _60040 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_60040] = 26
                        mem[_60040 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _60040 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _61738 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61738] = 30
                        mem[_61738 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = this.address
                        mem[32] = 26
                        _63254 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_63254] = 30
                        mem[_63254 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor26[address(this.address)]:
                            _63920 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _63920 + 68] = mem[idx + _63254 + 32]
                                idx = idx + 32
                                continue 
                            mem[_63920 + 68] = mem[_63920 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _63920 + -mem[64] + 100
                        if stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = stor26[msg.sender]
                        _66154 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_66154] = 30
                        mem[_66154 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            _66676 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _66676 + 68] = mem[idx + _66154 + 32]
                                idx = idx + 32
                                continue 
                            mem[_66676 + 68] = mem[_66676 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _66676 + -mem[64] + 100
                        if _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(0, this.address, msg.sender);
                        _68912 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_68912] = 26
                        mem[_68912 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _68912 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75342 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75342] = 30
                            mem[_75342 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _76758 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _76758 + 68] = mem[idx + _75342 + 32]
                                idx = idx + 32
                                continue 
                            mem[_76758 + 68] = mem[_76758 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _76758 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75986 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75986] = 30
                            mem[_75986 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _77656 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77656 + 68] = mem[idx + _75986 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77656 + 68] = mem[_77656 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77656 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _76757 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_76757] = 30
                        mem[_76757 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        _78547 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _78547 + 68] = mem[idx + _76757 + 32]
                            idx = idx + 32
                            continue 
                        mem[_78547 + 68] = mem[_78547 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _78547 + -mem[64] + 100
                    require idx < stor30.length
                    mem[0] = stor30[idx]
                    mem[32] = 27
                    if stor27[stor30[idx]] <= s:
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 26
                        _28935 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28935] = 30
                        mem[_28935 + 32] = 'SafeMath: subtraction overflow'
                        if stor26[stor30[idx]] > t:
                            _29022 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29022 + 68] = mem[idx + _28935 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29022 + 68] = mem[_29022 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _29022 + -mem[64] + 100
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 27
                        _29342 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29342] = 30
                        mem[_29342 + 32] = 'SafeMath: subtraction overflow'
                        if stor27[stor30[idx]] <= s:
                            idx = idx + 1
                            s = s - stor27[stor30[idx]]
                            t = t - stor26[stor30[idx]]
                            continue 
                        _29496 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29496 + 68] = mem[idx + _29342 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29496 + 68] = mem[_29496 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _29496 + -mem[64] + 100
                    _28983 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28983] = 26
                    mem[_28983 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _28983 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    _29499 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29499] = 26
                    mem[_29499 + 32] = 'SafeMath: division by zero'
                    if not stor32 / _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _29499 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if stor26[address(this.address)] / stor32 / _tTotal < 0:
                        revert with 0, 32, 33, 0x774e6f7420656e6f75676820746f6b656e7320696e2074686520636f6e74726163, mem[mem[64] + 101 len 31]
                    if msg.value + sub_536c8c02[msg.sender] < sub_536c8c02[msg.sender]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = msg.sender
                    mem[32] = 20
                    sub_536c8c02[msg.sender] += msg.value
                    if msg.value + ethSent < ethSent:
                        revert with 0, 'SafeMath: addition overflow'
                    ethSent += msg.value
                    _30492 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30492] = 26
                    mem[_30492 + 32] = 'SafeMath: division by zero'
                    _31304 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31304] = 30
                    mem[_31304 + 32] = 'SafeMath: subtraction overflow'
                    idx = 0
                    s = _tTotal
                    t = stor32
                    while idx < stor30.length:
                        mem[0] = stor30[idx]
                        mem[32] = 26
                        if stor26[stor30[idx]] > t:
                            _59594 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59594] = 26
                            mem[_59594 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59594 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            _61412 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61412] = 30
                            mem[_61412 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = this.address
                            mem[32] = 26
                            _62260 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_62260] = 30
                            mem[_62260 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                _62641 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _62641 + 68] = mem[idx + _62260 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_62641 + 68] = mem[_62641 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _62641 + -mem[64] + 100
                            if stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = stor26[msg.sender]
                            _65083 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_65083] = 30
                            mem[_65083 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _65777 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _65777 + 68] = mem[idx + _65083 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_65777 + 68] = mem[_65777 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _65777 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(0, this.address, msg.sender);
                            _67938 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_67938] = 26
                            mem[_67938 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _67938 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _73250 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_73250] = 30
                                mem[_73250 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                _74231 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _74231 + 68] = mem[idx + _73250 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_74231 + 68] = mem[_74231 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _74231 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _73730 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_73730] = 30
                                mem[_73730 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                _74745 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _74745 + 68] = mem[idx + _73730 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_74745 + 68] = mem[_74745 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _74745 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _74230 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_74230] = 30
                            mem[_74230 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _75357 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _75357 + 68] = mem[idx + _74230 + 32]
                                idx = idx + 32
                                continue 
                            mem[_75357 + 68] = mem[_75357 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _75357 + -mem[64] + 100
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 27
                        if stor27[stor30[idx]] <= s:
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            _59668 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59668] = 30
                            mem[_59668 + 32] = 'SafeMath: subtraction overflow'
                            if stor26[stor30[idx]] > t:
                                _59882 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _59882 + 68] = mem[idx + _59668 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_59882 + 68] = mem[_59882 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _59882 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            _60649 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_60649] = 30
                            mem[_60649 + 32] = 'SafeMath: subtraction overflow'
                            if stor27[stor30[idx]] <= s:
                                idx = idx + 1
                                s = s - stor27[stor30[idx]]
                                t = t - stor26[stor30[idx]]
                                continue 
                            _60985 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _60985 + 68] = mem[idx + _60649 + 32]
                                idx = idx + 32
                                continue 
                            mem[_60985 + 68] = mem[_60985 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _60985 + -mem[64] + 100
                        _59788 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_59788] = 26
                        mem[_59788 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _59788 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _61500 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61500] = 30
                        mem[_61500 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = this.address
                        mem[32] = 26
                        _62644 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_62644] = 30
                        mem[_62644 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor26[address(this.address)]:
                            _63266 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _63266 + 68] = mem[idx + _62644 + 32]
                                idx = idx + 32
                                continue 
                            mem[_63266 + 68] = mem[_63266 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _63266 + -mem[64] + 100
                        if stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = stor26[msg.sender]
                        _65780 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_65780] = 30
                        mem[_65780 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            _66162 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _66162 + 68] = mem[idx + _65780 + 32]
                                idx = idx + 32
                                continue 
                            mem[_66162 + 68] = mem[_66162 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _66162 + -mem[64] + 100
                        if _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(0, this.address, msg.sender);
                        _68452 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_68452] = 26
                        mem[_68452 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _68452 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _74236 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_74236] = 30
                            mem[_74236 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _75362 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _75362 + 68] = mem[idx + _74236 + 32]
                                idx = idx + 32
                                continue 
                            mem[_75362 + 68] = mem[_75362 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _75362 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _74748 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_74748] = 30
                            mem[_74748 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _76002 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _76002 + 68] = mem[idx + _74748 + 32]
                                idx = idx + 32
                                continue 
                            mem[_76002 + 68] = mem[_76002 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _76002 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _75361 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_75361] = 30
                        mem[_75361 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        _76785 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _76785 + 68] = mem[idx + _75361 + 32]
                            idx = idx + 32
                            continue 
                        mem[_76785 + 68] = mem[_76785 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _76785 + -mem[64] + 100
                    _58746 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_58746] = 26
                    mem[_58746 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _58746 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if t >= stor32 / _tTotal:
                        _60046 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_60046] = 26
                        mem[_60046 + 32] = 'SafeMath: division by zero'
                        if not s:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _60046 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _61739 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61739] = 30
                        mem[_61739 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = this.address
                        mem[32] = 26
                        _63261 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_63261] = 30
                        mem[_63261 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor26[address(this.address)]:
                            _63929 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _63929 + 68] = mem[idx + _63261 + 32]
                                idx = idx + 32
                                continue 
                            mem[_63929 + 68] = mem[_63929 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _63929 + -mem[64] + 100
                        if stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = stor26[msg.sender]
                        _66159 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_66159] = 30
                        mem[_66159 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            _66683 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _66683 + 68] = mem[idx + _66159 + 32]
                                idx = idx + 32
                                continue 
                            mem[_66683 + 68] = mem[_66683 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _66683 + -mem[64] + 100
                        if _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(0, this.address, msg.sender);
                        _68918 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_68918] = 26
                        mem[_68918 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _68918 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75353 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75353] = 30
                            mem[_75353 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _76772 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _76772 + 68] = mem[idx + _75353 + 32]
                                idx = idx + 32
                                continue 
                            mem[_76772 + 68] = mem[_76772 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _76772 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75995 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75995] = 30
                            mem[_75995 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _77669 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77669 + 68] = mem[idx + _75995 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77669 + 68] = mem[_77669 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77669 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _76771 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_76771] = 30
                        mem[_76771 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        _78558 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _78558 + 68] = mem[idx + _76771 + 32]
                            idx = idx + 32
                            continue 
                        mem[_78558 + 68] = mem[_78558 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _78558 + -mem[64] + 100
                    _60047 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_60047] = 26
                    mem[_60047 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _60047 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    _61740 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_61740] = 30
                    mem[_61740 + 32] = 'SafeMath: subtraction overflow'
                    mem[0] = this.address
                    mem[32] = 26
                    _63262 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_63262] = 30
                    mem[_63262 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor26[address(this.address)]:
                        _63932 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _63932 + 68] = mem[idx + _63262 + 32]
                            idx = idx + 32
                            continue 
                        mem[_63932 + 68] = mem[_63932 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _63932 + -mem[64] + 100
                    if stor26[msg.sender] < stor26[msg.sender]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = msg.sender
                    mem[32] = 26
                    stor26[address(msg.sender)] = stor26[msg.sender]
                    _66160 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_66160] = 30
                    mem[_66160 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor32:
                        _66686 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _66686 + 68] = mem[idx + _66160 + 32]
                            idx = idx + 32
                            continue 
                        mem[_66686 + 68] = mem[_66686 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _66686 + -mem[64] + 100
                    if _tFeeTotal < _tFeeTotal:
                        revert with 0, 'SafeMath: addition overflow'
                    emit Transfer(0, this.address, msg.sender);
                    _68919 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_68919] = 26
                    mem[_68919 + 32] = 'SafeMath: division by zero'
                    if not sub_1b2cabba:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _68919 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if not sub_8a3be0b6:
                        if ethSent <= 0:
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _75356 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_75356] = 30
                        mem[_75356 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        _76776 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _76776 + 68] = mem[idx + _75356 + 32]
                            idx = idx + 32
                            continue 
                        mem[_76776 + 68] = mem[_76776 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _76776 + -mem[64] + 100
                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                        if ethSent <= 0:
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _75996 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_75996] = 30
                        mem[_75996 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        _77672 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _77672 + 68] = mem[idx + _75996 + 32]
                            idx = idx + 32
                            continue 
                        mem[_77672 + 68] = mem[_77672 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _77672 + -mem[64] + 100
                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                        emit Transfer(0, this.address, msg.sender);
                        stor0 = 1
                    if timeBetweenRounds + block.timestamp < block.timestamp:
                        revert with 0, 'SafeMath: addition overflow'
                    presaleTime = timeBetweenRounds + block.timestamp
                    sub_8a3be0b6++
                    _76775 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_76775] = 30
                    mem[_76775 + 32] = 'SafeMath: subtraction overflow'
                    if sub_be71ce9f <= sub_49a6a335:
                        sub_49a6a335 -= sub_be71ce9f
                        emit Transfer(0, this.address, msg.sender);
                        stor0 = 1
                    _78562 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _78562 + 68] = mem[idx + _76775 + 32]
                        idx = idx + 32
                        continue 
                    mem[_78562 + 68] = mem[_78562 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _78562 + -mem[64] + 100
                _28769 = mem[64]
                mem[64] = mem[64] + 64
                mem[_28769] = 26
                mem[_28769 + 32] = 'SafeMath: division by zero'
                if not _tTotal:
                    revert with 0, 'SafeMath: division by zero'
                if t >= stor32 / _tTotal:
                    _29085 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29085] = 26
                    mem[_29085 + 32] = 'SafeMath: division by zero'
                    if not s:
                        revert with 0, 'SafeMath: division by zero'
                    _29606 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29606] = 26
                    mem[_29606 + 32] = 'SafeMath: division by zero'
                    if not t / s:
                        revert with 0, 'SafeMath: division by zero'
                    if stor26[address(this.address)] / t / s < 0:
                        revert with 0, 32, 33, 0x774e6f7420656e6f75676820746f6b656e7320696e2074686520636f6e74726163, mem[mem[64] + 101 len 31]
                    if msg.value + sub_536c8c02[msg.sender] < sub_536c8c02[msg.sender]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = msg.sender
                    mem[32] = 20
                    sub_536c8c02[msg.sender] += msg.value
                    if msg.value + ethSent < ethSent:
                        revert with 0, 'SafeMath: addition overflow'
                    ethSent += msg.value
                    _30692 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30692] = 26
                    mem[_30692 + 32] = 'SafeMath: division by zero'
                    _31488 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31488] = 30
                    mem[_31488 + 32] = 'SafeMath: subtraction overflow'
                    idx = 0
                    s = _tTotal
                    t = stor32
                    while idx < stor30.length:
                        mem[0] = stor30[idx]
                        mem[32] = 26
                        if stor26[stor30[idx]] > t:
                            _59579 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59579] = 26
                            mem[_59579 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59579 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            _61409 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61409] = 30
                            mem[_61409 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = this.address
                            mem[32] = 26
                            _62257 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_62257] = 30
                            mem[_62257 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                _62629 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _62629 + 68] = mem[idx + _62257 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_62629 + 68] = mem[_62629 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _62629 + -mem[64] + 100
                            if stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = stor26[msg.sender]
                            _65065 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_65065] = 30
                            mem[_65065 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _65759 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _65759 + 68] = mem[idx + _65065 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_65759 + 68] = mem[_65759 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _65759 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(0, this.address, msg.sender);
                            _67911 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_67911] = 26
                            mem[_67911 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _67911 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _73223 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_73223] = 30
                                mem[_73223 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                _74198 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _74198 + 68] = mem[idx + _73223 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_74198 + 68] = mem[_74198 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _74198 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _73709 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_73709] = 30
                                mem[_73709 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                _74721 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _74721 + 68] = mem[idx + _73709 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_74721 + 68] = mem[_74721 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _74721 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _74197 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_74197] = 30
                            mem[_74197 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _75315 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _75315 + 68] = mem[idx + _74197 + 32]
                                idx = idx + 32
                                continue 
                            mem[_75315 + 68] = mem[_75315 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _75315 + -mem[64] + 100
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 27
                        if stor27[stor30[idx]] <= s:
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            _59659 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59659] = 30
                            mem[_59659 + 32] = 'SafeMath: subtraction overflow'
                            if stor26[stor30[idx]] > t:
                                _59870 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _59870 + 68] = mem[idx + _59659 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_59870 + 68] = mem[_59870 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _59870 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            _60628 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_60628] = 30
                            mem[_60628 + 32] = 'SafeMath: subtraction overflow'
                            if stor27[stor30[idx]] <= s:
                                idx = idx + 1
                                s = s - stor27[stor30[idx]]
                                t = t - stor26[stor30[idx]]
                                continue 
                            _60961 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _60961 + 68] = mem[idx + _60628 + 32]
                                idx = idx + 32
                                continue 
                            mem[_60961 + 68] = mem[_60961 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _60961 + -mem[64] + 100
                        _59773 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_59773] = 26
                        mem[_59773 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _59773 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _61497 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61497] = 30
                        mem[_61497 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = this.address
                        mem[32] = 26
                        _62632 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_62632] = 30
                        mem[_62632 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor26[address(this.address)]:
                            _63242 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _63242 + 68] = mem[idx + _62632 + 32]
                                idx = idx + 32
                                continue 
                            mem[_63242 + 68] = mem[_63242 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _63242 + -mem[64] + 100
                        if stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = stor26[msg.sender]
                        _65762 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_65762] = 30
                        mem[_65762 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            _66144 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _66144 + 68] = mem[idx + _65762 + 32]
                                idx = idx + 32
                                continue 
                            mem[_66144 + 68] = mem[_66144 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _66144 + -mem[64] + 100
                        if _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(0, this.address, msg.sender);
                        _68428 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_68428] = 26
                        mem[_68428 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _68428 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _74203 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_74203] = 30
                            mem[_74203 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _75320 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _75320 + 68] = mem[idx + _74203 + 32]
                                idx = idx + 32
                                continue 
                            mem[_75320 + 68] = mem[_75320 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _75320 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _74724 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_74724] = 30
                            mem[_74724 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _75972 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _75972 + 68] = mem[idx + _74724 + 32]
                                idx = idx + 32
                                continue 
                            mem[_75972 + 68] = mem[_75972 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _75972 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _75319 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_75319] = 30
                        mem[_75319 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        _76731 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _76731 + 68] = mem[idx + _75319 + 32]
                            idx = idx + 32
                            continue 
                        mem[_76731 + 68] = mem[_76731 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _76731 + -mem[64] + 100
                    _58719 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_58719] = 26
                    mem[_58719 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    if t >= stor32 / _tTotal:
                        _60025 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_60025] = 26
                        mem[_60025 + 32] = 'SafeMath: division by zero'
                        if not s:
                            revert with 0, 'SafeMath: division by zero'
                        _61733 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61733] = 30
                        mem[_61733 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = this.address
                        mem[32] = 26
                        _63237 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_63237] = 30
                        mem[_63237 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor26[address(this.address)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = stor26[msg.sender]
                        _66141 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_66141] = 30
                        mem[_66141 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(0, this.address, msg.sender);
                        _68897 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_68897] = 26
                        mem[_68897 + 32] = 'SafeMath: division by zero'
                    else:
                        _60026 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_60026] = 26
                        mem[_60026 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            revert with 0, 'SafeMath: division by zero'
                        _61734 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61734] = 30
                        mem[_61734 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = this.address
                        mem[32] = 26
                        _63238 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_63238] = 30
                        mem[_63238 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor26[address(this.address)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = stor26[msg.sender]
                        _66142 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_66142] = 30
                        mem[_66142 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(0, this.address, msg.sender);
                        _68898 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_68898] = 26
                        mem[_68898 + 32] = 'SafeMath: division by zero'
                else:
                    _29086 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29086] = 26
                    mem[_29086 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    _29608 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29608] = 26
                    mem[_29608 + 32] = 'SafeMath: division by zero'
                    if not stor32 / _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    if stor26[address(this.address)] / stor32 / _tTotal < 0:
                        revert with 0, 32, 33, 0x774e6f7420656e6f75676820746f6b656e7320696e2074686520636f6e74726163, mem[mem[64] + 101 len 31]
                    if msg.value + sub_536c8c02[msg.sender] < sub_536c8c02[msg.sender]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = msg.sender
                    mem[32] = 20
                    sub_536c8c02[msg.sender] += msg.value
                    if msg.value + ethSent < ethSent:
                        revert with 0, 'SafeMath: addition overflow'
                    ethSent += msg.value
                    _30693 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30693] = 26
                    mem[_30693 + 32] = 'SafeMath: division by zero'
                    _31489 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31489] = 30
                    mem[_31489 + 32] = 'SafeMath: subtraction overflow'
                    idx = 0
                    s = _tTotal
                    t = stor32
                    while idx < stor30.length:
                        mem[0] = stor30[idx]
                        mem[32] = 26
                        if stor26[stor30[idx]] > t:
                            _59584 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59584] = 26
                            mem[_59584 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59584 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            _61410 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61410] = 30
                            mem[_61410 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = this.address
                            mem[32] = 26
                            _62258 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_62258] = 30
                            mem[_62258 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                _62633 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _62633 + 68] = mem[idx + _62258 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_62633 + 68] = mem[_62633 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _62633 + -mem[64] + 100
                            if stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = stor26[msg.sender]
                            _65071 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_65071] = 30
                            mem[_65071 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _65765 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _65765 + 68] = mem[idx + _65071 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_65765 + 68] = mem[_65765 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _65765 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(0, this.address, msg.sender);
                            _67920 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_67920] = 26
                            mem[_67920 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _67920 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _73232 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_73232] = 30
                                mem[_73232 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                _74209 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _74209 + 68] = mem[idx + _73232 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_74209 + 68] = mem[_74209 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _74209 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _73716 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_73716] = 30
                                mem[_73716 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer(0, this.address, msg.sender);
                                    stor0 = 1
                                _74729 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _74729 + 68] = mem[idx + _73716 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_74729 + 68] = mem[_74729 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _74729 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _74208 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_74208] = 30
                            mem[_74208 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _75329 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _75329 + 68] = mem[idx + _74208 + 32]
                                idx = idx + 32
                                continue 
                            mem[_75329 + 68] = mem[_75329 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _75329 + -mem[64] + 100
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 27
                        if stor27[stor30[idx]] <= s:
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            _59662 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59662] = 30
                            mem[_59662 + 32] = 'SafeMath: subtraction overflow'
                            if stor26[stor30[idx]] > t:
                                _59874 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _59874 + 68] = mem[idx + _59662 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_59874 + 68] = mem[_59874 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _59874 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            _60635 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_60635] = 30
                            mem[_60635 + 32] = 'SafeMath: subtraction overflow'
                            if stor27[stor30[idx]] <= s:
                                idx = idx + 1
                                s = s - stor27[stor30[idx]]
                                t = t - stor26[stor30[idx]]
                                continue 
                            _60969 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _60969 + 68] = mem[idx + _60635 + 32]
                                idx = idx + 32
                                continue 
                            mem[_60969 + 68] = mem[_60969 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _60969 + -mem[64] + 100
                        _59778 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_59778] = 26
                        mem[_59778 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _59778 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _61498 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61498] = 30
                        mem[_61498 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = this.address
                        mem[32] = 26
                        _62636 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_62636] = 30
                        mem[_62636 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor26[address(this.address)]:
                            _63250 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _63250 + 68] = mem[idx + _62636 + 32]
                                idx = idx + 32
                                continue 
                            mem[_63250 + 68] = mem[_63250 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _63250 + -mem[64] + 100
                        if stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = stor26[msg.sender]
                        _65768 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_65768] = 30
                        mem[_65768 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            _66150 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _66150 + 68] = mem[idx + _65768 + 32]
                                idx = idx + 32
                                continue 
                            mem[_66150 + 68] = mem[_66150 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _66150 + -mem[64] + 100
                        if _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(0, this.address, msg.sender);
                        _68436 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_68436] = 26
                        mem[_68436 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _68436 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _74214 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_74214] = 30
                            mem[_74214 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _75334 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _75334 + 68] = mem[idx + _74214 + 32]
                                idx = idx + 32
                                continue 
                            mem[_75334 + 68] = mem[_75334 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _75334 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _74732 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_74732] = 30
                            mem[_74732 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer(0, this.address, msg.sender);
                                stor0 = 1
                            _75982 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _75982 + 68] = mem[idx + _74732 + 32]
                                idx = idx + 32
                                continue 
                            mem[_75982 + 68] = mem[_75982 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _75982 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _75333 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_75333] = 30
                        mem[_75333 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer(0, this.address, msg.sender);
                            stor0 = 1
                        _76749 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _76749 + 68] = mem[idx + _75333 + 32]
                            idx = idx + 32
                            continue 
                        mem[_76749 + 68] = mem[_76749 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _76749 + -mem[64] + 100
                    _58726 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_58726] = 26
                    mem[_58726 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    if t >= stor32 / _tTotal:
                        _60032 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_60032] = 26
                        mem[_60032 + 32] = 'SafeMath: division by zero'
                        if not s:
                            revert with 0, 'SafeMath: division by zero'
                        _61735 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61735] = 30
                        mem[_61735 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = this.address
                        mem[32] = 26
                        _63245 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_63245] = 30
                        mem[_63245 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor26[address(this.address)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = stor26[msg.sender]
                        _66147 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_66147] = 30
                        mem[_66147 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(0, this.address, msg.sender);
                        _68904 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_68904] = 26
                        mem[_68904 + 32] = 'SafeMath: division by zero'
                    else:
                        _60033 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_60033] = 26
                        mem[_60033 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            revert with 0, 'SafeMath: division by zero'
                        _61736 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61736] = 30
                        mem[_61736 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = this.address
                        mem[32] = 26
                        _63246 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_63246] = 30
                        mem[_63246 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor26[address(this.address)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = stor26[msg.sender]
                        _66148 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_66148] = 30
                        mem[_66148 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(0, this.address, msg.sender);
                        _68905 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_68905] = 26
                        mem[_68905 + 32] = 'SafeMath: division by zero'
            if not sub_1b2cabba:
                revert with 0, 'SafeMath: division by zero'
            if not sub_8a3be0b6:
                if ethSent > 0:
                    if timeBetweenRounds + block.timestamp < block.timestamp:
                        revert with 0, 'SafeMath: addition overflow'
                    presaleTime = timeBetweenRounds + block.timestamp
                    sub_8a3be0b6++
                    if sub_be71ce9f > sub_49a6a335:
                        revert with 0, 'SafeMath: subtraction overflow'
                    sub_49a6a335 -= sub_be71ce9f
            else:
                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                    if ethSent > 0:
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        if sub_be71ce9f > sub_49a6a335:
                            revert with 0, 'SafeMath: subtraction overflow'
                        sub_49a6a335 -= sub_be71ce9f
                else:
                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if ethSent > 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        if sub_be71ce9f > sub_49a6a335:
                            revert with 0, 'SafeMath: subtraction overflow'
                        sub_49a6a335 -= sub_be71ce9f
            emit Transfer(0, this.address, msg.sender);
        else:
            if sub_49a6a335 * msg.value / msg.value != sub_49a6a335:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            mem[96] = 26
            mem[128] = 'SafeMath: division by zero'
            mem[64] = 224
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            sub_84f44adf += sub_49a6a335 * msg.value / 10^9 / 2
            if stor29[address(this.address)]:
                if stor27[address(this.address)] < sub_49a6a335 * msg.value / 10^9:
                    revert with 0, 32, 33, 0x774e6f7420656e6f75676820746f6b656e7320696e2074686520636f6e74726163, mem[325 len 31]
                if msg.value + sub_536c8c02[msg.sender] < sub_536c8c02[msg.sender]:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = msg.sender
                mem[32] = 20
                sub_536c8c02[msg.sender] += msg.value
                if msg.value + ethSent < ethSent:
                    revert with 0, 'SafeMath: addition overflow'
                ethSent += msg.value
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                if not sub_49a6a335 * msg.value / 10^9 / 50:
                    mem[64] = 352
                    mem[288] = 30
                    mem[320] = 'SafeMath: subtraction overflow'
                    if 0 > sub_49a6a335 * msg.value / 10^9:
                        revert with 0, 'SafeMath: subtraction overflow'
                    idx = 0
                    s = _tTotal
                    t = stor32
                    while idx < stor30.length:
                        mem[0] = stor30[idx]
                        mem[32] = 26
                        if stor26[stor30[idx]] > t:
                            _28896 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28896] = 26
                            mem[_28896 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _28896 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                _29805 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29805] = 30
                                mem[_29805 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _30144 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30144] = 30
                                mem[_30144 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _30249 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _30249 + 68] = mem[idx + _30144 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_30249 + 68] = mem[_30249 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _30249 + -mem[64] + 100
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _30878 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30878] = 30
                                mem[_30878 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _31053 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _31053 + 68] = mem[idx + _30878 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_31053 + 68] = mem[_31053 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _31053 + -mem[64] + 100
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _31683 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31683] = 26
                                mem[_31683 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _31683 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _34455 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34455] = 30
                                    mem[_34455 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _35022 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _35022 + 68] = mem[idx + _34455 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35022 + 68] = mem[_35022 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35022 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _34770 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34770] = 30
                                    mem[_34770 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _35276 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _35276 + 68] = mem[idx + _34770 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35276 + 68] = mem[_35276 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35276 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _35021 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35021] = 30
                                mem[_35021 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35520 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35520 + 68] = mem[idx + _35021 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35520 + 68] = mem[_35520 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35520 + -mem[64] + 100
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _29836 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29836] = 30
                            mem[_29836 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _29912 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29912 + 68] = mem[idx + _29836 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29912 + 68] = mem[_29912 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _29912 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _30188 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30188] = 30
                            mem[_30188 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _30328 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _30328 + 68] = mem[idx + _30188 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_30328 + 68] = mem[_30328 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _30328 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                            _30971 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30971] = 30
                            mem[_30971 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _31111 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _31111 + 68] = mem[idx + _30971 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_31111 + 68] = mem[_31111 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _31111 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            _31774 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31774] = 26
                            mem[_31774 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _31774 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _34769 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34769] = 30
                                mem[_34769 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35273 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35273 + 68] = mem[idx + _34769 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35273 + 68] = mem[_35273 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35273 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _35020 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35020] = 30
                                mem[_35020 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35517 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35517 + 68] = mem[idx + _35020 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35517 + 68] = mem[_35517 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35517 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _35272 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35272] = 30
                            mem[_35272 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _35748 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _35748 + 68] = mem[idx + _35272 + 32]
                                idx = idx + 32
                                continue 
                            mem[_35748 + 68] = mem[_35748 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _35748 + -mem[64] + 100
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 27
                        if stor27[stor30[idx]] <= s:
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            _28932 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28932] = 30
                            mem[_28932 + 32] = 'SafeMath: subtraction overflow'
                            if stor26[stor30[idx]] > t:
                                _29018 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29018 + 68] = mem[idx + _28932 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29018 + 68] = mem[_29018 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _29018 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            _29334 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29334] = 30
                            mem[_29334 + 32] = 'SafeMath: subtraction overflow'
                            if stor27[stor30[idx]] <= s:
                                idx = idx + 1
                                s = s - stor27[stor30[idx]]
                                t = t - stor26[stor30[idx]]
                                continue 
                            _29485 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29485 + 68] = mem[idx + _29334 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29485 + 68] = mem[_29485 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _29485 + -mem[64] + 100
                        _28978 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28978] = 26
                        mem[_28978 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _28978 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_49a6a335 * msg.value / 10^9:
                            _29872 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29872] = 30
                            mem[_29872 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = this.address
                            mem[32] = 26
                            _30254 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30254] = 30
                            mem[_30254 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                _30412 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _30412 + 68] = mem[idx + _30254 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_30412 + 68] = mem[_30412 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _30412 + -mem[64] + 100
                            if stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = stor26[msg.sender]
                            _31056 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31056] = 30
                            mem[_31056 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _31157 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _31157 + 68] = mem[idx + _31056 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_31157 + 68] = mem[_31157 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _31157 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            _31844 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31844] = 26
                            mem[_31844 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _31844 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _35029 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35029] = 30
                                mem[_35029 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35526 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35526 + 68] = mem[idx + _35029 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35526 + 68] = mem[_35526 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35526 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _35282 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35282] = 30
                                mem[_35282 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35761 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35761 + 68] = mem[idx + _35282 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35761 + 68] = mem[_35761 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35761 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _35525 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35525] = 30
                            mem[_35525 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _36008 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _36008 + 68] = mem[idx + _35525 + 32]
                                idx = idx + 32
                                continue 
                            mem[_36008 + 68] = mem[_36008 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _36008 + -mem[64] + 100
                        if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _29915 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29915] = 30
                        mem[_29915 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                            _30019 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30019 + 68] = mem[idx + _29915 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30019 + 68] = mem[_30019 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _30019 + -mem[64] + 100
                        mem[0] = this.address
                        mem[32] = 26
                        _30331 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30331] = 30
                        mem[_30331 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                            _30489 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30489 + 68] = mem[idx + _30331 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30489 + 68] = mem[_30489 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _30489 + -mem[64] + 100
                        stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                        if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                        _31114 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31114] = 30
                        mem[_31114 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            _31216 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31216 + 68] = mem[idx + _31114 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31216 + 68] = mem[_31216 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _31216 + -mem[64] + 100
                        if _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                        _31919 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31919] = 26
                        mem[_31919 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _31919 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _35281 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35281] = 30
                            mem[_35281 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _35758 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _35758 + 68] = mem[idx + _35281 + 32]
                                idx = idx + 32
                                continue 
                            mem[_35758 + 68] = mem[_35758 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _35758 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _35524 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35524] = 30
                            mem[_35524 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _36005 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _36005 + 68] = mem[idx + _35524 + 32]
                                idx = idx + 32
                                continue 
                            mem[_36005 + 68] = mem[_36005 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _36005 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _35757 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35757] = 30
                        mem[_35757 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        _36272 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _36272 + 68] = mem[idx + _35757 + 32]
                            idx = idx + 32
                            continue 
                        mem[_36272 + 68] = mem[_36272 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _36272 + -mem[64] + 100
                    _28764 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28764] = 26
                    mem[_28764 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    if t >= stor32 / _tTotal:
                        _29078 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29078] = 26
                        mem[_29078 + 32] = 'SafeMath: division by zero'
                        if not s:
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_49a6a335 * msg.value / 10^9:
                            _29965 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29965] = 30
                            mem[_29965 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = this.address
                            mem[32] = 26
                            _30405 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30405] = 30
                            mem[_30405 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = stor26[msg.sender]
                            _31154 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31154] = 30
                            mem[_31154 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            _31991 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31991] = 26
                            mem[_31991 + 32] = 'SafeMath: division by zero'
                        else:
                            if t / s * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != t / s:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _30016 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30016] = 30
                            mem[_30016 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > t / s * sub_49a6a335 * msg.value / 10^9:
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[0] = this.address
                            mem[32] = 26
                            _30482 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30482] = 30
                            mem[_30482 + 32] = 'SafeMath: subtraction overflow'
                            if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                            if (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                            _31211 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31211] = 30
                            mem[_31211 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            _32068 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32068] = 26
                            mem[_32068 + 32] = 'SafeMath: division by zero'
                    else:
                        _29079 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29079] = 26
                        mem[_29079 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_49a6a335 * msg.value / 10^9:
                            _29966 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29966] = 30
                            mem[_29966 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = this.address
                            mem[32] = 26
                            _30408 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30408] = 30
                            mem[_30408 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = stor26[msg.sender]
                            _31155 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31155] = 30
                            mem[_31155 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            _31992 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31992] = 26
                            mem[_31992 + 32] = 'SafeMath: division by zero'
                        else:
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _30017 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30017] = 30
                            mem[_30017 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[0] = this.address
                            mem[32] = 26
                            _30483 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30483] = 30
                            mem[_30483 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                            _31212 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31212] = 30
                            mem[_31212 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            _32069 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32069] = 26
                            mem[_32069 + 32] = 'SafeMath: division by zero'
                else:
                    if 2 * sub_49a6a335 * msg.value / 10^9 / 50 / sub_49a6a335 * msg.value / 10^9 / 50 != 2:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    mem[64] = 352
                    mem[288] = 30
                    mem[320] = 'SafeMath: subtraction overflow'
                    if 2 * sub_49a6a335 * msg.value / 10^9 / 50 > sub_49a6a335 * msg.value / 10^9:
                        revert with 0, 'SafeMath: subtraction overflow'
                    idx = 0
                    s = _tTotal
                    t = stor32
                    while idx < stor30.length:
                        mem[0] = stor30[idx]
                        mem[32] = 26
                        if stor26[stor30[idx]] > t:
                            _28891 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28891] = 26
                            mem[_28891 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _28891 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _29804 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29804] = 30
                                    mem[_29804 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _30133 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30133] = 30
                                    mem[_30133 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _30237 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _30237 + 68] = mem[idx + _30133 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_30237 + 68] = mem[_30237 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _30237 + -mem[64] + 100
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _30858 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30858] = 30
                                    mem[_30858 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _31040 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _31040 + 68] = mem[idx + _30858 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_31040 + 68] = mem[_31040 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _31040 + -mem[64] + 100
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _31667 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31667] = 26
                                    mem[_31667 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _31667 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _34430 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34430] = 30
                                        mem[_34430 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _35000 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _35000 + 68] = mem[idx + _34430 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35000 + 68] = mem[_35000 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35000 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _34750 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34750] = 30
                                        mem[_34750 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _35252 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _35252 + 68] = mem[idx + _34750 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35252 + 68] = mem[_35252 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35252 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _34999 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34999] = 30
                                    mem[_34999 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _35494 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _35494 + 68] = mem[idx + _34999 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35494 + 68] = mem[_35494 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35494 + -mem[64] + 100
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _29833 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29833] = 30
                                mem[_29833 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                    _29907 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _29907 + 68] = mem[idx + _29833 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29907 + 68] = mem[_29907 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _29907 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _30181 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30181] = 30
                                mem[_30181 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _30315 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _30315 + 68] = mem[idx + _30181 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_30315 + 68] = mem[_30315 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _30315 + -mem[64] + 100
                                if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _30955 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30955] = 30
                                mem[_30955 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    _31104 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _31104 + 68] = mem[idx + _30955 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_31104 + 68] = mem[_31104 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _31104 + -mem[64] + 100
                                stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _31763 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31763] = 26
                                mem[_31763 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _31763 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _34749 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34749] = 30
                                    mem[_34749 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _35249 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _35249 + 68] = mem[idx + _34749 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35249 + 68] = mem[_35249 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35249 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _34998 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34998] = 30
                                    mem[_34998 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _35491 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _35491 + 68] = mem[idx + _34998 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35491 + 68] = mem[_35491 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35491 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _35248 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35248] = 30
                                mem[_35248 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35719 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35719 + 68] = mem[idx + _35248 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35719 + 68] = mem[_35719 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35719 + -mem[64] + 100
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _29832 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29832] = 30
                                mem[_29832 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    _29904 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _29904 + 68] = mem[idx + _29832 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29904 + 68] = mem[_29904 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _29904 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _30180 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30180] = 30
                                mem[_30180 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _30312 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _30312 + 68] = mem[idx + _30180 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_30312 + 68] = mem[_30312 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _30312 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _30954 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30954] = 30
                                mem[_30954 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _31101 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _31101 + 68] = mem[idx + _30954 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_31101 + 68] = mem[_31101 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _31101 + -mem[64] + 100
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _31762 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31762] = 26
                                mem[_31762 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _31762 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _34746 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34746] = 30
                                    mem[_34746 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _35245 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _35245 + 68] = mem[idx + _34746 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35245 + 68] = mem[_35245 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35245 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _34997 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34997] = 30
                                    mem[_34997 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _35488 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _35488 + 68] = mem[idx + _34997 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35488 + 68] = mem[_35488 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35488 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _35244 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35244] = 30
                                mem[_35244 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35715 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35715 + 68] = mem[idx + _35244 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35715 + 68] = mem[_35715 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35715 + -mem[64] + 100
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _29868 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29868] = 30
                            mem[_29868 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _29961 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29961 + 68] = mem[idx + _29868 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29961 + 68] = mem[_29961 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _29961 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _30236 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30236] = 30
                            mem[_30236 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _30393 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _30393 + 68] = mem[idx + _30236 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_30393 + 68] = mem[_30393 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _30393 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                            _31039 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31039] = 30
                            mem[_31039 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                _31146 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _31146 + 68] = mem[idx + _31039 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_31146 + 68] = mem[_31146 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _31146 + -mem[64] + 100
                            stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _31830 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31830] = 26
                            mem[_31830 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _31830 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _34996 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34996] = 30
                                mem[_34996 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35485 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35485 + 68] = mem[idx + _34996 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35485 + 68] = mem[_35485 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35485 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _35243 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35243] = 30
                                mem[_35243 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35712 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35712 + 68] = mem[idx + _35243 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35712 + 68] = mem[_35712 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35712 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _35484 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35484] = 30
                            mem[_35484 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _35950 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _35950 + 68] = mem[idx + _35484 + 32]
                                idx = idx + 32
                                continue 
                            mem[_35950 + 68] = mem[_35950 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _35950 + -mem[64] + 100
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 27
                        if stor27[stor30[idx]] <= s:
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            _28929 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28929] = 30
                            mem[_28929 + 32] = 'SafeMath: subtraction overflow'
                            if stor26[stor30[idx]] > t:
                                _29014 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29014 + 68] = mem[idx + _28929 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29014 + 68] = mem[_29014 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _29014 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            _29327 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29327] = 30
                            mem[_29327 + 32] = 'SafeMath: subtraction overflow'
                            if stor27[stor30[idx]] <= s:
                                idx = idx + 1
                                s = s - stor27[stor30[idx]]
                                t = t - stor26[stor30[idx]]
                                continue 
                            _29477 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29477 + 68] = mem[idx + _29327 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29477 + 68] = mem[_29477 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _29477 + -mem[64] + 100
                        _28973 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28973] = 26
                        mem[_28973 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _28973 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_49a6a335 * msg.value / 10^9:
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _29871 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29871] = 30
                                mem[_29871 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _30246 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30246] = 30
                                mem[_30246 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _30400 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _30400 + 68] = mem[idx + _30246 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_30400 + 68] = mem[_30400 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _30400 + -mem[64] + 100
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _31044 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31044] = 30
                                mem[_31044 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _31151 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _31151 + 68] = mem[idx + _31044 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_31151 + 68] = mem[_31151 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _31151 + -mem[64] + 100
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _31836 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31836] = 26
                                mem[_31836 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _31836 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _35011 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35011] = 30
                                    mem[_35011 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _35504 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _35504 + 68] = mem[idx + _35011 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35504 + 68] = mem[_35504 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35504 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _35263 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35263] = 30
                                    mem[_35263 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _35737 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _35737 + 68] = mem[idx + _35263 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35737 + 68] = mem[_35737 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35737 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _35503 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35503] = 30
                                mem[_35503 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35980 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35980 + 68] = mem[idx + _35503 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35980 + 68] = mem[_35980 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35980 + -mem[64] + 100
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _29911 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29911] = 30
                            mem[_29911 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                _30013 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _30013 + 68] = mem[idx + _29911 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_30013 + 68] = mem[_30013 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _30013 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _30321 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30321] = 30
                            mem[_30321 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                _30479 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _30479 + 68] = mem[idx + _30321 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_30479 + 68] = mem[_30479 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _30479 + -mem[64] + 100
                            if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                            _31108 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31108] = 30
                            mem[_31108 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                _31208 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _31208 + 68] = mem[idx + _31108 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_31208 + 68] = mem[_31208 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _31208 + -mem[64] + 100
                            stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _31910 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31910] = 26
                            mem[_31910 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _31910 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _35262 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35262] = 30
                                mem[_35262 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35734 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35734 + 68] = mem[idx + _35262 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35734 + 68] = mem[_35734 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35734 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _35502 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35502] = 30
                                mem[_35502 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35977 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35977 + 68] = mem[idx + _35502 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35977 + 68] = mem[_35977 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35977 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _35733 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35733] = 30
                            mem[_35733 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _36238 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _36238 + 68] = mem[idx + _35733 + 32]
                                idx = idx + 32
                                continue 
                            mem[_36238 + 68] = mem[_36238 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _36238 + -mem[64] + 100
                        if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                            _29910 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29910] = 30
                            mem[_29910 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _30010 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _30010 + 68] = mem[idx + _29910 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_30010 + 68] = mem[_30010 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _30010 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _30320 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30320] = 30
                            mem[_30320 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _30476 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _30476 + 68] = mem[idx + _30320 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_30476 + 68] = mem[_30476 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _30476 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                            _31107 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31107] = 30
                            mem[_31107 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _31205 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _31205 + 68] = mem[idx + _31107 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_31205 + 68] = mem[_31205 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _31205 + -mem[64] + 100
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _31909 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31909] = 26
                            mem[_31909 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _31909 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _35259 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35259] = 30
                                mem[_35259 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35730 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35730 + 68] = mem[idx + _35259 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35730 + 68] = mem[_35730 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35730 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _35501 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35501] = 30
                                mem[_35501 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _35974 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _35974 + 68] = mem[idx + _35501 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35974 + 68] = mem[_35974 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35974 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _35729 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35729] = 30
                            mem[_35729 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _36234 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _36234 + 68] = mem[idx + _35729 + 32]
                                idx = idx + 32
                                continue 
                            mem[_36234 + 68] = mem[_36234 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _36234 + -mem[64] + 100
                        if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _29964 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29964] = 30
                        mem[_29964 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                            _30060 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30060 + 68] = mem[idx + _29964 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30060 + 68] = mem[_30060 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _30060 + -mem[64] + 100
                        mem[0] = this.address
                        mem[32] = 26
                        _30399 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30399] = 30
                        mem[_30399 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                            _30563 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30563 + 68] = mem[idx + _30399 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30563 + 68] = mem[_30563 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _30563 + -mem[64] + 100
                        stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                        if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                        _31150 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31150] = 30
                        mem[_31150 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                            _31288 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31288 + 68] = mem[idx + _31150 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31288 + 68] = mem[_31288 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _31288 + -mem[64] + 100
                        stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                        if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                        emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                        _31987 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31987] = 26
                        mem[_31987 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _31987 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _35500 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35500] = 30
                            mem[_35500 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _35971 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _35971 + 68] = mem[idx + _35500 + 32]
                                idx = idx + 32
                                continue 
                            mem[_35971 + 68] = mem[_35971 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _35971 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _35728 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35728] = 30
                            mem[_35728 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _36231 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _36231 + 68] = mem[idx + _35728 + 32]
                                idx = idx + 32
                                continue 
                            mem[_36231 + 68] = mem[_36231 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _36231 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _35970 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35970] = 30
                        mem[_35970 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        _36493 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _36493 + 68] = mem[idx + _35970 + 32]
                            idx = idx + 32
                            continue 
                        mem[_36493 + 68] = mem[_36493 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _36493 + -mem[64] + 100
                    _28759 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28759] = 26
                    mem[_28759 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    if t >= stor32 / _tTotal:
                        _29071 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29071] = 26
                        mem[_29071 + 32] = 'SafeMath: division by zero'
                        if not s:
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_49a6a335 * msg.value / 10^9:
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _29957 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29957] = 30
                                mem[_29957 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _30385 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30385] = 30
                                mem[_30385 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _31143 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31143] = 30
                                mem[_31143 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _31976 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31976] = 26
                                mem[_31976 + 32] = 'SafeMath: division by zero'
                            else:
                                if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != t / s:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _30005 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30005] = 30
                                mem[_30005 + 32] = 'SafeMath: subtraction overflow'
                                if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _30463 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30463] = 30
                                mem[_30463 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if (-1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (-1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _31198 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31198] = 30
                                mem[_31198 + 32] = 'SafeMath: subtraction overflow'
                                if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor32 += -1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _32051 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32051] = 26
                                mem[_32051 + 32] = 'SafeMath: division by zero'
                        else:
                            if t / s * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != t / s:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _30004 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30004] = 30
                                mem[_30004 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > t / s * sub_49a6a335 * msg.value / 10^9:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _30462 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30462] = 30
                                mem[_30462 + 32] = 'SafeMath: subtraction overflow'
                                if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                                if (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _31197 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31197] = 30
                                mem[_31197 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _32050 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32050] = 26
                                mem[_32050 + 32] = 'SafeMath: division by zero'
                            else:
                                if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != t / s:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _30052 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30052] = 30
                                mem[_30052 + 32] = 'SafeMath: subtraction overflow'
                                if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > t / s * sub_49a6a335 * msg.value / 10^9:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _30545 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30545] = 30
                                mem[_30545 + 32] = 'SafeMath: subtraction overflow'
                                if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                                if (t / s * sub_49a6a335 * msg.value / 10^9) - (t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) - (t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _31272 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31272] = 30
                                mem[_31272 + 32] = 'SafeMath: subtraction overflow'
                                if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor32 += -1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _32151 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32151] = 26
                                mem[_32151 + 32] = 'SafeMath: division by zero'
                    else:
                        _29072 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29072] = 26
                        mem[_29072 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_49a6a335 * msg.value / 10^9:
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _29960 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29960] = 30
                                mem[_29960 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _30392 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30392] = 30
                                mem[_30392 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _31145 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31145] = 30
                                mem[_31145 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _31979 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31979] = 26
                                mem[_31979 + 32] = 'SafeMath: division by zero'
                            else:
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _30007 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30007] = 30
                                mem[_30007 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _30467 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30467] = 30
                                mem[_30467 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _31200 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31200] = 30
                                mem[_31200 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _32053 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32053] = 26
                                mem[_32053 + 32] = 'SafeMath: division by zero'
                        else:
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _30006 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30006] = 30
                                mem[_30006 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _30466 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30466] = 30
                                mem[_30466 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _31199 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31199] = 30
                                mem[_31199 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _32052 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32052] = 26
                                mem[_32052 + 32] = 'SafeMath: division by zero'
                            else:
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _30053 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30053] = 30
                                mem[_30053 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _30549 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30549] = 30
                                mem[_30549 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _31276 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31276] = 30
                                mem[_31276 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _32155 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32155] = 26
                                mem[_32155 + 32] = 'SafeMath: division by zero'
            else:
                mem[0] = this.address
                mem[32] = 26
                if stor26[address(this.address)] > stor32:
                    revert with 0, 32, 42, 0x73416d6f756e74206d757374206265206c657373207468616e20746f74616c207265666c656374696f6e, mem[334 len 22]
                idx = 0
                s = _tTotal
                t = stor32
                while idx < stor30.length:
                    mem[0] = stor30[idx]
                    mem[32] = 26
                    if stor26[stor30[idx]] > t:
                        _28886 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28886] = 26
                        mem[_28886 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _28886 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _29318 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29318] = 26
                        mem[_29318 + 32] = 'SafeMath: division by zero'
                        if not stor32 / _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _29318 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if stor26[address(this.address)] / stor32 / _tTotal < sub_49a6a335 * msg.value / 10^9:
                            revert with 0, 32, 33, 0x774e6f7420656e6f75676820746f6b656e7320696e2074686520636f6e74726163, mem[mem[64] + 101 len 31]
                        if msg.value + sub_536c8c02[msg.sender] < sub_536c8c02[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 20
                        sub_536c8c02[msg.sender] += msg.value
                        if msg.value + ethSent < ethSent:
                            revert with 0, 'SafeMath: addition overflow'
                        ethSent += msg.value
                        _30299 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30299] = 26
                        mem[_30299 + 32] = 'SafeMath: division by zero'
                        if not sub_49a6a335 * msg.value / 10^9 / 50:
                            _31141 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31141] = 30
                            mem[_31141 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > sub_49a6a335 * msg.value / 10^9:
                                _31268 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _31268 + 68] = mem[idx + _31141 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_31268 + 68] = mem[_31268 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _31268 + -mem[64] + 100
                            idx = 0
                            s = _tTotal
                            t = stor32
                            while idx < stor30.length:
                                mem[0] = stor30[idx]
                                mem[32] = 26
                                if stor26[stor30[idx]] > t:
                                    _59564 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_59564] = 26
                                    mem[_59564 + 32] = 'SafeMath: division by zero'
                                    if not _tTotal:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _59564 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_49a6a335 * msg.value / 10^9:
                                        _61404 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_61404] = 30
                                        mem[_61404 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = this.address
                                        mem[32] = 26
                                        _62224 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_62224] = 30
                                        mem[_62224 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor26[address(this.address)]:
                                            _62600 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _62600 + 68] = mem[idx + _62224 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_62600 + 68] = mem[_62600 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _62600 + -mem[64] + 100
                                        if stor26[msg.sender] < stor26[msg.sender]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 26
                                        stor26[address(msg.sender)] = stor26[msg.sender]
                                        _65014 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_65014] = 30
                                        mem[_65014 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor32:
                                            _65717 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _65717 + 68] = mem[idx + _65014 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_65717 + 68] = mem[_65717 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _65717 + -mem[64] + 100
                                        if _tFeeTotal < _tFeeTotal:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        _67865 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_67865] = 26
                                        mem[_67865 + 32] = 'SafeMath: division by zero'
                                        if not sub_1b2cabba:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _67865 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not sub_8a3be0b6:
                                            if ethSent <= 0:
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            presaleTime = timeBetweenRounds + block.timestamp
                                            sub_8a3be0b6++
                                            _73154 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_73154] = 30
                                            mem[_73154 + 32] = 'SafeMath: subtraction overflow'
                                            if sub_be71ce9f <= sub_49a6a335:
                                                sub_49a6a335 -= sub_be71ce9f
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            _74133 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _74133 + 68] = mem[idx + _73154 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_74133 + 68] = mem[_74133 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _74133 + -mem[64] + 100
                                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                            if ethSent <= 0:
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            presaleTime = timeBetweenRounds + block.timestamp
                                            sub_8a3be0b6++
                                            _73647 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_73647] = 30
                                            mem[_73647 + 32] = 'SafeMath: subtraction overflow'
                                            if sub_be71ce9f <= sub_49a6a335:
                                                sub_49a6a335 -= sub_be71ce9f
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            _74654 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _74654 + 68] = mem[idx + _73647 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_74654 + 68] = mem[_74654 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _74654 + -mem[64] + 100
                                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _74132 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_74132] = 30
                                        mem[_74132 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _75237 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _75237 + 68] = mem[idx + _74132 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_75237 + 68] = mem[_75237 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _75237 + -mem[64] + 100
                                    if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _61447 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61447] = 30
                                    mem[_61447 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                        _61609 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _61609 + 68] = mem[idx + _61447 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_61609 + 68] = mem[_61609 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _61609 + -mem[64] + 100
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62401 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62401] = 30
                                    mem[_62401 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                        _62873 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62873 + 68] = mem[idx + _62401 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62873 + 68] = mem[_62873 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62873 + -mem[64] + 100
                                    stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                    if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                    _65380 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65380] = 30
                                    mem[_65380 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _65945 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _65945 + 68] = mem[idx + _65380 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_65945 + 68] = mem[_65945 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _65945 + -mem[64] + 100
                                    if _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    _68155 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68155] = 26
                                    mem[_68155 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _68155 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73646 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73646] = 30
                                        mem[_73646 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74651 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74651 + 68] = mem[idx + _73646 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74651 + 68] = mem[_74651 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74651 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _74131 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_74131] = 30
                                        mem[_74131 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _75234 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _75234 + 68] = mem[idx + _74131 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_75234 + 68] = mem[_75234 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _75234 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74650 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74650] = 30
                                    mem[_74650 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75879 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75879 + 68] = mem[idx + _74650 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75879 + 68] = mem[_75879 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75879 + -mem[64] + 100
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 27
                                if stor27[stor30[idx]] <= s:
                                    require idx < stor30.length
                                    mem[0] = stor30[idx]
                                    mem[32] = 26
                                    _59650 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_59650] = 30
                                    mem[_59650 + 32] = 'SafeMath: subtraction overflow'
                                    if stor26[stor30[idx]] > t:
                                        _59858 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _59858 + 68] = mem[idx + _59650 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_59858 + 68] = mem[_59858 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _59858 + -mem[64] + 100
                                    require idx < stor30.length
                                    mem[0] = stor30[idx]
                                    mem[32] = 27
                                    _60607 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_60607] = 30
                                    mem[_60607 + 32] = 'SafeMath: subtraction overflow'
                                    if stor27[stor30[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor27[stor30[idx]]
                                        t = t - stor26[stor30[idx]]
                                        continue 
                                    _60937 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _60937 + 68] = mem[idx + _60607 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_60937 + 68] = mem[_60937 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _60937 + -mem[64] + 100
                                _59758 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59758] = 26
                                mem[_59758 + 32] = 'SafeMath: division by zero'
                                if not _tTotal:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _59758 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_49a6a335 * msg.value / 10^9:
                                    _61491 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61491] = 30
                                    mem[_61491 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62605 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62605] = 30
                                    mem[_62605 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _63198 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _63198 + 68] = mem[idx + _62605 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_63198 + 68] = mem[_63198 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _63198 + -mem[64] + 100
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _65720 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65720] = 30
                                    mem[_65720 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _66120 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _66120 + 68] = mem[idx + _65720 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_66120 + 68] = mem[_66120 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _66120 + -mem[64] + 100
                                    if _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    _68395 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68395] = 26
                                    mem[_68395 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _68395 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _74140 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_74140] = 30
                                        mem[_74140 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _75243 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _75243 + 68] = mem[idx + _74140 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_75243 + 68] = mem[_75243 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _75243 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _74660 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_74660] = 30
                                        mem[_74660 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _75892 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _75892 + 68] = mem[idx + _74660 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_75892 + 68] = mem[_75892 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _75892 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75242 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75242] = 30
                                    mem[_75242 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76633 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76633 + 68] = mem[idx + _75242 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76633 + 68] = mem[_76633 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76633 + -mem[64] + 100
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61612 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61612] = 30
                                mem[_61612 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    _61864 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61864 + 68] = mem[idx + _61612 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61864 + 68] = mem[_61864 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61864 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62876 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62876] = 30
                                mem[_62876 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _63498 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63498 + 68] = mem[idx + _62876 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63498 + 68] = mem[_63498 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63498 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _65948 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65948] = 30
                                mem[_65948 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66324 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66324 + 68] = mem[idx + _65948 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66324 + 68] = mem[_66324 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66324 + -mem[64] + 100
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68638 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68638] = 26
                                mem[_68638 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68638 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74659 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74659] = 30
                                    mem[_74659 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75889 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75889 + 68] = mem[idx + _74659 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75889 + 68] = mem[_75889 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75889 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75241 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75241] = 30
                                    mem[_75241 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76630 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76630 + 68] = mem[idx + _75241 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76630 + 68] = mem[_76630 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76630 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75888 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75888] = 30
                                mem[_75888 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77516 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77516 + 68] = mem[idx + _75888 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77516 + 68] = mem[_77516 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77516 + -mem[64] + 100
                            _58344 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_58344] = 26
                            mem[_58344 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _58344 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor32 / _tTotal:
                                _60004 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_60004] = 26
                                mem[_60004 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _60004 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_49a6a335 * msg.value / 10^9:
                                    _61719 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61719] = 30
                                    mem[_61719 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63191 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63191] = 30
                                    mem[_63191 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _63841 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _63841 + 68] = mem[idx + _63191 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_63841 + 68] = mem[_63841 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _63841 + -mem[64] + 100
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _66117 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66117] = 30
                                    mem[_66117 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _66609 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _66609 + 68] = mem[idx + _66117 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_66609 + 68] = mem[_66609 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _66609 + -mem[64] + 100
                                    if _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    _68864 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68864] = 26
                                    mem[_68864 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _68864 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _75228 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_75228] = 30
                                        mem[_75228 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _76611 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _76611 + 68] = mem[idx + _75228 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_76611 + 68] = mem[_76611 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _76611 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _75874 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_75874] = 30
                                        mem[_75874 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _77495 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _77495 + 68] = mem[idx + _75874 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_77495 + 68] = mem[_77495 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _77495 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _76610 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_76610] = 30
                                    mem[_76610 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _78389 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _78389 + 68] = mem[idx + _76610 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_78389 + 68] = mem[_78389 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _78389 + -mem[64] + 100
                                if t / s * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != t / s:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61861 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61861] = 30
                                mem[_61861 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > t / s * sub_49a6a335 * msg.value / 10^9:
                                    _62216 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62216 + 68] = mem[idx + _61861 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62216 + 68] = mem[_62216 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62216 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _63491 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63491] = 30
                                mem[_63491 + 32] = 'SafeMath: subtraction overflow'
                                if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _64246 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _64246 + 68] = mem[idx + _63491 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_64246 + 68] = mem[_64246 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _64246 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                                if (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _66319 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66319] = 30
                                mem[_66319 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66941 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66941 + 68] = mem[idx + _66319 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66941 + 68] = mem[_66941 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66941 + -mem[64] + 100
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _69123 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_69123] = 26
                                mem[_69123 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _69123 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75873 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75873] = 30
                                    mem[_75873 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _77492 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _77492 + 68] = mem[idx + _75873 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_77492 + 68] = mem[_77492 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _77492 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _76609 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_76609] = 30
                                    mem[_76609 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _78386 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _78386 + 68] = mem[idx + _76609 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_78386 + 68] = mem[_78386 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _78386 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _77491 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_77491] = 30
                                mem[_77491 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _79240 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _79240 + 68] = mem[idx + _77491 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_79240 + 68] = mem[_79240 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _79240 + -mem[64] + 100
                            _60005 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_60005] = 26
                            mem[_60005 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _60005 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                _61720 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61720] = 30
                                mem[_61720 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _63194 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63194] = 30
                                mem[_63194 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _63844 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63844 + 68] = mem[idx + _63194 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63844 + 68] = mem[_63844 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63844 + -mem[64] + 100
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _66118 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66118] = 30
                                mem[_66118 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66612 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66612 + 68] = mem[idx + _66118 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66612 + 68] = mem[_66612 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66612 + -mem[64] + 100
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68865 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68865] = 26
                                mem[_68865 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68865 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75233 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75233] = 30
                                    mem[_75233 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76616 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76616 + 68] = mem[idx + _75233 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76616 + 68] = mem[_76616 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76616 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75878 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75878] = 30
                                    mem[_75878 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _77502 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _77502 + 68] = mem[idx + _75878 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_77502 + 68] = mem[_77502 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _77502 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _76615 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_76615] = 30
                                mem[_76615 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _78396 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _78396 + 68] = mem[idx + _76615 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_78396 + 68] = mem[_78396 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _78396 + -mem[64] + 100
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61862 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61862] = 30
                            mem[_61862 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _62219 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _62219 + 68] = mem[idx + _61862 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_62219 + 68] = mem[_62219 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _62219 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _63492 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_63492] = 30
                            mem[_63492 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _64249 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _64249 + 68] = mem[idx + _63492 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_64249 + 68] = mem[_64249 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _64249 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                            _66320 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_66320] = 30
                            mem[_66320 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _66944 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66944 + 68] = mem[idx + _66320 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66944 + 68] = mem[_66944 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66944 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            _69124 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_69124] = 26
                            mem[_69124 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _69124 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75877 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75877] = 30
                                mem[_75877 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77499 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77499 + 68] = mem[idx + _75877 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77499 + 68] = mem[_77499 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77499 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _76614 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_76614] = 30
                                mem[_76614 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _78393 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _78393 + 68] = mem[idx + _76614 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_78393 + 68] = mem[_78393 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _78393 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _77498 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_77498] = 30
                            mem[_77498 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _79249 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _79249 + 68] = mem[idx + _77498 + 32]
                                idx = idx + 32
                                continue 
                            mem[_79249 + 68] = mem[_79249 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _79249 + -mem[64] + 100
                        if 2 * sub_49a6a335 * msg.value / 10^9 / 50 / sub_49a6a335 * msg.value / 10^9 / 50 != 2:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _31194 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31194] = 30
                        mem[_31194 + 32] = 'SafeMath: subtraction overflow'
                        if 2 * sub_49a6a335 * msg.value / 10^9 / 50 > sub_49a6a335 * msg.value / 10^9:
                            _31365 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31365 + 68] = mem[idx + _31194 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31365 + 68] = mem[_31365 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _31365 + -mem[64] + 100
                        idx = 0
                        s = _tTotal
                        t = stor32
                        while idx < stor30.length:
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            if stor26[stor30[idx]] > t:
                                _59559 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59559] = 26
                                mem[_59559 + 32] = 'SafeMath: division by zero'
                                if not _tTotal:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _59559 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_49a6a335 * msg.value / 10^9:
                                    if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                        _61403 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_61403] = 30
                                        mem[_61403 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = this.address
                                        mem[32] = 26
                                        _62213 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_62213] = 30
                                        mem[_62213 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor26[address(this.address)]:
                                            _62588 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _62588 + 68] = mem[idx + _62213 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_62588 + 68] = mem[_62588 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _62588 + -mem[64] + 100
                                        if stor26[msg.sender] < stor26[msg.sender]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 26
                                        stor26[address(msg.sender)] = stor26[msg.sender]
                                        _64994 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_64994] = 30
                                        mem[_64994 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor32:
                                            _65704 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _65704 + 68] = mem[idx + _64994 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_65704 + 68] = mem[_65704 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _65704 + -mem[64] + 100
                                        if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                        emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                        _67849 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_67849] = 26
                                        mem[_67849 + 32] = 'SafeMath: division by zero'
                                        if not sub_1b2cabba:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _67849 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not sub_8a3be0b6:
                                            if ethSent <= 0:
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            presaleTime = timeBetweenRounds + block.timestamp
                                            sub_8a3be0b6++
                                            _73129 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_73129] = 30
                                            mem[_73129 + 32] = 'SafeMath: subtraction overflow'
                                            if sub_be71ce9f <= sub_49a6a335:
                                                sub_49a6a335 -= sub_be71ce9f
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            _74111 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _74111 + 68] = mem[idx + _73129 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_74111 + 68] = mem[_74111 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _74111 + -mem[64] + 100
                                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                            if ethSent <= 0:
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            presaleTime = timeBetweenRounds + block.timestamp
                                            sub_8a3be0b6++
                                            _73627 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_73627] = 30
                                            mem[_73627 + 32] = 'SafeMath: subtraction overflow'
                                            if sub_be71ce9f <= sub_49a6a335:
                                                sub_49a6a335 -= sub_be71ce9f
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            _74630 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _74630 + 68] = mem[idx + _73627 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_74630 + 68] = mem[_74630 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _74630 + -mem[64] + 100
                                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _74110 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_74110] = 30
                                        mem[_74110 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _75211 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _75211 + 68] = mem[idx + _74110 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_75211 + 68] = mem[_75211 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _75211 + -mem[64] + 100
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _61444 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61444] = 30
                                    mem[_61444 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                        _61604 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _61604 + 68] = mem[idx + _61444 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_61604 + 68] = mem[_61604 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _61604 + -mem[64] + 100
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62394 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62394] = 30
                                    mem[_62394 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _62860 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62860 + 68] = mem[idx + _62394 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62860 + 68] = mem[_62860 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62860 + -mem[64] + 100
                                    if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                    _65364 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65364] = 30
                                    mem[_65364 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                        _65938 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _65938 + 68] = mem[idx + _65364 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_65938 + 68] = mem[_65938 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _65938 + -mem[64] + 100
                                    stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68144 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68144] = 26
                                    mem[_68144 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _68144 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73626 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73626] = 30
                                        mem[_73626 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74627 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74627 + 68] = mem[idx + _73626 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74627 + 68] = mem[_74627 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74627 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _74109 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_74109] = 30
                                        mem[_74109 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _75208 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _75208 + 68] = mem[idx + _74109 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_75208 + 68] = mem[_75208 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _75208 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74626 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74626] = 30
                                    mem[_74626 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75850 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75850 + 68] = mem[idx + _74626 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75850 + 68] = mem[_75850 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75850 + -mem[64] + 100
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61443 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61443] = 30
                                    mem[_61443 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                        _61601 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _61601 + 68] = mem[idx + _61443 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_61601 + 68] = mem[_61601 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _61601 + -mem[64] + 100
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62393 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62393] = 30
                                    mem[_62393 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                        _62857 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62857 + 68] = mem[idx + _62393 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62857 + 68] = mem[_62857 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62857 + -mem[64] + 100
                                    stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                    if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                    _65363 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65363] = 30
                                    mem[_65363 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _65935 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _65935 + 68] = mem[idx + _65363 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_65935 + 68] = mem[_65935 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _65935 + -mem[64] + 100
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68143 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68143] = 26
                                    mem[_68143 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _68143 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73623 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73623] = 30
                                        mem[_73623 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74623 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74623 + 68] = mem[idx + _73623 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74623 + 68] = mem[_74623 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74623 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _74108 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_74108] = 30
                                        mem[_74108 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _75205 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _75205 + 68] = mem[idx + _74108 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_75205 + 68] = mem[_75205 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _75205 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74622 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74622] = 30
                                    mem[_74622 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75846 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75846 + 68] = mem[idx + _74622 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75846 + 68] = mem[_75846 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75846 + -mem[64] + 100
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61487 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61487] = 30
                                mem[_61487 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    _61715 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61715 + 68] = mem[idx + _61487 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61715 + 68] = mem[_61715 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61715 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62587 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62587] = 30
                                mem[_62587 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _63179 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63179 + 68] = mem[idx + _62587 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63179 + 68] = mem[_63179 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63179 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _65703 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65703] = 30
                                mem[_65703 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    _66109 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66109 + 68] = mem[idx + _65703 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66109 + 68] = mem[_66109 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66109 + -mem[64] + 100
                                stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68381 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68381] = 26
                                mem[_68381 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68381 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74107 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74107] = 30
                                    mem[_74107 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75202 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75202 + 68] = mem[idx + _74107 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75202 + 68] = mem[_75202 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75202 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74621 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74621] = 30
                                    mem[_74621 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75843 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75843 + 68] = mem[idx + _74621 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75843 + 68] = mem[_75843 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75843 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75201 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75201] = 30
                                mem[_75201 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76575 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76575 + 68] = mem[idx + _75201 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76575 + 68] = mem[_76575 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76575 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            if stor27[stor30[idx]] <= s:
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 26
                                _59647 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59647] = 30
                                mem[_59647 + 32] = 'SafeMath: subtraction overflow'
                                if stor26[stor30[idx]] > t:
                                    _59854 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _59854 + 68] = mem[idx + _59647 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59854 + 68] = mem[_59854 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59854 + -mem[64] + 100
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 27
                                _60600 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_60600] = 30
                                mem[_60600 + 32] = 'SafeMath: subtraction overflow'
                                if stor27[stor30[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor27[stor30[idx]]
                                    t = t - stor26[stor30[idx]]
                                    continue 
                                _60929 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _60929 + 68] = mem[idx + _60600 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_60929 + 68] = mem[_60929 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _60929 + -mem[64] + 100
                            _59753 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59753] = 26
                            mem[_59753 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59753 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61490 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61490] = 30
                                    mem[_61490 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62597 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62597] = 30
                                    mem[_62597 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _63186 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _63186 + 68] = mem[idx + _62597 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_63186 + 68] = mem[_63186 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _63186 + -mem[64] + 100
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _65708 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65708] = 30
                                    mem[_65708 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _66114 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _66114 + 68] = mem[idx + _65708 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_66114 + 68] = mem[_66114 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _66114 + -mem[64] + 100
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68387 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68387] = 26
                                    mem[_68387 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _68387 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _74122 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_74122] = 30
                                        mem[_74122 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _75221 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _75221 + 68] = mem[idx + _74122 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_75221 + 68] = mem[_75221 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _75221 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _74641 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_74641] = 30
                                        mem[_74641 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _75868 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _75868 + 68] = mem[idx + _74641 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_75868 + 68] = mem[_75868 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _75868 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75220 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75220] = 30
                                    mem[_75220 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76605 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76605 + 68] = mem[idx + _75220 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76605 + 68] = mem[_76605 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76605 + -mem[64] + 100
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61608 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61608] = 30
                                mem[_61608 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                    _61858 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61858 + 68] = mem[idx + _61608 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61858 + 68] = mem[_61858 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61858 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62866 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62866] = 30
                                mem[_62866 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _63488 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63488 + 68] = mem[idx + _62866 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63488 + 68] = mem[_63488 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63488 + -mem[64] + 100
                                if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _65942 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65942] = 30
                                mem[_65942 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    _66316 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66316 + 68] = mem[idx + _65942 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66316 + 68] = mem[_66316 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66316 + -mem[64] + 100
                                stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68629 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68629] = 26
                                mem[_68629 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68629 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74640 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74640] = 30
                                    mem[_74640 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75865 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75865 + 68] = mem[idx + _74640 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75865 + 68] = mem[_75865 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75865 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75219 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75219] = 30
                                    mem[_75219 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76602 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76602 + 68] = mem[idx + _75219 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76602 + 68] = mem[_76602 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76602 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75864 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75864] = 30
                                mem[_75864 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77482 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77482 + 68] = mem[idx + _75864 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77482 + 68] = mem[_77482 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77482 + -mem[64] + 100
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _61607 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61607] = 30
                                mem[_61607 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    _61855 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61855 + 68] = mem[idx + _61607 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61855 + 68] = mem[_61855 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61855 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62865 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62865] = 30
                                mem[_62865 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _63485 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63485 + 68] = mem[idx + _62865 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63485 + 68] = mem[_63485 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63485 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _65941 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65941] = 30
                                mem[_65941 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66313 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66313 + 68] = mem[idx + _65941 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66313 + 68] = mem[_66313 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66313 + -mem[64] + 100
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68628 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68628] = 26
                                mem[_68628 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68628 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74637 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74637] = 30
                                    mem[_74637 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75861 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75861 + 68] = mem[idx + _74637 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75861 + 68] = mem[_75861 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75861 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75218 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75218] = 30
                                    mem[_75218 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76599 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76599 + 68] = mem[idx + _75218 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76599 + 68] = mem[_76599 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76599 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75860 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75860] = 30
                                mem[_75860 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77478 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77478 + 68] = mem[idx + _75860 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77478 + 68] = mem[_77478 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77478 + -mem[64] + 100
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61718 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61718] = 30
                            mem[_61718 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _61981 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _61981 + 68] = mem[idx + _61718 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_61981 + 68] = mem[_61981 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _61981 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _63185 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_63185] = 30
                            mem[_63185 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _63835 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63835 + 68] = mem[idx + _63185 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63835 + 68] = mem[_63835 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63835 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                            _66113 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_66113] = 30
                            mem[_66113 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                _66605 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66605 + 68] = mem[idx + _66113 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66605 + 68] = mem[_66605 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66605 + -mem[64] + 100
                            stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _68860 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68860] = 26
                            mem[_68860 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68860 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75217 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75217] = 30
                                mem[_75217 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76596 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76596 + 68] = mem[idx + _75217 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76596 + 68] = mem[_76596 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76596 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75859 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75859] = 30
                                mem[_75859 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77475 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77475 + 68] = mem[idx + _75859 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77475 + 68] = mem[_77475 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77475 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _76595 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_76595] = 30
                            mem[_76595 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _78366 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _78366 + 68] = mem[idx + _76595 + 32]
                                idx = idx + 32
                                continue 
                            mem[_78366 + 68] = mem[_78366 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _78366 + -mem[64] + 100
                        _58339 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_58339] = 26
                        mem[_58339 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _58339 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor32 / _tTotal:
                            _59997 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59997] = 26
                            mem[_59997 + 32] = 'SafeMath: division by zero'
                            if not s:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59997 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61711 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61711] = 30
                                    mem[_61711 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63171 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63171] = 30
                                    mem[_63171 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _63818 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _63818 + 68] = mem[idx + _63171 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_63818 + 68] = mem[_63818 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _63818 + -mem[64] + 100
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _66106 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66106] = 30
                                    mem[_66106 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _66590 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _66590 + 68] = mem[idx + _66106 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_66590 + 68] = mem[_66590 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _66590 + -mem[64] + 100
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68849 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68849] = 26
                                    mem[_68849 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _68849 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _75191 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_75191] = 30
                                        mem[_75191 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _76563 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _76563 + 68] = mem[idx + _75191 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_76563 + 68] = mem[_76563 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _76563 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _75833 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_75833] = 30
                                        mem[_75833 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _77438 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _77438 + 68] = mem[idx + _75833 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_77438 + 68] = mem[_77438 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _77438 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _76562 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_76562] = 30
                                    mem[_76562 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _78331 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _78331 + 68] = mem[idx + _76562 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_78331 + 68] = mem[_78331 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _78331 + -mem[64] + 100
                                if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != t / s:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61850 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61850] = 30
                                mem[_61850 + 32] = 'SafeMath: subtraction overflow'
                                if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                    _62198 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62198 + 68] = mem[idx + _61850 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62198 + 68] = mem[_62198 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62198 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _63472 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63472] = 30
                                mem[_63472 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _64220 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _64220 + 68] = mem[idx + _63472 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_64220 + 68] = mem[_64220 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _64220 + -mem[64] + 100
                                if (-1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (-1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _66306 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66306] = 30
                                mem[_66306 + 32] = 'SafeMath: subtraction overflow'
                                if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    _66920 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66920 + 68] = mem[idx + _66306 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66920 + 68] = mem[_66920 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66920 + -mem[64] + 100
                                stor32 += -1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _69106 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_69106] = 26
                                mem[_69106 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _69106 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75832 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75832] = 30
                                    mem[_75832 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _77435 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _77435 + 68] = mem[idx + _75832 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_77435 + 68] = mem[_77435 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _77435 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _76561 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_76561] = 30
                                    mem[_76561 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _78328 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _78328 + 68] = mem[idx + _76561 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_78328 + 68] = mem[_78328 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _78328 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _77434 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_77434] = 30
                                mem[_77434 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _79186 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _79186 + 68] = mem[idx + _77434 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_79186 + 68] = mem[_79186 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _79186 + -mem[64] + 100
                            if t / s * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != t / s:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _61849 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61849] = 30
                                mem[_61849 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > t / s * sub_49a6a335 * msg.value / 10^9:
                                    _62195 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62195 + 68] = mem[idx + _61849 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62195 + 68] = mem[_62195 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62195 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _63471 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63471] = 30
                                mem[_63471 + 32] = 'SafeMath: subtraction overflow'
                                if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _64217 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _64217 + 68] = mem[idx + _63471 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_64217 + 68] = mem[_64217 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _64217 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                                if (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _66305 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66305] = 30
                                mem[_66305 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66917 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66917 + 68] = mem[idx + _66305 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66917 + 68] = mem[_66917 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66917 + -mem[64] + 100
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _69105 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_69105] = 26
                                mem[_69105 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _69105 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75829 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75829] = 30
                                    mem[_75829 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _77431 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _77431 + 68] = mem[idx + _75829 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_77431 + 68] = mem[_77431 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _77431 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _76560 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_76560] = 30
                                    mem[_76560 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _78325 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _78325 + 68] = mem[idx + _76560 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_78325 + 68] = mem[_78325 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _78325 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _77430 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_77430] = 30
                                mem[_77430 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _79182 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _79182 + 68] = mem[idx + _77430 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_79182 + 68] = mem[_79182 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _79182 + -mem[64] + 100
                            if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != t / s:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61973 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61973] = 30
                            mem[_61973 + 32] = 'SafeMath: subtraction overflow'
                            if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > t / s * sub_49a6a335 * msg.value / 10^9:
                                _62385 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _62385 + 68] = mem[idx + _61973 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_62385 + 68] = mem[_62385 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _62385 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _63817 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_63817] = 30
                            mem[_63817 + 32] = 'SafeMath: subtraction overflow'
                            if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _64587 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _64587 + 68] = mem[idx + _63817 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_64587 + 68] = mem[_64587 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _64587 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                            if (t / s * sub_49a6a335 * msg.value / 10^9) - (t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) - (t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                            _66589 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_66589] = 30
                            mem[_66589 + 32] = 'SafeMath: subtraction overflow'
                            if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                _67205 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _67205 + 68] = mem[idx + _66589 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_67205 + 68] = mem[_67205 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _67205 + -mem[64] + 100
                            stor32 += -1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _69429 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_69429] = 26
                            mem[_69429 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _69429 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _76559 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_76559] = 30
                                mem[_76559 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _78322 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _78322 + 68] = mem[idx + _76559 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_78322 + 68] = mem[_78322 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _78322 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _77429 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_77429] = 30
                                mem[_77429 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _79179 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _79179 + 68] = mem[idx + _77429 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_79179 + 68] = mem[_79179 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _79179 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _78321 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_78321] = 30
                            mem[_78321 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _79989 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _79989 + 68] = mem[idx + _78321 + 32]
                                idx = idx + 32
                                continue 
                            mem[_79989 + 68] = mem[_79989 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _79989 + -mem[64] + 100
                        _59998 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_59998] = 26
                        mem[_59998 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _59998 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_49a6a335 * msg.value / 10^9:
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _61714 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61714] = 30
                                mem[_61714 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _63178 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63178] = 30
                                mem[_63178 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _63822 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63822 + 68] = mem[idx + _63178 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63822 + 68] = mem[_63822 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63822 + -mem[64] + 100
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _66108 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66108] = 30
                                mem[_66108 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66594 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66594 + 68] = mem[idx + _66108 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66594 + 68] = mem[_66594 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66594 + -mem[64] + 100
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68852 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68852] = 26
                                mem[_68852 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68852 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75200 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75200] = 30
                                    mem[_75200 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76572 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76572 + 68] = mem[idx + _75200 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76572 + 68] = mem[_76572 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76572 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75842 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75842] = 30
                                    mem[_75842 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _77450 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _77450 + 68] = mem[idx + _75842 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_77450 + 68] = mem[_77450 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _77450 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _76571 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_76571] = 30
                                mem[_76571 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _78345 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _78345 + 68] = mem[idx + _76571 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_78345 + 68] = mem[_78345 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _78345 + -mem[64] + 100
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61852 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61852] = 30
                            mem[_61852 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                _62204 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _62204 + 68] = mem[idx + _61852 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_62204 + 68] = mem[_62204 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _62204 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _63476 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_63476] = 30
                            mem[_63476 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                _64226 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _64226 + 68] = mem[idx + _63476 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_64226 + 68] = mem[_64226 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _64226 + -mem[64] + 100
                            if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                            _66308 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_66308] = 30
                            mem[_66308 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                _66926 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66926 + 68] = mem[idx + _66308 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66926 + 68] = mem[_66926 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66926 + -mem[64] + 100
                            stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _69108 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_69108] = 26
                            mem[_69108 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _69108 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75841 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75841] = 30
                                mem[_75841 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77447 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77447 + 68] = mem[idx + _75841 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77447 + 68] = mem[_77447 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77447 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _76570 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_76570] = 30
                                mem[_76570 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _78342 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _78342 + 68] = mem[idx + _76570 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_78342 + 68] = mem[_78342 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _78342 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _77446 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_77446] = 30
                            mem[_77446 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _79202 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _79202 + 68] = mem[idx + _77446 + 32]
                                idx = idx + 32
                                continue 
                            mem[_79202 + 68] = mem[_79202 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _79202 + -mem[64] + 100
                        if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                            _61851 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61851] = 30
                            mem[_61851 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _62201 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _62201 + 68] = mem[idx + _61851 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_62201 + 68] = mem[_62201 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _62201 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _63475 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_63475] = 30
                            mem[_63475 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _64223 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _64223 + 68] = mem[idx + _63475 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_64223 + 68] = mem[_64223 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _64223 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                            _66307 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_66307] = 30
                            mem[_66307 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _66923 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66923 + 68] = mem[idx + _66307 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66923 + 68] = mem[_66923 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66923 + -mem[64] + 100
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _69107 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_69107] = 26
                            mem[_69107 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _69107 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75838 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75838] = 30
                                mem[_75838 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77443 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77443 + 68] = mem[idx + _75838 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77443 + 68] = mem[_77443 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77443 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _76569 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_76569] = 30
                                mem[_76569 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _78339 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _78339 + 68] = mem[idx + _76569 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_78339 + 68] = mem[_78339 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _78339 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _77442 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_77442] = 30
                            mem[_77442 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _79198 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _79198 + 68] = mem[idx + _77442 + 32]
                                idx = idx + 32
                                continue 
                            mem[_79198 + 68] = mem[_79198 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _79198 + -mem[64] + 100
                        if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _61974 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61974] = 30
                        mem[_61974 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                            _62388 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _62388 + 68] = mem[idx + _61974 + 32]
                                idx = idx + 32
                                continue 
                            mem[_62388 + 68] = mem[_62388 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _62388 + -mem[64] + 100
                        mem[0] = this.address
                        mem[32] = 26
                        _63821 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_63821] = 30
                        mem[_63821 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                            _64593 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _64593 + 68] = mem[idx + _63821 + 32]
                                idx = idx + 32
                                continue 
                            mem[_64593 + 68] = mem[_64593 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _64593 + -mem[64] + 100
                        stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                        if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                        _66593 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_66593] = 30
                        mem[_66593 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                            _67209 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _67209 + 68] = mem[idx + _66593 + 32]
                                idx = idx + 32
                                continue 
                            mem[_67209 + 68] = mem[_67209 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _67209 + -mem[64] + 100
                        stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                        if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                        emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                        _69433 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_69433] = 26
                        mem[_69433 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _69433 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _76568 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_76568] = 30
                            mem[_76568 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _78336 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _78336 + 68] = mem[idx + _76568 + 32]
                                idx = idx + 32
                                continue 
                            mem[_78336 + 68] = mem[_78336 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _78336 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _77441 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_77441] = 30
                            mem[_77441 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _79195 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _79195 + 68] = mem[idx + _77441 + 32]
                                idx = idx + 32
                                continue 
                            mem[_79195 + 68] = mem[_79195 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _79195 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _78335 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_78335] = 30
                        mem[_78335 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        _80009 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _80009 + 68] = mem[idx + _78335 + 32]
                            idx = idx + 32
                            continue 
                        mem[_80009 + 68] = mem[_80009 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _80009 + -mem[64] + 100
                    require idx < stor30.length
                    mem[0] = stor30[idx]
                    mem[32] = 27
                    if stor27[stor30[idx]] <= s:
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 26
                        _28926 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28926] = 30
                        mem[_28926 + 32] = 'SafeMath: subtraction overflow'
                        if stor26[stor30[idx]] > t:
                            _29010 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29010 + 68] = mem[idx + _28926 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29010 + 68] = mem[_29010 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _29010 + -mem[64] + 100
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 27
                        _29320 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29320] = 30
                        mem[_29320 + 32] = 'SafeMath: subtraction overflow'
                        if stor27[stor30[idx]] <= s:
                            idx = idx + 1
                            s = s - stor27[stor30[idx]]
                            t = t - stor26[stor30[idx]]
                            continue 
                        _29468 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29468 + 68] = mem[idx + _29320 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29468 + 68] = mem[_29468 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _29468 + -mem[64] + 100
                    _28968 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28968] = 26
                    mem[_28968 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _28968 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    _29471 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29471] = 26
                    mem[_29471 + 32] = 'SafeMath: division by zero'
                    if not stor32 / _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _29471 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if stor26[address(this.address)] / stor32 / _tTotal < sub_49a6a335 * msg.value / 10^9:
                        revert with 0, 32, 33, 0x774e6f7420656e6f75676820746f6b656e7320696e2074686520636f6e74726163, mem[mem[64] + 101 len 31]
                    if msg.value + sub_536c8c02[msg.sender] < sub_536c8c02[msg.sender]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = msg.sender
                    mem[32] = 20
                    sub_536c8c02[msg.sender] += msg.value
                    if msg.value + ethSent < ethSent:
                        revert with 0, 'SafeMath: addition overflow'
                    ethSent += msg.value
                    _30459 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30459] = 26
                    mem[_30459 + 32] = 'SafeMath: division by zero'
                    if not sub_49a6a335 * msg.value / 10^9 / 50:
                        _31271 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31271] = 30
                        mem[_31271 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > sub_49a6a335 * msg.value / 10^9:
                            _31455 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31455 + 68] = mem[idx + _31271 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31455 + 68] = mem[_31455 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _31455 + -mem[64] + 100
                        idx = 0
                        s = _tTotal
                        t = stor32
                        while idx < stor30.length:
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            if stor26[stor30[idx]] > t:
                                _59574 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59574] = 26
                                mem[_59574 + 32] = 'SafeMath: division by zero'
                                if not _tTotal:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _59574 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_49a6a335 * msg.value / 10^9:
                                    _61408 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61408] = 30
                                    mem[_61408 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62255 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62255] = 30
                                    mem[_62255 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _62623 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62623 + 68] = mem[idx + _62255 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62623 + 68] = mem[_62623 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62623 + -mem[64] + 100
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _65056 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65056] = 30
                                    mem[_65056 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _65753 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _65753 + 68] = mem[idx + _65056 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_65753 + 68] = mem[_65753 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _65753 + -mem[64] + 100
                                    if _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    _67902 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_67902] = 26
                                    mem[_67902 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _67902 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73212 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73212] = 30
                                        mem[_73212 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74185 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74185 + 68] = mem[idx + _73212 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74185 + 68] = mem[_74185 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74185 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73700 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73700] = 30
                                        mem[_73700 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74710 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74710 + 68] = mem[idx + _73700 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74710 + 68] = mem[_74710 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74710 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74184 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74184] = 30
                                    mem[_74184 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75300 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75300 + 68] = mem[idx + _74184 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75300 + 68] = mem[_75300 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75300 + -mem[64] + 100
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61452 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61452] = 30
                                mem[_61452 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    _61625 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61625 + 68] = mem[idx + _61452 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61625 + 68] = mem[_61625 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61625 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62421 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62421] = 30
                                mem[_62421 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _62905 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62905 + 68] = mem[idx + _62421 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62905 + 68] = mem[_62905 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62905 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _65419 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65419] = 30
                                mem[_65419 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _65969 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _65969 + 68] = mem[idx + _65419 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_65969 + 68] = mem[_65969 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _65969 + -mem[64] + 100
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68186 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68186] = 26
                                mem[_68186 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68186 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73699 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73699] = 30
                                    mem[_73699 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74707 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74707 + 68] = mem[idx + _73699 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74707 + 68] = mem[_74707 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74707 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74183 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74183] = 30
                                    mem[_74183 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75297 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75297 + 68] = mem[idx + _74183 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75297 + 68] = mem[_75297 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75297 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74706 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74706] = 30
                                mem[_74706 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _75949 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75949 + 68] = mem[idx + _74706 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75949 + 68] = mem[_75949 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75949 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            if stor27[stor30[idx]] <= s:
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 26
                                _59656 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59656] = 30
                                mem[_59656 + 32] = 'SafeMath: subtraction overflow'
                                if stor26[stor30[idx]] > t:
                                    _59866 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _59866 + 68] = mem[idx + _59656 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59866 + 68] = mem[_59866 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59866 + -mem[64] + 100
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 27
                                _60621 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_60621] = 30
                                mem[_60621 + 32] = 'SafeMath: subtraction overflow'
                                if stor27[stor30[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor27[stor30[idx]]
                                    t = t - stor26[stor30[idx]]
                                    continue 
                                _60953 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _60953 + 68] = mem[idx + _60621 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_60953 + 68] = mem[_60953 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _60953 + -mem[64] + 100
                            _59768 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59768] = 26
                            mem[_59768 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59768 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                _61496 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61496] = 30
                                mem[_61496 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _62628 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62628] = 30
                                mem[_62628 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _63234 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63234 + 68] = mem[idx + _62628 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63234 + 68] = mem[_63234 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63234 + -mem[64] + 100
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _65756 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65756] = 30
                                mem[_65756 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66138 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66138 + 68] = mem[idx + _65756 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66138 + 68] = mem[_66138 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66138 + -mem[64] + 100
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68420 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68420] = 26
                                mem[_68420 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68420 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74192 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74192] = 30
                                    mem[_74192 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75306 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75306 + 68] = mem[idx + _74192 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75306 + 68] = mem[_75306 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75306 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74716 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74716] = 30
                                    mem[_74716 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75962 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75962 + 68] = mem[idx + _74716 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75962 + 68] = mem[_75962 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75962 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75305 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75305] = 30
                                mem[_75305 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76713 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76713 + 68] = mem[idx + _75305 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76713 + 68] = mem[_76713 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76713 + -mem[64] + 100
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61628 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61628] = 30
                            mem[_61628 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _61882 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _61882 + 68] = mem[idx + _61628 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_61882 + 68] = mem[_61882 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _61882 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _62908 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_62908] = 30
                            mem[_62908 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _63530 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63530 + 68] = mem[idx + _62908 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63530 + 68] = mem[_63530 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63530 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                            _65972 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_65972] = 30
                            mem[_65972 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _66346 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66346 + 68] = mem[idx + _65972 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66346 + 68] = mem[_66346 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66346 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            _68664 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68664] = 26
                            mem[_68664 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68664 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74715 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74715] = 30
                                mem[_74715 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _75959 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75959 + 68] = mem[idx + _74715 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75959 + 68] = mem[_75959 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75959 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75304 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75304] = 30
                                mem[_75304 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76710 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76710 + 68] = mem[idx + _75304 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76710 + 68] = mem[_76710 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76710 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75958 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75958] = 30
                            mem[_75958 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _77612 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77612 + 68] = mem[idx + _75958 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77612 + 68] = mem[_77612 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77612 + -mem[64] + 100
                        _58362 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_58362] = 26
                        mem[_58362 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _58362 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor32 / _tTotal:
                            _60018 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_60018] = 26
                            mem[_60018 + 32] = 'SafeMath: division by zero'
                            if not s:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _60018 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                _61731 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61731] = 30
                                mem[_61731 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _63227 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63227] = 30
                                mem[_63227 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _63879 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63879 + 68] = mem[idx + _63227 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63879 + 68] = mem[_63879 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63879 + -mem[64] + 100
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _66135 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66135] = 30
                                mem[_66135 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66641 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66641 + 68] = mem[idx + _66135 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66641 + 68] = mem[_66641 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66641 + -mem[64] + 100
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68889 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68889] = 26
                                mem[_68889 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68889 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75291 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75291] = 30
                                    mem[_75291 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76691 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76691 + 68] = mem[idx + _75291 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76691 + 68] = mem[_76691 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76691 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75944 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75944] = 30
                                    mem[_75944 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _77591 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _77591 + 68] = mem[idx + _75944 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_77591 + 68] = mem[_77591 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _77591 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _76690 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_76690] = 30
                                mem[_76690 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _78485 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _78485 + 68] = mem[idx + _76690 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_78485 + 68] = mem[_78485 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _78485 + -mem[64] + 100
                            if t / s * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != t / s:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61879 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61879] = 30
                            mem[_61879 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > t / s * sub_49a6a335 * msg.value / 10^9:
                                _62247 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _62247 + 68] = mem[idx + _61879 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_62247 + 68] = mem[_62247 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _62247 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _63523 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_63523] = 30
                            mem[_63523 + 32] = 'SafeMath: subtraction overflow'
                            if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _64290 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _64290 + 68] = mem[idx + _63523 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_64290 + 68] = mem[_64290 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _64290 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                            if (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                            _66341 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_66341] = 30
                            mem[_66341 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _66977 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66977 + 68] = mem[idx + _66341 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66977 + 68] = mem[_66977 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66977 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            _69151 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_69151] = 26
                            mem[_69151 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _69151 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75943 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75943] = 30
                                mem[_75943 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77588 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77588 + 68] = mem[idx + _75943 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77588 + 68] = mem[_77588 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77588 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _76689 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_76689] = 30
                                mem[_76689 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _78482 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _78482 + 68] = mem[idx + _76689 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_78482 + 68] = mem[_78482 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _78482 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _77587 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_77587] = 30
                            mem[_77587 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _79331 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _79331 + 68] = mem[idx + _77587 + 32]
                                idx = idx + 32
                                continue 
                            mem[_79331 + 68] = mem[_79331 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _79331 + -mem[64] + 100
                        _60019 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_60019] = 26
                        mem[_60019 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _60019 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_49a6a335 * msg.value / 10^9:
                            _61732 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61732] = 30
                            mem[_61732 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = this.address
                            mem[32] = 26
                            _63230 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_63230] = 30
                            mem[_63230 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                _63882 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63882 + 68] = mem[idx + _63230 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63882 + 68] = mem[_63882 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63882 + -mem[64] + 100
                            if stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = stor26[msg.sender]
                            _66136 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_66136] = 30
                            mem[_66136 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _66644 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66644 + 68] = mem[idx + _66136 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66644 + 68] = mem[_66644 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66644 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            _68890 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68890] = 26
                            mem[_68890 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68890 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75296 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75296] = 30
                                mem[_75296 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76696 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76696 + 68] = mem[idx + _75296 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76696 + 68] = mem[_76696 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76696 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75948 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75948] = 30
                                mem[_75948 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77598 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77598 + 68] = mem[idx + _75948 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77598 + 68] = mem[_77598 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77598 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _76695 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_76695] = 30
                            mem[_76695 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _78492 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _78492 + 68] = mem[idx + _76695 + 32]
                                idx = idx + 32
                                continue 
                            mem[_78492 + 68] = mem[_78492 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _78492 + -mem[64] + 100
                        if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _61880 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61880] = 30
                        mem[_61880 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                            _62250 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _62250 + 68] = mem[idx + _61880 + 32]
                                idx = idx + 32
                                continue 
                            mem[_62250 + 68] = mem[_62250 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _62250 + -mem[64] + 100
                        mem[0] = this.address
                        mem[32] = 26
                        _63524 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_63524] = 30
                        mem[_63524 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                            _64293 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _64293 + 68] = mem[idx + _63524 + 32]
                                idx = idx + 32
                                continue 
                            mem[_64293 + 68] = mem[_64293 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _64293 + -mem[64] + 100
                        stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                        if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                        _66342 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_66342] = 30
                        mem[_66342 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            _66980 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _66980 + 68] = mem[idx + _66342 + 32]
                                idx = idx + 32
                                continue 
                            mem[_66980 + 68] = mem[_66980 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _66980 + -mem[64] + 100
                        if _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                        _69152 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_69152] = 26
                        mem[_69152 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _69152 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75947 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75947] = 30
                            mem[_75947 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _77595 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77595 + 68] = mem[idx + _75947 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77595 + 68] = mem[_77595 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77595 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _76694 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_76694] = 30
                            mem[_76694 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _78489 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _78489 + 68] = mem[idx + _76694 + 32]
                                idx = idx + 32
                                continue 
                            mem[_78489 + 68] = mem[_78489 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _78489 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _77594 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_77594] = 30
                        mem[_77594 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        _79340 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _79340 + 68] = mem[idx + _77594 + 32]
                            idx = idx + 32
                            continue 
                        mem[_79340 + 68] = mem[_79340 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _79340 + -mem[64] + 100
                    if 2 * sub_49a6a335 * msg.value / 10^9 / 50 / sub_49a6a335 * msg.value / 10^9 / 50 != 2:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _31368 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31368] = 30
                    mem[_31368 + 32] = 'SafeMath: subtraction overflow'
                    if 2 * sub_49a6a335 * msg.value / 10^9 / 50 > sub_49a6a335 * msg.value / 10^9:
                        _31545 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _31545 + 68] = mem[idx + _31368 + 32]
                            idx = idx + 32
                            continue 
                        mem[_31545 + 68] = mem[_31545 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _31545 + -mem[64] + 100
                    idx = 0
                    s = _tTotal
                    t = stor32
                    while idx < stor30.length:
                        mem[0] = stor30[idx]
                        mem[32] = 26
                        if stor26[stor30[idx]] > t:
                            _59569 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59569] = 26
                            mem[_59569 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59569 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61407 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61407] = 30
                                    mem[_61407 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62244 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62244] = 30
                                    mem[_62244 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _62611 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62611 + 68] = mem[idx + _62244 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62611 + 68] = mem[_62611 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62611 + -mem[64] + 100
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _65036 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65036] = 30
                                    mem[_65036 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _65740 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _65740 + 68] = mem[idx + _65036 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_65740 + 68] = mem[_65740 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _65740 + -mem[64] + 100
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _67886 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_67886] = 26
                                    mem[_67886 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _67886 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73187 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73187] = 30
                                        mem[_73187 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74163 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74163 + 68] = mem[idx + _73187 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74163 + 68] = mem[_74163 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74163 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73680 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73680] = 30
                                        mem[_73680 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74686 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74686 + 68] = mem[idx + _73680 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74686 + 68] = mem[_74686 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74686 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74162 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74162] = 30
                                    mem[_74162 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75274 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75274 + 68] = mem[idx + _74162 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75274 + 68] = mem[_75274 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75274 + -mem[64] + 100
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61449 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61449] = 30
                                mem[_61449 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                    _61620 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61620 + 68] = mem[idx + _61449 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61620 + 68] = mem[_61620 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61620 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62414 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62414] = 30
                                mem[_62414 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _62892 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62892 + 68] = mem[idx + _62414 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62892 + 68] = mem[_62892 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62892 + -mem[64] + 100
                                if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _65403 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65403] = 30
                                mem[_65403 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    _65962 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _65962 + 68] = mem[idx + _65403 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_65962 + 68] = mem[_65962 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _65962 + -mem[64] + 100
                                stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68175 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68175] = 26
                                mem[_68175 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68175 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73679 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73679] = 30
                                    mem[_73679 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74683 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74683 + 68] = mem[idx + _73679 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74683 + 68] = mem[_74683 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74683 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74161 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74161] = 30
                                    mem[_74161 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75271 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75271 + 68] = mem[idx + _74161 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75271 + 68] = mem[_75271 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75271 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74682 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74682] = 30
                                mem[_74682 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _75920 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75920 + 68] = mem[idx + _74682 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75920 + 68] = mem[_75920 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75920 + -mem[64] + 100
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _61448 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61448] = 30
                                mem[_61448 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    _61617 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61617 + 68] = mem[idx + _61448 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61617 + 68] = mem[_61617 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61617 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62413 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62413] = 30
                                mem[_62413 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _62889 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62889 + 68] = mem[idx + _62413 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62889 + 68] = mem[_62889 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62889 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _65402 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65402] = 30
                                mem[_65402 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _65959 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _65959 + 68] = mem[idx + _65402 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_65959 + 68] = mem[_65959 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _65959 + -mem[64] + 100
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68174 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68174] = 26
                                mem[_68174 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68174 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73676 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73676] = 30
                                    mem[_73676 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74679 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74679 + 68] = mem[idx + _73676 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74679 + 68] = mem[_74679 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74679 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74160 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74160] = 30
                                    mem[_74160 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75268 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75268 + 68] = mem[idx + _74160 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75268 + 68] = mem[_75268 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75268 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74678 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74678] = 30
                                mem[_74678 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _75916 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75916 + 68] = mem[idx + _74678 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75916 + 68] = mem[_75916 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75916 + -mem[64] + 100
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61492 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61492] = 30
                            mem[_61492 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _61727 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _61727 + 68] = mem[idx + _61492 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_61727 + 68] = mem[_61727 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _61727 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _62610 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_62610] = 30
                            mem[_62610 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _63215 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63215 + 68] = mem[idx + _62610 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63215 + 68] = mem[_63215 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63215 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                            _65739 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_65739] = 30
                            mem[_65739 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                _66127 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66127 + 68] = mem[idx + _65739 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66127 + 68] = mem[_66127 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66127 + -mem[64] + 100
                            stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _68406 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68406] = 26
                            mem[_68406 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68406 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74159 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74159] = 30
                                mem[_74159 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _75265 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75265 + 68] = mem[idx + _74159 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75265 + 68] = mem[_75265 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75265 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74677 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74677] = 30
                                mem[_74677 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _75913 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75913 + 68] = mem[idx + _74677 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75913 + 68] = mem[_75913 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75913 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75264 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75264] = 30
                            mem[_75264 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _76655 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _76655 + 68] = mem[idx + _75264 + 32]
                                idx = idx + 32
                                continue 
                            mem[_76655 + 68] = mem[_76655 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _76655 + -mem[64] + 100
                        require idx < stor30.length
                        mem[0] = stor30[idx]
                        mem[32] = 27
                        if stor27[stor30[idx]] <= s:
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            _59653 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59653] = 30
                            mem[_59653 + 32] = 'SafeMath: subtraction overflow'
                            if stor26[stor30[idx]] > t:
                                _59862 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _59862 + 68] = mem[idx + _59653 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_59862 + 68] = mem[_59862 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _59862 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            _60614 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_60614] = 30
                            mem[_60614 + 32] = 'SafeMath: subtraction overflow'
                            if stor27[stor30[idx]] <= s:
                                idx = idx + 1
                                s = s - stor27[stor30[idx]]
                                t = t - stor26[stor30[idx]]
                                continue 
                            _60945 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _60945 + 68] = mem[idx + _60614 + 32]
                                idx = idx + 32
                                continue 
                            mem[_60945 + 68] = mem[_60945 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _60945 + -mem[64] + 100
                        _59763 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_59763] = 26
                        mem[_59763 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _59763 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_49a6a335 * msg.value / 10^9:
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _61495 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61495] = 30
                                mem[_61495 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _62620 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62620] = 30
                                mem[_62620 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _63222 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63222 + 68] = mem[idx + _62620 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63222 + 68] = mem[_63222 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63222 + -mem[64] + 100
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _65744 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65744] = 30
                                mem[_65744 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66132 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66132 + 68] = mem[idx + _65744 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66132 + 68] = mem[_66132 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66132 + -mem[64] + 100
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68412 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68412] = 26
                                mem[_68412 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68412 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74174 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74174] = 30
                                    mem[_74174 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75284 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75284 + 68] = mem[idx + _74174 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75284 + 68] = mem[_75284 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75284 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74697 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74697] = 30
                                    mem[_74697 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75938 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75938 + 68] = mem[idx + _74697 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75938 + 68] = mem[_75938 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75938 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75283 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75283] = 30
                                mem[_75283 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76685 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76685 + 68] = mem[idx + _75283 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76685 + 68] = mem[_76685 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76685 + -mem[64] + 100
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61624 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61624] = 30
                            mem[_61624 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                _61876 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _61876 + 68] = mem[idx + _61624 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_61876 + 68] = mem[_61876 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _61876 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _62898 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_62898] = 30
                            mem[_62898 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                _63520 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63520 + 68] = mem[idx + _62898 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63520 + 68] = mem[_63520 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63520 + -mem[64] + 100
                            if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                            _65966 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_65966] = 30
                            mem[_65966 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                _66338 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66338 + 68] = mem[idx + _65966 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66338 + 68] = mem[_66338 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66338 + -mem[64] + 100
                            stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _68655 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68655] = 26
                            mem[_68655 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68655 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74696 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74696] = 30
                                mem[_74696 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _75935 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75935 + 68] = mem[idx + _74696 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75935 + 68] = mem[_75935 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75935 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75282 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75282] = 30
                                mem[_75282 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76682 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76682 + 68] = mem[idx + _75282 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76682 + 68] = mem[_76682 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76682 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75934 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75934] = 30
                            mem[_75934 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _77578 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77578 + 68] = mem[idx + _75934 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77578 + 68] = mem[_77578 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77578 + -mem[64] + 100
                        if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                            _61623 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61623] = 30
                            mem[_61623 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _61873 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _61873 + 68] = mem[idx + _61623 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_61873 + 68] = mem[_61873 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _61873 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _62897 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_62897] = 30
                            mem[_62897 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _63517 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63517 + 68] = mem[idx + _62897 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63517 + 68] = mem[_63517 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63517 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                            _65965 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_65965] = 30
                            mem[_65965 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _66335 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66335 + 68] = mem[idx + _65965 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66335 + 68] = mem[_66335 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66335 + -mem[64] + 100
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _68654 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68654] = 26
                            mem[_68654 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68654 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74693 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74693] = 30
                                mem[_74693 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _75931 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75931 + 68] = mem[idx + _74693 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75931 + 68] = mem[_75931 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75931 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75281 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75281] = 30
                                mem[_75281 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76679 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76679 + 68] = mem[idx + _75281 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76679 + 68] = mem[_76679 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76679 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75930 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75930] = 30
                            mem[_75930 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _77574 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77574 + 68] = mem[idx + _75930 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77574 + 68] = mem[_77574 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77574 + -mem[64] + 100
                        if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _61730 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61730] = 30
                        mem[_61730 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                            _61995 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _61995 + 68] = mem[idx + _61730 + 32]
                                idx = idx + 32
                                continue 
                            mem[_61995 + 68] = mem[_61995 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _61995 + -mem[64] + 100
                        mem[0] = this.address
                        mem[32] = 26
                        _63221 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_63221] = 30
                        mem[_63221 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                            _63873 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _63873 + 68] = mem[idx + _63221 + 32]
                                idx = idx + 32
                                continue 
                            mem[_63873 + 68] = mem[_63873 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _63873 + -mem[64] + 100
                        stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                        if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                        _66131 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_66131] = 30
                        mem[_66131 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                            _66637 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _66637 + 68] = mem[idx + _66131 + 32]
                                idx = idx + 32
                                continue 
                            mem[_66637 + 68] = mem[_66637 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _66637 + -mem[64] + 100
                        stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                        if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                        emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                        _68885 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_68885] = 26
                        mem[_68885 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _68885 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75280 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75280] = 30
                            mem[_75280 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _76676 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _76676 + 68] = mem[idx + _75280 + 32]
                                idx = idx + 32
                                continue 
                            mem[_76676 + 68] = mem[_76676 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _76676 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75929 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75929] = 30
                            mem[_75929 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _77571 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77571 + 68] = mem[idx + _75929 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77571 + 68] = mem[_77571 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77571 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _76675 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_76675] = 30
                        mem[_76675 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        _78462 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _78462 + 68] = mem[idx + _76675 + 32]
                            idx = idx + 32
                            continue 
                        mem[_78462 + 68] = mem[_78462 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _78462 + -mem[64] + 100
                    _58357 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_58357] = 26
                    mem[_58357 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _58357 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if t >= stor32 / _tTotal:
                        _60011 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_60011] = 26
                        mem[_60011 + 32] = 'SafeMath: division by zero'
                        if not s:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _60011 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_49a6a335 * msg.value / 10^9:
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _61723 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61723] = 30
                                mem[_61723 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _63207 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63207] = 30
                                mem[_63207 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _63856 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63856 + 68] = mem[idx + _63207 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63856 + 68] = mem[_63856 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63856 + -mem[64] + 100
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _66124 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66124] = 30
                                mem[_66124 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66622 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66622 + 68] = mem[idx + _66124 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66622 + 68] = mem[_66622 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66622 + -mem[64] + 100
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68874 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68874] = 26
                                mem[_68874 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68874 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75254 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75254] = 30
                                    mem[_75254 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76643 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76643 + 68] = mem[idx + _75254 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76643 + 68] = mem[_76643 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76643 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75903 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75903] = 30
                                    mem[_75903 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _77534 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _77534 + 68] = mem[idx + _75903 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_77534 + 68] = mem[_77534 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _77534 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _76642 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_76642] = 30
                                mem[_76642 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _78427 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _78427 + 68] = mem[idx + _76642 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_78427 + 68] = mem[_78427 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _78427 + -mem[64] + 100
                            if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != t / s:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61868 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61868] = 30
                            mem[_61868 + 32] = 'SafeMath: subtraction overflow'
                            if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                _62229 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _62229 + 68] = mem[idx + _61868 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_62229 + 68] = mem[_62229 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _62229 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _63504 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_63504] = 30
                            mem[_63504 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                _64264 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _64264 + 68] = mem[idx + _63504 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_64264 + 68] = mem[_64264 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _64264 + -mem[64] + 100
                            if (-1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (-1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                            _66328 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_66328] = 30
                            mem[_66328 + 32] = 'SafeMath: subtraction overflow'
                            if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                _66956 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66956 + 68] = mem[idx + _66328 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66956 + 68] = mem[_66956 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66956 + -mem[64] + 100
                            stor32 += -1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _69134 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_69134] = 26
                            mem[_69134 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _69134 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75902 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75902] = 30
                                mem[_75902 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77531 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77531 + 68] = mem[idx + _75902 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77531 + 68] = mem[_77531 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77531 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _76641 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_76641] = 30
                                mem[_76641 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _78424 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _78424 + 68] = mem[idx + _76641 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_78424 + 68] = mem[_78424 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _78424 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _77530 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_77530] = 30
                            mem[_77530 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _79277 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _79277 + 68] = mem[idx + _77530 + 32]
                                idx = idx + 32
                                continue 
                            mem[_79277 + 68] = mem[_79277 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _79277 + -mem[64] + 100
                        if t / s * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != t / s:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                            _61867 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61867] = 30
                            mem[_61867 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > t / s * sub_49a6a335 * msg.value / 10^9:
                                _62226 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _62226 + 68] = mem[idx + _61867 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_62226 + 68] = mem[_62226 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _62226 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _63503 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_63503] = 30
                            mem[_63503 + 32] = 'SafeMath: subtraction overflow'
                            if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _64261 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _64261 + 68] = mem[idx + _63503 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_64261 + 68] = mem[_64261 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _64261 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                            if (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                            _66327 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_66327] = 30
                            mem[_66327 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _66953 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66953 + 68] = mem[idx + _66327 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66953 + 68] = mem[_66953 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66953 + -mem[64] + 100
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _69133 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_69133] = 26
                            mem[_69133 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _69133 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75899 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75899] = 30
                                mem[_75899 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77527 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77527 + 68] = mem[idx + _75899 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77527 + 68] = mem[_77527 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77527 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _76640 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_76640] = 30
                                mem[_76640 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _78421 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _78421 + 68] = mem[idx + _76640 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_78421 + 68] = mem[_78421 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _78421 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _77526 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_77526] = 30
                            mem[_77526 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _79273 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _79273 + 68] = mem[idx + _77526 + 32]
                                idx = idx + 32
                                continue 
                            mem[_79273 + 68] = mem[_79273 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _79273 + -mem[64] + 100
                        if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != t / s:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _61987 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61987] = 30
                        mem[_61987 + 32] = 'SafeMath: subtraction overflow'
                        if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > t / s * sub_49a6a335 * msg.value / 10^9:
                            _62405 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _62405 + 68] = mem[idx + _61987 + 32]
                                idx = idx + 32
                                continue 
                            mem[_62405 + 68] = mem[_62405 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _62405 + -mem[64] + 100
                        mem[0] = this.address
                        mem[32] = 26
                        _63855 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_63855] = 30
                        mem[_63855 + 32] = 'SafeMath: subtraction overflow'
                        if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                            _64626 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _64626 + 68] = mem[idx + _63855 + 32]
                                idx = idx + 32
                                continue 
                            mem[_64626 + 68] = mem[_64626 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _64626 + -mem[64] + 100
                        stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                        if (t / s * sub_49a6a335 * msg.value / 10^9) - (t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) - (t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                        _66621 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_66621] = 30
                        mem[_66621 + 32] = 'SafeMath: subtraction overflow'
                        if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                            _67235 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _67235 + 68] = mem[idx + _66621 + 32]
                                idx = idx + 32
                                continue 
                            mem[_67235 + 68] = mem[_67235 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _67235 + -mem[64] + 100
                        stor32 += -1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                        if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                        emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                        _69465 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_69465] = 26
                        mem[_69465 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _69465 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _76639 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_76639] = 30
                            mem[_76639 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _78418 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _78418 + 68] = mem[idx + _76639 + 32]
                                idx = idx + 32
                                continue 
                            mem[_78418 + 68] = mem[_78418 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _78418 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _77525 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_77525] = 30
                            mem[_77525 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _79270 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _79270 + 68] = mem[idx + _77525 + 32]
                                idx = idx + 32
                                continue 
                            mem[_79270 + 68] = mem[_79270 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _79270 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _78417 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_78417] = 30
                        mem[_78417 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        _80075 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _80075 + 68] = mem[idx + _78417 + 32]
                            idx = idx + 32
                            continue 
                        mem[_80075 + 68] = mem[_80075 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _80075 + -mem[64] + 100
                    _60012 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_60012] = 26
                    mem[_60012 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _60012 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if not sub_49a6a335 * msg.value / 10^9:
                        if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                            _61726 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61726] = 30
                            mem[_61726 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = this.address
                            mem[32] = 26
                            _63214 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_63214] = 30
                            mem[_63214 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor26[address(this.address)]:
                                _63860 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63860 + 68] = mem[idx + _63214 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63860 + 68] = mem[_63860 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63860 + -mem[64] + 100
                            if stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = stor26[msg.sender]
                            _66126 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_66126] = 30
                            mem[_66126 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _66626 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66626 + 68] = mem[idx + _66126 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66626 + 68] = mem[_66626 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66626 + -mem[64] + 100
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _68877 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68877] = 26
                            mem[_68877 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68877 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75263 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75263] = 30
                                mem[_75263 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76652 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76652 + 68] = mem[idx + _75263 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76652 + 68] = mem[_76652 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76652 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75912 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75912] = 30
                                mem[_75912 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77546 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77546 + 68] = mem[idx + _75912 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77546 + 68] = mem[_77546 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77546 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _76651 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_76651] = 30
                            mem[_76651 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _78441 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _78441 + 68] = mem[idx + _76651 + 32]
                                idx = idx + 32
                                continue 
                            mem[_78441 + 68] = mem[_78441 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _78441 + -mem[64] + 100
                        if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _61870 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61870] = 30
                        mem[_61870 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                            _62235 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _62235 + 68] = mem[idx + _61870 + 32]
                                idx = idx + 32
                                continue 
                            mem[_62235 + 68] = mem[_62235 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _62235 + -mem[64] + 100
                        mem[0] = this.address
                        mem[32] = 26
                        _63508 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_63508] = 30
                        mem[_63508 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor26[address(this.address)]:
                            _64270 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _64270 + 68] = mem[idx + _63508 + 32]
                                idx = idx + 32
                                continue 
                            mem[_64270 + 68] = mem[_64270 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _64270 + -mem[64] + 100
                        if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                        _66330 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_66330] = 30
                        mem[_66330 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                            _66962 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _66962 + 68] = mem[idx + _66330 + 32]
                                idx = idx + 32
                                continue 
                            mem[_66962 + 68] = mem[_66962 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _66962 + -mem[64] + 100
                        stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                        if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                        emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                        _69136 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_69136] = 26
                        mem[_69136 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _69136 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75911 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75911] = 30
                            mem[_75911 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _77543 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77543 + 68] = mem[idx + _75911 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77543 + 68] = mem[_77543 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77543 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _76650 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_76650] = 30
                            mem[_76650 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _78438 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _78438 + 68] = mem[idx + _76650 + 32]
                                idx = idx + 32
                                continue 
                            mem[_78438 + 68] = mem[_78438 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _78438 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _77542 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_77542] = 30
                        mem[_77542 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        _79293 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _79293 + 68] = mem[idx + _77542 + 32]
                            idx = idx + 32
                            continue 
                        mem[_79293 + 68] = mem[_79293 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _79293 + -mem[64] + 100
                    if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                        _61869 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_61869] = 30
                        mem[_61869 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                            _62232 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _62232 + 68] = mem[idx + _61869 + 32]
                                idx = idx + 32
                                continue 
                            mem[_62232 + 68] = mem[_62232 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _62232 + -mem[64] + 100
                        mem[0] = this.address
                        mem[32] = 26
                        _63507 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_63507] = 30
                        mem[_63507 + 32] = 'SafeMath: subtraction overflow'
                        if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                            _64267 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _64267 + 68] = mem[idx + _63507 + 32]
                                idx = idx + 32
                                continue 
                            mem[_64267 + 68] = mem[_64267 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _64267 + -mem[64] + 100
                        stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                        if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = msg.sender
                        mem[32] = 26
                        stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                        _66329 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_66329] = 30
                        mem[_66329 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor32:
                            _66959 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _66959 + 68] = mem[idx + _66329 + 32]
                                idx = idx + 32
                                continue 
                            mem[_66959 + 68] = mem[_66959 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _66959 + -mem[64] + 100
                        if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                            revert with 0, 'SafeMath: addition overflow'
                        _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                        emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                        _69135 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_69135] = 26
                        mem[_69135 + 32] = 'SafeMath: division by zero'
                        if not sub_1b2cabba:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _69135 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75908 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75908] = 30
                            mem[_75908 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _77539 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77539 + 68] = mem[idx + _75908 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77539 + 68] = mem[_77539 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77539 + -mem[64] + 100
                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            if ethSent <= 0:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _76649 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_76649] = 30
                            mem[_76649 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _78435 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _78435 + 68] = mem[idx + _76649 + 32]
                                idx = idx + 32
                                continue 
                            mem[_78435 + 68] = mem[_78435 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _78435 + -mem[64] + 100
                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _77538 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_77538] = 30
                        mem[_77538 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        _79289 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _79289 + 68] = mem[idx + _77538 + 32]
                            idx = idx + 32
                            continue 
                        mem[_79289 + 68] = mem[_79289 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _79289 + -mem[64] + 100
                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _61988 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_61988] = 30
                    mem[_61988 + 32] = 'SafeMath: subtraction overflow'
                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                        _62408 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _62408 + 68] = mem[idx + _61988 + 32]
                            idx = idx + 32
                            continue 
                        mem[_62408 + 68] = mem[_62408 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _62408 + -mem[64] + 100
                    mem[0] = this.address
                    mem[32] = 26
                    _63859 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_63859] = 30
                    mem[_63859 + 32] = 'SafeMath: subtraction overflow'
                    if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                        _64632 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _64632 + 68] = mem[idx + _63859 + 32]
                            idx = idx + 32
                            continue 
                        mem[_64632 + 68] = mem[_64632 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _64632 + -mem[64] + 100
                    stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                    if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = msg.sender
                    mem[32] = 26
                    stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                    _66625 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_66625] = 30
                    mem[_66625 + 32] = 'SafeMath: subtraction overflow'
                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                        _67239 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _67239 + 68] = mem[idx + _66625 + 32]
                            idx = idx + 32
                            continue 
                        mem[_67239 + 68] = mem[_67239 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _67239 + -mem[64] + 100
                    stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                        revert with 0, 'SafeMath: addition overflow'
                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                    _69469 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_69469] = 26
                    mem[_69469 + 32] = 'SafeMath: division by zero'
                    if not sub_1b2cabba:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _69469 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if not sub_8a3be0b6:
                        if ethSent <= 0:
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _76648 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_76648] = 30
                        mem[_76648 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        _78432 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _78432 + 68] = mem[idx + _76648 + 32]
                            idx = idx + 32
                            continue 
                        mem[_78432 + 68] = mem[_78432 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _78432 + -mem[64] + 100
                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                        if ethSent <= 0:
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        _77537 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_77537] = 30
                        mem[_77537 + 32] = 'SafeMath: subtraction overflow'
                        if sub_be71ce9f <= sub_49a6a335:
                            sub_49a6a335 -= sub_be71ce9f
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            stor0 = 1
                        _79286 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _79286 + 68] = mem[idx + _77537 + 32]
                            idx = idx + 32
                            continue 
                        mem[_79286 + 68] = mem[_79286 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _79286 + -mem[64] + 100
                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                        stor0 = 1
                    if timeBetweenRounds + block.timestamp < block.timestamp:
                        revert with 0, 'SafeMath: addition overflow'
                    presaleTime = timeBetweenRounds + block.timestamp
                    sub_8a3be0b6++
                    _78431 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_78431] = 30
                    mem[_78431 + 32] = 'SafeMath: subtraction overflow'
                    if sub_be71ce9f <= sub_49a6a335:
                        sub_49a6a335 -= sub_be71ce9f
                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                        stor0 = 1
                    _80095 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _80095 + 68] = mem[idx + _78431 + 32]
                        idx = idx + 32
                        continue 
                    mem[_80095 + 68] = mem[_80095 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _80095 + -mem[64] + 100
                _28756 = mem[64]
                mem[64] = mem[64] + 64
                mem[_28756] = 26
                mem[_28756 + 32] = 'SafeMath: division by zero'
                if not _tTotal:
                    revert with 0, 'SafeMath: division by zero'
                if t >= stor32 / _tTotal:
                    _29064 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29064] = 26
                    mem[_29064 + 32] = 'SafeMath: division by zero'
                    if not s:
                        revert with 0, 'SafeMath: division by zero'
                    _29586 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29586] = 26
                    mem[_29586 + 32] = 'SafeMath: division by zero'
                    if not t / s:
                        revert with 0, 'SafeMath: division by zero'
                    if stor26[address(this.address)] / t / s < sub_49a6a335 * msg.value / 10^9:
                        revert with 0, 32, 33, 0x774e6f7420656e6f75676820746f6b656e7320696e2074686520636f6e74726163, mem[mem[64] + 101 len 31]
                    if msg.value + sub_536c8c02[msg.sender] < sub_536c8c02[msg.sender]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = msg.sender
                    mem[32] = 20
                    sub_536c8c02[msg.sender] += msg.value
                    if msg.value + ethSent < ethSent:
                        revert with 0, 'SafeMath: addition overflow'
                    ethSent += msg.value
                    _30646 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30646] = 26
                    mem[_30646 + 32] = 'SafeMath: division by zero'
                    if not sub_49a6a335 * msg.value / 10^9 / 50:
                        _31452 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31452] = 30
                        mem[_31452 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > sub_49a6a335 * msg.value / 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = _tTotal
                        t = stor32
                        while idx < stor30.length:
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            if stor26[stor30[idx]] > t:
                                _59544 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59544] = 26
                                mem[_59544 + 32] = 'SafeMath: division by zero'
                                if not _tTotal:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _59544 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_49a6a335 * msg.value / 10^9:
                                    _61396 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61396] = 30
                                    mem[_61396 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62162 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62162] = 30
                                    mem[_62162 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _62554 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62554 + 68] = mem[idx + _62162 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62554 + 68] = mem[_62554 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62554 + -mem[64] + 100
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _64930 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_64930] = 30
                                    mem[_64930 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _65645 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _65645 + 68] = mem[idx + _64930 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_65645 + 68] = mem[_65645 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _65645 + -mem[64] + 100
                                    if _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    _67791 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_67791] = 26
                                    mem[_67791 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _67791 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73038 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73038] = 30
                                        mem[_73038 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74029 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74029 + 68] = mem[idx + _73038 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74029 + 68] = mem[_74029 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74029 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73541 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73541] = 30
                                        mem[_73541 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74542 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74542 + 68] = mem[idx + _73541 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74542 + 68] = mem[_74542 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74542 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74028 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74028] = 30
                                    mem[_74028 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75111 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75111 + 68] = mem[idx + _74028 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75111 + 68] = mem[_75111 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75111 + -mem[64] + 100
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61437 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61437] = 30
                                mem[_61437 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    _61577 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61577 + 68] = mem[idx + _61437 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61577 + 68] = mem[_61577 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61577 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62361 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62361] = 30
                                mem[_62361 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _62809 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62809 + 68] = mem[idx + _62361 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62809 + 68] = mem[_62809 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62809 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _65302 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65302] = 30
                                mem[_65302 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _65897 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _65897 + 68] = mem[idx + _65302 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_65897 + 68] = mem[_65897 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _65897 + -mem[64] + 100
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68093 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68093] = 26
                                mem[_68093 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68093 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73540 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73540] = 30
                                    mem[_73540 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74539 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74539 + 68] = mem[idx + _73540 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74539 + 68] = mem[_74539 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74539 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74027 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74027] = 30
                                    mem[_74027 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75108 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75108 + 68] = mem[idx + _74027 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75108 + 68] = mem[_75108 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75108 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74538 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74538] = 30
                                mem[_74538 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _75739 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75739 + 68] = mem[idx + _74538 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75739 + 68] = mem[_75739 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75739 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            if stor27[stor30[idx]] <= s:
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 26
                                _59638 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59638] = 30
                                mem[_59638 + 32] = 'SafeMath: subtraction overflow'
                                if stor26[stor30[idx]] > t:
                                    _59842 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _59842 + 68] = mem[idx + _59638 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59842 + 68] = mem[_59842 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59842 + -mem[64] + 100
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 27
                                _60579 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_60579] = 30
                                mem[_60579 + 32] = 'SafeMath: subtraction overflow'
                                if stor27[stor30[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor27[stor30[idx]]
                                    t = t - stor26[stor30[idx]]
                                    continue 
                                _60905 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _60905 + 68] = mem[idx + _60579 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_60905 + 68] = mem[_60905 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _60905 + -mem[64] + 100
                            _59738 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59738] = 26
                            mem[_59738 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59738 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                _61481 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61481] = 30
                                mem[_61481 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _62559 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62559] = 30
                                mem[_62559 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _63126 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63126 + 68] = mem[idx + _62559 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63126 + 68] = mem[_63126 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63126 + -mem[64] + 100
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _65648 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65648] = 30
                                mem[_65648 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66084 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66084 + 68] = mem[idx + _65648 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66084 + 68] = mem[_66084 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66084 + -mem[64] + 100
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68345 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68345] = 26
                                mem[_68345 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68345 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74036 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74036] = 30
                                    mem[_74036 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75117 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75117 + 68] = mem[idx + _74036 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75117 + 68] = mem[_75117 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75117 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74548 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74548] = 30
                                    mem[_74548 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75752 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75752 + 68] = mem[idx + _74548 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75752 + 68] = mem[_75752 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75752 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75116 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75116] = 30
                                mem[_75116 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76473 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76473 + 68] = mem[idx + _75116 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76473 + 68] = mem[_76473 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76473 + -mem[64] + 100
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61580 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61580] = 30
                            mem[_61580 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _61828 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _61828 + 68] = mem[idx + _61580 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_61828 + 68] = mem[_61828 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _61828 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _62812 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_62812] = 30
                            mem[_62812 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _63434 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63434 + 68] = mem[idx + _62812 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63434 + 68] = mem[_63434 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63434 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                            _65900 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_65900] = 30
                            mem[_65900 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _66280 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66280 + 68] = mem[idx + _65900 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66280 + 68] = mem[_66280 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66280 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            _68586 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68586] = 26
                            mem[_68586 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68586 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74547 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74547] = 30
                                mem[_74547 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _75749 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75749 + 68] = mem[idx + _74547 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75749 + 68] = mem[_75749 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75749 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75115 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75115] = 30
                                mem[_75115 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76470 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76470 + 68] = mem[idx + _75115 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76470 + 68] = mem[_76470 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76470 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75748 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75748] = 30
                            mem[_75748 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _77324 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77324 + 68] = mem[idx + _75748 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77324 + 68] = mem[_77324 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77324 + -mem[64] + 100
                        _58314 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_58314] = 26
                        mem[_58314 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor32 / _tTotal:
                            _59976 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59976] = 26
                            mem[_59976 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                _61695 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61695] = 30
                                mem[_61695 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _63119 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63119] = 30
                                mem[_63119 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _66081 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66081] = 30
                                mem[_66081 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68814 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68814] = 26
                                mem[_68814 + 32] = 'SafeMath: division by zero'
                            else:
                                if t / s * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != t / s:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61825 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61825] = 30
                                mem[_61825 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > t / s * sub_49a6a335 * msg.value / 10^9:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _63427 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63427] = 30
                                mem[_63427 + 32] = 'SafeMath: subtraction overflow'
                                if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                                if (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _66275 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66275] = 30
                                mem[_66275 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _69067 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_69067] = 26
                                mem[_69067 + 32] = 'SafeMath: division by zero'
                        else:
                            _59977 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59977] = 26
                            mem[_59977 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                _61696 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61696] = 30
                                mem[_61696 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _63122 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63122] = 30
                                mem[_63122 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _66082 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66082] = 30
                                mem[_66082 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68815 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68815] = 26
                                mem[_68815 + 32] = 'SafeMath: division by zero'
                            else:
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61826 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61826] = 30
                                mem[_61826 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _63428 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63428] = 30
                                mem[_63428 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _66276 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66276] = 30
                                mem[_66276 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _69068 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_69068] = 26
                                mem[_69068 + 32] = 'SafeMath: division by zero'
                    else:
                        if 2 * sub_49a6a335 * msg.value / 10^9 / 50 / sub_49a6a335 * msg.value / 10^9 / 50 != 2:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _31540 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31540] = 30
                        mem[_31540 + 32] = 'SafeMath: subtraction overflow'
                        if 2 * sub_49a6a335 * msg.value / 10^9 / 50 > sub_49a6a335 * msg.value / 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = _tTotal
                        t = stor32
                        while idx < stor30.length:
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            if stor26[stor30[idx]] > t:
                                _59539 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59539] = 26
                                mem[_59539 + 32] = 'SafeMath: division by zero'
                                if not _tTotal:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _59539 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_49a6a335 * msg.value / 10^9:
                                    if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                        _61395 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_61395] = 30
                                        mem[_61395 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = this.address
                                        mem[32] = 26
                                        _62151 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_62151] = 30
                                        mem[_62151 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor26[address(this.address)]:
                                            _62542 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _62542 + 68] = mem[idx + _62151 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_62542 + 68] = mem[_62542 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _62542 + -mem[64] + 100
                                        if stor26[msg.sender] < stor26[msg.sender]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 26
                                        stor26[address(msg.sender)] = stor26[msg.sender]
                                        _64910 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_64910] = 30
                                        mem[_64910 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor32:
                                            _65632 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _65632 + 68] = mem[idx + _64910 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_65632 + 68] = mem[_65632 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _65632 + -mem[64] + 100
                                        if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                        emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                        _67775 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_67775] = 26
                                        mem[_67775 + 32] = 'SafeMath: division by zero'
                                        if not sub_1b2cabba:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _67775 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not sub_8a3be0b6:
                                            if ethSent <= 0:
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            presaleTime = timeBetweenRounds + block.timestamp
                                            sub_8a3be0b6++
                                            _73013 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_73013] = 30
                                            mem[_73013 + 32] = 'SafeMath: subtraction overflow'
                                            if sub_be71ce9f <= sub_49a6a335:
                                                sub_49a6a335 -= sub_be71ce9f
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            _74007 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _74007 + 68] = mem[idx + _73013 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_74007 + 68] = mem[_74007 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _74007 + -mem[64] + 100
                                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                            if ethSent <= 0:
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            presaleTime = timeBetweenRounds + block.timestamp
                                            sub_8a3be0b6++
                                            _73521 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_73521] = 30
                                            mem[_73521 + 32] = 'SafeMath: subtraction overflow'
                                            if sub_be71ce9f <= sub_49a6a335:
                                                sub_49a6a335 -= sub_be71ce9f
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            _74518 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _74518 + 68] = mem[idx + _73521 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_74518 + 68] = mem[_74518 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _74518 + -mem[64] + 100
                                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _74006 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_74006] = 30
                                        mem[_74006 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _75085 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _75085 + 68] = mem[idx + _74006 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_75085 + 68] = mem[_75085 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _75085 + -mem[64] + 100
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _61434 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61434] = 30
                                    mem[_61434 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                        _61572 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _61572 + 68] = mem[idx + _61434 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_61572 + 68] = mem[_61572 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _61572 + -mem[64] + 100
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62354 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62354] = 30
                                    mem[_62354 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _62796 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62796 + 68] = mem[idx + _62354 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62796 + 68] = mem[_62796 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62796 + -mem[64] + 100
                                    if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                    _65286 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65286] = 30
                                    mem[_65286 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                        _65890 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _65890 + 68] = mem[idx + _65286 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_65890 + 68] = mem[_65890 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _65890 + -mem[64] + 100
                                    stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68082 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68082] = 26
                                    mem[_68082 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _68082 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73520 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73520] = 30
                                        mem[_73520 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74515 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74515 + 68] = mem[idx + _73520 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74515 + 68] = mem[_74515 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74515 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _74005 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_74005] = 30
                                        mem[_74005 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _75082 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _75082 + 68] = mem[idx + _74005 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_75082 + 68] = mem[_75082 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _75082 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74514 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74514] = 30
                                    mem[_74514 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75710 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75710 + 68] = mem[idx + _74514 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75710 + 68] = mem[_75710 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75710 + -mem[64] + 100
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61433 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61433] = 30
                                    mem[_61433 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                        _61569 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _61569 + 68] = mem[idx + _61433 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_61569 + 68] = mem[_61569 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _61569 + -mem[64] + 100
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62353 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62353] = 30
                                    mem[_62353 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                        _62793 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62793 + 68] = mem[idx + _62353 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62793 + 68] = mem[_62793 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62793 + -mem[64] + 100
                                    stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                    if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                    _65285 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65285] = 30
                                    mem[_65285 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _65887 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _65887 + 68] = mem[idx + _65285 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_65887 + 68] = mem[_65887 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _65887 + -mem[64] + 100
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68081 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68081] = 26
                                    mem[_68081 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _68081 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73517 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73517] = 30
                                        mem[_73517 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74511 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74511 + 68] = mem[idx + _73517 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74511 + 68] = mem[_74511 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74511 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _74004 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_74004] = 30
                                        mem[_74004 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _75079 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _75079 + 68] = mem[idx + _74004 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_75079 + 68] = mem[_75079 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _75079 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74510 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74510] = 30
                                    mem[_74510 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75706 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75706 + 68] = mem[idx + _74510 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75706 + 68] = mem[_75706 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75706 + -mem[64] + 100
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61477 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61477] = 30
                                mem[_61477 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    _61691 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61691 + 68] = mem[idx + _61477 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61691 + 68] = mem[_61691 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61691 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62541 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62541] = 30
                                mem[_62541 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _63107 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63107 + 68] = mem[idx + _62541 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63107 + 68] = mem[_63107 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63107 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _65631 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65631] = 30
                                mem[_65631 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    _66073 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66073 + 68] = mem[idx + _65631 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66073 + 68] = mem[_66073 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66073 + -mem[64] + 100
                                stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68331 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68331] = 26
                                mem[_68331 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68331 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74003 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74003] = 30
                                    mem[_74003 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75076 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75076 + 68] = mem[idx + _74003 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75076 + 68] = mem[_75076 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75076 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74509 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74509] = 30
                                    mem[_74509 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75703 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75703 + 68] = mem[idx + _74509 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75703 + 68] = mem[_75703 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75703 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75075 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75075] = 30
                                mem[_75075 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76415 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76415 + 68] = mem[idx + _75075 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76415 + 68] = mem[_76415 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76415 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            if stor27[stor30[idx]] <= s:
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 26
                                _59635 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59635] = 30
                                mem[_59635 + 32] = 'SafeMath: subtraction overflow'
                                if stor26[stor30[idx]] > t:
                                    _59838 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _59838 + 68] = mem[idx + _59635 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59838 + 68] = mem[_59838 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59838 + -mem[64] + 100
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 27
                                _60572 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_60572] = 30
                                mem[_60572 + 32] = 'SafeMath: subtraction overflow'
                                if stor27[stor30[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor27[stor30[idx]]
                                    t = t - stor26[stor30[idx]]
                                    continue 
                                _60897 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _60897 + 68] = mem[idx + _60572 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_60897 + 68] = mem[_60897 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _60897 + -mem[64] + 100
                            _59733 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59733] = 26
                            mem[_59733 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59733 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61480 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61480] = 30
                                    mem[_61480 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62551 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62551] = 30
                                    mem[_62551 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _63114 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _63114 + 68] = mem[idx + _62551 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_63114 + 68] = mem[_63114 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _63114 + -mem[64] + 100
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _65636 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65636] = 30
                                    mem[_65636 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _66078 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _66078 + 68] = mem[idx + _65636 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_66078 + 68] = mem[_66078 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _66078 + -mem[64] + 100
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68337 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68337] = 26
                                    mem[_68337 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _68337 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _74018 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_74018] = 30
                                        mem[_74018 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _75095 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _75095 + 68] = mem[idx + _74018 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_75095 + 68] = mem[_75095 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _75095 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _74529 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_74529] = 30
                                        mem[_74529 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _75728 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _75728 + 68] = mem[idx + _74529 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_75728 + 68] = mem[_75728 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _75728 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75094 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75094] = 30
                                    mem[_75094 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76445 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76445 + 68] = mem[idx + _75094 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76445 + 68] = mem[_76445 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76445 + -mem[64] + 100
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61576 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61576] = 30
                                mem[_61576 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                    _61822 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61822 + 68] = mem[idx + _61576 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61822 + 68] = mem[_61822 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61822 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62802 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62802] = 30
                                mem[_62802 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _63424 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63424 + 68] = mem[idx + _62802 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63424 + 68] = mem[_63424 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63424 + -mem[64] + 100
                                if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _65894 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65894] = 30
                                mem[_65894 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    _66272 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66272 + 68] = mem[idx + _65894 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66272 + 68] = mem[_66272 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66272 + -mem[64] + 100
                                stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68577 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68577] = 26
                                mem[_68577 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68577 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74528 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74528] = 30
                                    mem[_74528 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75725 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75725 + 68] = mem[idx + _74528 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75725 + 68] = mem[_75725 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75725 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75093 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75093] = 30
                                    mem[_75093 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76442 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76442 + 68] = mem[idx + _75093 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76442 + 68] = mem[_76442 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76442 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75724 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75724] = 30
                                mem[_75724 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77290 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77290 + 68] = mem[idx + _75724 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77290 + 68] = mem[_77290 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77290 + -mem[64] + 100
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _61575 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61575] = 30
                                mem[_61575 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    _61819 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61819 + 68] = mem[idx + _61575 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61819 + 68] = mem[_61819 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61819 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62801 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62801] = 30
                                mem[_62801 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _63421 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63421 + 68] = mem[idx + _62801 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63421 + 68] = mem[_63421 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63421 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _65893 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65893] = 30
                                mem[_65893 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66269 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66269 + 68] = mem[idx + _65893 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66269 + 68] = mem[_66269 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66269 + -mem[64] + 100
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68576 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68576] = 26
                                mem[_68576 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68576 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74525 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74525] = 30
                                    mem[_74525 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75721 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75721 + 68] = mem[idx + _74525 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75721 + 68] = mem[_75721 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75721 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75092 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75092] = 30
                                    mem[_75092 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76439 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76439 + 68] = mem[idx + _75092 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76439 + 68] = mem[_76439 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76439 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75720 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75720] = 30
                                mem[_75720 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77286 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77286 + 68] = mem[idx + _75720 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77286 + 68] = mem[_77286 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77286 + -mem[64] + 100
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61694 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61694] = 30
                            mem[_61694 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _61953 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _61953 + 68] = mem[idx + _61694 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_61953 + 68] = mem[_61953 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _61953 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _63113 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_63113] = 30
                            mem[_63113 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _63759 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63759 + 68] = mem[idx + _63113 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63759 + 68] = mem[_63759 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63759 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                            _66077 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_66077] = 30
                            mem[_66077 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                _66541 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66541 + 68] = mem[idx + _66077 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66541 + 68] = mem[_66541 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66541 + -mem[64] + 100
                            stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _68810 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68810] = 26
                            mem[_68810 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68810 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75091 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75091] = 30
                                mem[_75091 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76436 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76436 + 68] = mem[idx + _75091 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76436 + 68] = mem[_76436 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76436 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75719 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75719] = 30
                                mem[_75719 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77283 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77283 + 68] = mem[idx + _75719 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77283 + 68] = mem[_77283 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77283 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _76435 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_76435] = 30
                            mem[_76435 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _78174 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _78174 + 68] = mem[idx + _76435 + 32]
                                idx = idx + 32
                                continue 
                            mem[_78174 + 68] = mem[_78174 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _78174 + -mem[64] + 100
                        _58309 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_58309] = 26
                        mem[_58309 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor32 / _tTotal:
                            _59969 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59969] = 26
                            mem[_59969 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61687 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61687] = 30
                                    mem[_61687 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63099 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63099] = 30
                                    mem[_63099 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _66070 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66070] = 30
                                    mem[_66070 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68799 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68799] = 26
                                    mem[_68799 + 32] = 'SafeMath: division by zero'
                                else:
                                    if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != t / s:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _61814 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61814] = 30
                                    mem[_61814 + 32] = 'SafeMath: subtraction overflow'
                                    if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63408 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63408] = 30
                                    mem[_63408 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (-1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (-1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                    _66262 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66262] = 30
                                    mem[_66262 + 32] = 'SafeMath: subtraction overflow'
                                    if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor32 += -1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _69050 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_69050] = 26
                                    mem[_69050 + 32] = 'SafeMath: division by zero'
                            else:
                                if t / s * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != t / s:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61813 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61813] = 30
                                    mem[_61813 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > t / s * sub_49a6a335 * msg.value / 10^9:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63407 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63407] = 30
                                    mem[_63407 + 32] = 'SafeMath: subtraction overflow'
                                    if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                                    if (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                    _66261 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66261] = 30
                                    mem[_66261 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _69049 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_69049] = 26
                                    mem[_69049 + 32] = 'SafeMath: division by zero'
                                else:
                                    if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != t / s:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _61945 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61945] = 30
                                    mem[_61945 + 32] = 'SafeMath: subtraction overflow'
                                    if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > t / s * sub_49a6a335 * msg.value / 10^9:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63741 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63741] = 30
                                    mem[_63741 + 32] = 'SafeMath: subtraction overflow'
                                    if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                                    if (t / s * sub_49a6a335 * msg.value / 10^9) - (t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) - (t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                    _66525 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66525] = 30
                                    mem[_66525 + 32] = 'SafeMath: subtraction overflow'
                                    if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor32 += -1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _69357 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_69357] = 26
                                    mem[_69357 + 32] = 'SafeMath: division by zero'
                        else:
                            _59970 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59970] = 26
                            mem[_59970 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61690 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61690] = 30
                                    mem[_61690 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63106 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63106] = 30
                                    mem[_63106 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _66072 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66072] = 30
                                    mem[_66072 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68802 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68802] = 26
                                    mem[_68802 + 32] = 'SafeMath: division by zero'
                                else:
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _61816 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61816] = 30
                                    mem[_61816 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63412 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63412] = 30
                                    mem[_63412 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                    _66264 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66264] = 30
                                    mem[_66264 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _69052 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_69052] = 26
                                    mem[_69052 + 32] = 'SafeMath: division by zero'
                            else:
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61815 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61815] = 30
                                    mem[_61815 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63411 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63411] = 30
                                    mem[_63411 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                    if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                    _66263 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66263] = 30
                                    mem[_66263 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _69051 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_69051] = 26
                                    mem[_69051 + 32] = 'SafeMath: division by zero'
                                else:
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _61946 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61946] = 30
                                    mem[_61946 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63745 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63745] = 30
                                    mem[_63745 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                    if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                    _66529 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66529] = 30
                                    mem[_66529 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _69361 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_69361] = 26
                                    mem[_69361 + 32] = 'SafeMath: division by zero'
                else:
                    _29065 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29065] = 26
                    mem[_29065 + 32] = 'SafeMath: division by zero'
                    if not _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    _29588 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29588] = 26
                    mem[_29588 + 32] = 'SafeMath: division by zero'
                    if not stor32 / _tTotal:
                        revert with 0, 'SafeMath: division by zero'
                    if stor26[address(this.address)] / stor32 / _tTotal < sub_49a6a335 * msg.value / 10^9:
                        revert with 0, 32, 33, 0x774e6f7420656e6f75676820746f6b656e7320696e2074686520636f6e74726163, mem[mem[64] + 101 len 31]
                    if msg.value + sub_536c8c02[msg.sender] < sub_536c8c02[msg.sender]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = msg.sender
                    mem[32] = 20
                    sub_536c8c02[msg.sender] += msg.value
                    if msg.value + ethSent < ethSent:
                        revert with 0, 'SafeMath: addition overflow'
                    ethSent += msg.value
                    _30647 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30647] = 26
                    mem[_30647 + 32] = 'SafeMath: division by zero'
                    if not sub_49a6a335 * msg.value / 10^9 / 50:
                        _31453 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31453] = 30
                        mem[_31453 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > sub_49a6a335 * msg.value / 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = _tTotal
                        t = stor32
                        while idx < stor30.length:
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            if stor26[stor30[idx]] > t:
                                _59554 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59554] = 26
                                mem[_59554 + 32] = 'SafeMath: division by zero'
                                if not _tTotal:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _59554 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_49a6a335 * msg.value / 10^9:
                                    _61400 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61400] = 30
                                    mem[_61400 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62193 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62193] = 30
                                    mem[_62193 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _62577 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62577 + 68] = mem[idx + _62193 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62577 + 68] = mem[_62577 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62577 + -mem[64] + 100
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _64972 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_64972] = 30
                                    mem[_64972 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _65681 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _65681 + 68] = mem[idx + _64972 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_65681 + 68] = mem[_65681 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _65681 + -mem[64] + 100
                                    if _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    _67828 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_67828] = 26
                                    mem[_67828 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _67828 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73096 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73096] = 30
                                        mem[_73096 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74081 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74081 + 68] = mem[idx + _73096 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74081 + 68] = mem[_74081 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74081 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73594 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73594] = 30
                                        mem[_73594 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74598 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74598 + 68] = mem[idx + _73594 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74598 + 68] = mem[_74598 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74598 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74080 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74080] = 30
                                    mem[_74080 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75174 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75174 + 68] = mem[idx + _74080 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75174 + 68] = mem[_75174 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75174 + -mem[64] + 100
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61442 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61442] = 30
                                mem[_61442 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    _61593 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61593 + 68] = mem[idx + _61442 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61593 + 68] = mem[_61593 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61593 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62381 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62381] = 30
                                mem[_62381 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _62841 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _62841 + 68] = mem[idx + _62381 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_62841 + 68] = mem[_62841 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _62841 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _65341 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65341] = 30
                                mem[_65341 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _65921 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _65921 + 68] = mem[idx + _65341 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_65921 + 68] = mem[_65921 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _65921 + -mem[64] + 100
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68124 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68124] = 26
                                mem[_68124 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68124 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _73593 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_73593] = 30
                                    mem[_73593 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _74595 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _74595 + 68] = mem[idx + _73593 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_74595 + 68] = mem[_74595 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _74595 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74079 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74079] = 30
                                    mem[_74079 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75171 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75171 + 68] = mem[idx + _74079 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75171 + 68] = mem[_75171 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75171 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74594 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74594] = 30
                                mem[_74594 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _75809 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75809 + 68] = mem[idx + _74594 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75809 + 68] = mem[_75809 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75809 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            if stor27[stor30[idx]] <= s:
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 26
                                _59644 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59644] = 30
                                mem[_59644 + 32] = 'SafeMath: subtraction overflow'
                                if stor26[stor30[idx]] > t:
                                    _59850 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _59850 + 68] = mem[idx + _59644 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59850 + 68] = mem[_59850 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59850 + -mem[64] + 100
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 27
                                _60593 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_60593] = 30
                                mem[_60593 + 32] = 'SafeMath: subtraction overflow'
                                if stor27[stor30[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor27[stor30[idx]]
                                    t = t - stor26[stor30[idx]]
                                    continue 
                                _60921 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _60921 + 68] = mem[idx + _60593 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_60921 + 68] = mem[_60921 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _60921 + -mem[64] + 100
                            _59748 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59748] = 26
                            mem[_59748 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59748 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                _61486 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61486] = 30
                                mem[_61486 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _62582 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62582] = 30
                                mem[_62582 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _63162 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63162 + 68] = mem[idx + _62582 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63162 + 68] = mem[_63162 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63162 + -mem[64] + 100
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _65684 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65684] = 30
                                mem[_65684 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66102 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66102 + 68] = mem[idx + _65684 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66102 + 68] = mem[_66102 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66102 + -mem[64] + 100
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68370 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68370] = 26
                                mem[_68370 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68370 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74088 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74088] = 30
                                    mem[_74088 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75180 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75180 + 68] = mem[idx + _74088 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75180 + 68] = mem[_75180 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75180 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74604 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74604] = 30
                                    mem[_74604 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75822 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75822 + 68] = mem[idx + _74604 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75822 + 68] = mem[_75822 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75822 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75179 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75179] = 30
                                mem[_75179 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76553 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76553 + 68] = mem[idx + _75179 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76553 + 68] = mem[_76553 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76553 + -mem[64] + 100
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61596 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61596] = 30
                            mem[_61596 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _61846 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _61846 + 68] = mem[idx + _61596 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_61846 + 68] = mem[_61846 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _61846 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _62844 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_62844] = 30
                            mem[_62844 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _63466 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63466 + 68] = mem[idx + _62844 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63466 + 68] = mem[_63466 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63466 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                            _65924 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_65924] = 30
                            mem[_65924 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor32:
                                _66302 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66302 + 68] = mem[idx + _65924 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66302 + 68] = mem[_66302 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66302 + -mem[64] + 100
                            if _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                            _68612 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68612] = 26
                            mem[_68612 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68612 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _74603 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_74603] = 30
                                mem[_74603 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _75819 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _75819 + 68] = mem[idx + _74603 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_75819 + 68] = mem[_75819 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _75819 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75178 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75178] = 30
                                mem[_75178 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76550 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76550 + 68] = mem[idx + _75178 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76550 + 68] = mem[_76550 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76550 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _75818 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_75818] = 30
                            mem[_75818 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _77420 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _77420 + 68] = mem[idx + _75818 + 32]
                                idx = idx + 32
                                continue 
                            mem[_77420 + 68] = mem[_77420 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _77420 + -mem[64] + 100
                        _58328 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_58328] = 26
                        mem[_58328 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor32 / _tTotal:
                            _59990 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59990] = 26
                            mem[_59990 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                _61707 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61707] = 30
                                mem[_61707 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _63155 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63155] = 30
                                mem[_63155 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _66099 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66099] = 30
                                mem[_66099 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68839 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68839] = 26
                                mem[_68839 + 32] = 'SafeMath: division by zero'
                            else:
                                if t / s * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != t / s:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61843 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61843] = 30
                                mem[_61843 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > t / s * sub_49a6a335 * msg.value / 10^9:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _63459 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63459] = 30
                                mem[_63459 + 32] = 'SafeMath: subtraction overflow'
                                if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                                if (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _66297 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66297] = 30
                                mem[_66297 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _69095 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_69095] = 26
                                mem[_69095 + 32] = 'SafeMath: division by zero'
                        else:
                            _59991 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59991] = 26
                            mem[_59991 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                _61708 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61708] = 30
                                mem[_61708 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _63158 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63158] = 30
                                mem[_63158 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = stor26[msg.sender]
                                _66100 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66100] = 30
                                mem[_66100 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _68840 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68840] = 26
                                mem[_68840 + 32] = 'SafeMath: division by zero'
                            else:
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61844 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61844] = 30
                                mem[_61844 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = this.address
                                mem[32] = 26
                                _63460 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_63460] = 30
                                mem[_63460 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _66298 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_66298] = 30
                                mem[_66298 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                _69096 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_69096] = 26
                                mem[_69096 + 32] = 'SafeMath: division by zero'
                    else:
                        if 2 * sub_49a6a335 * msg.value / 10^9 / 50 / sub_49a6a335 * msg.value / 10^9 / 50 != 2:
                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _31541 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31541] = 30
                        mem[_31541 + 32] = 'SafeMath: subtraction overflow'
                        if 2 * sub_49a6a335 * msg.value / 10^9 / 50 > sub_49a6a335 * msg.value / 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = _tTotal
                        t = stor32
                        while idx < stor30.length:
                            mem[0] = stor30[idx]
                            mem[32] = 26
                            if stor26[stor30[idx]] > t:
                                _59549 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59549] = 26
                                mem[_59549 + 32] = 'SafeMath: division by zero'
                                if not _tTotal:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _59549 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_49a6a335 * msg.value / 10^9:
                                    if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                        _61399 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_61399] = 30
                                        mem[_61399 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = this.address
                                        mem[32] = 26
                                        _62182 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_62182] = 30
                                        mem[_62182 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor26[address(this.address)]:
                                            _62565 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _62565 + 68] = mem[idx + _62182 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_62565 + 68] = mem[_62565 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _62565 + -mem[64] + 100
                                        if stor26[msg.sender] < stor26[msg.sender]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 26
                                        stor26[address(msg.sender)] = stor26[msg.sender]
                                        _64952 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_64952] = 30
                                        mem[_64952 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor32:
                                            _65668 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _65668 + 68] = mem[idx + _64952 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_65668 + 68] = mem[_65668 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _65668 + -mem[64] + 100
                                        if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                        emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                        _67812 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_67812] = 26
                                        mem[_67812 + 32] = 'SafeMath: division by zero'
                                        if not sub_1b2cabba:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _67812 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not sub_8a3be0b6:
                                            if ethSent <= 0:
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            presaleTime = timeBetweenRounds + block.timestamp
                                            sub_8a3be0b6++
                                            _73071 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_73071] = 30
                                            mem[_73071 + 32] = 'SafeMath: subtraction overflow'
                                            if sub_be71ce9f <= sub_49a6a335:
                                                sub_49a6a335 -= sub_be71ce9f
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            _74059 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _74059 + 68] = mem[idx + _73071 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_74059 + 68] = mem[_74059 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _74059 + -mem[64] + 100
                                        if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                            if ethSent <= 0:
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            presaleTime = timeBetweenRounds + block.timestamp
                                            sub_8a3be0b6++
                                            _73574 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_73574] = 30
                                            mem[_73574 + 32] = 'SafeMath: subtraction overflow'
                                            if sub_be71ce9f <= sub_49a6a335:
                                                sub_49a6a335 -= sub_be71ce9f
                                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                                stor0 = 1
                                            _74574 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _74574 + 68] = mem[idx + _73574 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_74574 + 68] = mem[_74574 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _74574 + -mem[64] + 100
                                        if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                            revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _74058 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_74058] = 30
                                        mem[_74058 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _75148 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _75148 + 68] = mem[idx + _74058 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_75148 + 68] = mem[_75148 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _75148 + -mem[64] + 100
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _61439 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61439] = 30
                                    mem[_61439 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                        _61588 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _61588 + 68] = mem[idx + _61439 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_61588 + 68] = mem[_61588 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _61588 + -mem[64] + 100
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62374 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62374] = 30
                                    mem[_62374 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _62828 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62828 + 68] = mem[idx + _62374 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62828 + 68] = mem[_62828 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62828 + -mem[64] + 100
                                    if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                    _65325 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65325] = 30
                                    mem[_65325 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                        _65914 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _65914 + 68] = mem[idx + _65325 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_65914 + 68] = mem[_65914 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _65914 + -mem[64] + 100
                                    stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68113 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68113] = 26
                                    mem[_68113 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _68113 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73573 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73573] = 30
                                        mem[_73573 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74571 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74571 + 68] = mem[idx + _73573 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74571 + 68] = mem[_74571 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74571 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _74057 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_74057] = 30
                                        mem[_74057 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _75145 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _75145 + 68] = mem[idx + _74057 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_75145 + 68] = mem[_75145 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _75145 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74570 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74570] = 30
                                    mem[_74570 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75780 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75780 + 68] = mem[idx + _74570 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75780 + 68] = mem[_75780 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75780 + -mem[64] + 100
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61438 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61438] = 30
                                    mem[_61438 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                        _61585 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _61585 + 68] = mem[idx + _61438 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_61585 + 68] = mem[_61585 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _61585 + -mem[64] + 100
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62373 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62373] = 30
                                    mem[_62373 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                        _62825 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _62825 + 68] = mem[idx + _62373 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_62825 + 68] = mem[_62825 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _62825 + -mem[64] + 100
                                    stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                    if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                    _65324 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65324] = 30
                                    mem[_65324 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _65911 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _65911 + 68] = mem[idx + _65324 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_65911 + 68] = mem[_65911 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _65911 + -mem[64] + 100
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68112 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68112] = 26
                                    mem[_68112 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _68112 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _73570 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_73570] = 30
                                        mem[_73570 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _74567 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _74567 + 68] = mem[idx + _73570 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_74567 + 68] = mem[_74567 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _74567 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _74056 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_74056] = 30
                                        mem[_74056 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _75142 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _75142 + 68] = mem[idx + _74056 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_75142 + 68] = mem[_75142 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _75142 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74566 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74566] = 30
                                    mem[_74566 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75776 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75776 + 68] = mem[idx + _74566 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75776 + 68] = mem[_75776 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75776 + -mem[64] + 100
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61482 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61482] = 30
                                mem[_61482 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    _61703 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61703 + 68] = mem[idx + _61482 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61703 + 68] = mem[_61703 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61703 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62564 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62564] = 30
                                mem[_62564 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _63143 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63143 + 68] = mem[idx + _62564 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63143 + 68] = mem[_63143 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63143 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _65667 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65667] = 30
                                mem[_65667 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    _66091 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66091 + 68] = mem[idx + _65667 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66091 + 68] = mem[_66091 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66091 + -mem[64] + 100
                                stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68356 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68356] = 26
                                mem[_68356 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68356 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74055 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74055] = 30
                                    mem[_74055 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75139 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75139 + 68] = mem[idx + _74055 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75139 + 68] = mem[_75139 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75139 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74565 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74565] = 30
                                    mem[_74565 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75773 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75773 + 68] = mem[idx + _74565 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75773 + 68] = mem[_75773 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75773 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75138 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75138] = 30
                                mem[_75138 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76495 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76495 + 68] = mem[idx + _75138 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76495 + 68] = mem[_76495 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76495 + -mem[64] + 100
                            require idx < stor30.length
                            mem[0] = stor30[idx]
                            mem[32] = 27
                            if stor27[stor30[idx]] <= s:
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 26
                                _59641 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59641] = 30
                                mem[_59641 + 32] = 'SafeMath: subtraction overflow'
                                if stor26[stor30[idx]] > t:
                                    _59846 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _59846 + 68] = mem[idx + _59641 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59846 + 68] = mem[_59846 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59846 + -mem[64] + 100
                                require idx < stor30.length
                                mem[0] = stor30[idx]
                                mem[32] = 27
                                _60586 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_60586] = 30
                                mem[_60586 + 32] = 'SafeMath: subtraction overflow'
                                if stor27[stor30[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor27[stor30[idx]]
                                    t = t - stor26[stor30[idx]]
                                    continue 
                                _60913 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _60913 + 68] = mem[idx + _60586 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_60913 + 68] = mem[_60913 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _60913 + -mem[64] + 100
                            _59743 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59743] = 26
                            mem[_59743 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _59743 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61485 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61485] = 30
                                    mem[_61485 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _62574 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_62574] = 30
                                    mem[_62574 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        _63150 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _63150 + 68] = mem[idx + _62574 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_63150 + 68] = mem[_63150 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _63150 + -mem[64] + 100
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _65672 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_65672] = 30
                                    mem[_65672 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        _66096 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _66096 + 68] = mem[idx + _65672 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_66096 + 68] = mem[_66096 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _66096 + -mem[64] + 100
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68362 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68362] = 26
                                    mem[_68362 + 32] = 'SafeMath: division by zero'
                                    if not sub_1b2cabba:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _68362 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _74070 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_74070] = 30
                                        mem[_74070 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _75158 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _75158 + 68] = mem[idx + _74070 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_75158 + 68] = mem[_75158 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _75158 + -mem[64] + 100
                                    if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        if ethSent <= 0:
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        if timeBetweenRounds + block.timestamp < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        presaleTime = timeBetweenRounds + block.timestamp
                                        sub_8a3be0b6++
                                        _74585 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_74585] = 30
                                        mem[_74585 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_be71ce9f <= sub_49a6a335:
                                            sub_49a6a335 -= sub_be71ce9f
                                            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                            stor0 = 1
                                        _75798 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _75798 + 68] = mem[idx + _74585 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_75798 + 68] = mem[_75798 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _75798 + -mem[64] + 100
                                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75157 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75157] = 30
                                    mem[_75157 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76525 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76525 + 68] = mem[idx + _75157 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76525 + 68] = mem[_76525 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76525 + -mem[64] + 100
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _61592 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61592] = 30
                                mem[_61592 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                    _61840 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61840 + 68] = mem[idx + _61592 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61840 + 68] = mem[_61840 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61840 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62834 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62834] = 30
                                mem[_62834 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor26[address(this.address)]:
                                    _63456 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63456 + 68] = mem[idx + _62834 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63456 + 68] = mem[_63456 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63456 + -mem[64] + 100
                                if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                _65918 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65918] = 30
                                mem[_65918 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                    _66294 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66294 + 68] = mem[idx + _65918 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66294 + 68] = mem[_66294 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66294 + -mem[64] + 100
                                stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68603 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68603] = 26
                                mem[_68603 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68603 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74584 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74584] = 30
                                    mem[_74584 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75795 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75795 + 68] = mem[idx + _74584 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75795 + 68] = mem[_75795 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75795 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75156 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75156] = 30
                                    mem[_75156 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76522 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76522 + 68] = mem[idx + _75156 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76522 + 68] = mem[_76522 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76522 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75794 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75794] = 30
                                mem[_75794 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77386 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77386 + 68] = mem[idx + _75794 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77386 + 68] = mem[_77386 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77386 + -mem[64] + 100
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                _61591 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_61591] = 30
                                mem[_61591 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                    _61837 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _61837 + 68] = mem[idx + _61591 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_61837 + 68] = mem[_61837 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _61837 + -mem[64] + 100
                                mem[0] = this.address
                                mem[32] = 26
                                _62833 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_62833] = 30
                                mem[_62833 + 32] = 'SafeMath: subtraction overflow'
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                    _63453 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _63453 + 68] = mem[idx + _62833 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_63453 + 68] = mem[_63453 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _63453 + -mem[64] + 100
                                stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = msg.sender
                                mem[32] = 26
                                stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                _65917 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_65917] = 30
                                mem[_65917 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor32:
                                    _66291 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _66291 + 68] = mem[idx + _65917 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_66291 + 68] = mem[_66291 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _66291 + -mem[64] + 100
                                if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                    revert with 0, 'SafeMath: addition overflow'
                                _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                _68602 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_68602] = 26
                                mem[_68602 + 32] = 'SafeMath: division by zero'
                                if not sub_1b2cabba:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _68602 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _74581 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_74581] = 30
                                    mem[_74581 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _75791 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _75791 + 68] = mem[idx + _74581 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_75791 + 68] = mem[_75791 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _75791 + -mem[64] + 100
                                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    if ethSent <= 0:
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    if timeBetweenRounds + block.timestamp < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    presaleTime = timeBetweenRounds + block.timestamp
                                    sub_8a3be0b6++
                                    _75155 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_75155] = 30
                                    mem[_75155 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_be71ce9f <= sub_49a6a335:
                                        sub_49a6a335 -= sub_be71ce9f
                                        emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                        stor0 = 1
                                    _76519 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _76519 + 68] = mem[idx + _75155 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_76519 + 68] = mem[_76519 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _76519 + -mem[64] + 100
                                if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75790 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75790] = 30
                                mem[_75790 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77382 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77382 + 68] = mem[idx + _75790 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77382 + 68] = mem[_77382 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77382 + -mem[64] + 100
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _61706 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_61706] = 30
                            mem[_61706 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                _61967 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _61967 + 68] = mem[idx + _61706 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_61967 + 68] = mem[_61967 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _61967 + -mem[64] + 100
                            mem[0] = this.address
                            mem[32] = 26
                            _63149 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_63149] = 30
                            mem[_63149 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                _63797 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _63797 + 68] = mem[idx + _63149 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_63797 + 68] = mem[_63797 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _63797 + -mem[64] + 100
                            stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                            if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = msg.sender
                            mem[32] = 26
                            stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                            _66095 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_66095] = 30
                            mem[_66095 + 32] = 'SafeMath: subtraction overflow'
                            if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                _66573 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _66573 + 68] = mem[idx + _66095 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_66573 + 68] = mem[_66573 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _66573 + -mem[64] + 100
                            stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                revert with 0, 'SafeMath: addition overflow'
                            _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                            emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                            _68835 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_68835] = 26
                            mem[_68835 + 32] = 'SafeMath: division by zero'
                            if not sub_1b2cabba:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _68835 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75154 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75154] = 30
                                mem[_75154 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _76516 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _76516 + 68] = mem[idx + _75154 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_76516 + 68] = mem[_76516 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _76516 + -mem[64] + 100
                            if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                if ethSent <= 0:
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                if timeBetweenRounds + block.timestamp < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                presaleTime = timeBetweenRounds + block.timestamp
                                sub_8a3be0b6++
                                _75789 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_75789] = 30
                                mem[_75789 + 32] = 'SafeMath: subtraction overflow'
                                if sub_be71ce9f <= sub_49a6a335:
                                    sub_49a6a335 -= sub_be71ce9f
                                    emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                    stor0 = 1
                                _77379 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _77379 + 68] = mem[idx + _75789 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_77379 + 68] = mem[_77379 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _77379 + -mem[64] + 100
                            if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                                revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ethSent <= 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            if timeBetweenRounds + block.timestamp < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            presaleTime = timeBetweenRounds + block.timestamp
                            sub_8a3be0b6++
                            _76515 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_76515] = 30
                            mem[_76515 + 32] = 'SafeMath: subtraction overflow'
                            if sub_be71ce9f <= sub_49a6a335:
                                sub_49a6a335 -= sub_be71ce9f
                                emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
                                stor0 = 1
                            _78270 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _78270 + 68] = mem[idx + _76515 + 32]
                                idx = idx + 32
                                continue 
                            mem[_78270 + 68] = mem[_78270 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _78270 + -mem[64] + 100
                        _58323 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_58323] = 26
                        mem[_58323 + 32] = 'SafeMath: division by zero'
                        if not _tTotal:
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor32 / _tTotal:
                            _59983 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59983] = 26
                            mem[_59983 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61699 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61699] = 30
                                    mem[_61699 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63135 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63135] = 30
                                    mem[_63135 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _66088 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66088] = 30
                                    mem[_66088 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68824 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68824] = 26
                                    mem[_68824 + 32] = 'SafeMath: division by zero'
                                else:
                                    if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != t / s:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _61832 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61832] = 30
                                    mem[_61832 + 32] = 'SafeMath: subtraction overflow'
                                    if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63440 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63440] = 30
                                    mem[_63440 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (-1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (-1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                    _66284 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66284] = 30
                                    mem[_66284 + 32] = 'SafeMath: subtraction overflow'
                                    if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor32 += -1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _69078 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_69078] = 26
                                    mem[_69078 + 32] = 'SafeMath: division by zero'
                            else:
                                if t / s * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != t / s:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61831 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61831] = 30
                                    mem[_61831 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > t / s * sub_49a6a335 * msg.value / 10^9:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63439 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63439] = 30
                                    mem[_63439 + 32] = 'SafeMath: subtraction overflow'
                                    if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                                    if (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                    _66283 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66283] = 30
                                    mem[_66283 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _69077 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_69077] = 26
                                    mem[_69077 + 32] = 'SafeMath: division by zero'
                                else:
                                    if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != t / s:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _61959 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61959] = 30
                                    mem[_61959 + 32] = 'SafeMath: subtraction overflow'
                                    if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > t / s * sub_49a6a335 * msg.value / 10^9:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63779 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63779] = 30
                                    mem[_63779 + 32] = 'SafeMath: subtraction overflow'
                                    if t / s * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor26[address(this.address)] += -1 * t / s * sub_49a6a335 * msg.value / 10^9
                                    if (t / s * sub_49a6a335 * msg.value / 10^9) - (t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (t / s * sub_49a6a335 * msg.value / 10^9) - (t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                    _66557 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66557] = 30
                                    mem[_66557 + 32] = 'SafeMath: subtraction overflow'
                                    if t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor32 += -1 * t / s * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _69393 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_69393] = 26
                                    mem[_69393 + 32] = 'SafeMath: division by zero'
                        else:
                            _59984 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_59984] = 26
                            mem[_59984 + 32] = 'SafeMath: division by zero'
                            if not _tTotal:
                                revert with 0, 'SafeMath: division by zero'
                            if not sub_49a6a335 * msg.value / 10^9:
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61702 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61702] = 30
                                    mem[_61702 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63142 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63142] = 30
                                    mem[_63142 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = stor26[msg.sender]
                                    _66090 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66090] = 30
                                    mem[_66090 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _68827 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_68827] = 26
                                    mem[_68827 + 32] = 'SafeMath: division by zero'
                                else:
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _61834 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61834] = 30
                                    mem[_61834 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63444 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63444] = 30
                                    mem[_63444 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (-1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                    _66286 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66286] = 30
                                    mem[_66286 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _69080 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_69080] = 26
                                    mem[_69080 + 32] = 'SafeMath: division by zero'
                            else:
                                if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 / sub_49a6a335 * msg.value / 10^9 != stor32 / _tTotal:
                                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 2 * sub_49a6a335 * msg.value / 10^9 / 50:
                                    _61833 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61833] = 30
                                    mem[_61833 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63443 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63443] = 30
                                    mem[_63443 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                    if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) + stor26[msg.sender]
                                    _66285 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66285] = 30
                                    mem[_66285 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _69079 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_69079] = 26
                                    mem[_69079 + 32] = 'SafeMath: division by zero'
                                else:
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 / 2 * sub_49a6a335 * msg.value / 10^9 / 50 != stor32 / _tTotal:
                                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _61960 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_61960] = 30
                                    mem[_61960 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = this.address
                                    mem[32] = 26
                                    _63783 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_63783] = 30
                                    mem[_63783 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9 > stor26[address(this.address)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor26[address(this.address)] += -1 * stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9
                                    if (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender] < stor26[msg.sender]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 26
                                    stor26[address(msg.sender)] = (stor32 / _tTotal * sub_49a6a335 * msg.value / 10^9) - (stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50) + stor26[msg.sender]
                                    _66561 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_66561] = 30
                                    mem[_66561 + 32] = 'SafeMath: subtraction overflow'
                                    if stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50 > stor32:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor32 += -1 * stor32 / _tTotal * 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    if (2 * sub_49a6a335 * msg.value / 10^9 / 50) + _tFeeTotal < _tFeeTotal:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _tFeeTotal += 2 * sub_49a6a335 * msg.value / 10^9 / 50
                                    emit Transfer(((sub_49a6a335 * msg.value / 10^9) - (2 * sub_49a6a335 * msg.value / 10^9 / 50)), this.address, msg.sender);
                                    _69397 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_69397] = 26
                                    mem[_69397 + 32] = 'SafeMath: division by zero'
            if not sub_1b2cabba:
                revert with 0, 'SafeMath: division by zero'
            if not sub_8a3be0b6:
                if ethSent > 0:
                    if timeBetweenRounds + block.timestamp < block.timestamp:
                        revert with 0, 'SafeMath: addition overflow'
                    presaleTime = timeBetweenRounds + block.timestamp
                    sub_8a3be0b6++
                    if sub_be71ce9f > sub_49a6a335:
                        revert with 0, 'SafeMath: subtraction overflow'
                    sub_49a6a335 -= sub_be71ce9f
            else:
                if presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / sub_8a3be0b6 != presaleHardcap / sub_1b2cabba:
                    revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                    if ethSent > 0:
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        if sub_be71ce9f > sub_49a6a335:
                            revert with 0, 'SafeMath: subtraction overflow'
                        sub_49a6a335 -= sub_be71ce9f
                else:
                    if 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6 / presaleHardcap / sub_1b2cabba * sub_8a3be0b6 != 10^18:
                        revert with 0, 32, 33, 0x2e536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if ethSent > 10^18 * presaleHardcap / sub_1b2cabba * sub_8a3be0b6:
                        if timeBetweenRounds + block.timestamp < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        presaleTime = timeBetweenRounds + block.timestamp
                        sub_8a3be0b6++
                        if sub_be71ce9f > sub_49a6a335:
                            revert with 0, 'SafeMath: subtraction overflow'
                        sub_49a6a335 -= sub_be71ce9f
            emit Transfer((sub_49a6a335 * msg.value / 10^9), this.address, msg.sender);
    stor0 = 1
}



}
