contract main {




// =====================  Runtime code  =====================


#
#  - transferFrom(address arg1, address arg2, uint256 arg3)
#  - deliver(uint256 arg1)
#  - transfer(address arg1, uint256 arg2)
#
const name = 'BITCONNEEEEEEEEEEEEEEEEEEEEEECT', 0

const decimals = 9

const symbol = 'MH MH MH NO NO NO', 0


address owner;
mapping of uint256 stor1;
mapping of uint256 stor2;
mapping of uint256 allowance;
mapping of uint8 stor4;
mapping of uint8 stor5;
array of address stor6;
array of address stor7;
uint256 totalSupply;
uint256 stor9;
uint256 totalFees;
uint256 totalBurn;
uint256 totalCharity;
uint256 stor13;
uint256 stor14;
uint256 stor15;

function totalFees() payable {
    return totalFees
}

function totalSupply() payable {
    return totalSupply
}

function totalBurn() payable {
    return totalBurn
}

function owner() payable {
    return owner
}

function isExcluded(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor4[address(arg1)])
}

function totalCharity() payable {
    return totalCharity
}

function allowance(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return allowance[address(arg1)][address(arg2)]
}

function isCharity(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor5[address(arg1)])
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function approve(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function setAsCharityAccount(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 == 0x7a250d5630b4cf539739df2c5dacb4c659f2488d:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The Uniswap router can not be the charity account.'
    if stor5[address(arg1)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Account is already charity account'
    stor5[address(arg1)] = 1
    stor7.length++
    stor7[stor7.length] = arg1
}

function decreaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if arg2 > allowance[msg.sender][address(arg1)]:
        revert with 0, 32, 37, 0x6542455032303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572, mem[165 len 27] >> 40, 0
    if allowance[msg.sender][address(arg1)] < arg2:
        revert with 0, 17
    if not msg.sender:
        revert with 0, 'BEP20: approve from the zero address'
    if not arg1:
        revert with 0, 'BEP20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] - arg2
    emit Approval((allowance[msg.sender][address(arg1)] - arg2), msg.sender, arg1);
    return 1
}

function increaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if allowance[msg.sender][address(arg1)] > !arg2:
        revert with 0, 17
    if allowance[msg.sender][address(arg1)] + arg2 < allowance[msg.sender][address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] + arg2
    emit Approval((allowance[msg.sender][address(arg1)] + arg2), msg.sender, arg1);
    return 1
}

function includeAccount(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not stor4[address(arg1)]:
        revert with 0, 'Account is already excluded'
    idx = 0
    while idx < stor6.length:
        mem[0] = 6
        if stor6[idx] != arg1:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if stor6.length < 1:
            revert with 0, 17
        if stor6.length - 1 >= stor6.length:
            revert with 0, 50
        if idx >= stor6.length:
            revert with 0, 50
        stor6[idx] = stor6[stor6.length]
        stor2[address(arg1)] = 0
        stor4[address(arg1)] = 0
        if not stor6.length:
            revert with 0, 49
        stor6[stor6.length] = 0
        stor6.length--
}

function tokenFromReflection(uint256 arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if arg1 > stor9:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = totalSupply
    t = stor9
    while idx < stor6.length:
        mem[0] = stor6[idx]
        mem[32] = 1
        if stor1[stor6[idx]] > t:
            _92 = mem[64]
            mem[64] = mem[64] + 64
            mem[_92] = 26
            mem[_92 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _96 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _96 + 68] = mem[idx + _92 + 32]
                    idx = idx + 32
                    continue 
                mem[_96 + 94] = 0
                revert with memory
                  from mem[64]
                   len _96 + -mem[64] + 100
            _117 = mem[64]
            mem[64] = mem[64] + 64
            mem[_117] = 26
            mem[_117 + 32] = 'SafeMath: division by zero'
            if stor9 / totalSupply:
                return (arg1 / stor9 / totalSupply)
            _126 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _126 + 68] = mem[idx + _117 + 32]
                idx = idx + 32
                continue 
            mem[_126 + 94] = 0
            revert with memory
              from mem[64]
               len _126 + -mem[64] + 100
        if idx >= stor6.length:
            revert with 0, 50
        mem[0] = stor6[idx]
        mem[32] = 2
        if stor2[stor6[idx]] > s:
            _98 = mem[64]
            mem[64] = mem[64] + 64
            mem[_98] = 26
            mem[_98 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _103 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _103 + 68] = mem[idx + _98 + 32]
                    idx = idx + 32
                    continue 
                mem[_103 + 94] = 0
                revert with memory
                  from mem[64]
                   len _103 + -mem[64] + 100
            _128 = mem[64]
            mem[64] = mem[64] + 64
            mem[_128] = 26
            mem[_128 + 32] = 'SafeMath: division by zero'
            if stor9 / totalSupply:
                return (arg1 / stor9 / totalSupply)
            _133 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _133 + 68] = mem[idx + _128 + 32]
                idx = idx + 32
                continue 
            mem[_133 + 94] = 0
            revert with memory
              from mem[64]
               len _133 + -mem[64] + 100
        if idx >= stor6.length:
            revert with 0, 50
        mem[0] = stor6[idx]
        mem[32] = 1
        _97 = mem[64]
        mem[64] = mem[64] + 64
        mem[_97] = 30
        mem[_97 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor6[idx]] > t:
            _102 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _102 + 68] = mem[idx + _97 + 32]
                idx = idx + 32
                continue 
            mem[_102 + 98] = 0
            revert with memory
              from mem[64]
               len _102 + -mem[64] + 100
        if t < stor1[stor6[idx]]:
            revert with 0, 17
        if idx >= stor6.length:
            revert with 0, 50
        mem[0] = stor6[idx]
        mem[32] = 2
        _127 = mem[64]
        mem[64] = mem[64] + 64
        mem[_127] = 30
        mem[_127 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor6[idx]] <= s:
            if s < stor2[stor6[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor2[stor6[idx]]
            t = t - stor1[stor6[idx]]
            continue 
        _132 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _132 + 68] = mem[idx + _127 + 32]
            idx = idx + 32
            continue 
        mem[_132 + 98] = 0
        revert with memory
          from mem[64]
           len _132 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if t >= stor9 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not t / s:
            revert with 0, 'SafeMath: division by zero', 0
        return (arg1 / t / s)
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not stor9 / totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    return (arg1 / stor9 / totalSupply)
}

function balanceOf(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor4[address(arg1)]:
        return stor2[address(arg1)]
    mem[0] = arg1
    mem[32] = 1
    if stor1[address(arg1)] > stor9:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = totalSupply
    t = stor9
    while idx < stor6.length:
        mem[0] = stor6[idx]
        mem[32] = 1
        if stor1[stor6[idx]] > t:
            _97 = mem[64]
            mem[64] = mem[64] + 64
            mem[_97] = 26
            mem[_97 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _101 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _101 + 68] = mem[idx + _97 + 32]
                    idx = idx + 32
                    continue 
                mem[_101 + 94] = 0
                revert with memory
                  from mem[64]
                   len _101 + -mem[64] + 100
            _122 = mem[64]
            mem[64] = mem[64] + 64
            mem[_122] = 26
            mem[_122 + 32] = 'SafeMath: division by zero'
            if stor9 / totalSupply:
                return (stor1[address(arg1)] / stor9 / totalSupply)
            _131 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _131 + 68] = mem[idx + _122 + 32]
                idx = idx + 32
                continue 
            mem[_131 + 94] = 0
            revert with memory
              from mem[64]
               len _131 + -mem[64] + 100
        if idx >= stor6.length:
            revert with 0, 50
        mem[0] = stor6[idx]
        mem[32] = 2
        if stor2[stor6[idx]] > s:
            _103 = mem[64]
            mem[64] = mem[64] + 64
            mem[_103] = 26
            mem[_103 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _108 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _108 + 68] = mem[idx + _103 + 32]
                    idx = idx + 32
                    continue 
                mem[_108 + 94] = 0
                revert with memory
                  from mem[64]
                   len _108 + -mem[64] + 100
            _133 = mem[64]
            mem[64] = mem[64] + 64
            mem[_133] = 26
            mem[_133 + 32] = 'SafeMath: division by zero'
            if stor9 / totalSupply:
                return (stor1[address(arg1)] / stor9 / totalSupply)
            _138 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _138 + 68] = mem[idx + _133 + 32]
                idx = idx + 32
                continue 
            mem[_138 + 94] = 0
            revert with memory
              from mem[64]
               len _138 + -mem[64] + 100
        if idx >= stor6.length:
            revert with 0, 50
        mem[0] = stor6[idx]
        mem[32] = 1
        _102 = mem[64]
        mem[64] = mem[64] + 64
        mem[_102] = 30
        mem[_102 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor6[idx]] > t:
            _107 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _107 + 68] = mem[idx + _102 + 32]
                idx = idx + 32
                continue 
            mem[_107 + 98] = 0
            revert with memory
              from mem[64]
               len _107 + -mem[64] + 100
        if t < stor1[stor6[idx]]:
            revert with 0, 17
        if idx >= stor6.length:
            revert with 0, 50
        mem[0] = stor6[idx]
        mem[32] = 2
        _132 = mem[64]
        mem[64] = mem[64] + 64
        mem[_132] = 30
        mem[_132 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor6[idx]] <= s:
            if s < stor2[stor6[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor2[stor6[idx]]
            t = t - stor1[stor6[idx]]
            continue 
        _137 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _137 + 68] = mem[idx + _132 + 32]
            idx = idx + 32
            continue 
        mem[_137 + 98] = 0
        revert with memory
          from mem[64]
           len _137 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if t >= stor9 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not t / s:
            revert with 0, 'SafeMath: division by zero', 0
        return (stor1[address(arg1)] / t / s)
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not stor9 / totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    return (stor1[address(arg1)] / stor9 / totalSupply)
}

function excludeAccount(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 == 0x7a250d5630b4cf539739df2c5dacb4c659f2488d:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'We can not exclude Uniswap router.'
    if stor4[address(arg1)]:
        revert with 0, 'Account is already excluded'
    if stor1[address(arg1)]:
        mem[0] = arg1
        mem[32] = 1
        if stor1[address(arg1)] > stor9:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
        idx = 0
        s = totalSupply
        t = stor9
        while idx < stor6.length:
            mem[0] = stor6[idx]
            mem[32] = 1
            if stor1[stor6[idx]] > t:
                _102 = mem[64]
                mem[64] = mem[64] + 64
                mem[_102] = 26
                mem[_102 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _106 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _106 + 68] = mem[idx + _102 + 32]
                        idx = idx + 32
                        continue 
                    mem[_106 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _106 + -mem[64] + 100
                _127 = mem[64]
                mem[64] = mem[64] + 64
                mem[_127] = 26
                mem[_127 + 32] = 'SafeMath: division by zero'
                if stor9 / totalSupply:
                    stor2[address(arg1)] = stor1[address(arg1)] / stor9 / totalSupply
                    stor4[address(arg1)] = 1
                    stor6.length++
                    stor6[stor6.length] = arg1
                _136 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _136 + 68] = mem[idx + _127 + 32]
                    idx = idx + 32
                    continue 
                mem[_136 + 94] = 0
                revert with memory
                  from mem[64]
                   len _136 + -mem[64] + 100
            if idx >= stor6.length:
                revert with 0, 50
            mem[0] = stor6[idx]
            mem[32] = 2
            if stor2[stor6[idx]] > s:
                _108 = mem[64]
                mem[64] = mem[64] + 64
                mem[_108] = 26
                mem[_108 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _113 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _113 + 68] = mem[idx + _108 + 32]
                        idx = idx + 32
                        continue 
                    mem[_113 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _113 + -mem[64] + 100
                _138 = mem[64]
                mem[64] = mem[64] + 64
                mem[_138] = 26
                mem[_138 + 32] = 'SafeMath: division by zero'
                if stor9 / totalSupply:
                    stor2[address(arg1)] = stor1[address(arg1)] / stor9 / totalSupply
                    stor4[address(arg1)] = 1
                    stor6.length++
                    stor6[stor6.length] = arg1
                _143 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _143 + 68] = mem[idx + _138 + 32]
                    idx = idx + 32
                    continue 
                mem[_143 + 94] = 0
                revert with memory
                  from mem[64]
                   len _143 + -mem[64] + 100
            if idx >= stor6.length:
                revert with 0, 50
            mem[0] = stor6[idx]
            mem[32] = 1
            _107 = mem[64]
            mem[64] = mem[64] + 64
            mem[_107] = 30
            mem[_107 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor6[idx]] > t:
                _112 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _112 + 68] = mem[idx + _107 + 32]
                    idx = idx + 32
                    continue 
                mem[_112 + 98] = 0
                revert with memory
                  from mem[64]
                   len _112 + -mem[64] + 100
            if t < stor1[stor6[idx]]:
                revert with 0, 17
            if idx >= stor6.length:
                revert with 0, 50
            mem[0] = stor6[idx]
            mem[32] = 2
            _137 = mem[64]
            mem[64] = mem[64] + 64
            mem[_137] = 30
            mem[_137 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor6[idx]] <= s:
                if s < stor2[stor6[idx]]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s - stor2[stor6[idx]]
                t = t - stor1[stor6[idx]]
                continue 
            _142 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _142 + 68] = mem[idx + _137 + 32]
                idx = idx + 32
                continue 
            mem[_142 + 98] = 0
            revert with memory
              from mem[64]
               len _142 + -mem[64] + 100
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if t >= stor9 / totalSupply:
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not t / s:
                revert with 0, 'SafeMath: division by zero', 0
            stor2[address(arg1)] = stor1[address(arg1)] / t / s
        else:
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not stor9 / totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            stor2[address(arg1)] = stor1[address(arg1)] / stor9 / totalSupply
    stor4[address(arg1)] = 1
    stor6.length++
    stor6[stor6.length] = arg1
}

function reflectionFromToken(uint256 arg1, bool arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if arg1 > totalSupply:
        revert with 0, 'Amount must be less than supply'
    if arg2:
        if not arg1:
            mem[96] = 26
            mem[128] = 'SafeMath: division by zero'
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if not arg1:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[288] = 26
                mem[320] = 'SafeMath: division by zero'
                if not arg1:
                    mem[352] = 26
                    mem[384] = 'SafeMath: division by zero'
                    mem[416] = 26
                    mem[448] = 'SafeMath: division by zero'
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 0, 17
                    mem[544] = 30
                    mem[576] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 0, 17
                    mem[64] = 672
                    mem[608] = 30
                    mem[640] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 0, 17
                    idx = 0
                    s = totalSupply
                    t = stor9
                    while idx < stor6.length:
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        if stor1[stor6[idx]] > t:
                            _9226 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9226] = 26
                            mem[_9226 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _9304 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _9304 + 68] = mem[idx + _9226 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_9304 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _9304 + -mem[64] + 100
                            if not arg1:
                                return 0
                            if arg1 and stor9 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10272 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10272] = 30
                            mem[_10272 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10430 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10430 + 68] = mem[idx + _10272 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10430 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10430 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _11025 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11025] = 30
                            mem[_11025 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11332 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11332 + 68] = mem[idx + _11025 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11332 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11332 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12575 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12575] = 30
                            mem[_12575 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _13064 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13064 + 68] = mem[idx + _12575 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13064 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13064 + -mem[64] + 100
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        if stor2[stor6[idx]] <= s:
                            if idx >= stor6.length:
                                revert with 0, 50
                            mem[0] = stor6[idx]
                            mem[32] = 1
                            _9305 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9305] = 30
                            mem[_9305 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor6[idx]] > t:
                                _9385 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _9385 + 68] = mem[idx + _9305 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_9385 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _9385 + -mem[64] + 100
                            if t < stor1[stor6[idx]]:
                                revert with 0, 17
                            if idx >= stor6.length:
                                revert with 0, 50
                            mem[0] = stor6[idx]
                            mem[32] = 2
                            _9738 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9738] = 30
                            mem[_9738 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor6[idx]] <= s:
                                if s < stor2[stor6[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor6[idx]]
                                t = t - stor1[stor6[idx]]
                                continue 
                            _9786 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9786 + 68] = mem[idx + _9738 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9786 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9786 + -mem[64] + 100
                        _9306 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9306] = 26
                        mem[_9306 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9386 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9386 + 68] = mem[idx + _9306 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9386 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9386 + -mem[64] + 100
                        if not arg1:
                            return 0
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10432 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10432] = 30
                        mem[_10432 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10549 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10549 + 68] = mem[idx + _10432 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10549 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10549 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11334 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11334] = 30
                        mem[_11334 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11689 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11689 + 68] = mem[idx + _11334 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11689 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11689 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13065 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13065] = 30
                        mem[_13065 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _13544 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13544 + 68] = mem[idx + _13065 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13544 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13544 + -mem[64] + 100
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if t >= stor9 / totalSupply:
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg1:
                            return 0
                        if arg1 and t / s > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * t / s / arg1 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        return 0
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor9 / totalSupply)
                if arg1 and stor15 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / arg1 != stor15:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9225 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9225] = 26
                        mem[_9225 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9301 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9301 + 68] = mem[idx + _9225 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9301 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9301 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor15 / 100 / 100:
                                return 0
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10268 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10268] = 30
                            mem[_10268 + 32] = 'SafeMath: subtraction overflow'
                            _11019 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11019] = 30
                            mem[_11019 + 32] = 'SafeMath: subtraction overflow'
                            _12568 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12568] = 30
                            mem[_12568 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                            _13059 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13059 + 68] = mem[idx + _12568 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13059 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13059 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _10267 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10267] = 30
                            mem[_10267 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10426 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10426 + 68] = mem[idx + _10267 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10426 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10426 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _11017 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11017] = 30
                            mem[_11017 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11326 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11326 + 68] = mem[idx + _11017 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11326 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11326 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12566 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12566] = 30
                            mem[_12566 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _13058 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13058 + 68] = mem[idx + _12566 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13058 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13058 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10743 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10743] = 30
                        mem[_10743 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11016 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11016 + 68] = mem[idx + _10743 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11016 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11016 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12099 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12099] = 30
                        mem[_12099 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _12565 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12565 + 68] = mem[idx + _12099 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12565 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12565 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _14107 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14107] = 30
                        mem[_14107 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                        _14666 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14666 + 68] = mem[idx + _14107 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14666 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14666 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9302 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9302] = 30
                        mem[_9302 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9382 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9382 + 68] = mem[idx + _9302 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9382 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9382 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9735 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9735] = 30
                        mem[_9735 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _9783 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9783 + 68] = mem[idx + _9735 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9783 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9783 + -mem[64] + 100
                    _9303 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9303] = 26
                    mem[_9303 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9383 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9383 + 68] = mem[idx + _9303 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9383 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9383 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10429 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10429] = 30
                        mem[_10429 + 32] = 'SafeMath: subtraction overflow'
                        _11331 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11331] = 30
                        mem[_11331 + 32] = 'SafeMath: subtraction overflow'
                        _13063 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13063] = 30
                        mem[_13063 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                            if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                        _13543 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13543 + 68] = mem[idx + _13063 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13543 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13543 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _10428 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10428] = 30
                        mem[_10428 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10547 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10547 + 68] = mem[idx + _10428 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10547 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10547 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11329 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11329] = 30
                        mem[_11329 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11687 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11687 + 68] = mem[idx + _11329 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11687 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11687 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13061 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13061] = 30
                        mem[_13061 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _13542 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13542 + 68] = mem[idx + _13061 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13542 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13542 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11020 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11020] = 30
                    mem[_11020 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11328 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11328 + 68] = mem[idx + _11020 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11328 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11328 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _12569 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12569] = 30
                    mem[_12569 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _13060 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13060 + 68] = mem[idx + _12569 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13060 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13060 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _14669 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14669] = 30
                    mem[_14669 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                        if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _15161 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15161 + 68] = mem[idx + _14669 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15161 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15161 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor9 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor15 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor15 / 100 / 100 * t / s:
                            revert with 0, 17
                        return (-1 * arg1 * stor15 / 100 / 100 * t / s)
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * stor15 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor15 / 100 / 100:
                        return 0
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor9 / totalSupply)
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            if arg1 and stor14 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor14 / arg1 != stor14:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor14 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor14 / 100 / 100) < 0:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9224 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9224] = 26
                        mem[_9224 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9298 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9298 + 68] = mem[idx + _9224 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9298 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9298 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor14 / 100 / 100:
                                return 0
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10264 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10264] = 30
                            mem[_10264 + 32] = 'SafeMath: subtraction overflow'
                            _11010 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11010] = 30
                            mem[_11010 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _11318 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11318 + 68] = mem[idx + _11010 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11318 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11318 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _12557 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12557] = 30
                            mem[_12557 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                            _13052 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13052 + 68] = mem[idx + _12557 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13052 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13052 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            _10263 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10263] = 30
                            mem[_10263 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10421 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10421 + 68] = mem[idx + _10263 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10421 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10421 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _11008 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11008] = 30
                            mem[_11008 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11317 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11317 + 68] = mem[idx + _11008 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11317 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11317 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12555 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12555] = 30
                            mem[_12555 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _13051 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13051 + 68] = mem[idx + _12555 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13051 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13051 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10738 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10738] = 30
                        mem[_10738 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11007 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11007 + 68] = mem[idx + _10738 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11007 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11007 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12089 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12089] = 30
                        mem[_12089 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _12554 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12554 + 68] = mem[idx + _12089 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12554 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12554 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _14096 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14096] = 30
                        mem[_14096 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                        _14656 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14656 + 68] = mem[idx + _14096 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14656 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14656 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9299 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9299] = 30
                        mem[_9299 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9379 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9379 + 68] = mem[idx + _9299 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9379 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9379 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9732 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9732] = 30
                        mem[_9732 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _9780 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9780 + 68] = mem[idx + _9732 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9780 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9780 + -mem[64] + 100
                    _9300 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9300] = 26
                    mem[_9300 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9380 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9380 + 68] = mem[idx + _9300 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9380 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9380 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor14 / 100 / 100:
                            return 0
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10425 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10425] = 30
                        mem[_10425 + 32] = 'SafeMath: subtraction overflow'
                        _11323 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11323] = 30
                        mem[_11323 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            _11683 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11683 + 68] = mem[idx + _11323 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11683 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11683 + -mem[64] + 100
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _13056 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13056] = 30
                        mem[_13056 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                        _13537 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13537 + 68] = mem[idx + _13056 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13537 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13537 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        _10424 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10424] = 30
                        mem[_10424 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10542 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10542 + 68] = mem[idx + _10424 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10542 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10542 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11321 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11321] = 30
                        mem[_11321 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11682 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11682 + 68] = mem[idx + _11321 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11682 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11682 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13054 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13054] = 30
                        mem[_13054 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _13536 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13536 + 68] = mem[idx + _13054 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13536 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13536 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11011 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11011] = 30
                    mem[_11011 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11320 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11320 + 68] = mem[idx + _11011 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11320 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11320 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _12559 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12559] = 30
                    mem[_12559 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _13053 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13053 + 68] = mem[idx + _12559 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13053 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13053 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _14659 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14659] = 30
                    mem[_14659 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                    _15158 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15158 + 68] = mem[idx + _14659 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15158 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15158 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor9 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * stor14 / 100 / 100:
                            return 0
                        if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor14 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor14 / 100 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor14 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor14 / 100 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * stor14 / 100 / 100 * t / s)
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s))
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor14 / 100 / 100:
                        return 0
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor9 / totalSupply)
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
            if arg1 and stor15 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor15 / arg1 != stor15:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[352] = 26
            mem[384] = 'SafeMath: division by zero'
            mem[416] = 26
            mem[448] = 'SafeMath: division by zero'
            mem[480] = 30
            mem[512] = 'SafeMath: subtraction overflow'
            if 0 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < 0:
                revert with 0, 17
            mem[544] = 30
            mem[576] = 'SafeMath: subtraction overflow'
            if arg1 * stor14 / 100 / 100 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * stor14 / 100 / 100:
                revert with 0, 17
            mem[64] = 672
            mem[608] = 30
            mem[640] = 'SafeMath: subtraction overflow'
            if arg1 * stor15 / 100 / 100 > arg1 - (arg1 * stor14 / 100 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * stor14 / 100 / 100) < arg1 * stor15 / 100 / 100:
                revert with 0, 17
            idx = 0
            s = totalSupply
            t = stor9
            while idx < stor6.length:
                mem[0] = stor6[idx]
                mem[32] = 1
                if stor1[stor6[idx]] > t:
                    _9223 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9223] = 26
                    mem[_9223 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9295 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9295 + 68] = mem[idx + _9223 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9295 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9295 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                return 0
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10256 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10256] = 30
                            mem[_10256 + 32] = 'SafeMath: subtraction overflow'
                            _10999 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10999] = 30
                            mem[_10999 + 32] = 'SafeMath: subtraction overflow'
                            _12541 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12541] = 30
                            mem[_12541 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                            _13042 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13042 + 68] = mem[idx + _12541 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13042 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13042 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _10255 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10255] = 30
                            mem[_10255 + 32] = 'SafeMath: subtraction overflow'
                            _10998 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10998] = 30
                            mem[_10998 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _11309 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11309 + 68] = mem[idx + _10998 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11309 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11309 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _12539 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12539] = 30
                            mem[_12539 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                            _13041 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13041 + 68] = mem[idx + _12539 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13041 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13041 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10729 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10729] = 30
                        mem[_10729 + 32] = 'SafeMath: subtraction overflow'
                        _12079 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12079] = 30
                        mem[_12079 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            _12538 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12538 + 68] = mem[idx + _12079 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12538 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12538 + -mem[64] + 100
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _14081 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14081] = 30
                        mem[_14081 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                        _14641 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14641 + 68] = mem[idx + _14081 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14641 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14641 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            _10254 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10254] = 30
                            mem[_10254 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10415 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10415 + 68] = mem[idx + _10254 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10415 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10415 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _10996 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10996] = 30
                            mem[_10996 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11308 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11308 + 68] = mem[idx + _10996 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11308 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11308 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12536 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12536] = 30
                            mem[_12536 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _13040 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13040 + 68] = mem[idx + _12536 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13040 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13040 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10728 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10728] = 30
                        mem[_10728 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10995 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10995 + 68] = mem[idx + _10728 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10995 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10995 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12077 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12077] = 30
                        mem[_12077 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _12535 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12535 + 68] = mem[idx + _12077 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12535 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12535 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _14079 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14079] = 30
                        mem[_14079 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                        _14639 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14639 + 68] = mem[idx + _14079 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14639 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14639 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _10727 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10727] = 30
                        mem[_10727 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10994 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10994 + 68] = mem[idx + _10727 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10994 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10994 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12075 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12075] = 30
                        mem[_12075 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _12534 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12534 + 68] = mem[idx + _12075 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12534 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12534 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _14077 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14077] = 30
                        mem[_14077 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                        _14638 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14638 + 68] = mem[idx + _14077 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14638 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14638 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11675 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11675] = 30
                    mem[_11675 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _12074 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12074 + 68] = mem[idx + _11675 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12074 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12074 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _13527 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13527] = 30
                    mem[_13527 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _14076 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14076 + 68] = mem[idx + _13527 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14076 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14076 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _15680 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15680] = 30
                    mem[_15680 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _16189 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16189 + 68] = mem[idx + _15680 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16189 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16189 + -mem[64] + 100
                if idx >= stor6.length:
                    revert with 0, 50
                mem[0] = stor6[idx]
                mem[32] = 2
                if stor2[stor6[idx]] <= s:
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    _9296 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9296] = 30
                    mem[_9296 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[stor6[idx]] > t:
                        _9376 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9376 + 68] = mem[idx + _9296 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9376 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9376 + -mem[64] + 100
                    if t < stor1[stor6[idx]]:
                        revert with 0, 17
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    _9729 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9729] = 30
                    mem[_9729 + 32] = 'SafeMath: subtraction overflow'
                    if stor2[stor6[idx]] <= s:
                        if s < stor2[stor6[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor2[stor6[idx]]
                        t = t - stor1[stor6[idx]]
                        continue 
                    _9777 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _9777 + 68] = mem[idx + _9729 + 32]
                        idx = idx + 32
                        continue 
                    mem[_9777 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _9777 + -mem[64] + 100
                _9297 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9297] = 26
                mem[_9297 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _9377 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _9377 + 68] = mem[idx + _9297 + 32]
                        idx = idx + 32
                        continue 
                    mem[_9377 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _9377 + -mem[64] + 100
                if not arg1:
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10420 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10420] = 30
                        mem[_10420 + 32] = 'SafeMath: subtraction overflow'
                        _11316 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11316] = 30
                        mem[_11316 + 32] = 'SafeMath: subtraction overflow'
                        _13050 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13050] = 30
                        mem[_13050 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                            if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                        _13531 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13531 + 68] = mem[idx + _13050 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13531 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13531 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _10419 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10419] = 30
                        mem[_10419 + 32] = 'SafeMath: subtraction overflow'
                        _11315 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11315] = 30
                        mem[_11315 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            _11678 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11678 + 68] = mem[idx + _11315 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11678 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11678 + -mem[64] + 100
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _13048 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13048] = 30
                        mem[_13048 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                        _13530 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13530 + 68] = mem[idx + _13048 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13530 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13530 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11002 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11002] = 30
                    mem[_11002 + 32] = 'SafeMath: subtraction overflow'
                    _12547 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12547] = 30
                    mem[_12547 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                        _13047 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13047 + 68] = mem[idx + _12547 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13047 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13047 + -mem[64] + 100
                    if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _14649 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14649] = 30
                    mem[_14649 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _15155 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15155 + 68] = mem[idx + _14649 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15155 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15155 + -mem[64] + 100
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        _10418 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10418] = 30
                        mem[_10418 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10540 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10540 + 68] = mem[idx + _10418 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10540 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10540 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11313 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11313] = 30
                        mem[_11313 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11677 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11677 + 68] = mem[idx + _11313 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11677 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11677 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13045 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13045] = 30
                        mem[_13045 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _13529 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13529 + 68] = mem[idx + _13045 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13529 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13529 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11001 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11001] = 30
                    mem[_11001 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11312 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11312 + 68] = mem[idx + _11001 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11312 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11312 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _12545 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12545] = 30
                    mem[_12545 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _13044 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13044 + 68] = mem[idx + _12545 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13044 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13044 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _14647 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14647] = 30
                    mem[_14647 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                        if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _15153 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15153 + 68] = mem[idx + _14647 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15153 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15153 + -mem[64] + 100
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    _11000 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11000] = 30
                    mem[_11000 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11311 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11311 + 68] = mem[idx + _11000 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11311 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11311 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _12543 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12543] = 30
                    mem[_12543 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _13043 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13043 + 68] = mem[idx + _12543 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13043 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13043 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _14645 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14645] = 30
                    mem[_14645 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                    _15152 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15152 + 68] = mem[idx + _14645 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15152 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15152 + -mem[64] + 100
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _12080 = mem[64]
                mem[64] = mem[64] + 64
                mem[_12080] = 30
                mem[_12080 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    _12542 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _12542 + 68] = mem[idx + _12080 + 32]
                        idx = idx + 32
                        continue 
                    mem[_12542 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _12542 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                _14084 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14084] = 30
                mem[_14084 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    _14644 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _14644 + 68] = mem[idx + _14084 + 32]
                        idx = idx + 32
                        continue 
                    mem[_14644 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14644 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                _16193 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16193] = 30
                mem[_16193 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                _16536 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _16536 + 68] = mem[idx + _16193 + 32]
                    idx = idx + 32
                    continue 
                mem[_16536 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16536 + -mem[64] + 100
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor9 / totalSupply:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor15 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor15 / 100 / 100 * t / s:
                            revert with 0, 17
                        return (-1 * arg1 * stor15 / 100 / 100 * t / s)
                    if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        if arg1 * stor14 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor14 / 100 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor14 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor14 / 100 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * stor14 / 100 / 100 * t / s)
                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor14 / 100 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor14 / 100 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * stor15 / 100 / 100 * t / s > -1 * arg1 * stor14 / 100 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor14 / 100 / 100 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * stor14 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * stor15 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
                if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s))
                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
                if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        return 0
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            if arg1 and stor9 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor14 / 100 / 100:
                if not arg1 * stor15 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor9 / totalSupply)
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor14 / 100 / 100:
                revert with 0, 18
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor15 / 100 / 100:
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor15 / 100 / 100:
                revert with 0, 18
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 > arg1 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor9 / totalSupply < 0:
                revert with 0, 17
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
        if arg1 and stor13 > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * stor13 / arg1 != stor13:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        mem[160] = 26
        mem[192] = 'SafeMath: division by zero'
        if not arg1:
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor13 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) < 0:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor13 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) < 0:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9222 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9222] = 26
                        mem[_9222 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9292 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9292 + 68] = mem[idx + _9222 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9292 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9292 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor13 / 100 / 100:
                                return 0
                            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10248 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10248] = 30
                            mem[_10248 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _10411 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10411 + 68] = mem[idx + _10248 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10411 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10411 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _10987 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10987] = 30
                            mem[_10987 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _11296 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11296 + 68] = mem[idx + _10987 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11296 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11296 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12522 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12522] = 30
                            mem[_12522 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                            _13032 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13032 + 68] = mem[idx + _12522 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13032 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13032 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor13 / 100 / 100:
                            _10247 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10247] = 30
                            mem[_10247 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10410 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10410 + 68] = mem[idx + _10247 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10410 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10410 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _10985 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10985] = 30
                            mem[_10985 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11295 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11295 + 68] = mem[idx + _10985 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11295 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11295 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12520 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12520] = 30
                            mem[_12520 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _13031 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13031 + 68] = mem[idx + _12520 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13031 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13031 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10718 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10718] = 30
                        mem[_10718 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _10984 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10984 + 68] = mem[idx + _10718 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10984 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10984 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _12060 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12060] = 30
                        mem[_12060 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _12519 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12519 + 68] = mem[idx + _12060 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12519 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12519 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        _14057 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14057] = 30
                        mem[_14057 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
                        _14626 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14626 + 68] = mem[idx + _14057 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14626 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14626 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9293 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9293] = 30
                        mem[_9293 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9373 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9373 + 68] = mem[idx + _9293 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9373 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9373 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9726 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9726] = 30
                        mem[_9726 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _9774 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9774 + 68] = mem[idx + _9726 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9774 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9774 + -mem[64] + 100
                    _9294 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9294] = 26
                    mem[_9294 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9374 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9374 + 68] = mem[idx + _9294 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9374 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9374 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            return 0
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10414 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10414] = 30
                        mem[_10414 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _10534 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10534 + 68] = mem[idx + _10414 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10534 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10534 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _11301 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11301] = 30
                        mem[_11301 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _11667 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11667 + 68] = mem[idx + _11301 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11667 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11667 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13036 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13036] = 30
                        mem[_13036 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                        _13514 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13514 + 68] = mem[idx + _13036 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13514 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13514 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        _10413 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10413] = 30
                        mem[_10413 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10533 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10533 + 68] = mem[idx + _10413 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10533 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10533 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11299 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11299] = 30
                        mem[_11299 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11666 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11666 + 68] = mem[idx + _11299 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11666 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11666 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13034 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13034] = 30
                        mem[_13034 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _13513 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13513 + 68] = mem[idx + _13034 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13513 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13513 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10989 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10989] = 30
                    mem[_10989 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _11298 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11298 + 68] = mem[idx + _10989 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11298 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11298 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _12524 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12524] = 30
                    mem[_12524 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _13033 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13033 + 68] = mem[idx + _12524 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13033 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13033 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
                    _14629 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14629] = 30
                    mem[_14629 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
                    _15145 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15145 + 68] = mem[idx + _14629 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15145 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15145 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor9 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            return 0
                        if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor13 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * stor13 / 100 / 100 * t / s)
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s))
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        return 0
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor9 / totalSupply)
                if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
            if arg1 and stor15 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor15 / arg1 != stor15:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[352] = 26
            mem[384] = 'SafeMath: division by zero'
            mem[416] = 26
            mem[448] = 'SafeMath: division by zero'
            mem[480] = 30
            mem[512] = 'SafeMath: subtraction overflow'
            if arg1 * stor13 / 100 / 100 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * stor13 / 100 / 100:
                revert with 0, 17
            mem[544] = 30
            mem[576] = 'SafeMath: subtraction overflow'
            if 0 > arg1 - (arg1 * stor13 / 100 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * stor13 / 100 / 100) < 0:
                revert with 0, 17
            mem[64] = 672
            mem[608] = 30
            mem[640] = 'SafeMath: subtraction overflow'
            if arg1 * stor15 / 100 / 100 > arg1 - (arg1 * stor13 / 100 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * stor13 / 100 / 100) < arg1 * stor15 / 100 / 100:
                revert with 0, 17
            idx = 0
            s = totalSupply
            t = stor9
            while idx < stor6.length:
                mem[0] = stor6[idx]
                mem[32] = 1
                if stor1[stor6[idx]] > t:
                    _9221 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9221] = 26
                    mem[_9221 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9289 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9289 + 68] = mem[idx + _9221 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9289 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9289 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                return 0
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10241 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10241] = 30
                            mem[_10241 + 32] = 'SafeMath: subtraction overflow'
                            _10974 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10974] = 30
                            mem[_10974 + 32] = 'SafeMath: subtraction overflow'
                            _12505 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12505] = 30
                            mem[_12505 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                            _13022 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13022 + 68] = mem[idx + _12505 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13022 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13022 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _10240 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10240] = 30
                            mem[_10240 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _10405 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10405 + 68] = mem[idx + _10240 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10405 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10405 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _10972 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10972] = 30
                            mem[_10972 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _11285 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11285 + 68] = mem[idx + _10972 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11285 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11285 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12503 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12503] = 30
                            mem[_12503 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                            _13021 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13021 + 68] = mem[idx + _12503 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13021 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13021 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10711 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10711] = 30
                        mem[_10711 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _10971 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10971 + 68] = mem[idx + _10711 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10971 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10971 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _12047 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12047] = 30
                        mem[_12047 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _12502 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12502 + 68] = mem[idx + _12047 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12502 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12502 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _14042 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14042] = 30
                        mem[_14042 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                        _14611 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14611 + 68] = mem[idx + _14042 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14611 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14611 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            _10239 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10239] = 30
                            mem[_10239 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10404 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10404 + 68] = mem[idx + _10239 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10404 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10404 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _10969 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10969] = 30
                            mem[_10969 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11284 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11284 + 68] = mem[idx + _10969 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11284 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11284 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12500 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12500] = 30
                            mem[_12500 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _13020 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13020 + 68] = mem[idx + _12500 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13020 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13020 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10710 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10710] = 30
                        mem[_10710 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10968 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10968 + 68] = mem[idx + _10710 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10968 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10968 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12045 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12045] = 30
                        mem[_12045 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _12499 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12499 + 68] = mem[idx + _12045 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12499 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12499 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _14040 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14040] = 30
                        mem[_14040 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                        _14609 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14609 + 68] = mem[idx + _14040 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14609 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14609 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _10709 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10709] = 30
                        mem[_10709 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _10967 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10967 + 68] = mem[idx + _10709 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10967 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10967 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _12043 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12043] = 30
                        mem[_12043 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _12498 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12498 + 68] = mem[idx + _12043 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12498 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12498 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        _14038 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14038] = 30
                        mem[_14038 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
                        _14608 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14608 + 68] = mem[idx + _14038 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14608 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14608 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11659 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11659] = 30
                    mem[_11659 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _12042 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12042 + 68] = mem[idx + _11659 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12042 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12042 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _13504 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13504] = 30
                    mem[_13504 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _14037 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14037 + 68] = mem[idx + _13504 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14037 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14037 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
                    _15651 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15651] = 30
                    mem[_15651 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _16159 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16159 + 68] = mem[idx + _15651 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16159 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16159 + -mem[64] + 100
                if idx >= stor6.length:
                    revert with 0, 50
                mem[0] = stor6[idx]
                mem[32] = 2
                if stor2[stor6[idx]] <= s:
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    _9290 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9290] = 30
                    mem[_9290 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[stor6[idx]] > t:
                        _9370 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9370 + 68] = mem[idx + _9290 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9370 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9370 + -mem[64] + 100
                    if t < stor1[stor6[idx]]:
                        revert with 0, 17
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    _9723 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9723] = 30
                    mem[_9723 + 32] = 'SafeMath: subtraction overflow'
                    if stor2[stor6[idx]] <= s:
                        if s < stor2[stor6[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor2[stor6[idx]]
                        t = t - stor1[stor6[idx]]
                        continue 
                    _9771 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _9771 + 68] = mem[idx + _9723 + 32]
                        idx = idx + 32
                        continue 
                    mem[_9771 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _9771 + -mem[64] + 100
                _9291 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9291] = 26
                mem[_9291 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _9371 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _9371 + 68] = mem[idx + _9291 + 32]
                        idx = idx + 32
                        continue 
                    mem[_9371 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _9371 + -mem[64] + 100
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10409 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10409] = 30
                        mem[_10409 + 32] = 'SafeMath: subtraction overflow'
                        _11294 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11294] = 30
                        mem[_11294 + 32] = 'SafeMath: subtraction overflow'
                        _13030 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13030] = 30
                        mem[_13030 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                            if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                        _13508 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13508 + 68] = mem[idx + _13030 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13508 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13508 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _10408 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10408] = 30
                        mem[_10408 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _10531 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10531 + 68] = mem[idx + _10408 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10531 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10531 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _11292 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11292] = 30
                        mem[_11292 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _11662 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11662 + 68] = mem[idx + _11292 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11662 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11662 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13028 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13028] = 30
                        mem[_13028 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                        _13507 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13507 + 68] = mem[idx + _13028 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13507 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13507 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10977 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10977] = 30
                    mem[_10977 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        _11291 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11291 + 68] = mem[idx + _10977 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11291 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11291 + -mem[64] + 100
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _12511 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12511] = 30
                    mem[_12511 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        _13027 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13027 + 68] = mem[idx + _12511 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13027 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13027 + -mem[64] + 100
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _14619 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14619] = 30
                    mem[_14619 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _15142 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15142 + 68] = mem[idx + _14619 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15142 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15142 + -mem[64] + 100
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        _10407 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10407] = 30
                        mem[_10407 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10530 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10530 + 68] = mem[idx + _10407 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10530 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10530 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11289 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11289] = 30
                        mem[_11289 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11661 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11661 + 68] = mem[idx + _11289 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11661 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11661 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13025 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13025] = 30
                        mem[_13025 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _13506 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13506 + 68] = mem[idx + _13025 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13506 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13506 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10976 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10976] = 30
                    mem[_10976 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11288 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11288 + 68] = mem[idx + _10976 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11288 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11288 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _12509 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12509] = 30
                    mem[_12509 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _13024 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13024 + 68] = mem[idx + _12509 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13024 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13024 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _14617 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14617] = 30
                    mem[_14617 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                        if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _15140 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15140 + 68] = mem[idx + _14617 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15140 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15140 + -mem[64] + 100
                if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    _10975 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10975] = 30
                    mem[_10975 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _11287 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11287 + 68] = mem[idx + _10975 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11287 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11287 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _12507 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12507] = 30
                    mem[_12507 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _13023 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13023 + 68] = mem[idx + _12507 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13023 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13023 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
                    _14615 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14615] = 30
                    mem[_14615 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
                    _15139 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15139 + 68] = mem[idx + _14615 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15139 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15139 + -mem[64] + 100
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _12049 = mem[64]
                mem[64] = mem[64] + 64
                mem[_12049] = 30
                mem[_12049 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    _12506 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _12506 + 68] = mem[idx + _12049 + 32]
                        idx = idx + 32
                        continue 
                    mem[_12506 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _12506 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                _14045 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14045] = 30
                mem[_14045 + 32] = 'SafeMath: subtraction overflow'
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    _14614 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _14614 + 68] = mem[idx + _14045 + 32]
                        idx = idx + 32
                        continue 
                    mem[_14614 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14614 + -mem[64] + 100
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                _16163 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16163] = 30
                mem[_16163 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                _16531 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _16531 + 68] = mem[idx + _16163 + 32]
                    idx = idx + 32
                    continue 
                mem[_16531 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16531 + -mem[64] + 100
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor9 / totalSupply:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor15 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor15 / 100 / 100 * t / s:
                            revert with 0, 17
                        return (-1 * arg1 * stor15 / 100 / 100 * t / s)
                    if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        if arg1 * stor13 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * stor13 / 100 / 100 * t / s)
                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor13 / 100 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                        revert with 0, 17
                    if arg1 * stor15 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * stor15 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
                if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s))
                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                    revert with 0, 17
                if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        return 0
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            if arg1 and stor9 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor13 / 100 / 100:
                if not arg1 * stor15 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor9 / totalSupply)
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor13 / 100 / 100:
                revert with 0, 18
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor15 / 100 / 100:
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor15 / 100 / 100:
                revert with 0, 18
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                revert with 0, 17
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
        if arg1 and stor14 > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * stor14 / arg1 != stor14:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[224] = 26
        mem[256] = 'SafeMath: division by zero'
        mem[288] = 26
        mem[320] = 'SafeMath: division by zero'
        if not arg1:
            mem[352] = 26
            mem[384] = 'SafeMath: division by zero'
            mem[416] = 26
            mem[448] = 'SafeMath: division by zero'
            mem[480] = 30
            mem[512] = 'SafeMath: subtraction overflow'
            if arg1 * stor13 / 100 / 100 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * stor13 / 100 / 100:
                revert with 0, 17
            mem[544] = 30
            mem[576] = 'SafeMath: subtraction overflow'
            if arg1 * stor14 / 100 / 100 > arg1 - (arg1 * stor13 / 100 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * stor13 / 100 / 100) < arg1 * stor14 / 100 / 100:
                revert with 0, 17
            mem[64] = 672
            mem[608] = 30
            mem[640] = 'SafeMath: subtraction overflow'
            if 0 > arg1 - (arg1 * stor13 / 100 / 100) - (arg1 * stor14 / 100 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * stor13 / 100 / 100) - (arg1 * stor14 / 100 / 100) < 0:
                revert with 0, 17
            idx = 0
            s = totalSupply
            t = stor9
            while idx < stor6.length:
                mem[0] = stor6[idx]
                mem[32] = 1
                if stor1[stor6[idx]] > t:
                    _9220 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9220] = 26
                    mem[_9220 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9286 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9286 + 68] = mem[idx + _9220 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9286 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9286 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor14 / 100 / 100:
                                return 0
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10234 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10234] = 30
                            mem[_10234 + 32] = 'SafeMath: subtraction overflow'
                            _10956 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10956] = 30
                            mem[_10956 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _11269 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11269 + 68] = mem[idx + _10956 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11269 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11269 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _12481 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12481] = 30
                            mem[_12481 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                            _13008 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13008 + 68] = mem[idx + _12481 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13008 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13008 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            _10233 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10233] = 30
                            mem[_10233 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _10397 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10397 + 68] = mem[idx + _10233 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10397 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10397 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _10954 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10954] = 30
                            mem[_10954 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _11268 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11268 + 68] = mem[idx + _10954 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11268 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11268 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12479 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12479] = 30
                            mem[_12479 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                            _13007 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13007 + 68] = mem[idx + _12479 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13007 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13007 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10702 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10702] = 30
                        mem[_10702 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _10953 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10953 + 68] = mem[idx + _10702 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10953 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10953 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _12023 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12023] = 30
                        mem[_12023 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _12478 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12478 + 68] = mem[idx + _12023 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12478 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12478 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _14016 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14016] = 30
                        mem[_14016 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                        _14591 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14591 + 68] = mem[idx + _14016 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14591 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14591 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            _10231 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10231] = 30
                            mem[_10231 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10396 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10396 + 68] = mem[idx + _10231 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10396 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10396 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _10951 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10951] = 30
                            mem[_10951 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11267 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11267 + 68] = mem[idx + _10951 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11267 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11267 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12476 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12476] = 30
                            mem[_12476 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _13006 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13006 + 68] = mem[idx + _12476 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13006 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13006 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10701 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10701] = 30
                        mem[_10701 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10950 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10950 + 68] = mem[idx + _10701 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10950 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10950 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12021 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12021] = 30
                        mem[_12021 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _12475 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12475 + 68] = mem[idx + _12021 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12475 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12475 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _14014 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14014] = 30
                        mem[_14014 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                        _14589 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14589 + 68] = mem[idx + _14014 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14589 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14589 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        _10700 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10700] = 30
                        mem[_10700 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _10949 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10949 + 68] = mem[idx + _10700 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10949 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10949 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _12019 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12019] = 30
                        mem[_12019 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _12474 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12474 + 68] = mem[idx + _12019 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12474 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12474 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        _14012 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14012] = 30
                        mem[_14012 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
                        _14588 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14588 + 68] = mem[idx + _14012 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14588 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14588 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11648 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11648] = 30
                    mem[_11648 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _12018 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12018 + 68] = mem[idx + _11648 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12018 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12018 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _13485 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13485] = 30
                    mem[_13485 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _14011 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14011 + 68] = mem[idx + _13485 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14011 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14011 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _15630 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15630] = 30
                    mem[_15630 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                    _16138 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16138 + 68] = mem[idx + _15630 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16138 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16138 + -mem[64] + 100
                if idx >= stor6.length:
                    revert with 0, 50
                mem[0] = stor6[idx]
                mem[32] = 2
                if stor2[stor6[idx]] <= s:
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    _9287 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9287] = 30
                    mem[_9287 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[stor6[idx]] > t:
                        _9367 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9367 + 68] = mem[idx + _9287 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9367 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9367 + -mem[64] + 100
                    if t < stor1[stor6[idx]]:
                        revert with 0, 17
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    _9720 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9720] = 30
                    mem[_9720 + 32] = 'SafeMath: subtraction overflow'
                    if stor2[stor6[idx]] <= s:
                        if s < stor2[stor6[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor2[stor6[idx]]
                        t = t - stor1[stor6[idx]]
                        continue 
                    _9768 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _9768 + 68] = mem[idx + _9720 + 32]
                        idx = idx + 32
                        continue 
                    mem[_9768 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _9768 + -mem[64] + 100
                _9288 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9288] = 26
                mem[_9288 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _9368 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _9368 + 68] = mem[idx + _9288 + 32]
                        idx = idx + 32
                        continue 
                    mem[_9368 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _9368 + -mem[64] + 100
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            return 0
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10403 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10403] = 30
                        mem[_10403 + 32] = 'SafeMath: subtraction overflow'
                        _11278 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11278] = 30
                        mem[_11278 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            _11651 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11651 + 68] = mem[idx + _11278 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11651 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11651 + -mem[64] + 100
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _13016 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13016] = 30
                        mem[_13016 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                        _13489 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13489 + 68] = mem[idx + _13016 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13489 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13489 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        _10402 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10402] = 30
                        mem[_10402 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _10524 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10524 + 68] = mem[idx + _10402 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10524 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10524 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _11276 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11276] = 30
                        mem[_11276 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _11650 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11650 + 68] = mem[idx + _11276 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11650 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11650 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13014 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13014] = 30
                        mem[_13014 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                        _13488 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13488 + 68] = mem[idx + _13014 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13488 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13488 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10960 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10960] = 30
                    mem[_10960 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        _11275 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11275 + 68] = mem[idx + _10960 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11275 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11275 + -mem[64] + 100
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _12488 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12488] = 30
                    mem[_12488 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        _13013 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13013 + 68] = mem[idx + _12488 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13013 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13013 + -mem[64] + 100
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _14599 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14599] = 30
                    mem[_14599 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                    _15132 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15132 + 68] = mem[idx + _14599 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15132 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15132 + -mem[64] + 100
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor14 / 100 / 100:
                        _10400 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10400] = 30
                        mem[_10400 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10523 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10523 + 68] = mem[idx + _10400 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10523 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10523 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11273 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11273] = 30
                        mem[_11273 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11649 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11649 + 68] = mem[idx + _11273 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11649 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11649 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13011 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13011] = 30
                        mem[_13011 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _13487 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13487 + 68] = mem[idx + _13011 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13487 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13487 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10959 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10959] = 30
                    mem[_10959 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11272 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11272 + 68] = mem[idx + _10959 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11272 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11272 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _12486 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12486] = 30
                    mem[_12486 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _13010 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13010 + 68] = mem[idx + _12486 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13010 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13010 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _14597 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14597] = 30
                    mem[_14597 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                    _15130 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15130 + 68] = mem[idx + _14597 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15130 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15130 + -mem[64] + 100
                if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    _10958 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10958] = 30
                    mem[_10958 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _11271 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11271 + 68] = mem[idx + _10958 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11271 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11271 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _12484 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12484] = 30
                    mem[_12484 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _13009 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13009 + 68] = mem[idx + _12484 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13009 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13009 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
                    _14595 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14595] = 30
                    mem[_14595 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
                    _15129 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15129 + 68] = mem[idx + _14595 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15129 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15129 + -mem[64] + 100
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _12025 = mem[64]
                mem[64] = mem[64] + 64
                mem[_12025] = 30
                mem[_12025 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    _12483 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _12483 + 68] = mem[idx + _12025 + 32]
                        idx = idx + 32
                        continue 
                    mem[_12483 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _12483 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                _14019 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14019] = 30
                mem[_14019 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    _14594 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _14594 + 68] = mem[idx + _14019 + 32]
                        idx = idx + 32
                        continue 
                    mem[_14594 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14594 + -mem[64] + 100
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                _16142 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16142] = 30
                mem[_16142 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                _16527 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _16527 + 68] = mem[idx + _16142 + 32]
                    idx = idx + 32
                    continue 
                mem[_16527 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16527 + -mem[64] + 100
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor9 / totalSupply:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            return 0
                        if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor14 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor14 / 100 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor14 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor14 / 100 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * stor14 / 100 / 100 * t / s)
                    if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if arg1 * stor13 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * stor13 / 100 / 100 * t / s)
                    if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor13 / 100 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * stor14 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor14 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s))
                if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s))
                if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                    revert with 0, 17
                if arg1 * stor14 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor14 / 100 / 100 * t / s:
                    revert with 0, 17
                if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s))
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor14 / 100 / 100:
                        return 0
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if 0 > (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
            if arg1 and stor9 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor13 / 100 / 100:
                if not arg1 * stor14 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor9 / totalSupply)
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor13 / 100 / 100:
                revert with 0, 18
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor14 / 100 / 100:
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor14 / 100 / 100:
                revert with 0, 18
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                revert with 0, 17
            return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
        if arg1 and stor15 > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * stor15 / arg1 != stor15:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[352] = 26
        mem[384] = 'SafeMath: division by zero'
        mem[416] = 26
        mem[448] = 'SafeMath: division by zero'
        mem[480] = 30
        mem[512] = 'SafeMath: subtraction overflow'
        if arg1 * stor13 / 100 / 100 > arg1:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 < arg1 * stor13 / 100 / 100:
            revert with 0, 17
        mem[544] = 30
        mem[576] = 'SafeMath: subtraction overflow'
        if arg1 * stor14 / 100 / 100 > arg1 - (arg1 * stor13 / 100 / 100):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 - (arg1 * stor13 / 100 / 100) < arg1 * stor14 / 100 / 100:
            revert with 0, 17
        mem[64] = 672
        mem[608] = 30
        mem[640] = 'SafeMath: subtraction overflow'
        if arg1 * stor15 / 100 / 100 > arg1 - (arg1 * stor13 / 100 / 100) - (arg1 * stor14 / 100 / 100):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 - (arg1 * stor13 / 100 / 100) - (arg1 * stor14 / 100 / 100) < arg1 * stor15 / 100 / 100:
            revert with 0, 17
        idx = 0
        s = totalSupply
        t = stor9
        while idx < stor6.length:
            mem[0] = stor6[idx]
            mem[32] = 1
            if stor1[stor6[idx]] > t:
                _9219 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9219] = 26
                mem[_9219 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _9283 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _9283 + 68] = mem[idx + _9219 + 32]
                        idx = idx + 32
                        continue 
                    mem[_9283 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _9283 + -mem[64] + 100
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                return 0
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10222 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10222] = 30
                            mem[_10222 + 32] = 'SafeMath: subtraction overflow'
                            _10935 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10935] = 30
                            mem[_10935 + 32] = 'SafeMath: subtraction overflow'
                            _12450 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12450] = 30
                            mem[_12450 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                            _12989 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12989 + 68] = mem[idx + _12450 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12989 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12989 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _10221 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10221] = 30
                            mem[_10221 + 32] = 'SafeMath: subtraction overflow'
                            _10934 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10934] = 30
                            mem[_10934 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _11254 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11254 + 68] = mem[idx + _10934 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11254 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11254 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _12448 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12448] = 30
                            mem[_12448 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                            _12988 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12988 + 68] = mem[idx + _12448 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12988 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12988 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10685 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10685] = 30
                        mem[_10685 + 32] = 'SafeMath: subtraction overflow'
                        _11997 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11997] = 30
                        mem[_11997 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            _12447 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12447 + 68] = mem[idx + _11997 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12447 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12447 + -mem[64] + 100
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _13981 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13981] = 30
                        mem[_13981 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                        _14562 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14562 + 68] = mem[idx + _13981 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14562 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14562 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            _10220 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10220] = 30
                            mem[_10220 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _10388 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10388 + 68] = mem[idx + _10220 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10388 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10388 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _10932 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10932] = 30
                            mem[_10932 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _11253 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11253 + 68] = mem[idx + _10932 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11253 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11253 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12445 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12445] = 30
                            mem[_12445 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                            _12987 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12987 + 68] = mem[idx + _12445 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12987 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12987 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10684 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10684] = 30
                        mem[_10684 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _10931 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10931 + 68] = mem[idx + _10684 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10931 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10931 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _11995 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11995] = 30
                        mem[_11995 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _12444 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12444 + 68] = mem[idx + _11995 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12444 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12444 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13979 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13979] = 30
                        mem[_13979 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                        _14560 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14560 + 68] = mem[idx + _13979 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14560 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14560 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _10683 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10683] = 30
                        mem[_10683 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _10930 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10930 + 68] = mem[idx + _10683 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10930 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10930 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _11993 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11993] = 30
                        mem[_11993 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _12443 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12443 + 68] = mem[idx + _11993 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12443 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12443 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _13977 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13977] = 30
                        mem[_13977 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                        _14559 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14559 + 68] = mem[idx + _13977 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14559 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14559 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11632 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11632] = 30
                    mem[_11632 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        _11992 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11992 + 68] = mem[idx + _11632 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11992 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11992 + -mem[64] + 100
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _13464 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13464] = 30
                    mem[_13464 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        _13976 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13976 + 68] = mem[idx + _13464 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13976 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13976 + -mem[64] + 100
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _15607 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15607] = 30
                    mem[_15607 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _16109 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16109 + 68] = mem[idx + _15607 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16109 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16109 + -mem[64] + 100
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            _10218 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10218] = 30
                            mem[_10218 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10387 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10387 + 68] = mem[idx + _10218 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10387 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10387 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _10928 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10928] = 30
                            mem[_10928 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11251 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11251 + 68] = mem[idx + _10928 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11251 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11251 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12441 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12441] = 30
                            mem[_12441 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _12986 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12986 + 68] = mem[idx + _12441 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12986 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12986 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10682 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10682] = 30
                        mem[_10682 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10927 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10927 + 68] = mem[idx + _10682 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10927 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10927 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11990 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11990] = 30
                        mem[_11990 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _12440 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12440 + 68] = mem[idx + _11990 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12440 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12440 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13974 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13974] = 30
                        mem[_13974 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                        _14557 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14557 + 68] = mem[idx + _13974 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14557 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14557 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _10681 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10681] = 30
                        mem[_10681 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10926 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10926 + 68] = mem[idx + _10681 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10926 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10926 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11988 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11988] = 30
                        mem[_11988 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _12439 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12439 + 68] = mem[idx + _11988 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12439 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12439 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _13972 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13972] = 30
                        mem[_13972 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                        _14556 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14556 + 68] = mem[idx + _13972 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14556 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14556 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11631 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11631] = 30
                    mem[_11631 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11987 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11987 + 68] = mem[idx + _11631 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11987 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11987 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _13462 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13462] = 30
                    mem[_13462 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _13971 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13971 + 68] = mem[idx + _13462 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13971 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13971 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _15604 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15604] = 30
                    mem[_15604 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _16106 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16106 + 68] = mem[idx + _15604 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16106 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16106 + -mem[64] + 100
                if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        _10680 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10680] = 30
                        mem[_10680 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _10925 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10925 + 68] = mem[idx + _10680 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10925 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10925 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _11985 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11985] = 30
                        mem[_11985 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _12438 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12438 + 68] = mem[idx + _11985 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12438 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12438 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        _13969 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13969] = 30
                        mem[_13969 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
                        _14555 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14555 + 68] = mem[idx + _13969 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14555 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14555 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11630 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11630] = 30
                    mem[_11630 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _11984 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11984 + 68] = mem[idx + _11630 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11984 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11984 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _13460 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13460] = 30
                    mem[_13460 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _13968 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13968 + 68] = mem[idx + _13460 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13968 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13968 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
                    _15602 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15602] = 30
                    mem[_15602 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _16104 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16104 + 68] = mem[idx + _15602 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16104 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16104 + -mem[64] + 100
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    _11629 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11629] = 30
                    mem[_11629 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _11983 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11983 + 68] = mem[idx + _11629 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11983 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11983 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _13458 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13458] = 30
                    mem[_13458 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _13967 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13967 + 68] = mem[idx + _13458 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13967 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13967 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _15600 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15600] = 30
                    mem[_15600 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                    _16103 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16103 + 68] = mem[idx + _15600 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16103 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16103 + -mem[64] + 100
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _12985 = mem[64]
                mem[64] = mem[64] + 64
                mem[_12985] = 30
                mem[_12985 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    _13457 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _13457 + 68] = mem[idx + _12985 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13457 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _13457 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                _15113 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15113] = 30
                mem[_15113 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    _15599 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15599 + 68] = mem[idx + _15113 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15599 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15599 + -mem[64] + 100
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                _16845 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16845] = 30
                mem[_16845 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                _17161 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _17161 + 68] = mem[idx + _16845 + 32]
                    idx = idx + 32
                    continue 
                mem[_17161 + 98] = 0
                revert with memory
                  from mem[64]
                   len _17161 + -mem[64] + 100
            if idx >= stor6.length:
                revert with 0, 50
            mem[0] = stor6[idx]
            mem[32] = 2
            if stor2[stor6[idx]] <= s:
                if idx >= stor6.length:
                    revert with 0, 50
                mem[0] = stor6[idx]
                mem[32] = 1
                _9284 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9284] = 30
                mem[_9284 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor6[idx]] > t:
                    _9364 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _9364 + 68] = mem[idx + _9284 + 32]
                        idx = idx + 32
                        continue 
                    mem[_9364 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _9364 + -mem[64] + 100
                if t < stor1[stor6[idx]]:
                    revert with 0, 17
                if idx >= stor6.length:
                    revert with 0, 50
                mem[0] = stor6[idx]
                mem[32] = 2
                _9717 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9717] = 30
                mem[_9717 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor6[idx]] <= s:
                    if s < stor2[stor6[idx]]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s - stor2[stor6[idx]]
                    t = t - stor1[stor6[idx]]
                    continue 
                _9765 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _9765 + 68] = mem[idx + _9717 + 32]
                    idx = idx + 32
                    continue 
                mem[_9765 + 98] = 0
                revert with memory
                  from mem[64]
                   len _9765 + -mem[64] + 100
            _9285 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9285] = 26
            mem[_9285 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _9365 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _9365 + 68] = mem[idx + _9285 + 32]
                    idx = idx + 32
                    continue 
                mem[_9365 + 94] = 0
                revert with memory
                  from mem[64]
                   len _9365 + -mem[64] + 100
            if not arg1:
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10395 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10395] = 30
                        mem[_10395 + 32] = 'SafeMath: subtraction overflow'
                        _11266 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11266] = 30
                        mem[_11266 + 32] = 'SafeMath: subtraction overflow'
                        _13003 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13003] = 30
                        mem[_13003 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                            if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                        _13470 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13470 + 68] = mem[idx + _13003 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13470 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13470 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _10394 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10394] = 30
                        mem[_10394 + 32] = 'SafeMath: subtraction overflow'
                        _11265 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11265] = 30
                        mem[_11265 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            _11638 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11638 + 68] = mem[idx + _11265 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11638 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11638 + -mem[64] + 100
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _13001 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13001] = 30
                        mem[_13001 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                        _13469 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13469 + 68] = mem[idx + _13001 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13469 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13469 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10942 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10942] = 30
                    mem[_10942 + 32] = 'SafeMath: subtraction overflow'
                    _12465 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12465] = 30
                    mem[_12465 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                        _13000 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13000 + 68] = mem[idx + _12465 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13000 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13000 + -mem[64] + 100
                    if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _14579 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14579] = 30
                    mem[_14579 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _15122 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15122 + 68] = mem[idx + _14579 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15122 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15122 + -mem[64] + 100
                if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        _10393 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10393] = 30
                        mem[_10393 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _10521 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10521 + 68] = mem[idx + _10393 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10521 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10521 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _11263 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11263] = 30
                        mem[_11263 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _11637 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11637 + 68] = mem[idx + _11263 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11637 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11637 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12998 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12998] = 30
                        mem[_12998 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                        _13468 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13468 + 68] = mem[idx + _12998 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13468 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13468 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10941 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10941] = 30
                    mem[_10941 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        _11262 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11262 + 68] = mem[idx + _10941 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11262 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11262 + -mem[64] + 100
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _12463 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12463] = 30
                    mem[_12463 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        _12997 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12997 + 68] = mem[idx + _12463 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12997 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12997 + -mem[64] + 100
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _14577 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14577] = 30
                    mem[_14577 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _15120 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15120 + 68] = mem[idx + _14577 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15120 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15120 + -mem[64] + 100
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    _10940 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10940] = 30
                    mem[_10940 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        _11261 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11261 + 68] = mem[idx + _10940 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11261 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11261 + -mem[64] + 100
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _12461 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12461] = 30
                    mem[_12461 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        _12996 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12996 + 68] = mem[idx + _12461 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12996 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12996 + -mem[64] + 100
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _14575 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14575] = 30
                    mem[_14575 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                    _15119 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15119 + 68] = mem[idx + _14575 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15119 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15119 + -mem[64] + 100
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _12001 = mem[64]
                mem[64] = mem[64] + 64
                mem[_12001] = 30
                mem[_12001 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                    _12460 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _12460 + 68] = mem[idx + _12001 + 32]
                        idx = idx + 32
                        continue 
                    mem[_12460 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _12460 + -mem[64] + 100
                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                _13991 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13991] = 30
                mem[_13991 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    _14574 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _14574 + 68] = mem[idx + _13991 + 32]
                        idx = idx + 32
                        continue 
                    mem[_14574 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14574 + -mem[64] + 100
                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                _16121 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16121] = 30
                mem[_16121 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                _16523 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _16523 + 68] = mem[idx + _16121 + 32]
                    idx = idx + 32
                    continue 
                mem[_16523 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16523 + -mem[64] + 100
            if arg1 and stor9 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor13 / 100 / 100:
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        _10391 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10391] = 30
                        mem[_10391 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10520 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10520 + 68] = mem[idx + _10391 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10520 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10520 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11259 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11259] = 30
                        mem[_11259 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11635 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11635 + 68] = mem[idx + _11259 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11635 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11635 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12994 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12994] = 30
                        mem[_12994 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _13467 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13467 + 68] = mem[idx + _12994 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13467 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13467 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10939 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10939] = 30
                    mem[_10939 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11258 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11258 + 68] = mem[idx + _10939 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11258 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11258 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _12458 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12458] = 30
                    mem[_12458 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _12993 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12993 + 68] = mem[idx + _12458 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12993 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12993 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _14572 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14572] = 30
                    mem[_14572 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                        if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _15117 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15117 + 68] = mem[idx + _14572 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15117 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15117 + -mem[64] + 100
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    _10938 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10938] = 30
                    mem[_10938 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11257 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11257 + 68] = mem[idx + _10938 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11257 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11257 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _12456 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12456] = 30
                    mem[_12456 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _12992 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12992 + 68] = mem[idx + _12456 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12992 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12992 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _14570 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14570] = 30
                    mem[_14570 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                    _15116 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15116 + 68] = mem[idx + _14570 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15116 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15116 + -mem[64] + 100
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _12000 = mem[64]
                mem[64] = mem[64] + 64
                mem[_12000] = 30
                mem[_12000 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    _12455 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _12455 + 68] = mem[idx + _12000 + 32]
                        idx = idx + 32
                        continue 
                    mem[_12455 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _12455 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                _13989 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13989] = 30
                mem[_13989 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    _14569 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _14569 + 68] = mem[idx + _13989 + 32]
                        idx = idx + 32
                        continue 
                    mem[_14569 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14569 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                _16118 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16118] = 30
                mem[_16118 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                _16520 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _16520 + 68] = mem[idx + _16118 + 32]
                    idx = idx + 32
                    continue 
                mem[_16520 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16520 + -mem[64] + 100
            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor13 / 100 / 100:
                revert with 0, 18
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor14 / 100 / 100:
                if not arg1 * stor15 / 100 / 100:
                    _10937 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10937] = 30
                    mem[_10937 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _11256 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11256 + 68] = mem[idx + _10937 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11256 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11256 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _12453 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12453] = 30
                    mem[_12453 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _12991 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12991 + 68] = mem[idx + _12453 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12991 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12991 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
                    _14567 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14567] = 30
                    mem[_14567 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
                    _15115 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15115 + 68] = mem[idx + _14567 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15115 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15115 + -mem[64] + 100
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _11999 = mem[64]
                mem[64] = mem[64] + 64
                mem[_11999] = 30
                mem[_11999 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    _12452 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _12452 + 68] = mem[idx + _11999 + 32]
                        idx = idx + 32
                        continue 
                    mem[_12452 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _12452 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                _13987 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13987] = 30
                mem[_13987 + 32] = 'SafeMath: subtraction overflow'
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    _14566 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _14566 + 68] = mem[idx + _13987 + 32]
                        idx = idx + 32
                        continue 
                    mem[_14566 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14566 + -mem[64] + 100
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                _16116 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16116] = 30
                mem[_16116 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                _16518 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _16518 + 68] = mem[idx + _16116 + 32]
                    idx = idx + 32
                    continue 
                mem[_16518 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16518 + -mem[64] + 100
            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor14 / 100 / 100:
                revert with 0, 18
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor15 / 100 / 100:
                _11998 = mem[64]
                mem[64] = mem[64] + 64
                mem[_11998] = 30
                mem[_11998 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    _12451 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _12451 + 68] = mem[idx + _11998 + 32]
                        idx = idx + 32
                        continue 
                    mem[_12451 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _12451 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                _13985 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13985] = 30
                mem[_13985 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    _14565 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _14565 + 68] = mem[idx + _13985 + 32]
                        idx = idx + 32
                        continue 
                    mem[_14565 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14565 + -mem[64] + 100
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                _16114 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16114] = 30
                mem[_16114 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                _16517 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _16517 + 68] = mem[idx + _16114 + 32]
                    idx = idx + 32
                    continue 
                mem[_16517 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16517 + -mem[64] + 100
            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor15 / 100 / 100:
                revert with 0, 18
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            _13466 = mem[64]
            mem[64] = mem[64] + 64
            mem[_13466] = 30
            mem[_13466 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                _13984 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _13984 + 68] = mem[idx + _13466 + 32]
                    idx = idx + 32
                    continue 
                mem[_13984 + 98] = 0
                revert with memory
                  from mem[64]
                   len _13984 + -mem[64] + 100
            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            _15612 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15612] = 30
            mem[_15612 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                _16113 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _16113 + 68] = mem[idx + _15612 + 32]
                    idx = idx + 32
                    continue 
                mem[_16113 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16113 + -mem[64] + 100
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            _17166 = mem[64]
            mem[64] = mem[64] + 64
            mem[_17166] = 30
            mem[_17166 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            _17345 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _17345 + 68] = mem[idx + _17166 + 32]
                idx = idx + 32
                continue 
            mem[_17345 + 98] = 0
            revert with memory
              from mem[64]
               len _17345 + -mem[64] + 100
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if t >= stor9 / totalSupply:
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor15 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor15 / 100 / 100 * t / s:
                            revert with 0, 17
                        return (-1 * arg1 * stor15 / 100 / 100 * t / s)
                    if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        if arg1 * stor14 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor14 / 100 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor14 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor14 / 100 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * stor14 / 100 / 100 * t / s)
                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor14 / 100 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor14 / 100 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * stor15 / 100 / 100 * t / s > -1 * arg1 * stor14 / 100 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor14 / 100 / 100 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * stor14 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
                if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        if arg1 * stor13 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * stor13 / 100 / 100 * t / s)
                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor13 / 100 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                        revert with 0, 17
                    if arg1 * stor15 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
                if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if arg1 * stor13 / 100 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * stor14 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s))
                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor13 / 100 / 100 * t / s > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor13 / 100 / 100 * t / s:
                    revert with 0, 17
                if arg1 * stor14 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * t / s > (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                    revert with 0, 17
                return ((-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
            if arg1 and t / s > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * t / s / arg1 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor13 / 100 / 100:
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * stor15 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
                if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s))
                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
                if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
            if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor13 / 100 / 100:
                revert with 0, 18
            if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor14 / 100 / 100:
                if not arg1 * stor15 / 100 / 100:
                    if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s))
                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                    revert with 0, 17
                if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
            if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor14 / 100 / 100:
                revert with 0, 18
            if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor15 / 100 / 100:
                if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                    revert with 0, 17
                if arg1 * stor14 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor14 / 100 / 100 * t / s:
                    revert with 0, 17
                if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s))
            if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor15 / 100 / 100:
                revert with 0, 18
            if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                revert with 0, 17
            if arg1 * stor14 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor14 / 100 / 100 * t / s:
                revert with 0, 17
            if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                revert with 0, 17
            return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if not arg1:
            if not arg1 * stor13 / 100 / 100:
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        return 0
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor13 / 100 / 100:
                revert with 0, 18
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor14 / 100 / 100:
                if not arg1 * stor15 / 100 / 100:
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor14 / 100 / 100:
                revert with 0, 18
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor15 / 100 / 100:
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if 0 > (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor15 / 100 / 100:
                revert with 0, 18
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
        if arg1 and stor9 / totalSupply > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * stor13 / 100 / 100:
            if not arg1 * stor14 / 100 / 100:
                if not arg1 * stor15 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor9 / totalSupply)
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor14 / 100 / 100:
                revert with 0, 18
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor15 / 100 / 100:
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor15 / 100 / 100:
                revert with 0, 18
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 > arg1 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor9 / totalSupply < 0:
                revert with 0, 17
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
            revert with 0, 17
        if not arg1 * stor13 / 100 / 100:
            revert with 0, 18
        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * stor14 / 100 / 100:
            if not arg1 * stor15 / 100 / 100:
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor15 / 100 / 100:
                revert with 0, 18
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                revert with 0, 17
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
            revert with 0, 17
        if not arg1 * stor14 / 100 / 100:
            revert with 0, 18
        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * stor15 / 100 / 100:
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                revert with 0, 17
            return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
            revert with 0, 17
        if not arg1 * stor15 / 100 / 100:
            revert with 0, 18
        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
            revert with 0, 17
        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
            revert with 0, 17
        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
            revert with 0, 17
        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
    if not arg1:
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        mem[160] = 26
        mem[192] = 'SafeMath: division by zero'
        if not arg1:
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9234 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9234] = 26
                        mem[_9234 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9328 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9328 + 68] = mem[idx + _9234 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9328 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9328 + -mem[64] + 100
                        if not arg1:
                            return 0
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10334 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10334] = 30
                        mem[_10334 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10476 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10476 + 68] = mem[idx + _10334 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10476 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10476 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11133 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11133] = 30
                        mem[_11133 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11425 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11425 + 68] = mem[idx + _11133 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11425 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11425 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12729 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12729] = 30
                        mem[_12729 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _13154 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13154 + 68] = mem[idx + _12729 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13154 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13154 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9329 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9329] = 30
                        mem[_9329 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9409 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9409 + 68] = mem[idx + _9329 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9409 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9409 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9762 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9762] = 30
                        mem[_9762 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _9810 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9810 + 68] = mem[idx + _9762 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9810 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9810 + -mem[64] + 100
                    _9330 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9330] = 26
                    mem[_9330 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9410 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9410 + 68] = mem[idx + _9330 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9410 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9410 + -mem[64] + 100
                    if not arg1:
                        return 0
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10478 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10478] = 30
                    mem[_10478 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _10585 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _10585 + 68] = mem[idx + _10478 + 32]
                            idx = idx + 32
                            continue 
                        mem[_10585 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _10585 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _11427 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11427] = 30
                    mem[_11427 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11765 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11765 + 68] = mem[idx + _11427 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11765 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11765 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _13155 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13155] = 30
                    mem[_13155 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor9 / totalSupply:
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor9 / totalSupply)
                    _13662 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _13662 + 68] = mem[idx + _13155 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13662 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _13662 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor9 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    return 0
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
            else:
                if arg1 and stor15 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / arg1 != stor15:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9233 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9233] = 26
                        mem[_9233 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9325 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9325 + 68] = mem[idx + _9233 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9325 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9325 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor15 / 100 / 100:
                                return 0
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10330 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10330] = 30
                            mem[_10330 + 32] = 'SafeMath: subtraction overflow'
                            _11127 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11127] = 30
                            mem[_11127 + 32] = 'SafeMath: subtraction overflow'
                            _12722 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12722] = 30
                            mem[_12722 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13149 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13149 + 68] = mem[idx + _12722 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13149 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13149 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _10329 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10329] = 30
                            mem[_10329 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10472 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10472 + 68] = mem[idx + _10329 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10472 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10472 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _11125 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11125] = 30
                            mem[_11125 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11419 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11419 + 68] = mem[idx + _11125 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11419 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11419 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12720 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12720] = 30
                            mem[_12720 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _13148 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13148 + 68] = mem[idx + _12720 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13148 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13148 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10823 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10823] = 30
                        mem[_10823 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11124 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11124 + 68] = mem[idx + _10823 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11124 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11124 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12243 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12243] = 30
                        mem[_12243 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _12719 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12719 + 68] = mem[idx + _12243 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12719 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12719 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _14283 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14283] = 30
                        mem[_14283 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _14797 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14797 + 68] = mem[idx + _14283 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14797 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14797 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9326 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9326] = 30
                        mem[_9326 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9406 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9406 + 68] = mem[idx + _9326 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9406 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9406 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9759 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9759] = 30
                        mem[_9759 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _9807 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9807 + 68] = mem[idx + _9759 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9807 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9807 + -mem[64] + 100
                    _9327 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9327] = 26
                    mem[_9327 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9407 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9407 + 68] = mem[idx + _9327 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9407 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9407 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10475 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10475] = 30
                        mem[_10475 + 32] = 'SafeMath: subtraction overflow'
                        _11424 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11424] = 30
                        mem[_11424 + 32] = 'SafeMath: subtraction overflow'
                        _13153 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13153] = 30
                        mem[_13153 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                            if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _13661 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13661 + 68] = mem[idx + _13153 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13661 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13661 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _10474 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10474] = 30
                        mem[_10474 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10583 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10583 + 68] = mem[idx + _10474 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10583 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10583 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11422 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11422] = 30
                        mem[_11422 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11763 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11763 + 68] = mem[idx + _11422 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11763 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11763 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13151 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13151] = 30
                        mem[_13151 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _13660 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13660 + 68] = mem[idx + _13151 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13660 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13660 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11128 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11128] = 30
                    mem[_11128 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11421 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11421 + 68] = mem[idx + _11128 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11421 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11421 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _12723 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12723] = 30
                    mem[_12723 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _13150 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13150 + 68] = mem[idx + _12723 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13150 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13150 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _14800 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14800] = 30
                    mem[_14800 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                        if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor9 / totalSupply)
                    _15231 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15231 + 68] = mem[idx + _14800 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15231 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15231 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor9 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if arg1 * stor15 / 100 / 100:
                            if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor15 / 100 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor15 / 100 / 100 * t / s:
                                revert with 0, 17
                            else:
                                return 0
                        else:
                            return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * stor15 / 100 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                            revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if arg1 * stor15 / 100 / 100:
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        else:
                            return 0
                    else:
                        return 0
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                else:
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
        else:
            if arg1 and stor14 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor14 / arg1 != stor14:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor14 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor14 / 100 / 100) < 0:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9232 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9232] = 26
                        mem[_9232 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9322 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9322 + 68] = mem[idx + _9232 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9322 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9322 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor14 / 100 / 100:
                                return 0
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10326 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10326] = 30
                            mem[_10326 + 32] = 'SafeMath: subtraction overflow'
                            _11118 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11118] = 30
                            mem[_11118 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _11411 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11411 + 68] = mem[idx + _11118 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11411 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11411 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _12711 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12711] = 30
                            mem[_12711 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13142 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13142 + 68] = mem[idx + _12711 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13142 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13142 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            _10325 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10325] = 30
                            mem[_10325 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10467 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10467 + 68] = mem[idx + _10325 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10467 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10467 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _11116 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11116] = 30
                            mem[_11116 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11410 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11410 + 68] = mem[idx + _11116 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11410 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11410 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12709 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12709] = 30
                            mem[_12709 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _13141 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13141 + 68] = mem[idx + _12709 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13141 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13141 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10818 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10818] = 30
                        mem[_10818 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11115 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11115 + 68] = mem[idx + _10818 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11115 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11115 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12233 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12233] = 30
                        mem[_12233 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _12708 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12708 + 68] = mem[idx + _12233 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12708 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12708 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _14272 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14272] = 30
                        mem[_14272 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _14787 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14787 + 68] = mem[idx + _14272 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14787 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14787 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9323 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9323] = 30
                        mem[_9323 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9403 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9403 + 68] = mem[idx + _9323 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9403 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9403 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9756 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9756] = 30
                        mem[_9756 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _9804 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9804 + 68] = mem[idx + _9756 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9804 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9804 + -mem[64] + 100
                    _9324 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9324] = 26
                    mem[_9324 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9404 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9404 + 68] = mem[idx + _9324 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9404 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9404 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor14 / 100 / 100:
                            return 0
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10471 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10471] = 30
                        mem[_10471 + 32] = 'SafeMath: subtraction overflow'
                        _11416 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11416] = 30
                        mem[_11416 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            _11759 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11759 + 68] = mem[idx + _11416 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11759 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11759 + -mem[64] + 100
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _13146 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13146] = 30
                        mem[_13146 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            else:
                                return 0
                        _13655 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13655 + 68] = mem[idx + _13146 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13655 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13655 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        _10470 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10470] = 30
                        mem[_10470 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10578 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10578 + 68] = mem[idx + _10470 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10578 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10578 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11414 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11414] = 30
                        mem[_11414 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11758 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11758 + 68] = mem[idx + _11414 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11758 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11758 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13144 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13144] = 30
                        mem[_13144 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _13654 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13654 + 68] = mem[idx + _13144 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13654 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13654 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11119 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11119] = 30
                    mem[_11119 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11413 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11413 + 68] = mem[idx + _11119 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11413 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11413 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _12713 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12713] = 30
                    mem[_12713 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _13143 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13143 + 68] = mem[idx + _12713 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13143 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13143 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _14790 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14790] = 30
                    mem[_14790 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return (arg1 * stor9 / totalSupply)
                    _15228 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15228 + 68] = mem[idx + _14790 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15228 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15228 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor9 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if arg1 * stor14 / 100 / 100:
                            if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor14 / 100 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor14 / 100 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * stor14 / 100 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor14 / 100 / 100 * t / s < 0:
                                revert with 0, 17
                            else:
                                return 0
                        else:
                            return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                            revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if arg1 * stor14 / 100 / 100:
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        else:
                            return 0
                    else:
                        return 0
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                else:
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
            else:
                if arg1 and stor15 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / arg1 != stor15:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 > arg1 - (arg1 * stor14 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor14 / 100 / 100) < arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9231 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9231] = 26
                        mem[_9231 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9319 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9319 + 68] = mem[idx + _9231 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9319 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9319 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor14 / 100 / 100:
                                if not arg1 * stor15 / 100 / 100:
                                    return 0
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _10318 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10318] = 30
                                mem[_10318 + 32] = 'SafeMath: subtraction overflow'
                                _11107 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11107] = 30
                                mem[_11107 + 32] = 'SafeMath: subtraction overflow'
                                _12695 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12695] = 30
                                mem[_12695 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                    if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13132 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13132 + 68] = mem[idx + _12695 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13132 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13132 + -mem[64] + 100
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                _10317 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10317] = 30
                                mem[_10317 + 32] = 'SafeMath: subtraction overflow'
                                _11106 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11106] = 30
                                mem[_11106 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                    _11402 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11402 + 68] = mem[idx + _11106 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11402 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11402 + -mem[64] + 100
                                if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                _12693 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12693] = 30
                                mem[_12693 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13131 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13131 + 68] = mem[idx + _12693 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13131 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13131 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10809 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10809] = 30
                            mem[_10809 + 32] = 'SafeMath: subtraction overflow'
                            _12223 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12223] = 30
                            mem[_12223 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _12692 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12692 + 68] = mem[idx + _12223 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12692 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12692 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _14257 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14257] = 30
                            mem[_14257 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _14772 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14772 + 68] = mem[idx + _14257 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14772 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14772 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                _10316 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10316] = 30
                                mem[_10316 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _10461 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _10461 + 68] = mem[idx + _10316 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10461 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10461 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _11104 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11104] = 30
                                mem[_11104 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _11401 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11401 + 68] = mem[idx + _11104 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11401 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11401 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _12690 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12690] = 30
                                mem[_12690 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor9 / totalSupply:
                                    if arg1 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor9 / totalSupply)
                                _13130 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13130 + 68] = mem[idx + _12690 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13130 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13130 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10808 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10808] = 30
                            mem[_10808 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11103 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11103 + 68] = mem[idx + _10808 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11103 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11103 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12221 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12221] = 30
                            mem[_12221 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _12689 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12689 + 68] = mem[idx + _12221 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12689 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12689 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _14255 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14255] = 30
                            mem[_14255 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _14770 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14770 + 68] = mem[idx + _14255 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14770 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14770 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _10807 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10807] = 30
                            mem[_10807 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11102 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11102 + 68] = mem[idx + _10807 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11102 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11102 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12219 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12219] = 30
                            mem[_12219 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _12688 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12688 + 68] = mem[idx + _12219 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12688 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12688 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _14253 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14253] = 30
                            mem[_14253 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _14769 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14769 + 68] = mem[idx + _14253 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14769 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14769 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11751 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11751] = 30
                        mem[_11751 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _12218 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12218 + 68] = mem[idx + _11751 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12218 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12218 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13645 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13645] = 30
                        mem[_13645 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _14252 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14252 + 68] = mem[idx + _13645 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14252 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14252 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _15819 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15819] = 30
                        mem[_15819 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _16325 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16325 + 68] = mem[idx + _15819 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16325 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16325 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9320 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9320] = 30
                        mem[_9320 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9400 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9400 + 68] = mem[idx + _9320 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9400 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9400 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9753 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9753] = 30
                        mem[_9753 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _9801 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9801 + 68] = mem[idx + _9753 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9801 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9801 + -mem[64] + 100
                    _9321 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9321] = 26
                    mem[_9321 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9401 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9401 + 68] = mem[idx + _9321 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9401 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9401 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                return 0
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10466 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10466] = 30
                            mem[_10466 + 32] = 'SafeMath: subtraction overflow'
                            _11409 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11409] = 30
                            mem[_11409 + 32] = 'SafeMath: subtraction overflow'
                            _13140 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13140] = 30
                            mem[_13140 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13649 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13649 + 68] = mem[idx + _13140 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13649 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13649 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _10465 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10465] = 30
                            mem[_10465 + 32] = 'SafeMath: subtraction overflow'
                            _11408 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11408] = 30
                            mem[_11408 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _11754 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11754 + 68] = mem[idx + _11408 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11754 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11754 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _13138 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13138] = 30
                            mem[_13138 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13648 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13648 + 68] = mem[idx + _13138 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13648 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13648 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11110 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11110] = 30
                        mem[_11110 + 32] = 'SafeMath: subtraction overflow'
                        _12701 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12701] = 30
                        mem[_12701 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            _13137 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13137 + 68] = mem[idx + _12701 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13137 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13137 + -mem[64] + 100
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _14780 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14780] = 30
                        mem[_14780 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _15225 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15225 + 68] = mem[idx + _14780 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15225 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15225 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            _10464 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10464] = 30
                            mem[_10464 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10576 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10576 + 68] = mem[idx + _10464 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10576 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10576 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _11406 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11406] = 30
                            mem[_11406 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11753 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11753 + 68] = mem[idx + _11406 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11753 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11753 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _13135 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13135] = 30
                            mem[_13135 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _13647 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13647 + 68] = mem[idx + _13135 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13647 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13647 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11109 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11109] = 30
                        mem[_11109 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11405 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11405 + 68] = mem[idx + _11109 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11405 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11405 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12699 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12699] = 30
                        mem[_12699 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _13134 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13134 + 68] = mem[idx + _12699 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13134 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13134 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _14778 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14778] = 30
                        mem[_14778 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _15223 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15223 + 68] = mem[idx + _14778 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15223 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15223 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _11108 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11108] = 30
                        mem[_11108 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11404 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11404 + 68] = mem[idx + _11108 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11404 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11404 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12697 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12697] = 30
                        mem[_12697 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _13133 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13133 + 68] = mem[idx + _12697 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13133 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13133 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _14776 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14776] = 30
                        mem[_14776 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _15222 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15222 + 68] = mem[idx + _14776 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15222 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15222 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _12224 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12224] = 30
                    mem[_12224 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _12696 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12696 + 68] = mem[idx + _12224 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12696 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12696 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _14260 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14260] = 30
                    mem[_14260 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _14775 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14775 + 68] = mem[idx + _14260 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14775 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14775 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _16329 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16329] = 30
                    mem[_16329 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor9 / totalSupply)
                    _16565 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16565 + 68] = mem[idx + _16329 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16565 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16565 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor9 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * stor14 / 100 / 100:
                            if arg1 * stor15 / 100 / 100:
                                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor15 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor15 / 100 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                if arg1 * stor14 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor14 / 100 / 100 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor14 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * stor15 / 100 / 100 * t / s > -1 * arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor14 / 100 / 100 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                                    revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if arg1 * stor15 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                                revert with 0, 17
                    else:
                        if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                                revert with 0, 17
                            if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                                revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor14 / 100 / 100:
                        if arg1 * stor15 / 100 / 100:
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                    return 0
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                else:
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
    else:
        if arg1 and stor13 > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * stor13 / arg1 != stor13:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        mem[160] = 26
        mem[192] = 'SafeMath: division by zero'
        if not arg1:
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor13 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) < 0:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor13 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) < 0:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9230 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9230] = 26
                        mem[_9230 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9316 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9316 + 68] = mem[idx + _9230 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9316 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9316 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor13 / 100 / 100:
                                return 0
                            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10310 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10310] = 30
                            mem[_10310 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _10457 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10457 + 68] = mem[idx + _10310 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10457 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10457 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _11095 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11095] = 30
                            mem[_11095 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _11389 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11389 + 68] = mem[idx + _11095 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11389 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11389 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12676 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12676] = 30
                            mem[_12676 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13122 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13122 + 68] = mem[idx + _12676 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13122 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13122 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor13 / 100 / 100:
                            _10309 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10309] = 30
                            mem[_10309 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10456 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10456 + 68] = mem[idx + _10309 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10456 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10456 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _11093 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11093] = 30
                            mem[_11093 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11388 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11388 + 68] = mem[idx + _11093 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11388 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11388 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12674 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12674] = 30
                            mem[_12674 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _13121 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13121 + 68] = mem[idx + _12674 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13121 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13121 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10798 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10798] = 30
                        mem[_10798 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _11092 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11092 + 68] = mem[idx + _10798 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11092 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11092 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _12204 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12204] = 30
                        mem[_12204 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _12673 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12673 + 68] = mem[idx + _12204 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12673 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12673 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        _14233 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14233] = 30
                        mem[_14233 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _14757 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14757 + 68] = mem[idx + _14233 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14757 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14757 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9317 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9317] = 30
                        mem[_9317 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9397 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9397 + 68] = mem[idx + _9317 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9397 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9397 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9750 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9750] = 30
                        mem[_9750 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _9798 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9798 + 68] = mem[idx + _9750 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9798 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9798 + -mem[64] + 100
                    _9318 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9318] = 26
                    mem[_9318 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9398 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9398 + 68] = mem[idx + _9318 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9398 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9398 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            return 0
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10460 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10460] = 30
                        mem[_10460 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _10570 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10570 + 68] = mem[idx + _10460 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10570 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10570 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _11394 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11394] = 30
                        mem[_11394 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _11743 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11743 + 68] = mem[idx + _11394 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11743 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11743 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13126 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13126] = 30
                        mem[_13126 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            else:
                                return 0
                        _13632 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13632 + 68] = mem[idx + _13126 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13632 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13632 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        _10459 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10459] = 30
                        mem[_10459 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10569 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10569 + 68] = mem[idx + _10459 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10569 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10569 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11392 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11392] = 30
                        mem[_11392 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11742 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11742 + 68] = mem[idx + _11392 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11742 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11742 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13124 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13124] = 30
                        mem[_13124 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _13631 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13631 + 68] = mem[idx + _13124 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13631 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13631 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11097 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11097] = 30
                    mem[_11097 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _11391 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11391 + 68] = mem[idx + _11097 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11391 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11391 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _12678 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12678] = 30
                    mem[_12678 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _13123 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13123 + 68] = mem[idx + _12678 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13123 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13123 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
                    _14760 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14760] = 30
                    mem[_14760 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return (arg1 * stor9 / totalSupply)
                    _15215 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15215 + 68] = mem[idx + _14760 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15215 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15215 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor9 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if arg1 * stor13 / 100 / 100:
                            if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor13 / 100 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                revert with 0, 17
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                revert with 0, 17
                            else:
                                return 0
                        else:
                            return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                            revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if arg1 * stor13 / 100 / 100:
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        else:
                            return 0
                    else:
                        return 0
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                else:
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
            else:
                if arg1 and stor15 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / arg1 != stor15:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor13 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) < 0:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 > arg1 - (arg1 * stor13 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) < arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9229 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9229] = 26
                        mem[_9229 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9313 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9313 + 68] = mem[idx + _9229 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9313 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9313 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor13 / 100 / 100:
                                if not arg1 * stor15 / 100 / 100:
                                    return 0
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _10303 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10303] = 30
                                mem[_10303 + 32] = 'SafeMath: subtraction overflow'
                                _11082 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11082] = 30
                                mem[_11082 + 32] = 'SafeMath: subtraction overflow'
                                _12659 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12659] = 30
                                mem[_12659 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                    if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13112 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13112 + 68] = mem[idx + _12659 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13112 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13112 + -mem[64] + 100
                            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                _10302 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10302] = 30
                                mem[_10302 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    _10451 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _10451 + 68] = mem[idx + _10302 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10451 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10451 + -mem[64] + 100
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                _11080 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11080] = 30
                                mem[_11080 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    _11378 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11378 + 68] = mem[idx + _11080 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11378 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11378 + -mem[64] + 100
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _12657 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12657] = 30
                                mem[_12657 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13111 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13111 + 68] = mem[idx + _12657 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13111 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13111 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10791 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10791] = 30
                            mem[_10791 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _11079 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11079 + 68] = mem[idx + _10791 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11079 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11079 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _12191 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12191] = 30
                            mem[_12191 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _12656 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12656 + 68] = mem[idx + _12191 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12656 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12656 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _14218 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14218] = 30
                            mem[_14218 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _14742 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14742 + 68] = mem[idx + _14218 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14742 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14742 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                _10301 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10301] = 30
                                mem[_10301 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _10450 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _10450 + 68] = mem[idx + _10301 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10450 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10450 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _11077 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11077] = 30
                                mem[_11077 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _11377 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11377 + 68] = mem[idx + _11077 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11377 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11377 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _12654 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12654] = 30
                                mem[_12654 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor9 / totalSupply:
                                    if arg1 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor9 / totalSupply)
                                _13110 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13110 + 68] = mem[idx + _12654 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13110 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13110 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10790 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10790] = 30
                            mem[_10790 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11076 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11076 + 68] = mem[idx + _10790 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11076 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11076 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12189 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12189] = 30
                            mem[_12189 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _12653 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12653 + 68] = mem[idx + _12189 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12653 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12653 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _14216 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14216] = 30
                            mem[_14216 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _14740 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14740 + 68] = mem[idx + _14216 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14740 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14740 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _10789 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10789] = 30
                            mem[_10789 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _11075 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11075 + 68] = mem[idx + _10789 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11075 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11075 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _12187 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12187] = 30
                            mem[_12187 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                _12652 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12652 + 68] = mem[idx + _12187 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12652 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12652 + -mem[64] + 100
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            _14214 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14214] = 30
                            mem[_14214 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _14739 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14739 + 68] = mem[idx + _14214 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14739 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14739 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11735 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11735] = 30
                        mem[_11735 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _12186 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12186 + 68] = mem[idx + _11735 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12186 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12186 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _13622 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13622] = 30
                        mem[_13622 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _14213 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14213 + 68] = mem[idx + _13622 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14213 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14213 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        _15790 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15790] = 30
                        mem[_15790 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _16295 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16295 + 68] = mem[idx + _15790 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16295 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16295 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9314 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9314] = 30
                        mem[_9314 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9394 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9394 + 68] = mem[idx + _9314 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9394 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9394 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9747 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9747] = 30
                        mem[_9747 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _9795 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9795 + 68] = mem[idx + _9747 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9795 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9795 + -mem[64] + 100
                    _9315 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9315] = 26
                    mem[_9315 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9395 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9395 + 68] = mem[idx + _9315 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9395 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9395 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                return 0
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10455 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10455] = 30
                            mem[_10455 + 32] = 'SafeMath: subtraction overflow'
                            _11387 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11387] = 30
                            mem[_11387 + 32] = 'SafeMath: subtraction overflow'
                            _13120 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13120] = 30
                            mem[_13120 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13626 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13626 + 68] = mem[idx + _13120 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13626 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13626 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _10454 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10454] = 30
                            mem[_10454 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _10567 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10567 + 68] = mem[idx + _10454 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10567 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10567 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _11385 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11385] = 30
                            mem[_11385 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _11738 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11738 + 68] = mem[idx + _11385 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11738 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11738 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _13118 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13118] = 30
                            mem[_13118 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13625 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13625 + 68] = mem[idx + _13118 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13625 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13625 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11085 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11085] = 30
                        mem[_11085 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _11384 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11384 + 68] = mem[idx + _11085 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11384 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11384 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _12665 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12665] = 30
                        mem[_12665 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _13117 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13117 + 68] = mem[idx + _12665 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13117 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13117 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _14750 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14750] = 30
                        mem[_14750 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _15212 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15212 + 68] = mem[idx + _14750 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15212 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15212 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            _10453 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10453] = 30
                            mem[_10453 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10566 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10566 + 68] = mem[idx + _10453 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10566 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10566 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _11382 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11382] = 30
                            mem[_11382 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11737 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11737 + 68] = mem[idx + _11382 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11737 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11737 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _13115 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13115] = 30
                            mem[_13115 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _13624 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13624 + 68] = mem[idx + _13115 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13624 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13624 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11084 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11084] = 30
                        mem[_11084 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11381 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11381 + 68] = mem[idx + _11084 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11381 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11381 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12663 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12663] = 30
                        mem[_12663 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _13114 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13114 + 68] = mem[idx + _12663 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13114 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13114 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _14748 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14748] = 30
                        mem[_14748 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _15210 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15210 + 68] = mem[idx + _14748 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15210 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15210 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _11083 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11083] = 30
                        mem[_11083 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _11380 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11380 + 68] = mem[idx + _11083 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11380 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11380 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _12661 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12661] = 30
                        mem[_12661 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _13113 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13113 + 68] = mem[idx + _12661 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13113 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13113 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        _14746 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14746] = 30
                        mem[_14746 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _15209 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15209 + 68] = mem[idx + _14746 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15209 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15209 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _12193 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12193] = 30
                    mem[_12193 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _12660 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12660 + 68] = mem[idx + _12193 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12660 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12660 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _14221 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14221] = 30
                    mem[_14221 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _14745 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14745 + 68] = mem[idx + _14221 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14745 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14745 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
                    _16299 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16299] = 30
                    mem[_16299 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor9 / totalSupply)
                    _16560 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16560 + 68] = mem[idx + _16299 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16560 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16560 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor9 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            if arg1 * stor15 / 100 / 100:
                                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor15 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor15 / 100 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                if arg1 * stor13 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor13 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * stor15 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                                    revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if arg1 * stor15 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                                revert with 0, 17
                    else:
                        if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                                revert with 0, 17
                            if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                                revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        if arg1 * stor15 / 100 / 100:
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                    return 0
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                else:
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
        else:
            if arg1 and stor14 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor14 / arg1 != stor14:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 > arg1 - (arg1 * stor13 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) < arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor13 / 100 / 100) - (arg1 * stor14 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) - (arg1 * stor14 / 100 / 100) < 0:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9228 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9228] = 26
                        mem[_9228 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9310 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9310 + 68] = mem[idx + _9228 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9310 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9310 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor13 / 100 / 100:
                                if not arg1 * stor14 / 100 / 100:
                                    return 0
                                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor14 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _10296 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10296] = 30
                                mem[_10296 + 32] = 'SafeMath: subtraction overflow'
                                _11064 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11064] = 30
                                mem[_11064 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                    _11362 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11362 + 68] = mem[idx + _11064 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11362 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11362 + -mem[64] + 100
                                if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                _12635 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12635] = 30
                                mem[_12635 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13098 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13098 + 68] = mem[idx + _12635 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13098 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13098 + -mem[64] + 100
                            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor14 / 100 / 100:
                                _10295 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10295] = 30
                                mem[_10295 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    _10443 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _10443 + 68] = mem[idx + _10295 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10443 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10443 + -mem[64] + 100
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                _11062 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11062] = 30
                                mem[_11062 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    _11361 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11361 + 68] = mem[idx + _11062 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11361 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11361 + -mem[64] + 100
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _12633 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12633] = 30
                                mem[_12633 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13097 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13097 + 68] = mem[idx + _12633 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13097 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13097 + -mem[64] + 100
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10782 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10782] = 30
                            mem[_10782 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _11061 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11061 + 68] = mem[idx + _10782 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11061 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11061 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _12167 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12167] = 30
                            mem[_12167 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _12632 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12632 + 68] = mem[idx + _12167 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12632 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12632 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _14192 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14192] = 30
                            mem[_14192 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _14722 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14722 + 68] = mem[idx + _14192 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14722 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14722 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor14 / 100 / 100:
                                _10293 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10293] = 30
                                mem[_10293 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _10442 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _10442 + 68] = mem[idx + _10293 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10442 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10442 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _11059 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11059] = 30
                                mem[_11059 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _11360 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11360 + 68] = mem[idx + _11059 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11360 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11360 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _12630 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12630] = 30
                                mem[_12630 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor9 / totalSupply:
                                    if arg1 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor9 / totalSupply)
                                _13096 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13096 + 68] = mem[idx + _12630 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13096 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13096 + -mem[64] + 100
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10781 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10781] = 30
                            mem[_10781 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11058 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11058 + 68] = mem[idx + _10781 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11058 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11058 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12165 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12165] = 30
                            mem[_12165 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _12629 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12629 + 68] = mem[idx + _12165 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12629 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12629 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _14190 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14190] = 30
                            mem[_14190 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _14720 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14720 + 68] = mem[idx + _14190 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14720 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14720 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            _10780 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10780] = 30
                            mem[_10780 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _11057 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11057 + 68] = mem[idx + _10780 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11057 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11057 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _12163 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12163] = 30
                            mem[_12163 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                _12628 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12628 + 68] = mem[idx + _12163 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12628 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12628 + -mem[64] + 100
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            _14188 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14188] = 30
                            mem[_14188 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _14719 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14719 + 68] = mem[idx + _14188 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14719 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14719 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11724 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11724] = 30
                        mem[_11724 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _12162 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12162 + 68] = mem[idx + _11724 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12162 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12162 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _13603 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13603] = 30
                        mem[_13603 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _14187 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14187 + 68] = mem[idx + _13603 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14187 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14187 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _15769 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15769] = 30
                        mem[_15769 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _16274 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16274 + 68] = mem[idx + _15769 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16274 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16274 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9311 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9311] = 30
                        mem[_9311 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9391 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9391 + 68] = mem[idx + _9311 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9391 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9391 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9744 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9744] = 30
                        mem[_9744 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _9792 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9792 + 68] = mem[idx + _9744 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9792 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9792 + -mem[64] + 100
                    _9312 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9312] = 26
                    mem[_9312 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9392 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9392 + 68] = mem[idx + _9312 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9392 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9392 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor14 / 100 / 100:
                                return 0
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10449 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10449] = 30
                            mem[_10449 + 32] = 'SafeMath: subtraction overflow'
                            _11371 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11371] = 30
                            mem[_11371 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _11727 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11727 + 68] = mem[idx + _11371 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11727 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11727 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _13106 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13106] = 30
                            mem[_13106 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13607 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13607 + 68] = mem[idx + _13106 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13607 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13607 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            _10448 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10448] = 30
                            mem[_10448 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _10560 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10560 + 68] = mem[idx + _10448 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10560 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10560 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _11369 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11369] = 30
                            mem[_11369 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _11726 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11726 + 68] = mem[idx + _11369 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11726 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11726 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _13104 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13104] = 30
                            mem[_13104 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13606 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13606 + 68] = mem[idx + _13104 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13606 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13606 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11068 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11068] = 30
                        mem[_11068 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _11368 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11368 + 68] = mem[idx + _11068 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11368 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11368 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _12642 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12642] = 30
                        mem[_12642 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _13103 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13103 + 68] = mem[idx + _12642 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13103 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13103 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _14730 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14730] = 30
                        mem[_14730 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            else:
                                return 0
                        _15202 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15202 + 68] = mem[idx + _14730 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15202 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15202 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            _10446 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10446] = 30
                            mem[_10446 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10559 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10559 + 68] = mem[idx + _10446 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10559 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10559 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _11366 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11366] = 30
                            mem[_11366 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11725 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11725 + 68] = mem[idx + _11366 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11725 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11725 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _13101 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13101] = 30
                            mem[_13101 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _13605 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13605 + 68] = mem[idx + _13101 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13605 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13605 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11067 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11067] = 30
                        mem[_11067 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11365 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11365 + 68] = mem[idx + _11067 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11365 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11365 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12640 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12640] = 30
                        mem[_12640 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _13100 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13100 + 68] = mem[idx + _12640 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13100 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13100 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _14728 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14728] = 30
                        mem[_14728 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _15200 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15200 + 68] = mem[idx + _14728 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15200 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15200 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        _11066 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11066] = 30
                        mem[_11066 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _11364 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11364 + 68] = mem[idx + _11066 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11364 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11364 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _12638 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12638] = 30
                        mem[_12638 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _13099 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13099 + 68] = mem[idx + _12638 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13099 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13099 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        _14726 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14726] = 30
                        mem[_14726 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _15199 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15199 + 68] = mem[idx + _14726 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15199 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15199 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _12169 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12169] = 30
                    mem[_12169 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _12637 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12637 + 68] = mem[idx + _12169 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12637 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12637 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _14195 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14195] = 30
                    mem[_14195 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _14725 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14725 + 68] = mem[idx + _14195 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14725 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14725 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _16278 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16278] = 30
                    mem[_16278 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return (arg1 * stor9 / totalSupply)
                    _16556 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16556 + 68] = mem[idx + _16278 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16556 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16556 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor9 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            if arg1 * stor14 / 100 / 100:
                                if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor14 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor14 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor14 / 100 / 100 * t / s < 0:
                                    revert with 0, 17
                        else:
                            if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor14 / 100 / 100:
                                if arg1 * stor13 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor14 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor13 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * stor14 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                                    revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                                revert with 0, 17
                    else:
                        if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                                revert with 0, 17
                            if arg1 * stor14 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor14 / 100 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                                revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        if arg1 * stor14 / 100 / 100:
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                    else:
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if 0 > (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                    return 0
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor14 / 100 / 100:
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                else:
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
            else:
                if arg1 and stor15 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / arg1 != stor15:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 > arg1 - (arg1 * stor13 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) < arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 > arg1 - (arg1 * stor13 / 100 / 100) - (arg1 * stor14 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) - (arg1 * stor14 / 100 / 100) < arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9227 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9227] = 26
                        mem[_9227 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9307 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9307 + 68] = mem[idx + _9227 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9307 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9307 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor13 / 100 / 100:
                                if not arg1 * stor14 / 100 / 100:
                                    if not arg1 * stor15 / 100 / 100:
                                        return 0
                                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                        revert with 0, 17
                                    if not arg1 * stor15 / 100 / 100:
                                        revert with 0, 18
                                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _10284 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10284] = 30
                                    mem[_10284 + 32] = 'SafeMath: subtraction overflow'
                                    _11043 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11043] = 30
                                    mem[_11043 + 32] = 'SafeMath: subtraction overflow'
                                    _12604 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12604] = 30
                                    mem[_12604 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                        if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _13079 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13079 + 68] = mem[idx + _12604 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13079 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13079 + -mem[64] + 100
                                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor14 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * stor15 / 100 / 100:
                                    _10283 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10283] = 30
                                    mem[_10283 + 32] = 'SafeMath: subtraction overflow'
                                    _11042 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11042] = 30
                                    mem[_11042 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                        _11347 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _11347 + 68] = mem[idx + _11042 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11347 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11347 + -mem[64] + 100
                                    if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                        revert with 0, 17
                                    _12602 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12602] = 30
                                    mem[_12602 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                        if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _13078 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13078 + 68] = mem[idx + _12602 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13078 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13078 + -mem[64] + 100
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _10765 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10765] = 30
                                mem[_10765 + 32] = 'SafeMath: subtraction overflow'
                                _12141 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12141] = 30
                                mem[_12141 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                    _12601 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12601 + 68] = mem[idx + _12141 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12601 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12601 + -mem[64] + 100
                                if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                _14157 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14157] = 30
                                mem[_14157 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _14693 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14693 + 68] = mem[idx + _14157 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14693 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14693 + -mem[64] + 100
                            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor14 / 100 / 100:
                                if not arg1 * stor15 / 100 / 100:
                                    _10282 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10282] = 30
                                    mem[_10282 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                        _10434 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _10434 + 68] = mem[idx + _10282 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_10434 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _10434 + -mem[64] + 100
                                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                        revert with 0, 17
                                    _11040 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11040] = 30
                                    mem[_11040 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                        _11346 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _11346 + 68] = mem[idx + _11040 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11346 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11346 + -mem[64] + 100
                                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    _12599 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12599] = 30
                                    mem[_12599 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _13077 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13077 + 68] = mem[idx + _12599 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13077 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13077 + -mem[64] + 100
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _10764 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10764] = 30
                                mem[_10764 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    _11039 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11039 + 68] = mem[idx + _10764 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11039 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11039 + -mem[64] + 100
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                _12139 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12139] = 30
                                mem[_12139 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    _12598 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12598 + 68] = mem[idx + _12139 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12598 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12598 + -mem[64] + 100
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _14155 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14155] = 30
                                mem[_14155 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _14691 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14691 + 68] = mem[idx + _14155 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14691 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14691 + -mem[64] + 100
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                _10763 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10763] = 30
                                mem[_10763 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    _11038 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11038 + 68] = mem[idx + _10763 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11038 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11038 + -mem[64] + 100
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                _12137 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12137] = 30
                                mem[_12137 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    _12597 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12597 + 68] = mem[idx + _12137 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12597 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12597 + -mem[64] + 100
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                _14153 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14153] = 30
                                mem[_14153 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                    if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _14690 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14690 + 68] = mem[idx + _14153 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14690 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14690 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11708 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11708] = 30
                            mem[_11708 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _12136 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12136 + 68] = mem[idx + _11708 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12136 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12136 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _13582 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13582] = 30
                            mem[_13582 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _14152 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14152 + 68] = mem[idx + _13582 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14152 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14152 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _15746 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15746] = 30
                            mem[_15746 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _16245 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16245 + 68] = mem[idx + _15746 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16245 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16245 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor14 / 100 / 100:
                                if not arg1 * stor15 / 100 / 100:
                                    _10280 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10280] = 30
                                    mem[_10280 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor9 / totalSupply:
                                        _10433 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _10433 + 68] = mem[idx + _10280 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_10433 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _10433 + -mem[64] + 100
                                    if arg1 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    _11036 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11036] = 30
                                    mem[_11036 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor9 / totalSupply:
                                        _11344 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _11344 + 68] = mem[idx + _11036 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11344 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11344 + -mem[64] + 100
                                    if arg1 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    _12595 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12595] = 30
                                    mem[_12595 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor9 / totalSupply:
                                        if arg1 * stor9 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor9 / totalSupply)
                                    _13076 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13076 + 68] = mem[idx + _12595 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13076 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13076 + -mem[64] + 100
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _10762 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10762] = 30
                                mem[_10762 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _11035 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11035 + 68] = mem[idx + _10762 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11035 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11035 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _12134 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12134] = 30
                                mem[_12134 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _12594 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12594 + 68] = mem[idx + _12134 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12594 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12594 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _14150 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14150] = 30
                                mem[_14150 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                                    if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor9 / totalSupply)
                                _14688 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14688 + 68] = mem[idx + _14150 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14688 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14688 + -mem[64] + 100
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                _10761 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10761] = 30
                                mem[_10761 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _11034 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11034 + 68] = mem[idx + _10761 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11034 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11034 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _12132 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12132] = 30
                                mem[_12132 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                    _12593 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12593 + 68] = mem[idx + _12132 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12593 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12593 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                _14148 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14148] = 30
                                mem[_14148 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                    if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor9 / totalSupply)
                                _14687 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14687 + 68] = mem[idx + _14148 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14687 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14687 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11707 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11707] = 30
                            mem[_11707 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _12131 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12131 + 68] = mem[idx + _11707 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12131 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12131 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _13580 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13580] = 30
                            mem[_13580 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _14147 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14147 + 68] = mem[idx + _13580 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14147 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14147 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _15743 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15743] = 30
                            mem[_15743 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _16242 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16242 + 68] = mem[idx + _15743 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16242 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16242 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                _10760 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10760] = 30
                                mem[_10760 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                    _11033 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11033 + 68] = mem[idx + _10760 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11033 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11033 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                _12129 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12129] = 30
                                mem[_12129 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                    _12592 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12592 + 68] = mem[idx + _12129 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12592 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12592 + -mem[64] + 100
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 0, 17
                                _14145 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14145] = 30
                                mem[_14145 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor9 / totalSupply)
                                _14686 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14686 + 68] = mem[idx + _14145 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14686 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14686 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11706 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11706] = 30
                            mem[_11706 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _12128 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12128 + 68] = mem[idx + _11706 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12128 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12128 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _13578 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13578] = 30
                            mem[_13578 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                _14144 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14144 + 68] = mem[idx + _13578 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14144 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14144 + -mem[64] + 100
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            _15741 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15741] = 30
                            mem[_15741 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _16240 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16240 + 68] = mem[idx + _15741 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16240 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16240 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _11705 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11705] = 30
                            mem[_11705 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _12127 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12127 + 68] = mem[idx + _11705 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12127 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12127 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _13576 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13576] = 30
                            mem[_13576 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                _14143 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14143 + 68] = mem[idx + _13576 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14143 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14143 + -mem[64] + 100
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _15739 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15739] = 30
                            mem[_15739 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _16239 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16239 + 68] = mem[idx + _15739 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16239 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16239 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _13075 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13075] = 30
                        mem[_13075 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _13575 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13575 + 68] = mem[idx + _13075 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13575 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13575 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _15183 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15183] = 30
                        mem[_15183 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _15738 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15738 + 68] = mem[idx + _15183 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15738 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15738 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _16935 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16935] = 30
                        mem[_16935 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _17239 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _17239 + 68] = mem[idx + _16935 + 32]
                            idx = idx + 32
                            continue 
                        mem[_17239 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _17239 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9308 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9308] = 30
                        mem[_9308 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9388 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9388 + 68] = mem[idx + _9308 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9388 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9388 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9741 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9741] = 30
                        mem[_9741 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _9789 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9789 + 68] = mem[idx + _9741 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9789 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9789 + -mem[64] + 100
                    _9309 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9309] = 26
                    mem[_9309 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9389 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9389 + 68] = mem[idx + _9309 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9389 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9389 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor14 / 100 / 100:
                                if not arg1 * stor15 / 100 / 100:
                                    return 0
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _10441 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10441] = 30
                                mem[_10441 + 32] = 'SafeMath: subtraction overflow'
                                _11359 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11359] = 30
                                mem[_11359 + 32] = 'SafeMath: subtraction overflow'
                                _13093 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13093] = 30
                                mem[_13093 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                    if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13588 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13588 + 68] = mem[idx + _13093 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13588 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13588 + -mem[64] + 100
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                _10440 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10440] = 30
                                mem[_10440 + 32] = 'SafeMath: subtraction overflow'
                                _11358 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11358] = 30
                                mem[_11358 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                    _11714 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11714 + 68] = mem[idx + _11358 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11714 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11714 + -mem[64] + 100
                                if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                _13091 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13091] = 30
                                mem[_13091 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13587 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13587 + 68] = mem[idx + _13091 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13587 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13587 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11050 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11050] = 30
                            mem[_11050 + 32] = 'SafeMath: subtraction overflow'
                            _12619 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12619] = 30
                            mem[_12619 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _13090 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13090 + 68] = mem[idx + _12619 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13090 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13090 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _14710 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14710] = 30
                            mem[_14710 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _15192 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15192 + 68] = mem[idx + _14710 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15192 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15192 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                _10439 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10439] = 30
                                mem[_10439 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    _10557 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _10557 + 68] = mem[idx + _10439 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10557 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10557 + -mem[64] + 100
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                _11356 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11356] = 30
                                mem[_11356 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    _11713 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11713 + 68] = mem[idx + _11356 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11713 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11713 + -mem[64] + 100
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _13088 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13088] = 30
                                mem[_13088 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13586 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13586 + 68] = mem[idx + _13088 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13586 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13586 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11049 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11049] = 30
                            mem[_11049 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _11355 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11355 + 68] = mem[idx + _11049 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11355 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11355 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _12617 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12617] = 30
                            mem[_12617 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _13087 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13087 + 68] = mem[idx + _12617 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13087 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13087 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _14708 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14708] = 30
                            mem[_14708 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _15190 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15190 + 68] = mem[idx + _14708 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15190 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15190 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _11048 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11048] = 30
                            mem[_11048 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _11354 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11354 + 68] = mem[idx + _11048 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11354 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11354 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _12615 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12615] = 30
                            mem[_12615 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _13086 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13086 + 68] = mem[idx + _12615 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13086 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13086 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _14706 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14706] = 30
                            mem[_14706 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _15189 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15189 + 68] = mem[idx + _14706 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15189 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15189 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _12145 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12145] = 30
                        mem[_12145 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _12614 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12614 + 68] = mem[idx + _12145 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12614 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12614 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _14167 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14167] = 30
                        mem[_14167 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _14705 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14705 + 68] = mem[idx + _14167 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14705 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14705 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _16257 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16257] = 30
                        mem[_16257 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _16552 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16552 + 68] = mem[idx + _16257 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16552 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16552 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                _10437 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10437] = 30
                                mem[_10437 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _10556 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _10556 + 68] = mem[idx + _10437 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10556 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10556 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _11352 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11352] = 30
                                mem[_11352 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _11711 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11711 + 68] = mem[idx + _11352 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11711 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11711 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _13084 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13084] = 30
                                mem[_13084 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor9 / totalSupply:
                                    if arg1 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor9 / totalSupply)
                                _13585 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13585 + 68] = mem[idx + _13084 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13585 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13585 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11047 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11047] = 30
                            mem[_11047 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11351 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11351 + 68] = mem[idx + _11047 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11351 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11351 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12612 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12612] = 30
                            mem[_12612 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _13083 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13083 + 68] = mem[idx + _12612 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13083 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13083 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _14703 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14703] = 30
                            mem[_14703 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _15187 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15187 + 68] = mem[idx + _14703 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15187 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15187 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _11046 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11046] = 30
                            mem[_11046 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11350 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11350 + 68] = mem[idx + _11046 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11350 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11350 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12610 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12610] = 30
                            mem[_12610 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _13082 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13082 + 68] = mem[idx + _12610 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13082 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13082 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _14701 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14701] = 30
                            mem[_14701 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _15186 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15186 + 68] = mem[idx + _14701 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15186 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15186 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _12144 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12144] = 30
                        mem[_12144 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _12609 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12609 + 68] = mem[idx + _12144 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12609 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12609 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _14165 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14165] = 30
                        mem[_14165 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _14700 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14700 + 68] = mem[idx + _14165 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14700 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14700 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _16254 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16254] = 30
                        mem[_16254 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _16549 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16549 + 68] = mem[idx + _16254 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16549 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16549 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            _11045 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11045] = 30
                            mem[_11045 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _11349 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11349 + 68] = mem[idx + _11045 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11349 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11349 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _12607 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12607] = 30
                            mem[_12607 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                _13081 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13081 + 68] = mem[idx + _12607 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13081 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13081 + -mem[64] + 100
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            _14698 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14698] = 30
                            mem[_14698 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _15185 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15185 + 68] = mem[idx + _14698 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15185 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15185 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _12143 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12143] = 30
                        mem[_12143 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _12606 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12606 + 68] = mem[idx + _12143 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12606 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12606 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _14163 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14163] = 30
                        mem[_14163 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _14697 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14697 + 68] = mem[idx + _14163 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14697 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14697 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        _16252 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16252] = 30
                        mem[_16252 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _16547 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16547 + 68] = mem[idx + _16252 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16547 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16547 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _12142 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12142] = 30
                        mem[_12142 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _12605 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12605 + 68] = mem[idx + _12142 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12605 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12605 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _14161 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14161] = 30
                        mem[_14161 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _14696 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14696 + 68] = mem[idx + _14161 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14696 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14696 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _16250 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16250] = 30
                        mem[_16250 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _16546 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16546 + 68] = mem[idx + _16250 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16546 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16546 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _13584 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13584] = 30
                    mem[_13584 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _14160 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14160 + 68] = mem[idx + _13584 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14160 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14160 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _15751 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15751] = 30
                    mem[_15751 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _16249 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16249 + 68] = mem[idx + _15751 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16249 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16249 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _17244 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_17244] = 30
                    mem[_17244 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor9 / totalSupply)
                    _17353 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _17353 + 68] = mem[idx + _17244 + 32]
                        idx = idx + 32
                        continue 
                    mem[_17353 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _17353 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor9 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor14 / 100 / 100:
                                if arg1 * stor15 / 100 / 100:
                                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                        revert with 0, 17
                                    if not arg1 * stor15 / 100 / 100:
                                        revert with 0, 18
                                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * stor15 / 100 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * stor15 / 100 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor14 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * stor15 / 100 / 100:
                                    if arg1 * stor14 / 100 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * stor14 / 100 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * stor14 / 100 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * stor14 / 100 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                        revert with 0, 17
                                    if not arg1 * stor15 / 100 / 100:
                                        revert with 0, 18
                                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * stor14 / 100 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * stor14 / 100 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * stor15 / 100 / 100 * t / s > -1 * arg1 * stor14 / 100 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * stor14 / 100 / 100 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor14 / 100 / 100:
                                if not arg1 * stor15 / 100 / 100:
                                    if arg1 * stor13 / 100 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                        revert with 0, 17
                                    if not arg1 * stor15 / 100 / 100:
                                        revert with 0, 18
                                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * stor13 / 100 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if arg1 * stor15 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor14 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * stor15 / 100 / 100:
                                    if arg1 * stor13 / 100 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * stor14 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                        revert with 0, 17
                                    if not arg1 * stor15 / 100 / 100:
                                        revert with 0, 18
                                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * stor13 / 100 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * stor14 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * stor15 / 100 / 100 * t / s > (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * stor15 / 100 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * stor14 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * stor14 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            if arg1 * stor15 / 100 / 100:
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                    else:
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            if 0 > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            if 0 > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                else:
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
    return (arg1 * stor9 / totalSupply)
}



}
