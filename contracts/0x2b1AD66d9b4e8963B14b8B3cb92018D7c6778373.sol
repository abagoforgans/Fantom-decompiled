contract main {




// =====================  Runtime code  =====================


#
#  - swapTokensForExactETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5)
#
address factoryAddress;

function factory() {
    return factoryAddress
}

function _fallback() payable {
    revert
}

function sub_5cc59caf(?) payable {
    require calldata.size - 4 >= 128
    require arg2 <= 4294967296
    require arg2 + 36 <= calldata.size
    require arg2.length <= 4294967296 and arg2 + (32 * arg2.length) + 36 <= calldata.size
    mem[96] = arg2.length
    mem[128 len 32 * arg2.length] = call.data[arg2 + 36 len 32 * arg2.length]
    if arg2.length < 2:
        revert with 0, ' INVALID_PATH'
    mem[(32 * arg2.length) + 128] = arg2.length
    if not arg2.length:
        require arg2.length - 1 < arg2.length
        mem[(32 * arg2.length - 1) + (32 * arg2.length) + 160] = arg1
        mem[(64 * arg2.length) + 160] = 2 * arg2.length - 1
        mem[64] = (64 * arg2.length) + (64 * arg2.length - 1) + 192
        if not uint255(arg2.length - 1):
            idx = mem[96] - 1
            while idx > 0:
                require idx - 1 < mem[96]
                _2339 = mem[(32 * idx - 1) + 128]
                require idx < mem[96]
                _2350 = mem[(32 * idx) + 128]
                if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                    if not mem[(32 * idx - 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' IDENTICAL_ADDRESSES'
                    if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                        if not mem[(32 * idx - 1) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2443 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                        mem[mem[64] + 52] = address(_2350)
                        _2444 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2446 = sha3(mem[_2444 + 32 len mem[_2444]])
                        mem[_2443 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2443 + 105] = factoryAddress
                        mem[_2443 + 125] = _2446
                        mem[_2443 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2443 + 72] = 85
                        mem[64] = _2443 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2446, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2446, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2443 + 189 len 96] = ext_call.return_data[0 len 96]
                    else:
                        if not mem[(32 * idx) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2451 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                        mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                        _2452 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2454 = sha3(mem[_2452 + 32 len mem[_2452]])
                        mem[_2451 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2451 + 105] = factoryAddress
                        mem[_2451 + 125] = _2454
                        mem[_2451 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2451 + 72] = 85
                        mem[64] = _2451 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2454, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2454, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2451 + 189 len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    require idx < mem[(32 * arg2.length) + 128]
                    if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                        revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
                    if address(_2339) == address(_2339):
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                            if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                        else:
                            require mem[(32 * idx) + (32 * arg2.length) + 160]
                            if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                        if address(_2339) == address(_2339):
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = ext_call.return_data[18 len 14] + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]
                        if address(_2339) == address(_2339):
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = ext_call.return_data[18 len 14] + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                            if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                        else:
                            require mem[(32 * idx) + (32 * arg2.length) + 160]
                            if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                        if address(_2339) == address(_2339):
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = ext_call.return_data[50 len 14] + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]
                        if address(_2339) == address(_2339):
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = ext_call.return_data[50 len 14] + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' IDENTICAL_ADDRESSES'
                    if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                        if not mem[(32 * idx - 1) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2459 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                        mem[mem[64] + 52] = address(_2350)
                        _2460 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2462 = sha3(mem[_2460 + 32 len mem[_2460]])
                        mem[_2459 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2459 + 105] = factoryAddress
                        mem[_2459 + 125] = _2462
                        mem[_2459 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2459 + 72] = 85
                        mem[64] = _2459 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2462, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2462, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2459 + 189 len 96] = ext_call.return_data[0 len 96]
                    else:
                        if not mem[(32 * idx) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2467 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                        mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                        _2468 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2470 = sha3(mem[_2468 + 32 len mem[_2468]])
                        mem[_2467 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2467 + 105] = factoryAddress
                        mem[_2467 + 125] = _2470
                        mem[_2467 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2467 + 72] = 85
                        mem[64] = _2467 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2470, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2470, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2467 + 189 len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    require idx < mem[(32 * arg2.length) + 128]
                    if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                        revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
                    if address(_2339) == address(_2350):
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                            if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                        else:
                            require mem[(32 * idx) + (32 * arg2.length) + 160]
                            if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                        if address(_2350) == address(_2339):
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = ext_call.return_data[18 len 14] + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]
                        if address(_2350) == address(_2339):
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = ext_call.return_data[18 len 14] + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                            if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                        else:
                            require mem[(32 * idx) + (32 * arg2.length) + 160]
                            if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                        if address(_2350) == address(_2339):
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = ext_call.return_data[50 len 14] + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]
                        if address(_2350) == address(_2339):
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = ext_call.return_data[50 len 14] + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                idx = idx - 1
                continue 
            mem[mem[64]] = 32
            mem[mem[64] + 32] = mem[(64 * arg2.length) + 160]
            _2349 = mem[(64 * arg2.length) + 160]
            mem[mem[64] + 64 len floor32(mem[(64 * arg2.length) + 160])] = mem[(64 * arg2.length) + 192 len floor32(mem[(64 * arg2.length) + 160])]
            return 32, mem[mem[64] + 32 len (32 * _2349) + 32]
        mem[(64 * arg2.length) + 192 len 64 * arg2.length - 1] = code.data[7597 len 64 * arg2.length - 1]
        idx = mem[96] - 1
        while idx > 0:
            require idx - 1 < mem[96]
            _2341 = mem[(32 * idx - 1) + 128]
            require idx < mem[96]
            _2354 = mem[(32 * idx) + 128]
            if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                if not mem[(32 * idx - 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                    if not mem[(32 * idx - 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2475 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                    mem[mem[64] + 52] = address(_2354)
                    _2476 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2478 = sha3(mem[_2476 + 32 len mem[_2476]])
                    mem[_2475 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2475 + 105] = factoryAddress
                    mem[_2475 + 125] = _2478
                    mem[_2475 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2475 + 72] = 85
                    mem[64] = _2475 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2478, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2478, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2475 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2483 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                    _2484 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2486 = sha3(mem[_2484 + 32 len mem[_2484]])
                    mem[_2483 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2483 + 105] = factoryAddress
                    mem[_2483 + 125] = _2486
                    mem[_2483 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2483 + 72] = 85
                    mem[64] = _2483 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2486, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2486, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2483 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg2.length) + 128]
                if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
                if address(_2341) == address(_2341):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg2.length) + 160]
                        if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    if address(_2341) == address(_2341):
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    if address(_2341) == address(_2341):
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg2.length) + 160]
                        if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    if address(_2341) == address(_2341):
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    if address(_2341) == address(_2341):
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
            else:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                    if not mem[(32 * idx - 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2491 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                    mem[mem[64] + 52] = address(_2354)
                    _2492 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2494 = sha3(mem[_2492 + 32 len mem[_2492]])
                    mem[_2491 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2491 + 105] = factoryAddress
                    mem[_2491 + 125] = _2494
                    mem[_2491 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2491 + 72] = 85
                    mem[64] = _2491 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2494, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2494, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2491 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2499 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                    _2500 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2502 = sha3(mem[_2500 + 32 len mem[_2500]])
                    mem[_2499 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2499 + 105] = factoryAddress
                    mem[_2499 + 125] = _2502
                    mem[_2499 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2499 + 72] = 85
                    mem[64] = _2499 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2502, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2502, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2499 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg2.length) + 128]
                if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
                if address(_2341) == address(_2354):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg2.length) + 160]
                        if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    if address(_2354) == address(_2341):
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    if address(_2354) == address(_2341):
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg2.length) + 160]
                        if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    if address(_2354) == address(_2341):
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    if address(_2354) == address(_2341):
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
            idx = idx - 1
            continue 
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[(64 * arg2.length) + 160]
        _2353 = mem[(64 * arg2.length) + 160]
        mem[mem[64] + 64 len floor32(mem[(64 * arg2.length) + 160])] = mem[(64 * arg2.length) + 192 len floor32(mem[(64 * arg2.length) + 160])]
        return 32, mem[mem[64] + 32 len (32 * _2353) + 32]
    mem[(32 * arg2.length) + 160 len 32 * arg2.length] = code.data[7597 len 32 * arg2.length]
    require arg2.length - 1 < arg2.length
    mem[(32 * arg2.length - 1) + (32 * arg2.length) + 160] = arg1
    mem[(64 * arg2.length) + 160] = 2 * arg2.length - 1
    mem[64] = (64 * arg2.length) + (64 * arg2.length - 1) + 192
    if not uint255(arg2.length - 1):
        idx = mem[96] - 1
        while idx > 0:
            require idx - 1 < mem[96]
            _2343 = mem[(32 * idx - 1) + 128]
            require idx < mem[96]
            _2358 = mem[(32 * idx) + 128]
            if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                if not mem[(32 * idx - 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                    if not mem[(32 * idx - 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2507 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                    mem[mem[64] + 52] = address(_2358)
                    _2508 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2510 = sha3(mem[_2508 + 32 len mem[_2508]])
                    mem[_2507 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2507 + 105] = factoryAddress
                    mem[_2507 + 125] = _2510
                    mem[_2507 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2507 + 72] = 85
                    mem[64] = _2507 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2510, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2510, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2507 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2515 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                    _2516 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2518 = sha3(mem[_2516 + 32 len mem[_2516]])
                    mem[_2515 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2515 + 105] = factoryAddress
                    mem[_2515 + 125] = _2518
                    mem[_2515 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2515 + 72] = 85
                    mem[64] = _2515 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2518, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2518, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2515 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg2.length) + 128]
                if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
                if address(_2343) == address(_2343):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg2.length) + 160]
                        if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    if address(_2343) == address(_2343):
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    if address(_2343) == address(_2343):
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg2.length) + 160]
                        if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    if address(_2343) == address(_2343):
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    if address(_2343) == address(_2343):
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
            else:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                    if not mem[(32 * idx - 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2523 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                    mem[mem[64] + 52] = address(_2358)
                    _2524 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2526 = sha3(mem[_2524 + 32 len mem[_2524]])
                    mem[_2523 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2523 + 105] = factoryAddress
                    mem[_2523 + 125] = _2526
                    mem[_2523 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2523 + 72] = 85
                    mem[64] = _2523 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2526, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2526, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2523 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2531 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                    _2532 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2534 = sha3(mem[_2532 + 32 len mem[_2532]])
                    mem[_2531 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2531 + 105] = factoryAddress
                    mem[_2531 + 125] = _2534
                    mem[_2531 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2531 + 72] = 85
                    mem[64] = _2531 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2534, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2534, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2531 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg2.length) + 128]
                if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
                if address(_2343) == address(_2358):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg2.length) + 160]
                        if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    if address(_2358) == address(_2343):
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    if address(_2358) == address(_2343):
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg2.length) + 160]
                        if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    if address(_2358) == address(_2343):
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    if address(_2358) == address(_2343):
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
            idx = idx - 1
            continue 
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[(64 * arg2.length) + 160]
        _2357 = mem[(64 * arg2.length) + 160]
        mem[mem[64] + 64 len floor32(mem[(64 * arg2.length) + 160])] = mem[(64 * arg2.length) + 192 len floor32(mem[(64 * arg2.length) + 160])]
        return 32, mem[mem[64] + 32 len (32 * _2357) + 32]
    mem[(64 * arg2.length) + 192 len 64 * arg2.length - 1] = code.data[7597 len 64 * arg2.length - 1]
    idx = mem[96] - 1
    while idx > 0:
        require idx - 1 < mem[96]
        _2345 = mem[(32 * idx - 1) + 128]
        require idx < mem[96]
        _2362 = mem[(32 * idx) + 128]
        if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
            revert with 0, ' IDENTICAL_ADDRESSES'
        if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
            if not mem[(32 * idx - 1) + 140 len 20]:
                revert with 0, ' ZERO_ADDRESS'
            if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                if not mem[(32 * idx - 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2539 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                mem[mem[64] + 52] = address(_2362)
                _2540 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2542 = sha3(mem[_2540 + 32 len mem[_2540]])
                mem[_2539 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2539 + 105] = factoryAddress
                mem[_2539 + 125] = _2542
                mem[_2539 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2539 + 72] = 85
                mem[64] = _2539 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2542, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2542, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2539 + 189 len 96] = ext_call.return_data[0 len 96]
            else:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2547 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                _2548 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2550 = sha3(mem[_2548 + 32 len mem[_2548]])
                mem[_2547 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2547 + 105] = factoryAddress
                mem[_2547 + 125] = _2550
                mem[_2547 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2547 + 72] = 85
                mem[64] = _2547 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2550, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2550, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2547 + 189 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require idx < mem[(32 * arg2.length) + 128]
            if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
            if address(_2345) == address(_2345):
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                    if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                else:
                    require mem[(32 * idx) + (32 * arg2.length) + 160]
                    if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                if address(_2345) == address(_2345):
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    require idx < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                if address(_2345) == address(_2345):
                    require idx < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
            else:
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                    if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                else:
                    require mem[(32 * idx) + (32 * arg2.length) + 160]
                    if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                if address(_2345) == address(_2345):
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    require idx < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                if address(_2345) == address(_2345):
                    require idx < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
        else:
            if not mem[(32 * idx) + 140 len 20]:
                revert with 0, ' ZERO_ADDRESS'
            if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                if not mem[(32 * idx - 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2555 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                mem[mem[64] + 52] = address(_2362)
                _2556 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2558 = sha3(mem[_2556 + 32 len mem[_2556]])
                mem[_2555 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2555 + 105] = factoryAddress
                mem[_2555 + 125] = _2558
                mem[_2555 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2555 + 72] = 85
                mem[64] = _2555 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2558, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2558, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2555 + 189 len 96] = ext_call.return_data[0 len 96]
            else:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2563 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                _2564 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2566 = sha3(mem[_2564 + 32 len mem[_2564]])
                mem[_2563 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2563 + 105] = factoryAddress
                mem[_2563 + 125] = _2566
                mem[_2563 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2563 + 72] = 85
                mem[64] = _2563 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2566, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2566, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2563 + 189 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require idx < mem[(32 * arg2.length) + 128]
            if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
            if address(_2345) == address(_2362):
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                    if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                else:
                    require mem[(32 * idx) + (32 * arg2.length) + 160]
                    if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                if address(_2362) == address(_2345):
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    require idx < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                if address(_2362) == address(_2345):
                    require idx < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
            else:
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                    if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                else:
                    require mem[(32 * idx) + (32 * arg2.length) + 160]
                    if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                if address(_2362) == address(_2345):
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    require idx < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                if address(_2362) == address(_2345):
                    require idx < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
        idx = idx - 1
        continue 
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[(64 * arg2.length) + 160]
    _2361 = mem[(64 * arg2.length) + 160]
    mem[mem[64] + 64 len floor32(mem[(64 * arg2.length) + 160])] = mem[(64 * arg2.length) + 192 len floor32(mem[(64 * arg2.length) + 160])]
    return 32, mem[mem[64] + 32 len (32 * _2361) + 32]
}

function swapETHForExactTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) payable {
    require calldata.size - 4 >= 128
    require arg2 <= 4294967296
    require arg2 + 36 <= calldata.size
    require arg2.length <= 4294967296 and arg2 + (32 * arg2.length) + 36 <= calldata.size
    mem[96] = arg2.length
    mem[128 len 32 * arg2.length] = call.data[arg2 + 36 len 32 * arg2.length]
    if arg2.length < 2:
        revert with 0, ' INVALID_PATH'
    mem[(32 * arg2.length) + 128] = arg2.length
    if not arg2.length:
        require arg2.length - 1 < arg2.length
        mem[(32 * arg2.length - 1) + (32 * arg2.length) + 160] = arg1
        mem[(64 * arg2.length) + 160] = 2 * arg2.length - 1
        mem[64] = (64 * arg2.length) + (64 * arg2.length - 1) + 192
        if not uint255(arg2.length - 1):
            idx = mem[96] - 1
            while idx > 0:
                require idx - 1 < mem[96]
                _2339 = mem[(32 * idx - 1) + 128]
                require idx < mem[96]
                _2350 = mem[(32 * idx) + 128]
                if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                    if not mem[(32 * idx - 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' IDENTICAL_ADDRESSES'
                    if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                        if not mem[(32 * idx - 1) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2443 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                        mem[mem[64] + 52] = address(_2350)
                        _2444 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2446 = sha3(mem[_2444 + 32 len mem[_2444]])
                        mem[_2443 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2443 + 105] = factoryAddress
                        mem[_2443 + 125] = _2446
                        mem[_2443 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2443 + 72] = 85
                        mem[64] = _2443 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2446, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2446, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2443 + 189 len 96] = ext_call.return_data[0 len 96]
                    else:
                        if not mem[(32 * idx) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2451 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                        mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                        _2452 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2454 = sha3(mem[_2452 + 32 len mem[_2452]])
                        mem[_2451 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2451 + 105] = factoryAddress
                        mem[_2451 + 125] = _2454
                        mem[_2451 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2451 + 72] = 85
                        mem[64] = _2451 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2454, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2454, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2451 + 189 len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    require idx < mem[(32 * arg2.length) + 128]
                    if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                        revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
                    if address(_2339) == address(_2339):
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                            if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                        else:
                            require mem[(32 * idx) + (32 * arg2.length) + 160]
                            if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                        if address(_2339) == address(_2339):
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = ext_call.return_data[18 len 14] + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]
                        if address(_2339) == address(_2339):
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = ext_call.return_data[18 len 14] + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                            if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                        else:
                            require mem[(32 * idx) + (32 * arg2.length) + 160]
                            if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                        if address(_2339) == address(_2339):
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = ext_call.return_data[50 len 14] + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]
                        if address(_2339) == address(_2339):
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = ext_call.return_data[50 len 14] + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' IDENTICAL_ADDRESSES'
                    if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                        if not mem[(32 * idx - 1) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2459 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                        mem[mem[64] + 52] = address(_2350)
                        _2460 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2462 = sha3(mem[_2460 + 32 len mem[_2460]])
                        mem[_2459 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2459 + 105] = factoryAddress
                        mem[_2459 + 125] = _2462
                        mem[_2459 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2459 + 72] = 85
                        mem[64] = _2459 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2462, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2462, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2459 + 189 len 96] = ext_call.return_data[0 len 96]
                    else:
                        if not mem[(32 * idx) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2467 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                        mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                        _2468 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2470 = sha3(mem[_2468 + 32 len mem[_2468]])
                        mem[_2467 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2467 + 105] = factoryAddress
                        mem[_2467 + 125] = _2470
                        mem[_2467 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2467 + 72] = 85
                        mem[64] = _2467 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2470, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2470, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2467 + 189 len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    require idx < mem[(32 * arg2.length) + 128]
                    if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                        revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
                    if address(_2339) == address(_2350):
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                            if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                        else:
                            require mem[(32 * idx) + (32 * arg2.length) + 160]
                            if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                        if address(_2350) == address(_2339):
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = ext_call.return_data[18 len 14] + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]
                        if address(_2350) == address(_2339):
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = ext_call.return_data[18 len 14] + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                            if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                        else:
                            require mem[(32 * idx) + (32 * arg2.length) + 160]
                            if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                        if address(_2350) == address(_2339):
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = ext_call.return_data[50 len 14] + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]
                        if address(_2350) == address(_2339):
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = ext_call.return_data[50 len 14] + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                idx = idx - 1
                continue 
            mem[mem[64]] = 32
            mem[mem[64] + 32] = mem[(64 * arg2.length) + 160]
            _2349 = mem[(64 * arg2.length) + 160]
            mem[mem[64] + 64 len floor32(mem[(64 * arg2.length) + 160])] = mem[(64 * arg2.length) + 192 len floor32(mem[(64 * arg2.length) + 160])]
            return 32, mem[mem[64] + 32 len (32 * _2349) + 32]
        mem[(64 * arg2.length) + 192 len 64 * arg2.length - 1] = code.data[7597 len 64 * arg2.length - 1]
        idx = mem[96] - 1
        while idx > 0:
            require idx - 1 < mem[96]
            _2341 = mem[(32 * idx - 1) + 128]
            require idx < mem[96]
            _2354 = mem[(32 * idx) + 128]
            if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                if not mem[(32 * idx - 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                    if not mem[(32 * idx - 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2475 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                    mem[mem[64] + 52] = address(_2354)
                    _2476 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2478 = sha3(mem[_2476 + 32 len mem[_2476]])
                    mem[_2475 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2475 + 105] = factoryAddress
                    mem[_2475 + 125] = _2478
                    mem[_2475 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2475 + 72] = 85
                    mem[64] = _2475 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2478, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2478, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2475 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2483 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                    _2484 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2486 = sha3(mem[_2484 + 32 len mem[_2484]])
                    mem[_2483 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2483 + 105] = factoryAddress
                    mem[_2483 + 125] = _2486
                    mem[_2483 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2483 + 72] = 85
                    mem[64] = _2483 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2486, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2486, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2483 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg2.length) + 128]
                if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
                if address(_2341) == address(_2341):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg2.length) + 160]
                        if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    if address(_2341) == address(_2341):
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    if address(_2341) == address(_2341):
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg2.length) + 160]
                        if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    if address(_2341) == address(_2341):
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    if address(_2341) == address(_2341):
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
            else:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                    if not mem[(32 * idx - 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2491 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                    mem[mem[64] + 52] = address(_2354)
                    _2492 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2494 = sha3(mem[_2492 + 32 len mem[_2492]])
                    mem[_2491 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2491 + 105] = factoryAddress
                    mem[_2491 + 125] = _2494
                    mem[_2491 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2491 + 72] = 85
                    mem[64] = _2491 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2494, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2494, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2491 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2499 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                    _2500 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2502 = sha3(mem[_2500 + 32 len mem[_2500]])
                    mem[_2499 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2499 + 105] = factoryAddress
                    mem[_2499 + 125] = _2502
                    mem[_2499 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2499 + 72] = 85
                    mem[64] = _2499 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2502, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2502, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2499 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg2.length) + 128]
                if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
                if address(_2341) == address(_2354):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg2.length) + 160]
                        if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    if address(_2354) == address(_2341):
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    if address(_2354) == address(_2341):
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg2.length) + 160]
                        if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    if address(_2354) == address(_2341):
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    if address(_2354) == address(_2341):
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
            idx = idx - 1
            continue 
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[(64 * arg2.length) + 160]
        _2353 = mem[(64 * arg2.length) + 160]
        mem[mem[64] + 64 len floor32(mem[(64 * arg2.length) + 160])] = mem[(64 * arg2.length) + 192 len floor32(mem[(64 * arg2.length) + 160])]
        return 32, mem[mem[64] + 32 len (32 * _2353) + 32]
    mem[(32 * arg2.length) + 160 len 32 * arg2.length] = code.data[7597 len 32 * arg2.length]
    require arg2.length - 1 < arg2.length
    mem[(32 * arg2.length - 1) + (32 * arg2.length) + 160] = arg1
    mem[(64 * arg2.length) + 160] = 2 * arg2.length - 1
    mem[64] = (64 * arg2.length) + (64 * arg2.length - 1) + 192
    if not uint255(arg2.length - 1):
        idx = mem[96] - 1
        while idx > 0:
            require idx - 1 < mem[96]
            _2343 = mem[(32 * idx - 1) + 128]
            require idx < mem[96]
            _2358 = mem[(32 * idx) + 128]
            if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                if not mem[(32 * idx - 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                    if not mem[(32 * idx - 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2507 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                    mem[mem[64] + 52] = address(_2358)
                    _2508 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2510 = sha3(mem[_2508 + 32 len mem[_2508]])
                    mem[_2507 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2507 + 105] = factoryAddress
                    mem[_2507 + 125] = _2510
                    mem[_2507 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2507 + 72] = 85
                    mem[64] = _2507 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2510, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2510, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2507 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2515 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                    _2516 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2518 = sha3(mem[_2516 + 32 len mem[_2516]])
                    mem[_2515 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2515 + 105] = factoryAddress
                    mem[_2515 + 125] = _2518
                    mem[_2515 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2515 + 72] = 85
                    mem[64] = _2515 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2518, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2518, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2515 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg2.length) + 128]
                if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
                if address(_2343) == address(_2343):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg2.length) + 160]
                        if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    if address(_2343) == address(_2343):
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    if address(_2343) == address(_2343):
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg2.length) + 160]
                        if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    if address(_2343) == address(_2343):
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    if address(_2343) == address(_2343):
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
            else:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                    if not mem[(32 * idx - 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2523 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                    mem[mem[64] + 52] = address(_2358)
                    _2524 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2526 = sha3(mem[_2524 + 32 len mem[_2524]])
                    mem[_2523 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2523 + 105] = factoryAddress
                    mem[_2523 + 125] = _2526
                    mem[_2523 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2523 + 72] = 85
                    mem[64] = _2523 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2526, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2526, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2523 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2531 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                    _2532 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2534 = sha3(mem[_2532 + 32 len mem[_2532]])
                    mem[_2531 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2531 + 105] = factoryAddress
                    mem[_2531 + 125] = _2534
                    mem[_2531 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2531 + 72] = 85
                    mem[64] = _2531 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2534, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2534, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2531 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg2.length) + 128]
                if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
                if address(_2343) == address(_2358):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg2.length) + 160]
                        if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    if address(_2358) == address(_2343):
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    if address(_2358) == address(_2343):
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg2.length) + 160]
                        if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    if address(_2358) == address(_2343):
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    if address(_2358) == address(_2343):
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
            idx = idx - 1
            continue 
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[(64 * arg2.length) + 160]
        _2357 = mem[(64 * arg2.length) + 160]
        mem[mem[64] + 64 len floor32(mem[(64 * arg2.length) + 160])] = mem[(64 * arg2.length) + 192 len floor32(mem[(64 * arg2.length) + 160])]
        return 32, mem[mem[64] + 32 len (32 * _2357) + 32]
    mem[(64 * arg2.length) + 192 len 64 * arg2.length - 1] = code.data[7597 len 64 * arg2.length - 1]
    idx = mem[96] - 1
    while idx > 0:
        require idx - 1 < mem[96]
        _2345 = mem[(32 * idx - 1) + 128]
        require idx < mem[96]
        _2362 = mem[(32 * idx) + 128]
        if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
            revert with 0, ' IDENTICAL_ADDRESSES'
        if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
            if not mem[(32 * idx - 1) + 140 len 20]:
                revert with 0, ' ZERO_ADDRESS'
            if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                if not mem[(32 * idx - 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2539 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                mem[mem[64] + 52] = address(_2362)
                _2540 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2542 = sha3(mem[_2540 + 32 len mem[_2540]])
                mem[_2539 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2539 + 105] = factoryAddress
                mem[_2539 + 125] = _2542
                mem[_2539 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2539 + 72] = 85
                mem[64] = _2539 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2542, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2542, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2539 + 189 len 96] = ext_call.return_data[0 len 96]
            else:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2547 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                _2548 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2550 = sha3(mem[_2548 + 32 len mem[_2548]])
                mem[_2547 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2547 + 105] = factoryAddress
                mem[_2547 + 125] = _2550
                mem[_2547 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2547 + 72] = 85
                mem[64] = _2547 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2550, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2550, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2547 + 189 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require idx < mem[(32 * arg2.length) + 128]
            if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
            if address(_2345) == address(_2345):
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                    if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                else:
                    require mem[(32 * idx) + (32 * arg2.length) + 160]
                    if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                if address(_2345) == address(_2345):
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    require idx < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                if address(_2345) == address(_2345):
                    require idx < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
            else:
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                    if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                else:
                    require mem[(32 * idx) + (32 * arg2.length) + 160]
                    if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                if address(_2345) == address(_2345):
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    require idx < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                if address(_2345) == address(_2345):
                    require idx < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
        else:
            if not mem[(32 * idx) + 140 len 20]:
                revert with 0, ' ZERO_ADDRESS'
            if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                if not mem[(32 * idx - 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2555 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                mem[mem[64] + 52] = address(_2362)
                _2556 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2558 = sha3(mem[_2556 + 32 len mem[_2556]])
                mem[_2555 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2555 + 105] = factoryAddress
                mem[_2555 + 125] = _2558
                mem[_2555 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2555 + 72] = 85
                mem[64] = _2555 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2558, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2558, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2555 + 189 len 96] = ext_call.return_data[0 len 96]
            else:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2563 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                _2564 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2566 = sha3(mem[_2564 + 32 len mem[_2564]])
                mem[_2563 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2563 + 105] = factoryAddress
                mem[_2563 + 125] = _2566
                mem[_2563 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2563 + 72] = 85
                mem[64] = _2563 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2566, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2566, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2563 + 189 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require idx < mem[(32 * arg2.length) + 128]
            if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
            if address(_2345) == address(_2362):
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                    if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                else:
                    require mem[(32 * idx) + (32 * arg2.length) + 160]
                    if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                if address(_2362) == address(_2345):
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    require idx < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                if address(_2362) == address(_2345):
                    require idx < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
            else:
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                    if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                else:
                    require mem[(32 * idx) + (32 * arg2.length) + 160]
                    if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                if address(_2362) == address(_2345):
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    require idx < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                if address(_2362) == address(_2345):
                    require idx < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
        idx = idx - 1
        continue 
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[(64 * arg2.length) + 160]
    _2361 = mem[(64 * arg2.length) + 160]
    mem[mem[64] + 64 len floor32(mem[(64 * arg2.length) + 160])] = mem[(64 * arg2.length) + 192 len floor32(mem[(64 * arg2.length) + 160])]
    return 32, mem[mem[64] + 32 len (32 * _2361) + 32]
}

function sub_d6726025(?) {
    require calldata.size - 4 >= 160
    require arg2 <= 4294967296
    require arg2 + 36 <= calldata.size
    require arg2.length <= 4294967296 and arg2 + (32 * arg2.length) + 36 <= calldata.size
    mem[96] = arg2.length
    mem[128 len 32 * arg2.length] = call.data[arg2 + 36 len 32 * arg2.length]
    if arg2.length < 2:
        revert with 0, ' INVALID_PATH'
    mem[(32 * arg2.length) + 128] = arg2.length
    if not arg2.length:
        require arg2.length - 1 < arg2.length
        mem[(32 * arg2.length - 1) + (32 * arg2.length) + 160] = arg1
        mem[(64 * arg2.length) + 160] = 2 * arg2.length - 1
        mem[64] = (64 * arg2.length) + (64 * arg2.length - 1) + 192
        if not uint255(arg2.length - 1):
            idx = mem[96] - 1
            while idx > 0:
                require idx - 1 < mem[96]
                _2339 = mem[(32 * idx - 1) + 128]
                require idx < mem[96]
                _2350 = mem[(32 * idx) + 128]
                if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                    if not mem[(32 * idx - 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' IDENTICAL_ADDRESSES'
                    if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                        if not mem[(32 * idx - 1) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2443 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                        mem[mem[64] + 52] = address(_2350)
                        _2444 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2446 = sha3(mem[_2444 + 32 len mem[_2444]])
                        mem[_2443 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2443 + 105] = factoryAddress
                        mem[_2443 + 125] = _2446
                        mem[_2443 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2443 + 72] = 85
                        mem[64] = _2443 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2446, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2446, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2443 + 189 len 96] = ext_call.return_data[0 len 96]
                    else:
                        if not mem[(32 * idx) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2451 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                        mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                        _2452 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2454 = sha3(mem[_2452 + 32 len mem[_2452]])
                        mem[_2451 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2451 + 105] = factoryAddress
                        mem[_2451 + 125] = _2454
                        mem[_2451 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2451 + 72] = 85
                        mem[64] = _2451 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2454, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2454, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2451 + 189 len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    require idx < mem[(32 * arg2.length) + 128]
                    if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                        revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
                    if address(_2339) == address(_2339):
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                            if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                        else:
                            require mem[(32 * idx) + (32 * arg2.length) + 160]
                            if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                        if address(_2339) == address(_2339):
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                        if address(_2339) == address(_2339):
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                            if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                        else:
                            require mem[(32 * idx) + (32 * arg2.length) + 160]
                            if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                        if address(_2339) == address(_2339):
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                        if address(_2339) == address(_2339):
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' IDENTICAL_ADDRESSES'
                    if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                        if not mem[(32 * idx - 1) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2459 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                        mem[mem[64] + 52] = address(_2350)
                        _2460 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2462 = sha3(mem[_2460 + 32 len mem[_2460]])
                        mem[_2459 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2459 + 105] = factoryAddress
                        mem[_2459 + 125] = _2462
                        mem[_2459 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2459 + 72] = 85
                        mem[64] = _2459 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2462, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2462, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2459 + 189 len 96] = ext_call.return_data[0 len 96]
                    else:
                        if not mem[(32 * idx) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2467 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                        mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                        _2468 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2470 = sha3(mem[_2468 + 32 len mem[_2468]])
                        mem[_2467 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2467 + 105] = factoryAddress
                        mem[_2467 + 125] = _2470
                        mem[_2467 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2467 + 72] = 85
                        mem[64] = _2467 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2470, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2470, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2467 + 189 len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    require idx < mem[(32 * arg2.length) + 128]
                    if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                        revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
                    if address(_2339) == address(_2350):
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                            if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                        else:
                            require mem[(32 * idx) + (32 * arg2.length) + 160]
                            if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                        if address(_2350) == address(_2339):
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                        if address(_2350) == address(_2339):
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                            if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                        else:
                            require mem[(32 * idx) + (32 * arg2.length) + 160]
                            if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                        if address(_2350) == address(_2339):
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                        if address(_2350) == address(_2339):
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx - 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                idx = idx - 1
                continue 
            mem[mem[64]] = 32
            mem[mem[64] + 32] = mem[(64 * arg2.length) + 160]
            _2349 = mem[(64 * arg2.length) + 160]
            mem[mem[64] + 64 len floor32(mem[(64 * arg2.length) + 160])] = mem[(64 * arg2.length) + 192 len floor32(mem[(64 * arg2.length) + 160])]
            return 32, mem[mem[64] + 32 len (32 * _2349) + 32]
        mem[(64 * arg2.length) + 192 len 64 * arg2.length - 1] = code.data[7597 len 64 * arg2.length - 1]
        idx = mem[96] - 1
        while idx > 0:
            require idx - 1 < mem[96]
            _2341 = mem[(32 * idx - 1) + 128]
            require idx < mem[96]
            _2354 = mem[(32 * idx) + 128]
            if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                if not mem[(32 * idx - 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                    if not mem[(32 * idx - 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2475 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                    mem[mem[64] + 52] = address(_2354)
                    _2476 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2478 = sha3(mem[_2476 + 32 len mem[_2476]])
                    mem[_2475 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2475 + 105] = factoryAddress
                    mem[_2475 + 125] = _2478
                    mem[_2475 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2475 + 72] = 85
                    mem[64] = _2475 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2478, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2478, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2475 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2483 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                    _2484 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2486 = sha3(mem[_2484 + 32 len mem[_2484]])
                    mem[_2483 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2483 + 105] = factoryAddress
                    mem[_2483 + 125] = _2486
                    mem[_2483 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2483 + 72] = 85
                    mem[64] = _2483 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2486, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2486, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2483 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg2.length) + 128]
                if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
                if address(_2341) == address(_2341):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg2.length) + 160]
                        if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    if address(_2341) == address(_2341):
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    if address(_2341) == address(_2341):
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg2.length) + 160]
                        if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    if address(_2341) == address(_2341):
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    if address(_2341) == address(_2341):
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
            else:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                    if not mem[(32 * idx - 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2491 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                    mem[mem[64] + 52] = address(_2354)
                    _2492 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2494 = sha3(mem[_2492 + 32 len mem[_2492]])
                    mem[_2491 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2491 + 105] = factoryAddress
                    mem[_2491 + 125] = _2494
                    mem[_2491 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2491 + 72] = 85
                    mem[64] = _2491 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2494, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2494, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2491 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2499 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                    _2500 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2502 = sha3(mem[_2500 + 32 len mem[_2500]])
                    mem[_2499 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2499 + 105] = factoryAddress
                    mem[_2499 + 125] = _2502
                    mem[_2499 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2499 + 72] = 85
                    mem[64] = _2499 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2502, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2502, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2499 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg2.length) + 128]
                if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
                if address(_2341) == address(_2354):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg2.length) + 160]
                        if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    if address(_2354) == address(_2341):
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    if address(_2354) == address(_2341):
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg2.length) + 160]
                        if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    if address(_2354) == address(_2341):
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    if address(_2354) == address(_2341):
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
            idx = idx - 1
            continue 
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[(64 * arg2.length) + 160]
        _2353 = mem[(64 * arg2.length) + 160]
        mem[mem[64] + 64 len floor32(mem[(64 * arg2.length) + 160])] = mem[(64 * arg2.length) + 192 len floor32(mem[(64 * arg2.length) + 160])]
        return 32, mem[mem[64] + 32 len (32 * _2353) + 32]
    mem[(32 * arg2.length) + 160 len 32 * arg2.length] = code.data[7597 len 32 * arg2.length]
    require arg2.length - 1 < arg2.length
    mem[(32 * arg2.length - 1) + (32 * arg2.length) + 160] = arg1
    mem[(64 * arg2.length) + 160] = 2 * arg2.length - 1
    mem[64] = (64 * arg2.length) + (64 * arg2.length - 1) + 192
    if not uint255(arg2.length - 1):
        idx = mem[96] - 1
        while idx > 0:
            require idx - 1 < mem[96]
            _2343 = mem[(32 * idx - 1) + 128]
            require idx < mem[96]
            _2358 = mem[(32 * idx) + 128]
            if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                if not mem[(32 * idx - 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                    if not mem[(32 * idx - 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2507 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                    mem[mem[64] + 52] = address(_2358)
                    _2508 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2510 = sha3(mem[_2508 + 32 len mem[_2508]])
                    mem[_2507 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2507 + 105] = factoryAddress
                    mem[_2507 + 125] = _2510
                    mem[_2507 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2507 + 72] = 85
                    mem[64] = _2507 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2510, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2510, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2507 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2515 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                    _2516 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2518 = sha3(mem[_2516 + 32 len mem[_2516]])
                    mem[_2515 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2515 + 105] = factoryAddress
                    mem[_2515 + 125] = _2518
                    mem[_2515 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2515 + 72] = 85
                    mem[64] = _2515 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2518, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2518, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2515 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg2.length) + 128]
                if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
                if address(_2343) == address(_2343):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg2.length) + 160]
                        if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    if address(_2343) == address(_2343):
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    if address(_2343) == address(_2343):
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg2.length) + 160]
                        if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    if address(_2343) == address(_2343):
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    if address(_2343) == address(_2343):
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
            else:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                    if not mem[(32 * idx - 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2523 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                    mem[mem[64] + 52] = address(_2358)
                    _2524 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2526 = sha3(mem[_2524 + 32 len mem[_2524]])
                    mem[_2523 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2523 + 105] = factoryAddress
                    mem[_2523 + 125] = _2526
                    mem[_2523 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2523 + 72] = 85
                    mem[64] = _2523 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2526, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2526, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2523 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2531 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                    _2532 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2534 = sha3(mem[_2532 + 32 len mem[_2532]])
                    mem[_2531 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2531 + 105] = factoryAddress
                    mem[_2531 + 125] = _2534
                    mem[_2531 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2531 + 72] = 85
                    mem[64] = _2531 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2534, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2534, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2531 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg2.length) + 128]
                if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
                if address(_2343) == address(_2358):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg2.length) + 160]
                        if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    if address(_2358) == address(_2343):
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    if address(_2358) == address(_2343):
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg2.length) + 160]
                        if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                    if address(_2358) == address(_2343):
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    if address(_2358) == address(_2343):
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
            idx = idx - 1
            continue 
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[(64 * arg2.length) + 160]
        _2357 = mem[(64 * arg2.length) + 160]
        mem[mem[64] + 64 len floor32(mem[(64 * arg2.length) + 160])] = mem[(64 * arg2.length) + 192 len floor32(mem[(64 * arg2.length) + 160])]
        return 32, mem[mem[64] + 32 len (32 * _2357) + 32]
    mem[(64 * arg2.length) + 192 len 64 * arg2.length - 1] = code.data[7597 len 64 * arg2.length - 1]
    idx = mem[96] - 1
    while idx > 0:
        require idx - 1 < mem[96]
        _2345 = mem[(32 * idx - 1) + 128]
        require idx < mem[96]
        _2362 = mem[(32 * idx) + 128]
        if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
            revert with 0, ' IDENTICAL_ADDRESSES'
        if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
            if not mem[(32 * idx - 1) + 140 len 20]:
                revert with 0, ' ZERO_ADDRESS'
            if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                if not mem[(32 * idx - 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2539 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                mem[mem[64] + 52] = address(_2362)
                _2540 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2542 = sha3(mem[_2540 + 32 len mem[_2540]])
                mem[_2539 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2539 + 105] = factoryAddress
                mem[_2539 + 125] = _2542
                mem[_2539 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2539 + 72] = 85
                mem[64] = _2539 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2542, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2542, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2539 + 189 len 96] = ext_call.return_data[0 len 96]
            else:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2547 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                _2548 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2550 = sha3(mem[_2548 + 32 len mem[_2548]])
                mem[_2547 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2547 + 105] = factoryAddress
                mem[_2547 + 125] = _2550
                mem[_2547 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2547 + 72] = 85
                mem[64] = _2547 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2550, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2550, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2547 + 189 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require idx < mem[(32 * arg2.length) + 128]
            if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
            if address(_2345) == address(_2345):
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                    if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                else:
                    require mem[(32 * idx) + (32 * arg2.length) + 160]
                    if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                if address(_2345) == address(_2345):
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    require idx < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                if address(_2345) == address(_2345):
                    require idx < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
            else:
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                    if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                else:
                    require mem[(32 * idx) + (32 * arg2.length) + 160]
                    if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                if address(_2345) == address(_2345):
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    require idx < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                if address(_2345) == address(_2345):
                    require idx < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
        else:
            if not mem[(32 * idx) + 140 len 20]:
                revert with 0, ' ZERO_ADDRESS'
            if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                if not mem[(32 * idx - 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2555 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                mem[mem[64] + 52] = address(_2362)
                _2556 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2558 = sha3(mem[_2556 + 32 len mem[_2556]])
                mem[_2555 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2555 + 105] = factoryAddress
                mem[_2555 + 125] = _2558
                mem[_2555 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2555 + 72] = 85
                mem[64] = _2555 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2558, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2558, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2555 + 189 len 96] = ext_call.return_data[0 len 96]
            else:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2563 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                _2564 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2566 = sha3(mem[_2564 + 32 len mem[_2564]])
                mem[_2563 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2563 + 105] = factoryAddress
                mem[_2563 + 125] = _2566
                mem[_2563 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2563 + 72] = 85
                mem[64] = _2563 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2566, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2566, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2563 + 189 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require idx < mem[(32 * arg2.length) + 128]
            if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
            if address(_2345) == address(_2362):
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                    if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                else:
                    require mem[(32 * idx) + (32 * arg2.length) + 160]
                    if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                if address(_2362) == address(_2345):
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    require idx < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                if address(_2362) == address(_2345):
                    require idx < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
            else:
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if not mem[(32 * idx) + (32 * arg2.length) + 160]:
                    if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                else:
                    require mem[(32 * idx) + (32 * arg2.length) + 160]
                    if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / mem[(32 * idx) + (32 * arg2.length) + 160] != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160] > ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg2.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg2.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160])) + 1
                if address(_2362) == address(_2345):
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
                else:
                    require idx < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                if address(_2362) == address(_2345):
                    require idx < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    require idx - 1 < mem[(32 * arg2.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg2.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg2.length) + 160]
        idx = idx - 1
        continue 
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[(64 * arg2.length) + 160]
    _2361 = mem[(64 * arg2.length) + 160]
    mem[mem[64] + 64 len floor32(mem[(64 * arg2.length) + 160])] = mem[(64 * arg2.length) + 192 len floor32(mem[(64 * arg2.length) + 160])]
    return 32, mem[mem[64] + 32 len (32 * _2361) + 32]
}

function swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) {
    require calldata.size - 4 >= 160
    require arg3 <= 4294967296
    require arg3 + 36 <= calldata.size
    require arg3.length <= 4294967296 and arg3 + (32 * arg3.length) + 36 <= calldata.size
    mem[96] = arg3.length
    mem[128 len 32 * arg3.length] = call.data[arg3 + 36 len 32 * arg3.length]
    if arg3.length < 2:
        revert with 0, ' INVALID_PATH'
    mem[(32 * arg3.length) + 128] = arg3.length
    if not arg3.length:
        require arg3.length - 1 < arg3.length
        mem[(32 * arg3.length - 1) + (32 * arg3.length) + 160] = arg1
        mem[(64 * arg3.length) + 160] = 2 * arg3.length - 1
        mem[64] = (64 * arg3.length) + (64 * arg3.length - 1) + 192
        if not uint255(arg3.length - 1):
            idx = mem[96] - 1
            while idx > 0:
                require idx - 1 < mem[96]
                _2339 = mem[(32 * idx - 1) + 128]
                require idx < mem[96]
                _2350 = mem[(32 * idx) + 128]
                if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                    if not mem[(32 * idx - 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' IDENTICAL_ADDRESSES'
                    if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                        if not mem[(32 * idx - 1) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2443 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                        mem[mem[64] + 52] = address(_2350)
                        _2444 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2446 = sha3(mem[_2444 + 32 len mem[_2444]])
                        mem[_2443 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2443 + 105] = factoryAddress
                        mem[_2443 + 125] = _2446
                        mem[_2443 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2443 + 72] = 85
                        mem[64] = _2443 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2446, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2446, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2443 + 189 len 96] = ext_call.return_data[0 len 96]
                    else:
                        if not mem[(32 * idx) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2451 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                        mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                        _2452 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2454 = sha3(mem[_2452 + 32 len mem[_2452]])
                        mem[_2451 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2451 + 105] = factoryAddress
                        mem[_2451 + 125] = _2454
                        mem[_2451 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2451 + 72] = 85
                        mem[64] = _2451 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2454, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2454, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2451 + 189 len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    require idx < mem[(32 * arg3.length) + 128]
                    if mem[(32 * idx) + (32 * arg3.length) + 160] <= 0:
                        revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
                    if address(_2339) == address(_2339):
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if not mem[(32 * idx) + (32 * arg3.length) + 160]:
                            if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg3.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                        else:
                            require mem[(32 * idx) + (32 * arg3.length) + 160]
                            if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / mem[(32 * idx) + (32 * arg3.length) + 160] != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg3.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                        if address(_2339) == address(_2339):
                            require idx - 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                        if address(_2339) == address(_2339):
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx - 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
                    else:
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if not mem[(32 * idx) + (32 * arg3.length) + 160]:
                            if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg3.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                        else:
                            require mem[(32 * idx) + (32 * arg3.length) + 160]
                            if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / mem[(32 * idx) + (32 * arg3.length) + 160] != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg3.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                        if address(_2339) == address(_2339):
                            require idx - 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                        if address(_2339) == address(_2339):
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx - 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' IDENTICAL_ADDRESSES'
                    if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                        if not mem[(32 * idx - 1) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2459 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                        mem[mem[64] + 52] = address(_2350)
                        _2460 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2462 = sha3(mem[_2460 + 32 len mem[_2460]])
                        mem[_2459 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2459 + 105] = factoryAddress
                        mem[_2459 + 125] = _2462
                        mem[_2459 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2459 + 72] = 85
                        mem[64] = _2459 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2462, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2462, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2459 + 189 len 96] = ext_call.return_data[0 len 96]
                    else:
                        if not mem[(32 * idx) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2467 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                        mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                        _2468 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2470 = sha3(mem[_2468 + 32 len mem[_2468]])
                        mem[_2467 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2467 + 105] = factoryAddress
                        mem[_2467 + 125] = _2470
                        mem[_2467 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2467 + 72] = 85
                        mem[64] = _2467 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2470, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2470, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2467 + 189 len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    require idx < mem[(32 * arg3.length) + 128]
                    if mem[(32 * idx) + (32 * arg3.length) + 160] <= 0:
                        revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
                    if address(_2339) == address(_2350):
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if not mem[(32 * idx) + (32 * arg3.length) + 160]:
                            if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg3.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                        else:
                            require mem[(32 * idx) + (32 * arg3.length) + 160]
                            if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / mem[(32 * idx) + (32 * arg3.length) + 160] != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg3.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                        if address(_2350) == address(_2339):
                            require idx - 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                        if address(_2350) == address(_2339):
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx - 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
                    else:
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if not mem[(32 * idx) + (32 * arg3.length) + 160]:
                            if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg3.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                        else:
                            require mem[(32 * idx) + (32 * arg3.length) + 160]
                            if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / mem[(32 * idx) + (32 * arg3.length) + 160] != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-sub-underflow'
                            if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                                revert with 0, 'ds-math-add-overflow'
                            require idx - 1 < mem[(32 * arg3.length) + 128]
                            mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                        if address(_2350) == address(_2339):
                            require idx - 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                        if address(_2350) == address(_2339):
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx - 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
                idx = idx - 1
                continue 
            mem[mem[64]] = 32
            mem[mem[64] + 32] = mem[(64 * arg3.length) + 160]
            _2349 = mem[(64 * arg3.length) + 160]
            mem[mem[64] + 64 len floor32(mem[(64 * arg3.length) + 160])] = mem[(64 * arg3.length) + 192 len floor32(mem[(64 * arg3.length) + 160])]
            return 32, mem[mem[64] + 32 len (32 * _2349) + 32]
        mem[(64 * arg3.length) + 192 len 64 * arg3.length - 1] = code.data[7597 len 64 * arg3.length - 1]
        idx = mem[96] - 1
        while idx > 0:
            require idx - 1 < mem[96]
            _2341 = mem[(32 * idx - 1) + 128]
            require idx < mem[96]
            _2354 = mem[(32 * idx) + 128]
            if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                if not mem[(32 * idx - 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                    if not mem[(32 * idx - 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2475 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                    mem[mem[64] + 52] = address(_2354)
                    _2476 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2478 = sha3(mem[_2476 + 32 len mem[_2476]])
                    mem[_2475 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2475 + 105] = factoryAddress
                    mem[_2475 + 125] = _2478
                    mem[_2475 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2475 + 72] = 85
                    mem[64] = _2475 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2478, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2478, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2475 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2483 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                    _2484 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2486 = sha3(mem[_2484 + 32 len mem[_2484]])
                    mem[_2483 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2483 + 105] = factoryAddress
                    mem[_2483 + 125] = _2486
                    mem[_2483 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2483 + 72] = 85
                    mem[64] = _2483 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2486, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2486, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2483 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg3.length) + 128]
                if mem[(32 * idx) + (32 * arg3.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
                if address(_2341) == address(_2341):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg3.length) + 160]:
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg3.length) + 160]
                        if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / mem[(32 * idx) + (32 * arg3.length) + 160] != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                    if address(_2341) == address(_2341):
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
                    else:
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                    if address(_2341) == address(_2341):
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg3.length) + 160]:
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg3.length) + 160]
                        if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / mem[(32 * idx) + (32 * arg3.length) + 160] != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                    if address(_2341) == address(_2341):
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
                    else:
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                    if address(_2341) == address(_2341):
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
            else:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                    if not mem[(32 * idx - 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2491 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                    mem[mem[64] + 52] = address(_2354)
                    _2492 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2494 = sha3(mem[_2492 + 32 len mem[_2492]])
                    mem[_2491 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2491 + 105] = factoryAddress
                    mem[_2491 + 125] = _2494
                    mem[_2491 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2491 + 72] = 85
                    mem[64] = _2491 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2494, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2494, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2491 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2499 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                    _2500 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2502 = sha3(mem[_2500 + 32 len mem[_2500]])
                    mem[_2499 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2499 + 105] = factoryAddress
                    mem[_2499 + 125] = _2502
                    mem[_2499 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2499 + 72] = 85
                    mem[64] = _2499 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2502, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2502, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2499 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg3.length) + 128]
                if mem[(32 * idx) + (32 * arg3.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
                if address(_2341) == address(_2354):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg3.length) + 160]:
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg3.length) + 160]
                        if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / mem[(32 * idx) + (32 * arg3.length) + 160] != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                    if address(_2354) == address(_2341):
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
                    else:
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                    if address(_2354) == address(_2341):
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg3.length) + 160]:
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg3.length) + 160]
                        if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / mem[(32 * idx) + (32 * arg3.length) + 160] != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                    if address(_2354) == address(_2341):
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
                    else:
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                    if address(_2354) == address(_2341):
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
            idx = idx - 1
            continue 
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[(64 * arg3.length) + 160]
        _2353 = mem[(64 * arg3.length) + 160]
        mem[mem[64] + 64 len floor32(mem[(64 * arg3.length) + 160])] = mem[(64 * arg3.length) + 192 len floor32(mem[(64 * arg3.length) + 160])]
        return 32, mem[mem[64] + 32 len (32 * _2353) + 32]
    mem[(32 * arg3.length) + 160 len 32 * arg3.length] = code.data[7597 len 32 * arg3.length]
    require arg3.length - 1 < arg3.length
    mem[(32 * arg3.length - 1) + (32 * arg3.length) + 160] = arg1
    mem[(64 * arg3.length) + 160] = 2 * arg3.length - 1
    mem[64] = (64 * arg3.length) + (64 * arg3.length - 1) + 192
    if not uint255(arg3.length - 1):
        idx = mem[96] - 1
        while idx > 0:
            require idx - 1 < mem[96]
            _2343 = mem[(32 * idx - 1) + 128]
            require idx < mem[96]
            _2358 = mem[(32 * idx) + 128]
            if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                if not mem[(32 * idx - 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                    if not mem[(32 * idx - 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2507 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                    mem[mem[64] + 52] = address(_2358)
                    _2508 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2510 = sha3(mem[_2508 + 32 len mem[_2508]])
                    mem[_2507 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2507 + 105] = factoryAddress
                    mem[_2507 + 125] = _2510
                    mem[_2507 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2507 + 72] = 85
                    mem[64] = _2507 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2510, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2510, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2507 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2515 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                    _2516 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2518 = sha3(mem[_2516 + 32 len mem[_2516]])
                    mem[_2515 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2515 + 105] = factoryAddress
                    mem[_2515 + 125] = _2518
                    mem[_2515 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2515 + 72] = 85
                    mem[64] = _2515 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2518, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2518, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2515 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg3.length) + 128]
                if mem[(32 * idx) + (32 * arg3.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
                if address(_2343) == address(_2343):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg3.length) + 160]:
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg3.length) + 160]
                        if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / mem[(32 * idx) + (32 * arg3.length) + 160] != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                    if address(_2343) == address(_2343):
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
                    else:
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                    if address(_2343) == address(_2343):
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg3.length) + 160]:
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg3.length) + 160]
                        if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / mem[(32 * idx) + (32 * arg3.length) + 160] != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                    if address(_2343) == address(_2343):
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
                    else:
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                    if address(_2343) == address(_2343):
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
            else:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                    if not mem[(32 * idx - 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2523 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                    mem[mem[64] + 52] = address(_2358)
                    _2524 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2526 = sha3(mem[_2524 + 32 len mem[_2524]])
                    mem[_2523 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2523 + 105] = factoryAddress
                    mem[_2523 + 125] = _2526
                    mem[_2523 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2523 + 72] = 85
                    mem[64] = _2523 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2526, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2526, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2523 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2531 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                    _2532 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2534 = sha3(mem[_2532 + 32 len mem[_2532]])
                    mem[_2531 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2531 + 105] = factoryAddress
                    mem[_2531 + 125] = _2534
                    mem[_2531 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2531 + 72] = 85
                    mem[64] = _2531 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2534, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2534, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2531 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg3.length) + 128]
                if mem[(32 * idx) + (32 * arg3.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
                if address(_2343) == address(_2358):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg3.length) + 160]:
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg3.length) + 160]
                        if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / mem[(32 * idx) + (32 * arg3.length) + 160] != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                    if address(_2358) == address(_2343):
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
                    else:
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                    if address(_2358) == address(_2343):
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if not mem[(32 * idx) + (32 * arg3.length) + 160]:
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                    else:
                        require mem[(32 * idx) + (32 * arg3.length) + 160]
                        if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / mem[(32 * idx) + (32 * arg3.length) + 160] != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-sub-underflow'
                        if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                            revert with 0, 'ds-math-add-overflow'
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                    if address(_2358) == address(_2343):
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
                    else:
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                    if address(_2358) == address(_2343):
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require idx - 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
            idx = idx - 1
            continue 
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[(64 * arg3.length) + 160]
        _2357 = mem[(64 * arg3.length) + 160]
        mem[mem[64] + 64 len floor32(mem[(64 * arg3.length) + 160])] = mem[(64 * arg3.length) + 192 len floor32(mem[(64 * arg3.length) + 160])]
        return 32, mem[mem[64] + 32 len (32 * _2357) + 32]
    mem[(64 * arg3.length) + 192 len 64 * arg3.length - 1] = code.data[7597 len 64 * arg3.length - 1]
    idx = mem[96] - 1
    while idx > 0:
        require idx - 1 < mem[96]
        _2345 = mem[(32 * idx - 1) + 128]
        require idx < mem[96]
        _2362 = mem[(32 * idx) + 128]
        if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
            revert with 0, ' IDENTICAL_ADDRESSES'
        if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
            if not mem[(32 * idx - 1) + 140 len 20]:
                revert with 0, ' ZERO_ADDRESS'
            if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                if not mem[(32 * idx - 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2539 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                mem[mem[64] + 52] = address(_2362)
                _2540 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2542 = sha3(mem[_2540 + 32 len mem[_2540]])
                mem[_2539 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2539 + 105] = factoryAddress
                mem[_2539 + 125] = _2542
                mem[_2539 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2539 + 72] = 85
                mem[64] = _2539 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2542, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2542, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2539 + 189 len 96] = ext_call.return_data[0 len 96]
            else:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2547 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                _2548 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2550 = sha3(mem[_2548 + 32 len mem[_2548]])
                mem[_2547 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2547 + 105] = factoryAddress
                mem[_2547 + 125] = _2550
                mem[_2547 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2547 + 72] = 85
                mem[64] = _2547 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2550, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2550, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2547 + 189 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require idx < mem[(32 * arg3.length) + 128]
            if mem[(32 * idx) + (32 * arg3.length) + 160] <= 0:
                revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
            if address(_2345) == address(_2345):
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if not mem[(32 * idx) + (32 * arg3.length) + 160]:
                    if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg3.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                else:
                    require mem[(32 * idx) + (32 * arg3.length) + 160]
                    if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / mem[(32 * idx) + (32 * arg3.length) + 160] != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg3.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                if address(_2345) == address(_2345):
                    require idx - 1 < mem[(32 * arg3.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
                else:
                    require idx < mem[(32 * arg3.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                if address(_2345) == address(_2345):
                    require idx < mem[(32 * arg3.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                else:
                    require idx - 1 < mem[(32 * arg3.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
            else:
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if not mem[(32 * idx) + (32 * arg3.length) + 160]:
                    if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg3.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                else:
                    require mem[(32 * idx) + (32 * arg3.length) + 160]
                    if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / mem[(32 * idx) + (32 * arg3.length) + 160] != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg3.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                if address(_2345) == address(_2345):
                    require idx - 1 < mem[(32 * arg3.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
                else:
                    require idx < mem[(32 * arg3.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                if address(_2345) == address(_2345):
                    require idx < mem[(32 * arg3.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                else:
                    require idx - 1 < mem[(32 * arg3.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
        else:
            if not mem[(32 * idx) + 140 len 20]:
                revert with 0, ' ZERO_ADDRESS'
            if mem[(32 * idx - 1) + 140 len 20] == mem[(32 * idx) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx - 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                if not mem[(32 * idx - 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2555 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx - 1) + 128])
                mem[mem[64] + 52] = address(_2362)
                _2556 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2558 = sha3(mem[_2556 + 32 len mem[_2556]])
                mem[_2555 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2555 + 105] = factoryAddress
                mem[_2555 + 125] = _2558
                mem[_2555 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2555 + 72] = 85
                mem[64] = _2555 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2558, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2558, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2555 + 189 len 96] = ext_call.return_data[0 len 96]
            else:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2563 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                mem[mem[64] + 52] = address(mem[(32 * idx - 1) + 128])
                _2564 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2566 = sha3(mem[_2564 + 32 len mem[_2564]])
                mem[_2563 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2563 + 105] = factoryAddress
                mem[_2563 + 125] = _2566
                mem[_2563 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2563 + 72] = 85
                mem[64] = _2563 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2566, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2566, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2563 + 189 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require idx < mem[(32 * arg3.length) + 128]
            if mem[(32 * idx) + (32 * arg3.length) + 160] <= 0:
                revert with 0, ' INSUFFICIENT_OUTPUT_AMOUNT'
            if address(_2345) == address(_2362):
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if not mem[(32 * idx) + (32 * arg3.length) + 160]:
                    if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    if (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg3.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (0 / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                else:
                    require mem[(32 * idx) + (32 * arg3.length) + 160]
                    if ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / mem[(32 * idx) + (32 * arg3.length) + 160] != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / 1000 != ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[50 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    if (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg3.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (1000 * ext_call.return_data[18 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[50 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                if address(_2362) == address(_2345):
                    require idx - 1 < mem[(32 * arg3.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
                else:
                    require idx < mem[(32 * arg3.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                if address(_2362) == address(_2345):
                    require idx < mem[(32 * arg3.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                else:
                    require idx - 1 < mem[(32 * arg3.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
            else:
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if not mem[(32 * idx) + (32 * arg3.length) + 160]:
                    if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    if (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg3.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (0 / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                else:
                    require mem[(32 * idx) + (32 * arg3.length) + 160]
                    if ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / mem[(32 * idx) + (32 * arg3.length) + 160] != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / 1000 != ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160] > ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-sub-underflow'
                    if (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) / 997 != ext_call.return_data[18 len 14] - mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    require (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    if (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1 < 1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160]):
                        revert with 0, 'ds-math-add-overflow'
                    require idx - 1 < mem[(32 * arg3.length) + 128]
                    mem[(32 * idx - 1) + (32 * arg3.length) + 160] = (1000 * ext_call.return_data[50 len 14] * mem[(32 * idx) + (32 * arg3.length) + 160] / (997 * ext_call.return_data[18 len 14]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160])) + 1
                if address(_2362) == address(_2345):
                    require idx - 1 < mem[(32 * arg3.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
                else:
                    require idx < mem[(32 * arg3.length) + 128]
                    require (2 * idx) - 2 < mem[(64 * arg3.length) + 160]
                    mem[(32 * (2 * idx) - 2) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                if address(_2362) == address(_2345):
                    require idx < mem[(32 * arg3.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + (32 * arg3.length) + 160]
                else:
                    require idx - 1 < mem[(32 * arg3.length) + 128]
                    require (2 * idx) - 1 < mem[(64 * arg3.length) + 160]
                    mem[(32 * (2 * idx) - 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx - 1) + (32 * arg3.length) + 160]
        idx = idx - 1
        continue 
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[(64 * arg3.length) + 160]
    _2361 = mem[(64 * arg3.length) + 160]
    mem[mem[64] + 64 len floor32(mem[(64 * arg3.length) + 160])] = mem[(64 * arg3.length) + 192 len floor32(mem[(64 * arg3.length) + 160])]
    return 32, mem[mem[64] + 32 len (32 * _2361) + 32]
}

function sub_e932f3ac(?) {
    require calldata.size - 4 >= 160
    require arg2 <= 4294967296
    require arg2 + 36 <= calldata.size
    require arg2.length <= 4294967296 and arg2 + (32 * arg2.length) + 36 <= calldata.size
    mem[96] = arg2.length
    mem[128 len 32 * arg2.length] = call.data[arg2 + 36 len 32 * arg2.length]
    if arg2.length < 2:
        revert with 0, ' INVALID_PATH'
    mem[(32 * arg2.length) + 128] = arg2.length
    if not arg2.length:
        mem[(64 * arg2.length) + 160] = 2 * arg2.length - 1
        mem[64] = (64 * arg2.length) + (64 * arg2.length - 1) + 192
        if not uint255(arg2.length - 1):
            require 0 < arg2.length
            mem[(32 * arg2.length) + 160] = arg1
            idx = 0
            while idx < arg2.length - 1:
                require idx < mem[96]
                _2215 = mem[(32 * idx) + 128]
                require idx + 1 < mem[96]
                _2226 = mem[(32 * idx + 1) + 128]
                if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' IDENTICAL_ADDRESSES'
                    if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                        if not mem[(32 * idx) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2319 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                        mem[mem[64] + 52] = address(_2226)
                        _2320 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2322 = sha3(mem[_2320 + 32 len mem[_2320]])
                        mem[_2319 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2319 + 105] = factoryAddress
                        mem[_2319 + 125] = _2322
                        mem[_2319 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2319 + 72] = 85
                        mem[64] = _2319 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2322, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2322, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2319 + 189 len 96] = ext_call.return_data[0 len 96]
                    else:
                        if not mem[(32 * idx + 1) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2327 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                        mem[mem[64] + 52] = address(_2215)
                        _2328 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2330 = sha3(mem[_2328 + 32 len mem[_2328]])
                        mem[_2327 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2327 + 105] = factoryAddress
                        mem[_2327 + 125] = _2330
                        mem[_2327 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2327 + 72] = 85
                        mem[64] = _2327 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2330, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2330, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2327 + 189 len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    require idx < mem[(32 * arg2.length) + 128]
                    if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                        revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                    if address(_2215) == address(_2215):
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if not ext_call.return_data[50 len 14]:
                            if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if address(_2215) == address(_2215):
                                require idx < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            if address(_2215) == address(_2215):
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            else:
                                require idx < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require ext_call.return_data[50 len 14]
                            if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if address(_2215) == address(_2215):
                                require idx < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            if address(_2215) == address(_2215):
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            else:
                                require idx < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if not ext_call.return_data[18 len 14]:
                            if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if address(_2215) == address(_2215):
                                require idx < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            if address(_2215) == address(_2215):
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            else:
                                require idx < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require ext_call.return_data[18 len 14]
                            if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if address(_2215) == address(_2215):
                                require idx < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            if address(_2215) == address(_2215):
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            else:
                                require idx < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    if not mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' IDENTICAL_ADDRESSES'
                    if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                        if not mem[(32 * idx) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2335 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                        mem[mem[64] + 52] = address(_2226)
                        _2336 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2338 = sha3(mem[_2336 + 32 len mem[_2336]])
                        mem[_2335 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2335 + 105] = factoryAddress
                        mem[_2335 + 125] = _2338
                        mem[_2335 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2335 + 72] = 85
                        mem[64] = _2335 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2338, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2338, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2335 + 189 len 96] = ext_call.return_data[0 len 96]
                    else:
                        if not mem[(32 * idx + 1) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2343 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                        mem[mem[64] + 52] = address(_2215)
                        _2344 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2346 = sha3(mem[_2344 + 32 len mem[_2344]])
                        mem[_2343 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2343 + 105] = factoryAddress
                        mem[_2343 + 125] = _2346
                        mem[_2343 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2343 + 72] = 85
                        mem[64] = _2343 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2346, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2346, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2343 + 189 len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    require idx < mem[(32 * arg2.length) + 128]
                    if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                        revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                    if address(_2215) == address(_2226):
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if not ext_call.return_data[50 len 14]:
                            if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if address(_2226) == address(_2215):
                                require idx < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            if address(_2226) == address(_2215):
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            else:
                                require idx < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require ext_call.return_data[50 len 14]
                            if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if address(_2226) == address(_2215):
                                require idx < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            if address(_2226) == address(_2215):
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            else:
                                require idx < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if not ext_call.return_data[18 len 14]:
                            if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if address(_2226) == address(_2215):
                                require idx < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            if address(_2226) == address(_2215):
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            else:
                                require idx < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require ext_call.return_data[18 len 14]
                            if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if address(_2226) == address(_2215):
                                require idx < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            if address(_2226) == address(_2215):
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            else:
                                require idx < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                idx = idx + 1
                continue 
            mem[mem[64]] = 32
            mem[mem[64] + 32] = mem[(64 * arg2.length) + 160]
            _2225 = mem[(64 * arg2.length) + 160]
            mem[mem[64] + 64 len floor32(mem[(64 * arg2.length) + 160])] = mem[(64 * arg2.length) + 192 len floor32(mem[(64 * arg2.length) + 160])]
            return 32, mem[mem[64] + 32 len (32 * _2225) + 32]
        mem[(64 * arg2.length) + 192 len 64 * arg2.length - 1] = code.data[7597 len 64 * arg2.length - 1]
        require 0 < arg2.length
        mem[(32 * arg2.length) + 160] = arg1
        idx = 0
        while idx < arg2.length - 1:
            require idx < mem[96]
            _2217 = mem[(32 * idx) + 128]
            require idx + 1 < mem[96]
            _2230 = mem[(32 * idx + 1) + 128]
            if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2351 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(_2230)
                    _2352 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2354 = sha3(mem[_2352 + 32 len mem[_2352]])
                    mem[_2351 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2351 + 105] = factoryAddress
                    mem[_2351 + 125] = _2354
                    mem[_2351 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2351 + 72] = 85
                    mem[64] = _2351 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2354, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2354, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2351 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2359 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                    mem[mem[64] + 52] = address(_2217)
                    _2360 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2362 = sha3(mem[_2360 + 32 len mem[_2360]])
                    mem[_2359 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2359 + 105] = factoryAddress
                    mem[_2359 + 125] = _2362
                    mem[_2359 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2359 + 72] = 85
                    mem[64] = _2359 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2362, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2362, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2359 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg2.length) + 128]
                if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                if address(_2217) == address(_2217):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[50 len 14]:
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2217) == address(_2217):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2217) == address(_2217):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require ext_call.return_data[50 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2217) == address(_2217):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2217) == address(_2217):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[18 len 14]:
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2217) == address(_2217):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2217) == address(_2217):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require ext_call.return_data[18 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2217) == address(_2217):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2217) == address(_2217):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
            else:
                if not mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2367 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(_2230)
                    _2368 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2370 = sha3(mem[_2368 + 32 len mem[_2368]])
                    mem[_2367 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2367 + 105] = factoryAddress
                    mem[_2367 + 125] = _2370
                    mem[_2367 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2367 + 72] = 85
                    mem[64] = _2367 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2370, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2370, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2367 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2375 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                    mem[mem[64] + 52] = address(_2217)
                    _2376 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2378 = sha3(mem[_2376 + 32 len mem[_2376]])
                    mem[_2375 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2375 + 105] = factoryAddress
                    mem[_2375 + 125] = _2378
                    mem[_2375 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2375 + 72] = 85
                    mem[64] = _2375 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2378, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2378, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2375 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg2.length) + 128]
                if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                if address(_2217) == address(_2230):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[50 len 14]:
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2230) == address(_2217):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2230) == address(_2217):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require ext_call.return_data[50 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2230) == address(_2217):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2230) == address(_2217):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[18 len 14]:
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2230) == address(_2217):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2230) == address(_2217):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require ext_call.return_data[18 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2230) == address(_2217):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2230) == address(_2217):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
            idx = idx + 1
            continue 
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[(64 * arg2.length) + 160]
        _2229 = mem[(64 * arg2.length) + 160]
        mem[mem[64] + 64 len floor32(mem[(64 * arg2.length) + 160])] = mem[(64 * arg2.length) + 192 len floor32(mem[(64 * arg2.length) + 160])]
        return 32, mem[mem[64] + 32 len (32 * _2229) + 32]
    mem[(32 * arg2.length) + 160 len 32 * arg2.length] = code.data[7597 len 32 * arg2.length]
    mem[(64 * arg2.length) + 160] = 2 * arg2.length - 1
    mem[64] = (64 * arg2.length) + (64 * arg2.length - 1) + 192
    if not uint255(arg2.length - 1):
        require 0 < arg2.length
        mem[(32 * arg2.length) + 160] = arg1
        idx = 0
        while idx < arg2.length - 1:
            require idx < mem[96]
            _2219 = mem[(32 * idx) + 128]
            require idx + 1 < mem[96]
            _2234 = mem[(32 * idx + 1) + 128]
            if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2383 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(_2234)
                    _2384 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2386 = sha3(mem[_2384 + 32 len mem[_2384]])
                    mem[_2383 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2383 + 105] = factoryAddress
                    mem[_2383 + 125] = _2386
                    mem[_2383 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2383 + 72] = 85
                    mem[64] = _2383 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2386, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2386, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2383 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2391 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                    mem[mem[64] + 52] = address(_2219)
                    _2392 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2394 = sha3(mem[_2392 + 32 len mem[_2392]])
                    mem[_2391 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2391 + 105] = factoryAddress
                    mem[_2391 + 125] = _2394
                    mem[_2391 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2391 + 72] = 85
                    mem[64] = _2391 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2394, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2394, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2391 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg2.length) + 128]
                if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                if address(_2219) == address(_2219):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[50 len 14]:
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2219) == address(_2219):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2219) == address(_2219):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require ext_call.return_data[50 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2219) == address(_2219):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2219) == address(_2219):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[18 len 14]:
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2219) == address(_2219):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2219) == address(_2219):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require ext_call.return_data[18 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2219) == address(_2219):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2219) == address(_2219):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
            else:
                if not mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2399 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(_2234)
                    _2400 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2402 = sha3(mem[_2400 + 32 len mem[_2400]])
                    mem[_2399 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2399 + 105] = factoryAddress
                    mem[_2399 + 125] = _2402
                    mem[_2399 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2399 + 72] = 85
                    mem[64] = _2399 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2402, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2402, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2399 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2407 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                    mem[mem[64] + 52] = address(_2219)
                    _2408 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2410 = sha3(mem[_2408 + 32 len mem[_2408]])
                    mem[_2407 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2407 + 105] = factoryAddress
                    mem[_2407 + 125] = _2410
                    mem[_2407 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2407 + 72] = 85
                    mem[64] = _2407 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2410, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2410, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2407 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg2.length) + 128]
                if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                if address(_2219) == address(_2234):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[50 len 14]:
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2234) == address(_2219):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2234) == address(_2219):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require ext_call.return_data[50 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2234) == address(_2219):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2234) == address(_2219):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[18 len 14]:
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2234) == address(_2219):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2234) == address(_2219):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require ext_call.return_data[18 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2234) == address(_2219):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2234) == address(_2219):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
            idx = idx + 1
            continue 
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[(64 * arg2.length) + 160]
        _2233 = mem[(64 * arg2.length) + 160]
        mem[mem[64] + 64 len floor32(mem[(64 * arg2.length) + 160])] = mem[(64 * arg2.length) + 192 len floor32(mem[(64 * arg2.length) + 160])]
        return 32, mem[mem[64] + 32 len (32 * _2233) + 32]
    mem[(64 * arg2.length) + 192 len 64 * arg2.length - 1] = code.data[7597 len 64 * arg2.length - 1]
    require 0 < arg2.length
    mem[(32 * arg2.length) + 160] = arg1
    idx = 0
    while idx < arg2.length - 1:
        require idx < mem[96]
        _2221 = mem[(32 * idx) + 128]
        require idx + 1 < mem[96]
        _2238 = mem[(32 * idx + 1) + 128]
        if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
            revert with 0, ' IDENTICAL_ADDRESSES'
        if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
            if not mem[(32 * idx) + 140 len 20]:
                revert with 0, ' ZERO_ADDRESS'
            if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2415 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                mem[mem[64] + 52] = address(_2238)
                _2416 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2418 = sha3(mem[_2416 + 32 len mem[_2416]])
                mem[_2415 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2415 + 105] = factoryAddress
                mem[_2415 + 125] = _2418
                mem[_2415 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2415 + 72] = 85
                mem[64] = _2415 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2418, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2418, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2415 + 189 len 96] = ext_call.return_data[0 len 96]
            else:
                if not mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2423 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                mem[mem[64] + 52] = address(_2221)
                _2424 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2426 = sha3(mem[_2424 + 32 len mem[_2424]])
                mem[_2423 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2423 + 105] = factoryAddress
                mem[_2423 + 125] = _2426
                mem[_2423 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2423 + 72] = 85
                mem[64] = _2423 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2426, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2426, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2423 + 189 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require idx < mem[(32 * arg2.length) + 128]
            if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
            if address(_2221) == address(_2221):
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                    revert with 0, 'ds-math-mul-overflow'
                if not ext_call.return_data[50 len 14]:
                    if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    require idx + 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if address(_2221) == address(_2221):
                        require idx < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    if address(_2221) == address(_2221):
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    require ext_call.return_data[50 len 14]
                    if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    require idx + 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if address(_2221) == address(_2221):
                        require idx < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    if address(_2221) == address(_2221):
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
            else:
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                    revert with 0, 'ds-math-mul-overflow'
                if not ext_call.return_data[18 len 14]:
                    if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    require idx + 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if address(_2221) == address(_2221):
                        require idx < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    if address(_2221) == address(_2221):
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    require ext_call.return_data[18 len 14]
                    if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    require idx + 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if address(_2221) == address(_2221):
                        require idx < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    if address(_2221) == address(_2221):
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
        else:
            if not mem[(32 * idx + 1) + 140 len 20]:
                revert with 0, ' ZERO_ADDRESS'
            if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2431 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                mem[mem[64] + 52] = address(_2238)
                _2432 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2434 = sha3(mem[_2432 + 32 len mem[_2432]])
                mem[_2431 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2431 + 105] = factoryAddress
                mem[_2431 + 125] = _2434
                mem[_2431 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2431 + 72] = 85
                mem[64] = _2431 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2434, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2434, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2431 + 189 len 96] = ext_call.return_data[0 len 96]
            else:
                if not mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2439 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                mem[mem[64] + 52] = address(_2221)
                _2440 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2442 = sha3(mem[_2440 + 32 len mem[_2440]])
                mem[_2439 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2439 + 105] = factoryAddress
                mem[_2439 + 125] = _2442
                mem[_2439 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2439 + 72] = 85
                mem[64] = _2439 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2442, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2442, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2439 + 189 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require idx < mem[(32 * arg2.length) + 128]
            if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
            if address(_2221) == address(_2238):
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                    revert with 0, 'ds-math-mul-overflow'
                if not ext_call.return_data[50 len 14]:
                    if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    require idx + 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if address(_2238) == address(_2221):
                        require idx < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    if address(_2238) == address(_2221):
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    require ext_call.return_data[50 len 14]
                    if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    require idx + 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if address(_2238) == address(_2221):
                        require idx < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    if address(_2238) == address(_2221):
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
            else:
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                    revert with 0, 'ds-math-mul-overflow'
                if not ext_call.return_data[18 len 14]:
                    if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    require idx + 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if address(_2238) == address(_2221):
                        require idx < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    if address(_2238) == address(_2221):
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    require ext_call.return_data[18 len 14]
                    if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    require idx + 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if address(_2238) == address(_2221):
                        require idx < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    if address(_2238) == address(_2221):
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
        idx = idx + 1
        continue 
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[(64 * arg2.length) + 160]
    _2237 = mem[(64 * arg2.length) + 160]
    mem[mem[64] + 64 len floor32(mem[(64 * arg2.length) + 160])] = mem[(64 * arg2.length) + 192 len floor32(mem[(64 * arg2.length) + 160])]
    return 32, mem[mem[64] + 32 len (32 * _2237) + 32]
}

function sub_1550f836(?) payable {
    require calldata.size - 4 >= 128
    require arg1 <= 4294967296
    require arg1 + 36 <= calldata.size
    require arg1.length <= 4294967296 and arg1 + (32 * arg1.length) + 36 <= calldata.size
    mem[96] = arg1.length
    mem[128 len 32 * arg1.length] = call.data[arg1 + 36 len 32 * arg1.length]
    if arg1.length < 2:
        revert with 0, ' INVALID_PATH'
    mem[(32 * arg1.length) + 128] = arg1.length
    if not arg1.length:
        mem[(64 * arg1.length) + 160] = 2 * arg1.length - 1
        mem[64] = (64 * arg1.length) + (64 * arg1.length - 1) + 192
        if not uint255(arg1.length - 1):
            require 0 < arg1.length
            mem[(32 * arg1.length) + 160] = msg.value
            idx = 0
            while idx < arg1.length - 1:
                require idx < mem[96]
                _2215 = mem[(32 * idx) + 128]
                require idx + 1 < mem[96]
                _2226 = mem[(32 * idx + 1) + 128]
                if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' IDENTICAL_ADDRESSES'
                    if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                        if not mem[(32 * idx) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2319 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                        mem[mem[64] + 52] = address(_2226)
                        _2320 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2322 = sha3(mem[_2320 + 32 len mem[_2320]])
                        mem[_2319 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2319 + 105] = factoryAddress
                        mem[_2319 + 125] = _2322
                        mem[_2319 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2319 + 72] = 85
                        mem[64] = _2319 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2322, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2322, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2319 + 189 len 96] = ext_call.return_data[0 len 96]
                    else:
                        if not mem[(32 * idx + 1) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2327 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                        mem[mem[64] + 52] = address(_2215)
                        _2328 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2330 = sha3(mem[_2328 + 32 len mem[_2328]])
                        mem[_2327 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2327 + 105] = factoryAddress
                        mem[_2327 + 125] = _2330
                        mem[_2327 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2327 + 72] = 85
                        mem[64] = _2327 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2330, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2330, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2327 + 189 len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    require idx < mem[(32 * arg1.length) + 128]
                    if mem[(32 * idx) + (32 * arg1.length) + 160] <= 0:
                        revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                    if address(_2215) == address(_2215):
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] / 997 != mem[(32 * idx) + (32 * arg1.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if not ext_call.return_data[50 len 14]:
                            if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                            if address(_2215) == address(_2215):
                                require idx < mem[(32 * arg1.length) + 128]
                                require 2 * idx < mem[(64 * arg1.length) + 160]
                                mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg1.length) + 128]
                                require 2 * idx < mem[(64 * arg1.length) + 160]
                                mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                            if address(_2215) == address(_2215):
                                require idx + 1 < mem[(32 * arg1.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                            else:
                                require idx < mem[(32 * arg1.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                        else:
                            require ext_call.return_data[50 len 14]
                            if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg1.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                            if address(_2215) == address(_2215):
                                require idx < mem[(32 * arg1.length) + 128]
                                require 2 * idx < mem[(64 * arg1.length) + 160]
                                mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg1.length) + 128]
                                require 2 * idx < mem[(64 * arg1.length) + 160]
                                mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                            if address(_2215) == address(_2215):
                                require idx + 1 < mem[(32 * arg1.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                            else:
                                require idx < mem[(32 * arg1.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                    else:
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] / 997 != mem[(32 * idx) + (32 * arg1.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if not ext_call.return_data[18 len 14]:
                            if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                            if address(_2215) == address(_2215):
                                require idx < mem[(32 * arg1.length) + 128]
                                require 2 * idx < mem[(64 * arg1.length) + 160]
                                mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg1.length) + 128]
                                require 2 * idx < mem[(64 * arg1.length) + 160]
                                mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                            if address(_2215) == address(_2215):
                                require idx + 1 < mem[(32 * arg1.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                            else:
                                require idx < mem[(32 * arg1.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                        else:
                            require ext_call.return_data[18 len 14]
                            if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg1.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                            if address(_2215) == address(_2215):
                                require idx < mem[(32 * arg1.length) + 128]
                                require 2 * idx < mem[(64 * arg1.length) + 160]
                                mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg1.length) + 128]
                                require 2 * idx < mem[(64 * arg1.length) + 160]
                                mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                            if address(_2215) == address(_2215):
                                require idx + 1 < mem[(32 * arg1.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                            else:
                                require idx < mem[(32 * arg1.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                else:
                    if not mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' IDENTICAL_ADDRESSES'
                    if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                        if not mem[(32 * idx) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2335 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                        mem[mem[64] + 52] = address(_2226)
                        _2336 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2338 = sha3(mem[_2336 + 32 len mem[_2336]])
                        mem[_2335 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2335 + 105] = factoryAddress
                        mem[_2335 + 125] = _2338
                        mem[_2335 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2335 + 72] = 85
                        mem[64] = _2335 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2338, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2338, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2335 + 189 len 96] = ext_call.return_data[0 len 96]
                    else:
                        if not mem[(32 * idx + 1) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2343 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                        mem[mem[64] + 52] = address(_2215)
                        _2344 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2346 = sha3(mem[_2344 + 32 len mem[_2344]])
                        mem[_2343 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2343 + 105] = factoryAddress
                        mem[_2343 + 125] = _2346
                        mem[_2343 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2343 + 72] = 85
                        mem[64] = _2343 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2346, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2346, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2343 + 189 len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    require idx < mem[(32 * arg1.length) + 128]
                    if mem[(32 * idx) + (32 * arg1.length) + 160] <= 0:
                        revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                    if address(_2215) == address(_2226):
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] / 997 != mem[(32 * idx) + (32 * arg1.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if not ext_call.return_data[50 len 14]:
                            if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                            if address(_2226) == address(_2215):
                                require idx < mem[(32 * arg1.length) + 128]
                                require 2 * idx < mem[(64 * arg1.length) + 160]
                                mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg1.length) + 128]
                                require 2 * idx < mem[(64 * arg1.length) + 160]
                                mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                            if address(_2226) == address(_2215):
                                require idx + 1 < mem[(32 * arg1.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                            else:
                                require idx < mem[(32 * arg1.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                        else:
                            require ext_call.return_data[50 len 14]
                            if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg1.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                            if address(_2226) == address(_2215):
                                require idx < mem[(32 * arg1.length) + 128]
                                require 2 * idx < mem[(64 * arg1.length) + 160]
                                mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg1.length) + 128]
                                require 2 * idx < mem[(64 * arg1.length) + 160]
                                mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                            if address(_2226) == address(_2215):
                                require idx + 1 < mem[(32 * arg1.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                            else:
                                require idx < mem[(32 * arg1.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                    else:
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] / 997 != mem[(32 * idx) + (32 * arg1.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if not ext_call.return_data[18 len 14]:
                            if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                            if address(_2226) == address(_2215):
                                require idx < mem[(32 * arg1.length) + 128]
                                require 2 * idx < mem[(64 * arg1.length) + 160]
                                mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg1.length) + 128]
                                require 2 * idx < mem[(64 * arg1.length) + 160]
                                mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                            if address(_2226) == address(_2215):
                                require idx + 1 < mem[(32 * arg1.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                            else:
                                require idx < mem[(32 * arg1.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                        else:
                            require ext_call.return_data[18 len 14]
                            if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg1.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                            if address(_2226) == address(_2215):
                                require idx < mem[(32 * arg1.length) + 128]
                                require 2 * idx < mem[(64 * arg1.length) + 160]
                                mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg1.length) + 128]
                                require 2 * idx < mem[(64 * arg1.length) + 160]
                                mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                            if address(_2226) == address(_2215):
                                require idx + 1 < mem[(32 * arg1.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                            else:
                                require idx < mem[(32 * arg1.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                idx = idx + 1
                continue 
            mem[mem[64]] = 32
            mem[mem[64] + 32] = mem[(64 * arg1.length) + 160]
            _2225 = mem[(64 * arg1.length) + 160]
            mem[mem[64] + 64 len floor32(mem[(64 * arg1.length) + 160])] = mem[(64 * arg1.length) + 192 len floor32(mem[(64 * arg1.length) + 160])]
            return 32, mem[mem[64] + 32 len (32 * _2225) + 32]
        mem[(64 * arg1.length) + 192 len 64 * arg1.length - 1] = code.data[7597 len 64 * arg1.length - 1]
        require 0 < arg1.length
        mem[(32 * arg1.length) + 160] = msg.value
        idx = 0
        while idx < arg1.length - 1:
            require idx < mem[96]
            _2217 = mem[(32 * idx) + 128]
            require idx + 1 < mem[96]
            _2230 = mem[(32 * idx + 1) + 128]
            if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2351 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(_2230)
                    _2352 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2354 = sha3(mem[_2352 + 32 len mem[_2352]])
                    mem[_2351 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2351 + 105] = factoryAddress
                    mem[_2351 + 125] = _2354
                    mem[_2351 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2351 + 72] = 85
                    mem[64] = _2351 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2354, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2354, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2351 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2359 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                    mem[mem[64] + 52] = address(_2217)
                    _2360 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2362 = sha3(mem[_2360 + 32 len mem[_2360]])
                    mem[_2359 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2359 + 105] = factoryAddress
                    mem[_2359 + 125] = _2362
                    mem[_2359 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2359 + 72] = 85
                    mem[64] = _2359 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2362, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2362, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2359 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg1.length) + 128]
                if mem[(32 * idx) + (32 * arg1.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                if address(_2217) == address(_2217):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] / 997 != mem[(32 * idx) + (32 * arg1.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[50 len 14]:
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        if address(_2217) == address(_2217):
                            require idx < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        if address(_2217) == address(_2217):
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        else:
                            require idx < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                    else:
                        require ext_call.return_data[50 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg1.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        if address(_2217) == address(_2217):
                            require idx < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        if address(_2217) == address(_2217):
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        else:
                            require idx < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] / 997 != mem[(32 * idx) + (32 * arg1.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[18 len 14]:
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        if address(_2217) == address(_2217):
                            require idx < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        if address(_2217) == address(_2217):
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        else:
                            require idx < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                    else:
                        require ext_call.return_data[18 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg1.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        if address(_2217) == address(_2217):
                            require idx < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        if address(_2217) == address(_2217):
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        else:
                            require idx < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
            else:
                if not mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2367 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(_2230)
                    _2368 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2370 = sha3(mem[_2368 + 32 len mem[_2368]])
                    mem[_2367 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2367 + 105] = factoryAddress
                    mem[_2367 + 125] = _2370
                    mem[_2367 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2367 + 72] = 85
                    mem[64] = _2367 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2370, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2370, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2367 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2375 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                    mem[mem[64] + 52] = address(_2217)
                    _2376 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2378 = sha3(mem[_2376 + 32 len mem[_2376]])
                    mem[_2375 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2375 + 105] = factoryAddress
                    mem[_2375 + 125] = _2378
                    mem[_2375 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2375 + 72] = 85
                    mem[64] = _2375 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2378, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2378, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2375 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg1.length) + 128]
                if mem[(32 * idx) + (32 * arg1.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                if address(_2217) == address(_2230):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] / 997 != mem[(32 * idx) + (32 * arg1.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[50 len 14]:
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        if address(_2230) == address(_2217):
                            require idx < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        if address(_2230) == address(_2217):
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        else:
                            require idx < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                    else:
                        require ext_call.return_data[50 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg1.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        if address(_2230) == address(_2217):
                            require idx < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        if address(_2230) == address(_2217):
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        else:
                            require idx < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] / 997 != mem[(32 * idx) + (32 * arg1.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[18 len 14]:
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        if address(_2230) == address(_2217):
                            require idx < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        if address(_2230) == address(_2217):
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        else:
                            require idx < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                    else:
                        require ext_call.return_data[18 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg1.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        if address(_2230) == address(_2217):
                            require idx < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        if address(_2230) == address(_2217):
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        else:
                            require idx < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
            idx = idx + 1
            continue 
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[(64 * arg1.length) + 160]
        _2229 = mem[(64 * arg1.length) + 160]
        mem[mem[64] + 64 len floor32(mem[(64 * arg1.length) + 160])] = mem[(64 * arg1.length) + 192 len floor32(mem[(64 * arg1.length) + 160])]
        return 32, mem[mem[64] + 32 len (32 * _2229) + 32]
    mem[(32 * arg1.length) + 160 len 32 * arg1.length] = code.data[7597 len 32 * arg1.length]
    mem[(64 * arg1.length) + 160] = 2 * arg1.length - 1
    mem[64] = (64 * arg1.length) + (64 * arg1.length - 1) + 192
    if not uint255(arg1.length - 1):
        require 0 < arg1.length
        mem[(32 * arg1.length) + 160] = msg.value
        idx = 0
        while idx < arg1.length - 1:
            require idx < mem[96]
            _2219 = mem[(32 * idx) + 128]
            require idx + 1 < mem[96]
            _2234 = mem[(32 * idx + 1) + 128]
            if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2383 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(_2234)
                    _2384 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2386 = sha3(mem[_2384 + 32 len mem[_2384]])
                    mem[_2383 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2383 + 105] = factoryAddress
                    mem[_2383 + 125] = _2386
                    mem[_2383 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2383 + 72] = 85
                    mem[64] = _2383 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2386, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2386, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2383 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2391 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                    mem[mem[64] + 52] = address(_2219)
                    _2392 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2394 = sha3(mem[_2392 + 32 len mem[_2392]])
                    mem[_2391 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2391 + 105] = factoryAddress
                    mem[_2391 + 125] = _2394
                    mem[_2391 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2391 + 72] = 85
                    mem[64] = _2391 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2394, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2394, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2391 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg1.length) + 128]
                if mem[(32 * idx) + (32 * arg1.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                if address(_2219) == address(_2219):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] / 997 != mem[(32 * idx) + (32 * arg1.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[50 len 14]:
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        if address(_2219) == address(_2219):
                            require idx < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        if address(_2219) == address(_2219):
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        else:
                            require idx < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                    else:
                        require ext_call.return_data[50 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg1.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        if address(_2219) == address(_2219):
                            require idx < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        if address(_2219) == address(_2219):
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        else:
                            require idx < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] / 997 != mem[(32 * idx) + (32 * arg1.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[18 len 14]:
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        if address(_2219) == address(_2219):
                            require idx < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        if address(_2219) == address(_2219):
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        else:
                            require idx < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                    else:
                        require ext_call.return_data[18 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg1.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        if address(_2219) == address(_2219):
                            require idx < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        if address(_2219) == address(_2219):
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        else:
                            require idx < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
            else:
                if not mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2399 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(_2234)
                    _2400 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2402 = sha3(mem[_2400 + 32 len mem[_2400]])
                    mem[_2399 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2399 + 105] = factoryAddress
                    mem[_2399 + 125] = _2402
                    mem[_2399 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2399 + 72] = 85
                    mem[64] = _2399 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2402, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2402, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2399 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2407 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                    mem[mem[64] + 52] = address(_2219)
                    _2408 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2410 = sha3(mem[_2408 + 32 len mem[_2408]])
                    mem[_2407 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2407 + 105] = factoryAddress
                    mem[_2407 + 125] = _2410
                    mem[_2407 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2407 + 72] = 85
                    mem[64] = _2407 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2410, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2410, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2407 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg1.length) + 128]
                if mem[(32 * idx) + (32 * arg1.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                if address(_2219) == address(_2234):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] / 997 != mem[(32 * idx) + (32 * arg1.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[50 len 14]:
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        if address(_2234) == address(_2219):
                            require idx < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        if address(_2234) == address(_2219):
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        else:
                            require idx < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                    else:
                        require ext_call.return_data[50 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg1.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        if address(_2234) == address(_2219):
                            require idx < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        if address(_2234) == address(_2219):
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        else:
                            require idx < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] / 997 != mem[(32 * idx) + (32 * arg1.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[18 len 14]:
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        if address(_2234) == address(_2219):
                            require idx < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        if address(_2234) == address(_2219):
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        else:
                            require idx < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                    else:
                        require ext_call.return_data[18 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg1.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                        if address(_2234) == address(_2219):
                            require idx < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require 2 * idx < mem[(64 * arg1.length) + 160]
                            mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        if address(_2234) == address(_2219):
                            require idx + 1 < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                        else:
                            require idx < mem[(32 * arg1.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
            idx = idx + 1
            continue 
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[(64 * arg1.length) + 160]
        _2233 = mem[(64 * arg1.length) + 160]
        mem[mem[64] + 64 len floor32(mem[(64 * arg1.length) + 160])] = mem[(64 * arg1.length) + 192 len floor32(mem[(64 * arg1.length) + 160])]
        return 32, mem[mem[64] + 32 len (32 * _2233) + 32]
    mem[(64 * arg1.length) + 192 len 64 * arg1.length - 1] = code.data[7597 len 64 * arg1.length - 1]
    require 0 < arg1.length
    mem[(32 * arg1.length) + 160] = msg.value
    idx = 0
    while idx < arg1.length - 1:
        require idx < mem[96]
        _2221 = mem[(32 * idx) + 128]
        require idx + 1 < mem[96]
        _2238 = mem[(32 * idx + 1) + 128]
        if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
            revert with 0, ' IDENTICAL_ADDRESSES'
        if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
            if not mem[(32 * idx) + 140 len 20]:
                revert with 0, ' ZERO_ADDRESS'
            if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2415 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                mem[mem[64] + 52] = address(_2238)
                _2416 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2418 = sha3(mem[_2416 + 32 len mem[_2416]])
                mem[_2415 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2415 + 105] = factoryAddress
                mem[_2415 + 125] = _2418
                mem[_2415 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2415 + 72] = 85
                mem[64] = _2415 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2418, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2418, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2415 + 189 len 96] = ext_call.return_data[0 len 96]
            else:
                if not mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2423 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                mem[mem[64] + 52] = address(_2221)
                _2424 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2426 = sha3(mem[_2424 + 32 len mem[_2424]])
                mem[_2423 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2423 + 105] = factoryAddress
                mem[_2423 + 125] = _2426
                mem[_2423 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2423 + 72] = 85
                mem[64] = _2423 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2426, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2426, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2423 + 189 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require idx < mem[(32 * arg1.length) + 128]
            if mem[(32 * idx) + (32 * arg1.length) + 160] <= 0:
                revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
            if address(_2221) == address(_2221):
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] / 997 != mem[(32 * idx) + (32 * arg1.length) + 160]:
                    revert with 0, 'ds-math-mul-overflow'
                if not ext_call.return_data[50 len 14]:
                    if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                    require idx + 1 < mem[(32 * arg1.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                    if address(_2221) == address(_2221):
                        require idx < mem[(32 * arg1.length) + 128]
                        require 2 * idx < mem[(64 * arg1.length) + 160]
                        mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        require 2 * idx < mem[(64 * arg1.length) + 160]
                        mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                    if address(_2221) == address(_2221):
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                    else:
                        require idx < mem[(32 * arg1.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                else:
                    require ext_call.return_data[50 len 14]
                    if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg1.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                    require idx + 1 < mem[(32 * arg1.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                    if address(_2221) == address(_2221):
                        require idx < mem[(32 * arg1.length) + 128]
                        require 2 * idx < mem[(64 * arg1.length) + 160]
                        mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        require 2 * idx < mem[(64 * arg1.length) + 160]
                        mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                    if address(_2221) == address(_2221):
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                    else:
                        require idx < mem[(32 * arg1.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
            else:
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] / 997 != mem[(32 * idx) + (32 * arg1.length) + 160]:
                    revert with 0, 'ds-math-mul-overflow'
                if not ext_call.return_data[18 len 14]:
                    if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                    require idx + 1 < mem[(32 * arg1.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                    if address(_2221) == address(_2221):
                        require idx < mem[(32 * arg1.length) + 128]
                        require 2 * idx < mem[(64 * arg1.length) + 160]
                        mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        require 2 * idx < mem[(64 * arg1.length) + 160]
                        mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                    if address(_2221) == address(_2221):
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                    else:
                        require idx < mem[(32 * arg1.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                else:
                    require ext_call.return_data[18 len 14]
                    if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg1.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                    require idx + 1 < mem[(32 * arg1.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                    if address(_2221) == address(_2221):
                        require idx < mem[(32 * arg1.length) + 128]
                        require 2 * idx < mem[(64 * arg1.length) + 160]
                        mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        require 2 * idx < mem[(64 * arg1.length) + 160]
                        mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                    if address(_2221) == address(_2221):
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                    else:
                        require idx < mem[(32 * arg1.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
        else:
            if not mem[(32 * idx + 1) + 140 len 20]:
                revert with 0, ' ZERO_ADDRESS'
            if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2431 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                mem[mem[64] + 52] = address(_2238)
                _2432 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2434 = sha3(mem[_2432 + 32 len mem[_2432]])
                mem[_2431 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2431 + 105] = factoryAddress
                mem[_2431 + 125] = _2434
                mem[_2431 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2431 + 72] = 85
                mem[64] = _2431 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2434, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2434, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2431 + 189 len 96] = ext_call.return_data[0 len 96]
            else:
                if not mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2439 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                mem[mem[64] + 52] = address(_2221)
                _2440 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2442 = sha3(mem[_2440 + 32 len mem[_2440]])
                mem[_2439 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2439 + 105] = factoryAddress
                mem[_2439 + 125] = _2442
                mem[_2439 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2439 + 72] = 85
                mem[64] = _2439 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2442, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2442, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2439 + 189 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require idx < mem[(32 * arg1.length) + 128]
            if mem[(32 * idx) + (32 * arg1.length) + 160] <= 0:
                revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
            if address(_2221) == address(_2238):
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] / 997 != mem[(32 * idx) + (32 * arg1.length) + 160]:
                    revert with 0, 'ds-math-mul-overflow'
                if not ext_call.return_data[50 len 14]:
                    if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                    require idx + 1 < mem[(32 * arg1.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                    if address(_2238) == address(_2221):
                        require idx < mem[(32 * arg1.length) + 128]
                        require 2 * idx < mem[(64 * arg1.length) + 160]
                        mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        require 2 * idx < mem[(64 * arg1.length) + 160]
                        mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                    if address(_2238) == address(_2221):
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                    else:
                        require idx < mem[(32 * arg1.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                else:
                    require ext_call.return_data[50 len 14]
                    if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg1.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                    require idx + 1 < mem[(32 * arg1.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                    if address(_2238) == address(_2221):
                        require idx < mem[(32 * arg1.length) + 128]
                        require 2 * idx < mem[(64 * arg1.length) + 160]
                        mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        require 2 * idx < mem[(64 * arg1.length) + 160]
                        mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                    if address(_2238) == address(_2221):
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                    else:
                        require idx < mem[(32 * arg1.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg1.length) + 160]
            else:
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] / 997 != mem[(32 * idx) + (32 * arg1.length) + 160]:
                    revert with 0, 'ds-math-mul-overflow'
                if not ext_call.return_data[18 len 14]:
                    if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                    require idx + 1 < mem[(32 * arg1.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                    if address(_2238) == address(_2221):
                        require idx < mem[(32 * arg1.length) + 128]
                        require 2 * idx < mem[(64 * arg1.length) + 160]
                        mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        require 2 * idx < mem[(64 * arg1.length) + 160]
                        mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                    if address(_2238) == address(_2221):
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                    else:
                        require idx < mem[(32 * arg1.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                else:
                    require ext_call.return_data[18 len 14]
                    if 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg1.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                    require idx + 1 < mem[(32 * arg1.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg1.length) + 160] = 997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160])
                    if address(_2238) == address(_2221):
                        require idx < mem[(32 * arg1.length) + 128]
                        require 2 * idx < mem[(64 * arg1.length) + 160]
                        mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        require 2 * idx < mem[(64 * arg1.length) + 160]
                        mem[(64 * idx) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                    if address(_2238) == address(_2221):
                        require idx + 1 < mem[(32 * arg1.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg1.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg1.length) + 160]))
                    else:
                        require idx < mem[(32 * arg1.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg1.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg1.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg1.length) + 160]
        idx = idx + 1
        continue 
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[(64 * arg1.length) + 160]
    _2237 = mem[(64 * arg1.length) + 160]
    mem[mem[64] + 64 len floor32(mem[(64 * arg1.length) + 160])] = mem[(64 * arg1.length) + 192 len floor32(mem[(64 * arg1.length) + 160])]
    return 32, mem[mem[64] + 32 len (32 * _2237) + 32]
}

function swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) {
    require calldata.size - 4 >= 160
    require arg3 <= 4294967296
    require arg3 + 36 <= calldata.size
    require arg3.length <= 4294967296 and arg3 + (32 * arg3.length) + 36 <= calldata.size
    mem[96] = arg3.length
    mem[128 len 32 * arg3.length] = call.data[arg3 + 36 len 32 * arg3.length]
    if arg3.length < 2:
        revert with 0, ' INVALID_PATH'
    mem[(32 * arg3.length) + 128] = arg3.length
    if not arg3.length:
        mem[(64 * arg3.length) + 160] = 2 * arg3.length - 1
        mem[64] = (64 * arg3.length) + (64 * arg3.length - 1) + 192
        if not uint255(arg3.length - 1):
            require 0 < arg3.length
            mem[(32 * arg3.length) + 160] = arg1
            idx = 0
            while idx < arg3.length - 1:
                require idx < mem[96]
                _2215 = mem[(32 * idx) + 128]
                require idx + 1 < mem[96]
                _2226 = mem[(32 * idx + 1) + 128]
                if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' IDENTICAL_ADDRESSES'
                    if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                        if not mem[(32 * idx) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2319 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                        mem[mem[64] + 52] = address(_2226)
                        _2320 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2322 = sha3(mem[_2320 + 32 len mem[_2320]])
                        mem[_2319 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2319 + 105] = factoryAddress
                        mem[_2319 + 125] = _2322
                        mem[_2319 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2319 + 72] = 85
                        mem[64] = _2319 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2322, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2322, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2319 + 189 len 96] = ext_call.return_data[0 len 96]
                    else:
                        if not mem[(32 * idx + 1) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2327 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                        mem[mem[64] + 52] = address(_2215)
                        _2328 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2330 = sha3(mem[_2328 + 32 len mem[_2328]])
                        mem[_2327 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2327 + 105] = factoryAddress
                        mem[_2327 + 125] = _2330
                        mem[_2327 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2327 + 72] = 85
                        mem[64] = _2327 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2330, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2330, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2327 + 189 len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    require idx < mem[(32 * arg3.length) + 128]
                    if mem[(32 * idx) + (32 * arg3.length) + 160] <= 0:
                        revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                    if address(_2215) == address(_2215):
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if not ext_call.return_data[50 len 14]:
                            if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            if address(_2215) == address(_2215):
                                require idx < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            if address(_2215) == address(_2215):
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            else:
                                require idx < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require ext_call.return_data[50 len 14]
                            if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            if address(_2215) == address(_2215):
                                require idx < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            if address(_2215) == address(_2215):
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            else:
                                require idx < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if not ext_call.return_data[18 len 14]:
                            if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            if address(_2215) == address(_2215):
                                require idx < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            if address(_2215) == address(_2215):
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            else:
                                require idx < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require ext_call.return_data[18 len 14]
                            if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            if address(_2215) == address(_2215):
                                require idx < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            if address(_2215) == address(_2215):
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            else:
                                require idx < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                else:
                    if not mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' IDENTICAL_ADDRESSES'
                    if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                        if not mem[(32 * idx) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2335 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                        mem[mem[64] + 52] = address(_2226)
                        _2336 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2338 = sha3(mem[_2336 + 32 len mem[_2336]])
                        mem[_2335 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2335 + 105] = factoryAddress
                        mem[_2335 + 125] = _2338
                        mem[_2335 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2335 + 72] = 85
                        mem[64] = _2335 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2338, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2338, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2335 + 189 len 96] = ext_call.return_data[0 len 96]
                    else:
                        if not mem[(32 * idx + 1) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2343 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                        mem[mem[64] + 52] = address(_2215)
                        _2344 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2346 = sha3(mem[_2344 + 32 len mem[_2344]])
                        mem[_2343 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2343 + 105] = factoryAddress
                        mem[_2343 + 125] = _2346
                        mem[_2343 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2343 + 72] = 85
                        mem[64] = _2343 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2346, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2346, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2343 + 189 len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    require idx < mem[(32 * arg3.length) + 128]
                    if mem[(32 * idx) + (32 * arg3.length) + 160] <= 0:
                        revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                    if address(_2215) == address(_2226):
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if not ext_call.return_data[50 len 14]:
                            if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            if address(_2226) == address(_2215):
                                require idx < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            if address(_2226) == address(_2215):
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            else:
                                require idx < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require ext_call.return_data[50 len 14]
                            if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            if address(_2226) == address(_2215):
                                require idx < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            if address(_2226) == address(_2215):
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            else:
                                require idx < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if not ext_call.return_data[18 len 14]:
                            if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            if address(_2226) == address(_2215):
                                require idx < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            if address(_2226) == address(_2215):
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            else:
                                require idx < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require ext_call.return_data[18 len 14]
                            if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            if address(_2226) == address(_2215):
                                require idx < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            if address(_2226) == address(_2215):
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            else:
                                require idx < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                idx = idx + 1
                continue 
            mem[mem[64]] = 32
            mem[mem[64] + 32] = mem[(64 * arg3.length) + 160]
            _2225 = mem[(64 * arg3.length) + 160]
            mem[mem[64] + 64 len floor32(mem[(64 * arg3.length) + 160])] = mem[(64 * arg3.length) + 192 len floor32(mem[(64 * arg3.length) + 160])]
            return 32, mem[mem[64] + 32 len (32 * _2225) + 32]
        mem[(64 * arg3.length) + 192 len 64 * arg3.length - 1] = code.data[7597 len 64 * arg3.length - 1]
        require 0 < arg3.length
        mem[(32 * arg3.length) + 160] = arg1
        idx = 0
        while idx < arg3.length - 1:
            require idx < mem[96]
            _2217 = mem[(32 * idx) + 128]
            require idx + 1 < mem[96]
            _2230 = mem[(32 * idx + 1) + 128]
            if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2351 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(_2230)
                    _2352 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2354 = sha3(mem[_2352 + 32 len mem[_2352]])
                    mem[_2351 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2351 + 105] = factoryAddress
                    mem[_2351 + 125] = _2354
                    mem[_2351 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2351 + 72] = 85
                    mem[64] = _2351 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2354, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2354, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2351 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2359 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                    mem[mem[64] + 52] = address(_2217)
                    _2360 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2362 = sha3(mem[_2360 + 32 len mem[_2360]])
                    mem[_2359 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2359 + 105] = factoryAddress
                    mem[_2359 + 125] = _2362
                    mem[_2359 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2359 + 72] = 85
                    mem[64] = _2359 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2362, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2362, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2359 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg3.length) + 128]
                if mem[(32 * idx) + (32 * arg3.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                if address(_2217) == address(_2217):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[50 len 14]:
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2217) == address(_2217):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2217) == address(_2217):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require ext_call.return_data[50 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2217) == address(_2217):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2217) == address(_2217):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[18 len 14]:
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2217) == address(_2217):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2217) == address(_2217):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require ext_call.return_data[18 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2217) == address(_2217):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2217) == address(_2217):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
            else:
                if not mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2367 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(_2230)
                    _2368 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2370 = sha3(mem[_2368 + 32 len mem[_2368]])
                    mem[_2367 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2367 + 105] = factoryAddress
                    mem[_2367 + 125] = _2370
                    mem[_2367 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2367 + 72] = 85
                    mem[64] = _2367 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2370, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2370, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2367 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2375 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                    mem[mem[64] + 52] = address(_2217)
                    _2376 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2378 = sha3(mem[_2376 + 32 len mem[_2376]])
                    mem[_2375 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2375 + 105] = factoryAddress
                    mem[_2375 + 125] = _2378
                    mem[_2375 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2375 + 72] = 85
                    mem[64] = _2375 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2378, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2378, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2375 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg3.length) + 128]
                if mem[(32 * idx) + (32 * arg3.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                if address(_2217) == address(_2230):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[50 len 14]:
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2230) == address(_2217):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2230) == address(_2217):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require ext_call.return_data[50 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2230) == address(_2217):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2230) == address(_2217):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[18 len 14]:
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2230) == address(_2217):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2230) == address(_2217):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require ext_call.return_data[18 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2230) == address(_2217):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2230) == address(_2217):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
            idx = idx + 1
            continue 
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[(64 * arg3.length) + 160]
        _2229 = mem[(64 * arg3.length) + 160]
        mem[mem[64] + 64 len floor32(mem[(64 * arg3.length) + 160])] = mem[(64 * arg3.length) + 192 len floor32(mem[(64 * arg3.length) + 160])]
        return 32, mem[mem[64] + 32 len (32 * _2229) + 32]
    mem[(32 * arg3.length) + 160 len 32 * arg3.length] = code.data[7597 len 32 * arg3.length]
    mem[(64 * arg3.length) + 160] = 2 * arg3.length - 1
    mem[64] = (64 * arg3.length) + (64 * arg3.length - 1) + 192
    if not uint255(arg3.length - 1):
        require 0 < arg3.length
        mem[(32 * arg3.length) + 160] = arg1
        idx = 0
        while idx < arg3.length - 1:
            require idx < mem[96]
            _2219 = mem[(32 * idx) + 128]
            require idx + 1 < mem[96]
            _2234 = mem[(32 * idx + 1) + 128]
            if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2383 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(_2234)
                    _2384 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2386 = sha3(mem[_2384 + 32 len mem[_2384]])
                    mem[_2383 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2383 + 105] = factoryAddress
                    mem[_2383 + 125] = _2386
                    mem[_2383 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2383 + 72] = 85
                    mem[64] = _2383 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2386, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2386, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2383 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2391 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                    mem[mem[64] + 52] = address(_2219)
                    _2392 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2394 = sha3(mem[_2392 + 32 len mem[_2392]])
                    mem[_2391 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2391 + 105] = factoryAddress
                    mem[_2391 + 125] = _2394
                    mem[_2391 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2391 + 72] = 85
                    mem[64] = _2391 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2394, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2394, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2391 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg3.length) + 128]
                if mem[(32 * idx) + (32 * arg3.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                if address(_2219) == address(_2219):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[50 len 14]:
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2219) == address(_2219):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2219) == address(_2219):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require ext_call.return_data[50 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2219) == address(_2219):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2219) == address(_2219):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[18 len 14]:
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2219) == address(_2219):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2219) == address(_2219):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require ext_call.return_data[18 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2219) == address(_2219):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2219) == address(_2219):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
            else:
                if not mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2399 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(_2234)
                    _2400 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2402 = sha3(mem[_2400 + 32 len mem[_2400]])
                    mem[_2399 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2399 + 105] = factoryAddress
                    mem[_2399 + 125] = _2402
                    mem[_2399 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2399 + 72] = 85
                    mem[64] = _2399 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2402, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2402, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2399 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2407 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                    mem[mem[64] + 52] = address(_2219)
                    _2408 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2410 = sha3(mem[_2408 + 32 len mem[_2408]])
                    mem[_2407 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2407 + 105] = factoryAddress
                    mem[_2407 + 125] = _2410
                    mem[_2407 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2407 + 72] = 85
                    mem[64] = _2407 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2410, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2410, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2407 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg3.length) + 128]
                if mem[(32 * idx) + (32 * arg3.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                if address(_2219) == address(_2234):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[50 len 14]:
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2234) == address(_2219):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2234) == address(_2219):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require ext_call.return_data[50 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2234) == address(_2219):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2234) == address(_2219):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[18 len 14]:
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2234) == address(_2219):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2234) == address(_2219):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require ext_call.return_data[18 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2234) == address(_2219):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2234) == address(_2219):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
            idx = idx + 1
            continue 
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[(64 * arg3.length) + 160]
        _2233 = mem[(64 * arg3.length) + 160]
        mem[mem[64] + 64 len floor32(mem[(64 * arg3.length) + 160])] = mem[(64 * arg3.length) + 192 len floor32(mem[(64 * arg3.length) + 160])]
        return 32, mem[mem[64] + 32 len (32 * _2233) + 32]
    mem[(64 * arg3.length) + 192 len 64 * arg3.length - 1] = code.data[7597 len 64 * arg3.length - 1]
    require 0 < arg3.length
    mem[(32 * arg3.length) + 160] = arg1
    idx = 0
    while idx < arg3.length - 1:
        require idx < mem[96]
        _2221 = mem[(32 * idx) + 128]
        require idx + 1 < mem[96]
        _2238 = mem[(32 * idx + 1) + 128]
        if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
            revert with 0, ' IDENTICAL_ADDRESSES'
        if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
            if not mem[(32 * idx) + 140 len 20]:
                revert with 0, ' ZERO_ADDRESS'
            if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2415 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                mem[mem[64] + 52] = address(_2238)
                _2416 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2418 = sha3(mem[_2416 + 32 len mem[_2416]])
                mem[_2415 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2415 + 105] = factoryAddress
                mem[_2415 + 125] = _2418
                mem[_2415 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2415 + 72] = 85
                mem[64] = _2415 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2418, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2418, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2415 + 189 len 96] = ext_call.return_data[0 len 96]
            else:
                if not mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2423 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                mem[mem[64] + 52] = address(_2221)
                _2424 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2426 = sha3(mem[_2424 + 32 len mem[_2424]])
                mem[_2423 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2423 + 105] = factoryAddress
                mem[_2423 + 125] = _2426
                mem[_2423 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2423 + 72] = 85
                mem[64] = _2423 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2426, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2426, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2423 + 189 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require idx < mem[(32 * arg3.length) + 128]
            if mem[(32 * idx) + (32 * arg3.length) + 160] <= 0:
                revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
            if address(_2221) == address(_2221):
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                    revert with 0, 'ds-math-mul-overflow'
                if not ext_call.return_data[50 len 14]:
                    if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    require idx + 1 < mem[(32 * arg3.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    if address(_2221) == address(_2221):
                        require idx < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    if address(_2221) == address(_2221):
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    else:
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                else:
                    require ext_call.return_data[50 len 14]
                    if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    require idx + 1 < mem[(32 * arg3.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    if address(_2221) == address(_2221):
                        require idx < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    if address(_2221) == address(_2221):
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    else:
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
            else:
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                    revert with 0, 'ds-math-mul-overflow'
                if not ext_call.return_data[18 len 14]:
                    if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    require idx + 1 < mem[(32 * arg3.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    if address(_2221) == address(_2221):
                        require idx < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    if address(_2221) == address(_2221):
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    else:
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                else:
                    require ext_call.return_data[18 len 14]
                    if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    require idx + 1 < mem[(32 * arg3.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    if address(_2221) == address(_2221):
                        require idx < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    if address(_2221) == address(_2221):
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    else:
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
        else:
            if not mem[(32 * idx + 1) + 140 len 20]:
                revert with 0, ' ZERO_ADDRESS'
            if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2431 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                mem[mem[64] + 52] = address(_2238)
                _2432 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2434 = sha3(mem[_2432 + 32 len mem[_2432]])
                mem[_2431 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2431 + 105] = factoryAddress
                mem[_2431 + 125] = _2434
                mem[_2431 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2431 + 72] = 85
                mem[64] = _2431 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2434, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2434, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2431 + 189 len 96] = ext_call.return_data[0 len 96]
            else:
                if not mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2439 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                mem[mem[64] + 52] = address(_2221)
                _2440 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2442 = sha3(mem[_2440 + 32 len mem[_2440]])
                mem[_2439 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2439 + 105] = factoryAddress
                mem[_2439 + 125] = _2442
                mem[_2439 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2439 + 72] = 85
                mem[64] = _2439 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2442, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2442, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2439 + 189 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require idx < mem[(32 * arg3.length) + 128]
            if mem[(32 * idx) + (32 * arg3.length) + 160] <= 0:
                revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
            if address(_2221) == address(_2238):
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                    revert with 0, 'ds-math-mul-overflow'
                if not ext_call.return_data[50 len 14]:
                    if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    require idx + 1 < mem[(32 * arg3.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    if address(_2238) == address(_2221):
                        require idx < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    if address(_2238) == address(_2221):
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    else:
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                else:
                    require ext_call.return_data[50 len 14]
                    if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    require idx + 1 < mem[(32 * arg3.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    if address(_2238) == address(_2221):
                        require idx < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    if address(_2238) == address(_2221):
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    else:
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
            else:
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                    revert with 0, 'ds-math-mul-overflow'
                if not ext_call.return_data[18 len 14]:
                    if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    require idx + 1 < mem[(32 * arg3.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    if address(_2238) == address(_2221):
                        require idx < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    if address(_2238) == address(_2221):
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    else:
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                else:
                    require ext_call.return_data[18 len 14]
                    if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    require idx + 1 < mem[(32 * arg3.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    if address(_2238) == address(_2221):
                        require idx < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    if address(_2238) == address(_2221):
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    else:
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
        idx = idx + 1
        continue 
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[(64 * arg3.length) + 160]
    _2237 = mem[(64 * arg3.length) + 160]
    mem[mem[64] + 64 len floor32(mem[(64 * arg3.length) + 160])] = mem[(64 * arg3.length) + 192 len floor32(mem[(64 * arg3.length) + 160])]
    return 32, mem[mem[64] + 32 len (32 * _2237) + 32]
}

function swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) {
    require calldata.size - 4 >= 160
    require arg3 <= 4294967296
    require arg3 + 36 <= calldata.size
    require arg3.length <= 4294967296 and arg3 + (32 * arg3.length) + 36 <= calldata.size
    mem[96] = arg3.length
    mem[128 len 32 * arg3.length] = call.data[arg3 + 36 len 32 * arg3.length]
    if arg3.length < 2:
        revert with 0, ' INVALID_PATH'
    mem[(32 * arg3.length) + 128] = arg3.length
    if not arg3.length:
        mem[(64 * arg3.length) + 160] = 2 * arg3.length - 1
        mem[64] = (64 * arg3.length) + (64 * arg3.length - 1) + 192
        if not uint255(arg3.length - 1):
            require 0 < arg3.length
            mem[(32 * arg3.length) + 160] = arg1
            idx = 0
            while idx < arg3.length - 1:
                require idx < mem[96]
                _2215 = mem[(32 * idx) + 128]
                require idx + 1 < mem[96]
                _2226 = mem[(32 * idx + 1) + 128]
                if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' IDENTICAL_ADDRESSES'
                    if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                        if not mem[(32 * idx) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2319 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                        mem[mem[64] + 52] = address(_2226)
                        _2320 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2322 = sha3(mem[_2320 + 32 len mem[_2320]])
                        mem[_2319 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2319 + 105] = factoryAddress
                        mem[_2319 + 125] = _2322
                        mem[_2319 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2319 + 72] = 85
                        mem[64] = _2319 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2322, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2322, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2319 + 189 len 96] = ext_call.return_data[0 len 96]
                    else:
                        if not mem[(32 * idx + 1) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2327 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                        mem[mem[64] + 52] = address(_2215)
                        _2328 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2330 = sha3(mem[_2328 + 32 len mem[_2328]])
                        mem[_2327 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2327 + 105] = factoryAddress
                        mem[_2327 + 125] = _2330
                        mem[_2327 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2327 + 72] = 85
                        mem[64] = _2327 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2330, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2330, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2327 + 189 len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    require idx < mem[(32 * arg3.length) + 128]
                    if mem[(32 * idx) + (32 * arg3.length) + 160] <= 0:
                        revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                    if address(_2215) == address(_2215):
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if not ext_call.return_data[50 len 14]:
                            if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            if address(_2215) == address(_2215):
                                require idx < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            if address(_2215) == address(_2215):
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            else:
                                require idx < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require ext_call.return_data[50 len 14]
                            if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            if address(_2215) == address(_2215):
                                require idx < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            if address(_2215) == address(_2215):
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            else:
                                require idx < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if not ext_call.return_data[18 len 14]:
                            if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            if address(_2215) == address(_2215):
                                require idx < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            if address(_2215) == address(_2215):
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            else:
                                require idx < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require ext_call.return_data[18 len 14]
                            if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            if address(_2215) == address(_2215):
                                require idx < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            if address(_2215) == address(_2215):
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            else:
                                require idx < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                else:
                    if not mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' IDENTICAL_ADDRESSES'
                    if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                        if not mem[(32 * idx) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2335 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                        mem[mem[64] + 52] = address(_2226)
                        _2336 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2338 = sha3(mem[_2336 + 32 len mem[_2336]])
                        mem[_2335 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2335 + 105] = factoryAddress
                        mem[_2335 + 125] = _2338
                        mem[_2335 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2335 + 72] = 85
                        mem[64] = _2335 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2338, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2338, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2335 + 189 len 96] = ext_call.return_data[0 len 96]
                    else:
                        if not mem[(32 * idx + 1) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2343 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                        mem[mem[64] + 52] = address(_2215)
                        _2344 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2346 = sha3(mem[_2344 + 32 len mem[_2344]])
                        mem[_2343 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2343 + 105] = factoryAddress
                        mem[_2343 + 125] = _2346
                        mem[_2343 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2343 + 72] = 85
                        mem[64] = _2343 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2346, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2346, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2343 + 189 len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    require idx < mem[(32 * arg3.length) + 128]
                    if mem[(32 * idx) + (32 * arg3.length) + 160] <= 0:
                        revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                    if address(_2215) == address(_2226):
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if not ext_call.return_data[50 len 14]:
                            if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            if address(_2226) == address(_2215):
                                require idx < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            if address(_2226) == address(_2215):
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            else:
                                require idx < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require ext_call.return_data[50 len 14]
                            if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            if address(_2226) == address(_2215):
                                require idx < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            if address(_2226) == address(_2215):
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            else:
                                require idx < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if not ext_call.return_data[18 len 14]:
                            if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            if address(_2226) == address(_2215):
                                require idx < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            if address(_2226) == address(_2215):
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            else:
                                require idx < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require ext_call.return_data[18 len 14]
                            if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                            if address(_2226) == address(_2215):
                                require idx < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require 2 * idx < mem[(64 * arg3.length) + 160]
                                mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            if address(_2226) == address(_2215):
                                require idx + 1 < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                            else:
                                require idx < mem[(32 * arg3.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                idx = idx + 1
                continue 
            mem[mem[64]] = 32
            mem[mem[64] + 32] = mem[(64 * arg3.length) + 160]
            _2225 = mem[(64 * arg3.length) + 160]
            mem[mem[64] + 64 len floor32(mem[(64 * arg3.length) + 160])] = mem[(64 * arg3.length) + 192 len floor32(mem[(64 * arg3.length) + 160])]
            return 32, mem[mem[64] + 32 len (32 * _2225) + 32]
        mem[(64 * arg3.length) + 192 len 64 * arg3.length - 1] = code.data[7597 len 64 * arg3.length - 1]
        require 0 < arg3.length
        mem[(32 * arg3.length) + 160] = arg1
        idx = 0
        while idx < arg3.length - 1:
            require idx < mem[96]
            _2217 = mem[(32 * idx) + 128]
            require idx + 1 < mem[96]
            _2230 = mem[(32 * idx + 1) + 128]
            if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2351 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(_2230)
                    _2352 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2354 = sha3(mem[_2352 + 32 len mem[_2352]])
                    mem[_2351 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2351 + 105] = factoryAddress
                    mem[_2351 + 125] = _2354
                    mem[_2351 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2351 + 72] = 85
                    mem[64] = _2351 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2354, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2354, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2351 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2359 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                    mem[mem[64] + 52] = address(_2217)
                    _2360 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2362 = sha3(mem[_2360 + 32 len mem[_2360]])
                    mem[_2359 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2359 + 105] = factoryAddress
                    mem[_2359 + 125] = _2362
                    mem[_2359 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2359 + 72] = 85
                    mem[64] = _2359 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2362, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2362, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2359 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg3.length) + 128]
                if mem[(32 * idx) + (32 * arg3.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                if address(_2217) == address(_2217):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[50 len 14]:
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2217) == address(_2217):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2217) == address(_2217):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require ext_call.return_data[50 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2217) == address(_2217):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2217) == address(_2217):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[18 len 14]:
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2217) == address(_2217):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2217) == address(_2217):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require ext_call.return_data[18 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2217) == address(_2217):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2217) == address(_2217):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
            else:
                if not mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2367 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(_2230)
                    _2368 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2370 = sha3(mem[_2368 + 32 len mem[_2368]])
                    mem[_2367 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2367 + 105] = factoryAddress
                    mem[_2367 + 125] = _2370
                    mem[_2367 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2367 + 72] = 85
                    mem[64] = _2367 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2370, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2370, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2367 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2375 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                    mem[mem[64] + 52] = address(_2217)
                    _2376 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2378 = sha3(mem[_2376 + 32 len mem[_2376]])
                    mem[_2375 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2375 + 105] = factoryAddress
                    mem[_2375 + 125] = _2378
                    mem[_2375 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2375 + 72] = 85
                    mem[64] = _2375 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2378, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2378, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2375 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg3.length) + 128]
                if mem[(32 * idx) + (32 * arg3.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                if address(_2217) == address(_2230):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[50 len 14]:
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2230) == address(_2217):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2230) == address(_2217):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require ext_call.return_data[50 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2230) == address(_2217):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2230) == address(_2217):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[18 len 14]:
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2230) == address(_2217):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2230) == address(_2217):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require ext_call.return_data[18 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2230) == address(_2217):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2230) == address(_2217):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
            idx = idx + 1
            continue 
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[(64 * arg3.length) + 160]
        _2229 = mem[(64 * arg3.length) + 160]
        mem[mem[64] + 64 len floor32(mem[(64 * arg3.length) + 160])] = mem[(64 * arg3.length) + 192 len floor32(mem[(64 * arg3.length) + 160])]
        return 32, mem[mem[64] + 32 len (32 * _2229) + 32]
    mem[(32 * arg3.length) + 160 len 32 * arg3.length] = code.data[7597 len 32 * arg3.length]
    mem[(64 * arg3.length) + 160] = 2 * arg3.length - 1
    mem[64] = (64 * arg3.length) + (64 * arg3.length - 1) + 192
    if not uint255(arg3.length - 1):
        require 0 < arg3.length
        mem[(32 * arg3.length) + 160] = arg1
        idx = 0
        while idx < arg3.length - 1:
            require idx < mem[96]
            _2219 = mem[(32 * idx) + 128]
            require idx + 1 < mem[96]
            _2234 = mem[(32 * idx + 1) + 128]
            if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2383 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(_2234)
                    _2384 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2386 = sha3(mem[_2384 + 32 len mem[_2384]])
                    mem[_2383 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2383 + 105] = factoryAddress
                    mem[_2383 + 125] = _2386
                    mem[_2383 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2383 + 72] = 85
                    mem[64] = _2383 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2386, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2386, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2383 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2391 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                    mem[mem[64] + 52] = address(_2219)
                    _2392 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2394 = sha3(mem[_2392 + 32 len mem[_2392]])
                    mem[_2391 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2391 + 105] = factoryAddress
                    mem[_2391 + 125] = _2394
                    mem[_2391 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2391 + 72] = 85
                    mem[64] = _2391 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2394, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2394, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2391 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg3.length) + 128]
                if mem[(32 * idx) + (32 * arg3.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                if address(_2219) == address(_2219):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[50 len 14]:
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2219) == address(_2219):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2219) == address(_2219):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require ext_call.return_data[50 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2219) == address(_2219):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2219) == address(_2219):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[18 len 14]:
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2219) == address(_2219):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2219) == address(_2219):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require ext_call.return_data[18 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2219) == address(_2219):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2219) == address(_2219):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
            else:
                if not mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2399 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(_2234)
                    _2400 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2402 = sha3(mem[_2400 + 32 len mem[_2400]])
                    mem[_2399 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2399 + 105] = factoryAddress
                    mem[_2399 + 125] = _2402
                    mem[_2399 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2399 + 72] = 85
                    mem[64] = _2399 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2402, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2402, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2399 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2407 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                    mem[mem[64] + 52] = address(_2219)
                    _2408 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2410 = sha3(mem[_2408 + 32 len mem[_2408]])
                    mem[_2407 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2407 + 105] = factoryAddress
                    mem[_2407 + 125] = _2410
                    mem[_2407 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2407 + 72] = 85
                    mem[64] = _2407 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2410, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2410, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2407 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg3.length) + 128]
                if mem[(32 * idx) + (32 * arg3.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                if address(_2219) == address(_2234):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[50 len 14]:
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2234) == address(_2219):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2234) == address(_2219):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require ext_call.return_data[50 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2234) == address(_2219):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2234) == address(_2219):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[18 len 14]:
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2234) == address(_2219):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2234) == address(_2219):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require ext_call.return_data[18 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                        if address(_2234) == address(_2219):
                            require idx < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require 2 * idx < mem[(64 * arg3.length) + 160]
                            mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        if address(_2234) == address(_2219):
                            require idx + 1 < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                        else:
                            require idx < mem[(32 * arg3.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
            idx = idx + 1
            continue 
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[(64 * arg3.length) + 160]
        _2233 = mem[(64 * arg3.length) + 160]
        mem[mem[64] + 64 len floor32(mem[(64 * arg3.length) + 160])] = mem[(64 * arg3.length) + 192 len floor32(mem[(64 * arg3.length) + 160])]
        return 32, mem[mem[64] + 32 len (32 * _2233) + 32]
    mem[(64 * arg3.length) + 192 len 64 * arg3.length - 1] = code.data[7597 len 64 * arg3.length - 1]
    require 0 < arg3.length
    mem[(32 * arg3.length) + 160] = arg1
    idx = 0
    while idx < arg3.length - 1:
        require idx < mem[96]
        _2221 = mem[(32 * idx) + 128]
        require idx + 1 < mem[96]
        _2238 = mem[(32 * idx + 1) + 128]
        if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
            revert with 0, ' IDENTICAL_ADDRESSES'
        if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
            if not mem[(32 * idx) + 140 len 20]:
                revert with 0, ' ZERO_ADDRESS'
            if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2415 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                mem[mem[64] + 52] = address(_2238)
                _2416 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2418 = sha3(mem[_2416 + 32 len mem[_2416]])
                mem[_2415 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2415 + 105] = factoryAddress
                mem[_2415 + 125] = _2418
                mem[_2415 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2415 + 72] = 85
                mem[64] = _2415 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2418, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2418, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2415 + 189 len 96] = ext_call.return_data[0 len 96]
            else:
                if not mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2423 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                mem[mem[64] + 52] = address(_2221)
                _2424 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2426 = sha3(mem[_2424 + 32 len mem[_2424]])
                mem[_2423 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2423 + 105] = factoryAddress
                mem[_2423 + 125] = _2426
                mem[_2423 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2423 + 72] = 85
                mem[64] = _2423 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2426, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2426, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2423 + 189 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require idx < mem[(32 * arg3.length) + 128]
            if mem[(32 * idx) + (32 * arg3.length) + 160] <= 0:
                revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
            if address(_2221) == address(_2221):
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                    revert with 0, 'ds-math-mul-overflow'
                if not ext_call.return_data[50 len 14]:
                    if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    require idx + 1 < mem[(32 * arg3.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    if address(_2221) == address(_2221):
                        require idx < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    if address(_2221) == address(_2221):
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    else:
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                else:
                    require ext_call.return_data[50 len 14]
                    if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    require idx + 1 < mem[(32 * arg3.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    if address(_2221) == address(_2221):
                        require idx < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    if address(_2221) == address(_2221):
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    else:
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
            else:
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                    revert with 0, 'ds-math-mul-overflow'
                if not ext_call.return_data[18 len 14]:
                    if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    require idx + 1 < mem[(32 * arg3.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    if address(_2221) == address(_2221):
                        require idx < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    if address(_2221) == address(_2221):
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    else:
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                else:
                    require ext_call.return_data[18 len 14]
                    if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    require idx + 1 < mem[(32 * arg3.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    if address(_2221) == address(_2221):
                        require idx < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    if address(_2221) == address(_2221):
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    else:
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
        else:
            if not mem[(32 * idx + 1) + 140 len 20]:
                revert with 0, ' ZERO_ADDRESS'
            if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2431 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                mem[mem[64] + 52] = address(_2238)
                _2432 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2434 = sha3(mem[_2432 + 32 len mem[_2432]])
                mem[_2431 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2431 + 105] = factoryAddress
                mem[_2431 + 125] = _2434
                mem[_2431 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2431 + 72] = 85
                mem[64] = _2431 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2434, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2434, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2431 + 189 len 96] = ext_call.return_data[0 len 96]
            else:
                if not mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2439 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                mem[mem[64] + 52] = address(_2221)
                _2440 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2442 = sha3(mem[_2440 + 32 len mem[_2440]])
                mem[_2439 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2439 + 105] = factoryAddress
                mem[_2439 + 125] = _2442
                mem[_2439 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2439 + 72] = 85
                mem[64] = _2439 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2442, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2442, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2439 + 189 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require idx < mem[(32 * arg3.length) + 128]
            if mem[(32 * idx) + (32 * arg3.length) + 160] <= 0:
                revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
            if address(_2221) == address(_2238):
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                    revert with 0, 'ds-math-mul-overflow'
                if not ext_call.return_data[50 len 14]:
                    if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    require idx + 1 < mem[(32 * arg3.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    if address(_2238) == address(_2221):
                        require idx < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    if address(_2238) == address(_2221):
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    else:
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                else:
                    require ext_call.return_data[50 len 14]
                    if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    require idx + 1 < mem[(32 * arg3.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    if address(_2238) == address(_2221):
                        require idx < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    if address(_2238) == address(_2221):
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    else:
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg3.length) + 160]
            else:
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] / 997 != mem[(32 * idx) + (32 * arg3.length) + 160]:
                    revert with 0, 'ds-math-mul-overflow'
                if not ext_call.return_data[18 len 14]:
                    if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    require idx + 1 < mem[(32 * arg3.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    if address(_2238) == address(_2221):
                        require idx < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    if address(_2238) == address(_2221):
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    else:
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                else:
                    require ext_call.return_data[18 len 14]
                    if 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg3.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    require idx + 1 < mem[(32 * arg3.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg3.length) + 160] = 997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160])
                    if address(_2238) == address(_2221):
                        require idx < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require 2 * idx < mem[(64 * arg3.length) + 160]
                        mem[(64 * idx) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    if address(_2238) == address(_2221):
                        require idx + 1 < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg3.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg3.length) + 160]))
                    else:
                        require idx < mem[(32 * arg3.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg3.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg3.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg3.length) + 160]
        idx = idx + 1
        continue 
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[(64 * arg3.length) + 160]
    _2237 = mem[(64 * arg3.length) + 160]
    mem[mem[64] + 64 len floor32(mem[(64 * arg3.length) + 160])] = mem[(64 * arg3.length) + 192 len floor32(mem[(64 * arg3.length) + 160])]
    return 32, mem[mem[64] + 32 len (32 * _2237) + 32]
}

function swapExactETHForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) payable {
    require calldata.size - 4 >= 128
    require arg2 <= 4294967296
    require arg2 + 36 <= calldata.size
    require arg2.length <= 4294967296 and arg2 + (32 * arg2.length) + 36 <= calldata.size
    mem[96] = arg2.length
    mem[128 len 32 * arg2.length] = call.data[arg2 + 36 len 32 * arg2.length]
    if arg2.length < 2:
        revert with 0, ' INVALID_PATH'
    mem[(32 * arg2.length) + 128] = arg2.length
    if not arg2.length:
        mem[(64 * arg2.length) + 160] = 2 * arg2.length - 1
        mem[64] = (64 * arg2.length) + (64 * arg2.length - 1) + 192
        if not uint255(arg2.length - 1):
            require 0 < arg2.length
            mem[(32 * arg2.length) + 160] = msg.value
            idx = 0
            while idx < arg2.length - 1:
                require idx < mem[96]
                _2215 = mem[(32 * idx) + 128]
                require idx + 1 < mem[96]
                _2226 = mem[(32 * idx + 1) + 128]
                if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' IDENTICAL_ADDRESSES'
                    if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                        if not mem[(32 * idx) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2319 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                        mem[mem[64] + 52] = address(_2226)
                        _2320 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2322 = sha3(mem[_2320 + 32 len mem[_2320]])
                        mem[_2319 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2319 + 105] = factoryAddress
                        mem[_2319 + 125] = _2322
                        mem[_2319 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2319 + 72] = 85
                        mem[64] = _2319 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2322, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2322, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2319 + 189 len 96] = ext_call.return_data[0 len 96]
                    else:
                        if not mem[(32 * idx + 1) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2327 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                        mem[mem[64] + 52] = address(_2215)
                        _2328 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2330 = sha3(mem[_2328 + 32 len mem[_2328]])
                        mem[_2327 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2327 + 105] = factoryAddress
                        mem[_2327 + 125] = _2330
                        mem[_2327 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2327 + 72] = 85
                        mem[64] = _2327 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2330, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2330, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2327 + 189 len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    require idx < mem[(32 * arg2.length) + 128]
                    if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                        revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                    if address(_2215) == address(_2215):
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if not ext_call.return_data[50 len 14]:
                            if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if address(_2215) == address(_2215):
                                require idx < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            if address(_2215) == address(_2215):
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            else:
                                require idx < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require ext_call.return_data[50 len 14]
                            if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if address(_2215) == address(_2215):
                                require idx < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            if address(_2215) == address(_2215):
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            else:
                                require idx < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if not ext_call.return_data[18 len 14]:
                            if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if address(_2215) == address(_2215):
                                require idx < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            if address(_2215) == address(_2215):
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            else:
                                require idx < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require ext_call.return_data[18 len 14]
                            if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if address(_2215) == address(_2215):
                                require idx < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            if address(_2215) == address(_2215):
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            else:
                                require idx < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    if not mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' IDENTICAL_ADDRESSES'
                    if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                        if not mem[(32 * idx) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2335 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                        mem[mem[64] + 52] = address(_2226)
                        _2336 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2338 = sha3(mem[_2336 + 32 len mem[_2336]])
                        mem[_2335 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2335 + 105] = factoryAddress
                        mem[_2335 + 125] = _2338
                        mem[_2335 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2335 + 72] = 85
                        mem[64] = _2335 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2338, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2338, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2335 + 189 len 96] = ext_call.return_data[0 len 96]
                    else:
                        if not mem[(32 * idx + 1) + 140 len 20]:
                            revert with 0, ' ZERO_ADDRESS'
                        _2343 = mem[64]
                        mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                        mem[mem[64] + 52] = address(_2215)
                        _2344 = mem[64]
                        mem[mem[64]] = 40
                        mem[64] = mem[64] + 72
                        _2346 = sha3(mem[_2344 + 32 len mem[_2344]])
                        mem[_2343 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                        mem[_2343 + 105] = factoryAddress
                        mem[_2343 + 125] = _2346
                        mem[_2343 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                        mem[_2343 + 72] = 85
                        mem[64] = _2343 + 189
                        require ext_code.size(address(sha3(0, factoryAddress, _2346, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                        staticcall address(sha3(0, factoryAddress, _2346, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                                gas gas_remaining wei
                        mem[_2343 + 189 len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    require idx < mem[(32 * arg2.length) + 128]
                    if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                        revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                    if address(_2215) == address(_2226):
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if not ext_call.return_data[50 len 14]:
                            if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if address(_2226) == address(_2215):
                                require idx < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            if address(_2226) == address(_2215):
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            else:
                                require idx < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require ext_call.return_data[50 len 14]
                            if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if address(_2226) == address(_2215):
                                require idx < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            if address(_2226) == address(_2215):
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            else:
                                require idx < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        if ext_call.return_data[50 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if ext_call.return_data[18 len 14] <= 0:
                            revert with 0, ' INSUFFICIENT_LIQUIDITY'
                        if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if not ext_call.return_data[18 len 14]:
                            if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if address(_2226) == address(_2215):
                                require idx < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            if address(_2226) == address(_2215):
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            else:
                                require idx < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require ext_call.return_data[18 len 14]
                            if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                            if address(_2226) == address(_2215):
                                require idx < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                            else:
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require 2 * idx < mem[(64 * arg2.length) + 160]
                                mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            if address(_2226) == address(_2215):
                                require idx + 1 < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                            else:
                                require idx < mem[(32 * arg2.length) + 128]
                                require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                                mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                idx = idx + 1
                continue 
            mem[mem[64]] = 32
            mem[mem[64] + 32] = mem[(64 * arg2.length) + 160]
            _2225 = mem[(64 * arg2.length) + 160]
            mem[mem[64] + 64 len floor32(mem[(64 * arg2.length) + 160])] = mem[(64 * arg2.length) + 192 len floor32(mem[(64 * arg2.length) + 160])]
            return 32, mem[mem[64] + 32 len (32 * _2225) + 32]
        mem[(64 * arg2.length) + 192 len 64 * arg2.length - 1] = code.data[7597 len 64 * arg2.length - 1]
        require 0 < arg2.length
        mem[(32 * arg2.length) + 160] = msg.value
        idx = 0
        while idx < arg2.length - 1:
            require idx < mem[96]
            _2217 = mem[(32 * idx) + 128]
            require idx + 1 < mem[96]
            _2230 = mem[(32 * idx + 1) + 128]
            if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2351 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(_2230)
                    _2352 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2354 = sha3(mem[_2352 + 32 len mem[_2352]])
                    mem[_2351 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2351 + 105] = factoryAddress
                    mem[_2351 + 125] = _2354
                    mem[_2351 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2351 + 72] = 85
                    mem[64] = _2351 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2354, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2354, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2351 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2359 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                    mem[mem[64] + 52] = address(_2217)
                    _2360 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2362 = sha3(mem[_2360 + 32 len mem[_2360]])
                    mem[_2359 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2359 + 105] = factoryAddress
                    mem[_2359 + 125] = _2362
                    mem[_2359 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2359 + 72] = 85
                    mem[64] = _2359 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2362, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2362, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2359 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg2.length) + 128]
                if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                if address(_2217) == address(_2217):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[50 len 14]:
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2217) == address(_2217):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2217) == address(_2217):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require ext_call.return_data[50 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2217) == address(_2217):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2217) == address(_2217):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[18 len 14]:
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2217) == address(_2217):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2217) == address(_2217):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require ext_call.return_data[18 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2217) == address(_2217):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2217) == address(_2217):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
            else:
                if not mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2367 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(_2230)
                    _2368 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2370 = sha3(mem[_2368 + 32 len mem[_2368]])
                    mem[_2367 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2367 + 105] = factoryAddress
                    mem[_2367 + 125] = _2370
                    mem[_2367 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2367 + 72] = 85
                    mem[64] = _2367 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2370, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2370, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2367 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2375 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                    mem[mem[64] + 52] = address(_2217)
                    _2376 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2378 = sha3(mem[_2376 + 32 len mem[_2376]])
                    mem[_2375 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2375 + 105] = factoryAddress
                    mem[_2375 + 125] = _2378
                    mem[_2375 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2375 + 72] = 85
                    mem[64] = _2375 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2378, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2378, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2375 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg2.length) + 128]
                if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                if address(_2217) == address(_2230):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[50 len 14]:
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2230) == address(_2217):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2230) == address(_2217):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require ext_call.return_data[50 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2230) == address(_2217):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2230) == address(_2217):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[18 len 14]:
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2230) == address(_2217):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2230) == address(_2217):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require ext_call.return_data[18 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2230) == address(_2217):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2230) == address(_2217):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
            idx = idx + 1
            continue 
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[(64 * arg2.length) + 160]
        _2229 = mem[(64 * arg2.length) + 160]
        mem[mem[64] + 64 len floor32(mem[(64 * arg2.length) + 160])] = mem[(64 * arg2.length) + 192 len floor32(mem[(64 * arg2.length) + 160])]
        return 32, mem[mem[64] + 32 len (32 * _2229) + 32]
    mem[(32 * arg2.length) + 160 len 32 * arg2.length] = code.data[7597 len 32 * arg2.length]
    mem[(64 * arg2.length) + 160] = 2 * arg2.length - 1
    mem[64] = (64 * arg2.length) + (64 * arg2.length - 1) + 192
    if not uint255(arg2.length - 1):
        require 0 < arg2.length
        mem[(32 * arg2.length) + 160] = msg.value
        idx = 0
        while idx < arg2.length - 1:
            require idx < mem[96]
            _2219 = mem[(32 * idx) + 128]
            require idx + 1 < mem[96]
            _2234 = mem[(32 * idx + 1) + 128]
            if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2383 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(_2234)
                    _2384 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2386 = sha3(mem[_2384 + 32 len mem[_2384]])
                    mem[_2383 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2383 + 105] = factoryAddress
                    mem[_2383 + 125] = _2386
                    mem[_2383 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2383 + 72] = 85
                    mem[64] = _2383 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2386, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2386, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2383 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2391 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                    mem[mem[64] + 52] = address(_2219)
                    _2392 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2394 = sha3(mem[_2392 + 32 len mem[_2392]])
                    mem[_2391 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2391 + 105] = factoryAddress
                    mem[_2391 + 125] = _2394
                    mem[_2391 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2391 + 72] = 85
                    mem[64] = _2391 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2394, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2394, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2391 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg2.length) + 128]
                if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                if address(_2219) == address(_2219):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[50 len 14]:
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2219) == address(_2219):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2219) == address(_2219):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require ext_call.return_data[50 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2219) == address(_2219):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2219) == address(_2219):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[18 len 14]:
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2219) == address(_2219):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2219) == address(_2219):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require ext_call.return_data[18 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2219) == address(_2219):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2219) == address(_2219):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
            else:
                if not mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' IDENTICAL_ADDRESSES'
                if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2399 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                    mem[mem[64] + 52] = address(_2234)
                    _2400 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2402 = sha3(mem[_2400 + 32 len mem[_2400]])
                    mem[_2399 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2399 + 105] = factoryAddress
                    mem[_2399 + 125] = _2402
                    mem[_2399 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2399 + 72] = 85
                    mem[64] = _2399 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2402, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2402, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2399 + 189 len 96] = ext_call.return_data[0 len 96]
                else:
                    if not mem[(32 * idx + 1) + 140 len 20]:
                        revert with 0, ' ZERO_ADDRESS'
                    _2407 = mem[64]
                    mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                    mem[mem[64] + 52] = address(_2219)
                    _2408 = mem[64]
                    mem[mem[64]] = 40
                    mem[64] = mem[64] + 72
                    _2410 = sha3(mem[_2408 + 32 len mem[_2408]])
                    mem[_2407 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                    mem[_2407 + 105] = factoryAddress
                    mem[_2407 + 125] = _2410
                    mem[_2407 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                    mem[_2407 + 72] = 85
                    mem[64] = _2407 + 189
                    require ext_code.size(address(sha3(0, factoryAddress, _2410, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                    staticcall address(sha3(0, factoryAddress, _2410, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                            gas gas_remaining wei
                    mem[_2407 + 189 len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require idx < mem[(32 * arg2.length) + 128]
                if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                    revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
                if address(_2219) == address(_2234):
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[50 len 14]:
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2234) == address(_2219):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2234) == address(_2219):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require ext_call.return_data[50 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2234) == address(_2219):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2234) == address(_2219):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    if ext_call.return_data[50 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if ext_call.return_data[18 len 14] <= 0:
                        revert with 0, ' INSUFFICIENT_LIQUIDITY'
                    if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if not ext_call.return_data[18 len 14]:
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2234) == address(_2219):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2234) == address(_2219):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require ext_call.return_data[18 len 14]
                        if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                        if address(_2234) == address(_2219):
                            require idx < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                        else:
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require 2 * idx < mem[(64 * arg2.length) + 160]
                            mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        if address(_2234) == address(_2219):
                            require idx + 1 < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                        else:
                            require idx < mem[(32 * arg2.length) + 128]
                            require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                            mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
            idx = idx + 1
            continue 
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[(64 * arg2.length) + 160]
        _2233 = mem[(64 * arg2.length) + 160]
        mem[mem[64] + 64 len floor32(mem[(64 * arg2.length) + 160])] = mem[(64 * arg2.length) + 192 len floor32(mem[(64 * arg2.length) + 160])]
        return 32, mem[mem[64] + 32 len (32 * _2233) + 32]
    mem[(64 * arg2.length) + 192 len 64 * arg2.length - 1] = code.data[7597 len 64 * arg2.length - 1]
    require 0 < arg2.length
    mem[(32 * arg2.length) + 160] = msg.value
    idx = 0
    while idx < arg2.length - 1:
        require idx < mem[96]
        _2221 = mem[(32 * idx) + 128]
        require idx + 1 < mem[96]
        _2238 = mem[(32 * idx + 1) + 128]
        if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
            revert with 0, ' IDENTICAL_ADDRESSES'
        if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
            if not mem[(32 * idx) + 140 len 20]:
                revert with 0, ' ZERO_ADDRESS'
            if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2415 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                mem[mem[64] + 52] = address(_2238)
                _2416 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2418 = sha3(mem[_2416 + 32 len mem[_2416]])
                mem[_2415 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2415 + 105] = factoryAddress
                mem[_2415 + 125] = _2418
                mem[_2415 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2415 + 72] = 85
                mem[64] = _2415 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2418, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2418, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2415 + 189 len 96] = ext_call.return_data[0 len 96]
            else:
                if not mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2423 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                mem[mem[64] + 52] = address(_2221)
                _2424 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2426 = sha3(mem[_2424 + 32 len mem[_2424]])
                mem[_2423 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2423 + 105] = factoryAddress
                mem[_2423 + 125] = _2426
                mem[_2423 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2423 + 72] = 85
                mem[64] = _2423 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2426, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2426, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2423 + 189 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require idx < mem[(32 * arg2.length) + 128]
            if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
            if address(_2221) == address(_2221):
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                    revert with 0, 'ds-math-mul-overflow'
                if not ext_call.return_data[50 len 14]:
                    if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    require idx + 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if address(_2221) == address(_2221):
                        require idx < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    if address(_2221) == address(_2221):
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    require ext_call.return_data[50 len 14]
                    if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    require idx + 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if address(_2221) == address(_2221):
                        require idx < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    if address(_2221) == address(_2221):
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
            else:
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                    revert with 0, 'ds-math-mul-overflow'
                if not ext_call.return_data[18 len 14]:
                    if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    require idx + 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if address(_2221) == address(_2221):
                        require idx < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    if address(_2221) == address(_2221):
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    require ext_call.return_data[18 len 14]
                    if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    require idx + 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if address(_2221) == address(_2221):
                        require idx < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    if address(_2221) == address(_2221):
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
        else:
            if not mem[(32 * idx + 1) + 140 len 20]:
                revert with 0, ' ZERO_ADDRESS'
            if mem[(32 * idx) + 140 len 20] == mem[(32 * idx + 1) + 140 len 20]:
                revert with 0, ' IDENTICAL_ADDRESSES'
            if mem[(32 * idx) + 140 len 20] < mem[(32 * idx + 1) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2431 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx) + 128])
                mem[mem[64] + 52] = address(_2238)
                _2432 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2434 = sha3(mem[_2432 + 32 len mem[_2432]])
                mem[_2431 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2431 + 105] = factoryAddress
                mem[_2431 + 125] = _2434
                mem[_2431 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2431 + 72] = 85
                mem[64] = _2431 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2434, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2434, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2431 + 189 len 96] = ext_call.return_data[0 len 96]
            else:
                if not mem[(32 * idx + 1) + 140 len 20]:
                    revert with 0, ' ZERO_ADDRESS'
                _2439 = mem[64]
                mem[mem[64] + 32] = address(mem[(32 * idx + 1) + 128])
                mem[mem[64] + 52] = address(_2221)
                _2440 = mem[64]
                mem[mem[64]] = 40
                mem[64] = mem[64] + 72
                _2442 = sha3(mem[_2440 + 32 len mem[_2440]])
                mem[_2439 + 104] = 0xff00000000000000000000000000000000000000000000000000000000000000
                mem[_2439 + 105] = factoryAddress
                mem[_2439 + 125] = _2442
                mem[_2439 + 157] = 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2
                mem[_2439 + 72] = 85
                mem[64] = _2439 + 189
                require ext_code.size(address(sha3(0, factoryAddress, _2442, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)))
                staticcall address(sha3(0, factoryAddress, _2442, 0xcdf2deca40a0bd56de8e3ce5c7df6727e5b1bf2ac96f283fa9c4b3e6b42ea9d2)).getReserves() with:
                        gas gas_remaining wei
                mem[_2439 + 189 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require idx < mem[(32 * arg2.length) + 128]
            if mem[(32 * idx) + (32 * arg2.length) + 160] <= 0:
                revert with 0, ' INSUFFICIENT_INPUT_AMOUNT'
            if address(_2221) == address(_2238):
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                    revert with 0, 'ds-math-mul-overflow'
                if not ext_call.return_data[50 len 14]:
                    if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    require idx + 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if address(_2238) == address(_2221):
                        require idx < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    if address(_2238) == address(_2221):
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    require ext_call.return_data[50 len 14]
                    if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    require idx + 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if address(_2238) == address(_2221):
                        require idx < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    if address(_2238) == address(_2221):
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) + mem[(32 * idx) + (32 * arg2.length) + 160]
            else:
                if ext_call.return_data[50 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if ext_call.return_data[18 len 14] <= 0:
                    revert with 0, ' INSUFFICIENT_LIQUIDITY'
                if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] / 997 != mem[(32 * idx) + (32 * arg2.length) + 160]:
                    revert with 0, 'ds-math-mul-overflow'
                if not ext_call.return_data[18 len 14]:
                    if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    require idx + 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if address(_2238) == address(_2221):
                        require idx < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    if address(_2238) == address(_2221):
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                else:
                    require ext_call.return_data[18 len 14]
                    if 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * mem[(32 * idx) + (32 * arg2.length) + 160]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]) < 1000 * ext_call.return_data[50 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    require (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    require idx + 1 < mem[(32 * arg2.length) + 128]
                    mem[(32 * idx + 1) + (32 * arg2.length) + 160] = 997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160])
                    if address(_2238) == address(_2221):
                        require idx < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
                    else:
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require 2 * idx < mem[(64 * arg2.length) + 160]
                        mem[(64 * idx) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    if address(_2238) == address(_2221):
                        require idx + 1 < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[0]) - (997 * mem[(32 * idx) + (32 * arg2.length) + 160] * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * mem[(32 * idx) + (32 * arg2.length) + 160]))
                    else:
                        require idx < mem[(32 * arg2.length) + 128]
                        require (2 * idx) + 1 < mem[(64 * arg2.length) + 160]
                        mem[(32 * (2 * idx) + 1) + (64 * arg2.length) + 192] = Mask(112, 0, ext_call.return_data[32]) + mem[(32 * idx) + (32 * arg2.length) + 160]
        idx = idx + 1
        continue 
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[(64 * arg2.length) + 160]
    _2237 = mem[(64 * arg2.length) + 160]
    mem[mem[64] + 64 len floor32(mem[(64 * arg2.length) + 160])] = mem[(64 * arg2.length) + 192 len floor32(mem[(64 * arg2.length) + 160])]
    return 32, mem[mem[64] + 32 len (32 * _2237) + 32]
}



}
