contract main {




// =====================  Runtime code  =====================


#
#  - transferFrom(address arg1, address arg2, uint256 arg3)
#  - deliver(uint256 arg1)
#  - transfer(address arg1, uint256 arg2)
#
address _owner;
mapping of uint256 stor1;
mapping of uint256 stor2;
mapping of uint256 allowance;
mapping of uint8 stor4;
mapping of uint8 stor5;
array of address stor6;
array of struct stor7;
array of struct stor8;
uint256 decimals;
address feeAddress;
uint256 stor13;
uint256 totalSupply;
uint256 stor15;
uint256 totalFees;
uint256 totalBurn;
uint256 totalCharity;
uint256 _TAX_FEE;
uint256 _BURN_FEE;
uint256 _CHARITY_FEE;
uint256 stor22;
uint256 stor23;
uint256 stor24;

function totalFees() payable {
    return totalFees
}

function totalSupply() payable {
    return totalSupply
}

function decimals() payable {
    return decimals
}

function totalBurn() payable {
    return totalBurn
}

function _BURN_FEE() payable {
    return _BURN_FEE
}

function FeeAddress() payable {
    return feeAddress
}

function owner() payable {
    return _owner
}

function _CHARITY_FEE() payable {
    return _CHARITY_FEE
}

function _owner() payable {
    return _owner
}

function _TAX_FEE() payable {
    return _TAX_FEE
}

function isExcluded(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor4[address(arg1)])
}

function totalCharity() payable {
    return totalCharity
}

function allowance(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return allowance[address(arg1)][address(arg2)]
}

function isCharity(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor5[address(arg1)])
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if _owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(_owner, 0);
    _owner = 0
}

function setAsCharityAccount(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if _owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if stor5[address(arg1)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Account is already charity account'
    stor5[address(arg1)] = 1
    feeAddress = arg1
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if _owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(_owner, arg1);
    _owner = arg1
}

function approve(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TOKEN20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TOKEN20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function burn(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 <= stor1[address(msg.sender)]
    if arg1 > stor1[address(msg.sender)]:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if stor1[address(msg.sender)] < arg1:
        revert with 0, 17
    stor1[address(msg.sender)] -= arg1
    if arg1 > totalSupply:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if totalSupply < arg1:
        revert with 0, 17
    totalSupply -= arg1
    emit 0x65ddf252: arg1, msg.sender, 0
}

function mint(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if _owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if totalSupply > !arg2:
        revert with 0, 17
    if totalSupply + arg2 < totalSupply:
        revert with 0, 'SafeMath: addition overflow'
    totalSupply += arg2
    if stor1[address(arg1)] > !arg2:
        revert with 0, 17
    if stor1[address(arg1)] + arg2 < stor1[address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    stor1[address(arg1)] += arg2
    emit 0x65ddf252: arg2, 0, arg1
}

function updateFee(uint256 arg1, uint256 arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    if _owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
        revert with 0, 17
    _TAX_FEE = 100 * arg1
    if arg2 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
        revert with 0, 17
    _BURN_FEE = 100 * arg2
    if arg3 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
        revert with 0, 17
    _CHARITY_FEE = 100 * arg3
    stor22 = _TAX_FEE
    stor23 = _BURN_FEE
    stor24 = 100 * arg3
}

function decreaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if arg2 > allowance[msg.sender][address(arg1)]:
        revert with 0, 32, 39, 0xfe544f4b454e32303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572, mem[167 len 25] >> 56, 0
    if allowance[msg.sender][address(arg1)] < arg2:
        revert with 0, 17
    if not msg.sender:
        revert with 0, 'TOKEN20: approve from the zero address'
    if not arg1:
        revert with 0, 'TOKEN20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] - arg2
    emit Approval((allowance[msg.sender][address(arg1)] - arg2), msg.sender, arg1);
    return 1
}

function increaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if allowance[msg.sender][address(arg1)] > !arg2:
        revert with 0, 17
    if allowance[msg.sender][address(arg1)] + arg2 < allowance[msg.sender][address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TOKEN20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TOKEN20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] + arg2
    emit Approval((allowance[msg.sender][address(arg1)] + arg2), msg.sender, arg1);
    return 1
}

function includeAccount(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if _owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not stor4[address(arg1)]:
        revert with 0, 'Account is already excluded'
    idx = 0
    while idx < stor6.length:
        mem[0] = 6
        if stor6[idx] != arg1:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if stor6.length < 1:
            revert with 0, 17
        if stor6.length - 1 >= stor6.length:
            revert with 0, 50
        if idx >= stor6.length:
            revert with 0, 50
        stor6[idx] = stor6[stor6.length]
        stor2[address(arg1)] = 0
        stor4[address(arg1)] = 0
        if not stor6.length:
            revert with 0, 49
        stor6[stor6.length] = 0
        stor6.length--
}

function name() payable {
    if bool(stor7.length):
        if bool(stor7.length) == uint255(stor7.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor7.length):
            if bool(stor7.length) == uint255(stor7.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor7.length):
                if 31 < uint255(stor7.length) * 0.5:
                    mem[128] = uint256(stor7.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor7.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor7[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor7.length), data=mem[128 len ceil32(uint255(stor7.length) * 0.5)])
                mem[128] = 256 * stor7.length.field_8
        else:
            if bool(stor7.length) == stor7.length.field_1 < 32:
                revert with 0, 34
            if stor7.length.field_1:
                if 31 < stor7.length.field_1:
                    mem[128] = uint256(stor7.field_0)
                    idx = 128
                    s = 0
                    while stor7.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor7[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor7.length), data=mem[128 len ceil32(uint255(stor7.length) * 0.5)])
                mem[128] = 256 * stor7.length.field_8
        mem[ceil32(uint255(stor7.length) * 0.5) + 192 len ceil32(uint255(stor7.length) * 0.5)] = mem[128 len ceil32(uint255(stor7.length) * 0.5)]
        if ceil32(uint255(stor7.length) * 0.5) > uint255(stor7.length) * 0.5:
            mem[ceil32(uint255(stor7.length) * 0.5) + (uint255(stor7.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor7.length), data=mem[128 len ceil32(uint255(stor7.length) * 0.5)], mem[(2 * ceil32(uint255(stor7.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor7.length) * 0.5)]), 
    if bool(stor7.length) == stor7.length.field_1 < 32:
        revert with 0, 34
    if bool(stor7.length):
        if bool(stor7.length) == uint255(stor7.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor7.length):
            if 31 < uint255(stor7.length) * 0.5:
                mem[128] = uint256(stor7.field_0)
                idx = 128
                s = 0
                while (uint255(stor7.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor7[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor7.length % 128, data=mem[128 len ceil32(stor7.length.field_1)])
            mem[128] = 256 * stor7.length.field_8
    else:
        if bool(stor7.length) == stor7.length.field_1 < 32:
            revert with 0, 34
        if stor7.length.field_1:
            if 31 < stor7.length.field_1:
                mem[128] = uint256(stor7.field_0)
                idx = 128
                s = 0
                while stor7.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor7[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor7.length % 128, data=mem[128 len ceil32(stor7.length.field_1)])
            mem[128] = 256 * stor7.length.field_8
    mem[ceil32(stor7.length.field_1) + 192 len ceil32(stor7.length.field_1)] = mem[128 len ceil32(stor7.length.field_1)]
    if ceil32(stor7.length.field_1) > stor7.length.field_1:
        mem[ceil32(stor7.length.field_1) + stor7.length.field_1 + 192] = 0
    return Array(len=stor7.length % 128, data=mem[128 len ceil32(stor7.length.field_1)], mem[(2 * ceil32(stor7.length.field_1)) + 192 len 2 * ceil32(stor7.length.field_1)]), 
}

function symbol() payable {
    if bool(stor8.length):
        if bool(stor8.length) == uint255(stor8.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor8.length):
            if bool(stor8.length) == uint255(stor8.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor8.length):
                if 31 < uint255(stor8.length) * 0.5:
                    mem[128] = uint256(stor8.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor8.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor8[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor8.length), data=mem[128 len ceil32(uint255(stor8.length) * 0.5)])
                mem[128] = 256 * stor8.length.field_8
        else:
            if bool(stor8.length) == stor8.length.field_1 < 32:
                revert with 0, 34
            if stor8.length.field_1:
                if 31 < stor8.length.field_1:
                    mem[128] = uint256(stor8.field_0)
                    idx = 128
                    s = 0
                    while stor8.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor8[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor8.length), data=mem[128 len ceil32(uint255(stor8.length) * 0.5)])
                mem[128] = 256 * stor8.length.field_8
        mem[ceil32(uint255(stor8.length) * 0.5) + 192 len ceil32(uint255(stor8.length) * 0.5)] = mem[128 len ceil32(uint255(stor8.length) * 0.5)]
        if ceil32(uint255(stor8.length) * 0.5) > uint255(stor8.length) * 0.5:
            mem[ceil32(uint255(stor8.length) * 0.5) + (uint255(stor8.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor8.length), data=mem[128 len ceil32(uint255(stor8.length) * 0.5)], mem[(2 * ceil32(uint255(stor8.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor8.length) * 0.5)]), 
    if bool(stor8.length) == stor8.length.field_1 < 32:
        revert with 0, 34
    if bool(stor8.length):
        if bool(stor8.length) == uint255(stor8.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor8.length):
            if 31 < uint255(stor8.length) * 0.5:
                mem[128] = uint256(stor8.field_0)
                idx = 128
                s = 0
                while (uint255(stor8.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor8[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor8.length % 128, data=mem[128 len ceil32(stor8.length.field_1)])
            mem[128] = 256 * stor8.length.field_8
    else:
        if bool(stor8.length) == stor8.length.field_1 < 32:
            revert with 0, 34
        if stor8.length.field_1:
            if 31 < stor8.length.field_1:
                mem[128] = uint256(stor8.field_0)
                idx = 128
                s = 0
                while stor8.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor8[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor8.length % 128, data=mem[128 len ceil32(stor8.length.field_1)])
            mem[128] = 256 * stor8.length.field_8
    mem[ceil32(stor8.length.field_1) + 192 len ceil32(stor8.length.field_1)] = mem[128 len ceil32(stor8.length.field_1)]
    if ceil32(stor8.length.field_1) > stor8.length.field_1:
        mem[ceil32(stor8.length.field_1) + stor8.length.field_1 + 192] = 0
    return Array(len=stor8.length % 128, data=mem[128 len ceil32(stor8.length.field_1)], mem[(2 * ceil32(stor8.length.field_1)) + 192 len 2 * ceil32(stor8.length.field_1)]), 
}

function tokenFromReflection(uint256 arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if arg1 > stor15:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = totalSupply
    t = stor15
    while idx < stor6.length:
        mem[0] = stor6[idx]
        mem[32] = 1
        if stor1[stor6[idx]] > t:
            _92 = mem[64]
            mem[64] = mem[64] + 64
            mem[_92] = 26
            mem[_92 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _96 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _96 + 68] = mem[idx + _92 + 32]
                    idx = idx + 32
                    continue 
                mem[_96 + 94] = 0
                revert with memory
                  from mem[64]
                   len _96 + -mem[64] + 100
            _117 = mem[64]
            mem[64] = mem[64] + 64
            mem[_117] = 26
            mem[_117 + 32] = 'SafeMath: division by zero'
            if stor15 / totalSupply:
                return (arg1 / stor15 / totalSupply)
            _126 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _126 + 68] = mem[idx + _117 + 32]
                idx = idx + 32
                continue 
            mem[_126 + 94] = 0
            revert with memory
              from mem[64]
               len _126 + -mem[64] + 100
        if idx >= stor6.length:
            revert with 0, 50
        mem[0] = stor6[idx]
        mem[32] = 2
        if stor2[stor6[idx]] > s:
            _98 = mem[64]
            mem[64] = mem[64] + 64
            mem[_98] = 26
            mem[_98 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _103 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _103 + 68] = mem[idx + _98 + 32]
                    idx = idx + 32
                    continue 
                mem[_103 + 94] = 0
                revert with memory
                  from mem[64]
                   len _103 + -mem[64] + 100
            _128 = mem[64]
            mem[64] = mem[64] + 64
            mem[_128] = 26
            mem[_128 + 32] = 'SafeMath: division by zero'
            if stor15 / totalSupply:
                return (arg1 / stor15 / totalSupply)
            _133 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _133 + 68] = mem[idx + _128 + 32]
                idx = idx + 32
                continue 
            mem[_133 + 94] = 0
            revert with memory
              from mem[64]
               len _133 + -mem[64] + 100
        if idx >= stor6.length:
            revert with 0, 50
        mem[0] = stor6[idx]
        mem[32] = 1
        _97 = mem[64]
        mem[64] = mem[64] + 64
        mem[_97] = 30
        mem[_97 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor6[idx]] > t:
            _102 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _102 + 68] = mem[idx + _97 + 32]
                idx = idx + 32
                continue 
            mem[_102 + 98] = 0
            revert with memory
              from mem[64]
               len _102 + -mem[64] + 100
        if t < stor1[stor6[idx]]:
            revert with 0, 17
        if idx >= stor6.length:
            revert with 0, 50
        mem[0] = stor6[idx]
        mem[32] = 2
        _127 = mem[64]
        mem[64] = mem[64] + 64
        mem[_127] = 30
        mem[_127 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor6[idx]] <= s:
            if s < stor2[stor6[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor2[stor6[idx]]
            t = t - stor1[stor6[idx]]
            continue 
        _132 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _132 + 68] = mem[idx + _127 + 32]
            idx = idx + 32
            continue 
        mem[_132 + 98] = 0
        revert with memory
          from mem[64]
           len _132 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if t >= stor15 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not t / s:
            revert with 0, 'SafeMath: division by zero', 0
        return (arg1 / t / s)
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not stor15 / totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    return (arg1 / stor15 / totalSupply)
}

function balanceOf(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor4[address(arg1)]:
        return stor2[address(arg1)]
    mem[0] = arg1
    mem[32] = 1
    if stor1[address(arg1)] > stor15:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = totalSupply
    t = stor15
    while idx < stor6.length:
        mem[0] = stor6[idx]
        mem[32] = 1
        if stor1[stor6[idx]] > t:
            _97 = mem[64]
            mem[64] = mem[64] + 64
            mem[_97] = 26
            mem[_97 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _101 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _101 + 68] = mem[idx + _97 + 32]
                    idx = idx + 32
                    continue 
                mem[_101 + 94] = 0
                revert with memory
                  from mem[64]
                   len _101 + -mem[64] + 100
            _122 = mem[64]
            mem[64] = mem[64] + 64
            mem[_122] = 26
            mem[_122 + 32] = 'SafeMath: division by zero'
            if stor15 / totalSupply:
                return (stor1[address(arg1)] / stor15 / totalSupply)
            _131 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _131 + 68] = mem[idx + _122 + 32]
                idx = idx + 32
                continue 
            mem[_131 + 94] = 0
            revert with memory
              from mem[64]
               len _131 + -mem[64] + 100
        if idx >= stor6.length:
            revert with 0, 50
        mem[0] = stor6[idx]
        mem[32] = 2
        if stor2[stor6[idx]] > s:
            _103 = mem[64]
            mem[64] = mem[64] + 64
            mem[_103] = 26
            mem[_103 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _108 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _108 + 68] = mem[idx + _103 + 32]
                    idx = idx + 32
                    continue 
                mem[_108 + 94] = 0
                revert with memory
                  from mem[64]
                   len _108 + -mem[64] + 100
            _133 = mem[64]
            mem[64] = mem[64] + 64
            mem[_133] = 26
            mem[_133 + 32] = 'SafeMath: division by zero'
            if stor15 / totalSupply:
                return (stor1[address(arg1)] / stor15 / totalSupply)
            _138 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _138 + 68] = mem[idx + _133 + 32]
                idx = idx + 32
                continue 
            mem[_138 + 94] = 0
            revert with memory
              from mem[64]
               len _138 + -mem[64] + 100
        if idx >= stor6.length:
            revert with 0, 50
        mem[0] = stor6[idx]
        mem[32] = 1
        _102 = mem[64]
        mem[64] = mem[64] + 64
        mem[_102] = 30
        mem[_102 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor6[idx]] > t:
            _107 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _107 + 68] = mem[idx + _102 + 32]
                idx = idx + 32
                continue 
            mem[_107 + 98] = 0
            revert with memory
              from mem[64]
               len _107 + -mem[64] + 100
        if t < stor1[stor6[idx]]:
            revert with 0, 17
        if idx >= stor6.length:
            revert with 0, 50
        mem[0] = stor6[idx]
        mem[32] = 2
        _132 = mem[64]
        mem[64] = mem[64] + 64
        mem[_132] = 30
        mem[_132 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor6[idx]] <= s:
            if s < stor2[stor6[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor2[stor6[idx]]
            t = t - stor1[stor6[idx]]
            continue 
        _137 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _137 + 68] = mem[idx + _132 + 32]
            idx = idx + 32
            continue 
        mem[_137 + 98] = 0
        revert with memory
          from mem[64]
           len _137 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if t >= stor15 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not t / s:
            revert with 0, 'SafeMath: division by zero', 0
        return (stor1[address(arg1)] / t / s)
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not stor15 / totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    return (stor1[address(arg1)] / stor15 / totalSupply)
}

function excludeAccount(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if _owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if stor4[address(arg1)]:
        revert with 0, 'Account is already excluded'
    if stor1[address(arg1)]:
        mem[0] = arg1
        mem[32] = 1
        if stor1[address(arg1)] > stor15:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
        idx = 0
        s = totalSupply
        t = stor15
        while idx < stor6.length:
            mem[0] = stor6[idx]
            mem[32] = 1
            if stor1[stor6[idx]] > t:
                _100 = mem[64]
                mem[64] = mem[64] + 64
                mem[_100] = 26
                mem[_100 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _104 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _104 + 68] = mem[idx + _100 + 32]
                        idx = idx + 32
                        continue 
                    mem[_104 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _104 + -mem[64] + 100
                _125 = mem[64]
                mem[64] = mem[64] + 64
                mem[_125] = 26
                mem[_125 + 32] = 'SafeMath: division by zero'
                if stor15 / totalSupply:
                    stor2[address(arg1)] = stor1[address(arg1)] / stor15 / totalSupply
                    stor4[address(arg1)] = 1
                    stor6.length++
                    stor6[stor6.length] = arg1
                _134 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _134 + 68] = mem[idx + _125 + 32]
                    idx = idx + 32
                    continue 
                mem[_134 + 94] = 0
                revert with memory
                  from mem[64]
                   len _134 + -mem[64] + 100
            if idx >= stor6.length:
                revert with 0, 50
            mem[0] = stor6[idx]
            mem[32] = 2
            if stor2[stor6[idx]] > s:
                _106 = mem[64]
                mem[64] = mem[64] + 64
                mem[_106] = 26
                mem[_106 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _111 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _111 + 68] = mem[idx + _106 + 32]
                        idx = idx + 32
                        continue 
                    mem[_111 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _111 + -mem[64] + 100
                _136 = mem[64]
                mem[64] = mem[64] + 64
                mem[_136] = 26
                mem[_136 + 32] = 'SafeMath: division by zero'
                if stor15 / totalSupply:
                    stor2[address(arg1)] = stor1[address(arg1)] / stor15 / totalSupply
                    stor4[address(arg1)] = 1
                    stor6.length++
                    stor6[stor6.length] = arg1
                _141 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _141 + 68] = mem[idx + _136 + 32]
                    idx = idx + 32
                    continue 
                mem[_141 + 94] = 0
                revert with memory
                  from mem[64]
                   len _141 + -mem[64] + 100
            if idx >= stor6.length:
                revert with 0, 50
            mem[0] = stor6[idx]
            mem[32] = 1
            _105 = mem[64]
            mem[64] = mem[64] + 64
            mem[_105] = 30
            mem[_105 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor6[idx]] > t:
                _110 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _110 + 68] = mem[idx + _105 + 32]
                    idx = idx + 32
                    continue 
                mem[_110 + 98] = 0
                revert with memory
                  from mem[64]
                   len _110 + -mem[64] + 100
            if t < stor1[stor6[idx]]:
                revert with 0, 17
            if idx >= stor6.length:
                revert with 0, 50
            mem[0] = stor6[idx]
            mem[32] = 2
            _135 = mem[64]
            mem[64] = mem[64] + 64
            mem[_135] = 30
            mem[_135 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor6[idx]] <= s:
                if s < stor2[stor6[idx]]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s - stor2[stor6[idx]]
                t = t - stor1[stor6[idx]]
                continue 
            _140 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _140 + 68] = mem[idx + _135 + 32]
                idx = idx + 32
                continue 
            mem[_140 + 98] = 0
            revert with memory
              from mem[64]
               len _140 + -mem[64] + 100
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if t >= stor15 / totalSupply:
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not t / s:
                revert with 0, 'SafeMath: division by zero', 0
            stor2[address(arg1)] = stor1[address(arg1)] / t / s
        else:
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not stor15 / totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            stor2[address(arg1)] = stor1[address(arg1)] / stor15 / totalSupply
    stor4[address(arg1)] = 1
    stor6.length++
    stor6[stor6.length] = arg1
}

function reflectionFromToken(uint256 arg1, bool arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if arg1 > totalSupply:
        revert with 0, 'Amount must be less than supply'
    if arg2:
        if not arg1:
            mem[96] = 26
            mem[128] = 'SafeMath: division by zero'
            if not stor13:
                revert with 0, 'SafeMath: division by zero', 0
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if not arg1:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                if not stor13:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[288] = 26
                mem[320] = 'SafeMath: division by zero'
                if not arg1:
                    mem[352] = 26
                    mem[384] = 'SafeMath: division by zero'
                    if not stor13:
                        revert with 0, 'SafeMath: division by zero', 0
                    mem[416] = 26
                    mem[448] = 'SafeMath: division by zero'
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0 / stor13 / 100:
                        revert with 0, 17
                    mem[544] = 30
                    mem[576] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 > arg1 - (0 / stor13 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (0 / stor13 / 100) < 0 / stor13 / 100:
                        revert with 0, 17
                    mem[64] = 672
                    mem[608] = 30
                    mem[640] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 > arg1 - (2 * 0 / stor13 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (2 * 0 / stor13 / 100) < 0 / stor13 / 100:
                        revert with 0, 17
                    idx = 0
                    s = totalSupply
                    t = stor15
                    while idx < stor6.length:
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        if stor1[stor6[idx]] > t:
                            _19234 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19234] = 26
                            mem[_19234 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _19312 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _19312 + 68] = mem[idx + _19234 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19312 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _19312 + -mem[64] + 100
                            if not arg1:
                                if not 0 / stor13 / 100:
                                    return 0
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    _20430 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20430] = 30
                                    mem[_20430 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                        _20680 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20680 + 68] = mem[idx + _20430 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20680 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20680 + -mem[64] + 100
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _21684 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21684] = 30
                                    mem[_21684 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        _22199 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22199 + 68] = mem[idx + _21684 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22199 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22199 + -mem[64] + 100
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24647 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24647] = 30
                                    mem[_24647 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                    _25693 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25693 + 68] = mem[idx + _24647 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25693 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25693 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    _21192 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21192] = 30
                                    mem[_21192 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                        _21683 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21683 + 68] = mem[idx + _21192 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21683 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21683 + -mem[64] + 100
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _23717 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23717] = 30
                                    mem[_23717 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        _24646 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _24646 + 68] = mem[idx + _23717 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24646 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _24646 + -mem[64] + 100
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _27995 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27995] = 30
                                    mem[_27995 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                        if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                            revert with 0, 17
                                        return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                    _29226 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _29226 + 68] = mem[idx + _27995 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29226 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29226 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _22896 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22896] = 30
                                mem[_22896 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _23716 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23716 + 68] = mem[idx + _22896 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23716 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23716 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _26758 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26758] = 30
                                mem[_26758 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _27994 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _27994 + 68] = mem[idx + _26758 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27994 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _27994 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _31594 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31594] = 30
                                mem[_31594 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _32770 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _32770 + 68] = mem[idx + _31594 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_32770 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _32770 + -mem[64] + 100
                            if arg1 and stor15 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _20428 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20428] = 30
                                mem[_20428 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20679 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20679 + 68] = mem[idx + _20428 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20679 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20679 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _21681 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21681] = 30
                                mem[_21681 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _22197 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22197 + 68] = mem[idx + _21681 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22197 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22197 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24644 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24644] = 30
                                mem[_24644 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _25692 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25692 + 68] = mem[idx + _24644 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25692 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25692 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21191 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21191] = 30
                                mem[_21191 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _21680 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21680 + 68] = mem[idx + _21191 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21680 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21680 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23714 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23714] = 30
                                mem[_23714 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    _24643 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24643 + 68] = mem[idx + _23714 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24643 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24643 + -mem[64] + 100
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                _27992 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27992] = 30
                                mem[_27992 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _29224 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29224 + 68] = mem[idx + _27992 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29224 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29224 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _22895 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22895] = 30
                                mem[_22895 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _23713 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23713 + 68] = mem[idx + _22895 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23713 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23713 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _26756 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26756] = 30
                                mem[_26756 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    _27991 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _27991 + 68] = mem[idx + _26756 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27991 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _27991 + -mem[64] + 100
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _31591 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31591] = 30
                                mem[_31591 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _32768 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _32768 + 68] = mem[idx + _31591 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_32768 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _32768 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _25691 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25691] = 30
                            mem[_25691 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _26755 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26755 + 68] = mem[idx + _25691 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26755 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26755 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _30361 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30361] = 30
                            mem[_30361 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _31590 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _31590 + 68] = mem[idx + _30361 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_31590 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _31590 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _34591 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34591] = 30
                            mem[_34591 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _35456 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _35456 + 68] = mem[idx + _34591 + 32]
                                idx = idx + 32
                                continue 
                            mem[_35456 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _35456 + -mem[64] + 100
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        if stor2[stor6[idx]] <= s:
                            if idx >= stor6.length:
                                revert with 0, 50
                            mem[0] = stor6[idx]
                            mem[32] = 1
                            _19313 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19313] = 30
                            mem[_19313 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor6[idx]] > t:
                                _19393 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19393 + 68] = mem[idx + _19313 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19393 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19393 + -mem[64] + 100
                            if t < stor1[stor6[idx]]:
                                revert with 0, 17
                            if idx >= stor6.length:
                                revert with 0, 50
                            mem[0] = stor6[idx]
                            mem[32] = 2
                            _19746 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19746] = 30
                            mem[_19746 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor6[idx]] <= s:
                                if s < stor2[stor6[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor6[idx]]
                                t = t - stor1[stor6[idx]]
                                continue 
                            _19794 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19794 + 68] = mem[idx + _19746 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19794 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19794 + -mem[64] + 100
                        _19314 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19314] = 26
                        mem[_19314 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19394 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19394 + 68] = mem[idx + _19314 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19394 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19394 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor13 / 100:
                                return 0
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _20684 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20684] = 30
                                mem[_20684 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20863 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20863 + 68] = mem[idx + _20684 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20863 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20863 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _22205 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22205] = 30
                                mem[_22205 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _22899 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22899 + 68] = mem[idx + _22205 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22899 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22899 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25699 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25699] = 30
                                mem[_25699 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                _26762 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26762 + 68] = mem[idx + _25699 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26762 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26762 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21688 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21688] = 30
                                mem[_21688 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _22204 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22204 + 68] = mem[idx + _21688 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22204 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22204 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _24653 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24653] = 30
                                mem[_24653 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _25698 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25698 + 68] = mem[idx + _24653 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25698 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25698 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _29232 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29232] = 30
                                mem[_29232 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _30365 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _30365 + 68] = mem[idx + _29232 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_30365 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _30365 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _23720 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23720] = 30
                            mem[_23720 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _24652 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24652 + 68] = mem[idx + _23720 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24652 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24652 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _28001 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28001] = 30
                            mem[_28001 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _29231 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29231 + 68] = mem[idx + _28001 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29231 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29231 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _32776 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32776] = 30
                            mem[_32776 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _33645 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _33645 + 68] = mem[idx + _32776 + 32]
                                idx = idx + 32
                                continue 
                            mem[_33645 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _33645 + -mem[64] + 100
                        if arg1 and stor15 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _20682 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20682] = 30
                            mem[_20682 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _20862 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20862 + 68] = mem[idx + _20682 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20862 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20862 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _22202 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22202] = 30
                            mem[_22202 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22897 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22897 + 68] = mem[idx + _22202 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22897 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22897 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25696 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25696] = 30
                            mem[_25696 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _26761 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26761 + 68] = mem[idx + _25696 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26761 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26761 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21687 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21687] = 30
                            mem[_21687 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _22201 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22201 + 68] = mem[idx + _21687 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22201 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22201 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24650 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24650] = 30
                            mem[_24650 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _25695 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25695 + 68] = mem[idx + _24650 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25695 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25695 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _29229 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29229] = 30
                            mem[_29229 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _30363 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30363 + 68] = mem[idx + _29229 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30363 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30363 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _23719 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23719] = 30
                            mem[_23719 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _24649 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24649 + 68] = mem[idx + _23719 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24649 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24649 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27999 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27999] = 30
                            mem[_27999 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _29228 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29228 + 68] = mem[idx + _27999 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29228 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29228 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _32773 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32773] = 30
                            mem[_32773 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _33643 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _33643 + 68] = mem[idx + _32773 + 32]
                                idx = idx + 32
                                continue 
                            mem[_33643 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _33643 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _26760 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26760] = 30
                        mem[_26760 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _27998 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27998 + 68] = mem[idx + _26760 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27998 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27998 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _31597 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31597] = 30
                        mem[_31597 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _32772 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32772 + 68] = mem[idx + _31597 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32772 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32772 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _35459 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35459] = 30
                        mem[_35459 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _35940 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35940 + 68] = mem[idx + _35459 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35940 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35940 + -mem[64] + 100
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if t >= stor15 / totalSupply:
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg1:
                            if not 0 / stor13 / 100:
                                return 0
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * t / s < 0:
                                    revert with 0, 17
                                return (-1 * 0 / stor13 / 100 * t / s)
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                return ((-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor13 / 100 * t / s > (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                        if arg1 and t / s > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * t / s / arg1 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            return (arg1 * t / s)
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((arg1 * t / s) - (0 / stor13 / 100 * t / s))
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not 0 / stor13 / 100:
                            return 0
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 / stor13 / 100 * stor15 / totalSupply > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if arg1 and _CHARITY_FEE > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / arg1 != _CHARITY_FEE:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor13:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0 / stor13 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1 - (0 / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor13 / 100) < 0 / stor13 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor13 / 100 > arg1 - (2 * 0 / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (2 * 0 / stor13 / 100) < arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor15
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _19233 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19233] = 26
                        mem[_19233 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19309 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19309 + 68] = mem[idx + _19233 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19309 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19309 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    return 0
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20422 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20422] = 30
                                mem[_20422 + 32] = 'SafeMath: subtraction overflow'
                                _21668 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21668] = 30
                                mem[_21668 + 32] = 'SafeMath: subtraction overflow'
                                _24622 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24622] = 30
                                mem[_24622 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                    if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply)
                                _25676 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25676 + 68] = mem[idx + _24622 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25676 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25676 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    _20421 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20421] = 30
                                    mem[_20421 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                        _20673 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20673 + 68] = mem[idx + _20421 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20673 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20673 + -mem[64] + 100
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _21666 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21666] = 30
                                    mem[_21666 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        _22186 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22186 + 68] = mem[idx + _21666 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22186 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22186 + -mem[64] + 100
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24620 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24620] = 30
                                    mem[_24620 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                    _25675 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25675 + 68] = mem[idx + _24620 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25675 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25675 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21181 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21181] = 30
                                mem[_21181 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21665 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21665 + 68] = mem[idx + _21181 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21665 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21665 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23696 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23696] = 30
                                mem[_23696 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _24619 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24619 + 68] = mem[idx + _23696 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24619 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24619 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _27967 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27967] = 30
                                mem[_27967 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                                _29203 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29203 + 68] = mem[idx + _27967 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29203 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29203 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21180 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21180] = 30
                                mem[_21180 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21664 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21664 + 68] = mem[idx + _21180 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21664 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21664 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23694 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23694] = 30
                                mem[_23694 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _24618 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24618 + 68] = mem[idx + _23694 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24618 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24618 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27965 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27965] = 30
                                mem[_27965 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _29202 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29202 + 68] = mem[idx + _27965 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29202 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29202 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22883 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22883] = 30
                            mem[_22883 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _23693 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23693 + 68] = mem[idx + _22883 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23693 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23693 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26737 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26737] = 30
                            mem[_26737 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _27964 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27964 + 68] = mem[idx + _26737 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27964 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27964 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31570 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31570] = 30
                            mem[_31570 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                            _32747 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32747 + 68] = mem[idx + _31570 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32747 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32747 + -mem[64] + 100
                        if arg1 and stor15 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20419 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20419] = 30
                                mem[_20419 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20672 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20672 + 68] = mem[idx + _20419 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20672 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20672 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _21662 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21662] = 30
                                mem[_21662 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _22184 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22184 + 68] = mem[idx + _21662 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22184 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22184 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24616 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24616] = 30
                                mem[_24616 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _25674 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25674 + 68] = mem[idx + _24616 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25674 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25674 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21179 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21179] = 30
                            mem[_21179 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _21661 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21661 + 68] = mem[idx + _21179 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21661 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21661 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _23691 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23691] = 30
                            mem[_23691 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _24615 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24615 + 68] = mem[idx + _23691 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24615 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24615 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _27962 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27962] = 30
                            mem[_27962 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                            _29200 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29200 + 68] = mem[idx + _27962 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29200 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29200 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21178 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21178] = 30
                                mem[_21178 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _21660 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21660 + 68] = mem[idx + _21178 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21660 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21660 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23689 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23689] = 30
                                mem[_23689 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    _24614 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24614 + 68] = mem[idx + _23689 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24614 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24614 + -mem[64] + 100
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                _27960 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27960] = 30
                                mem[_27960 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _29199 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29199 + 68] = mem[idx + _27960 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29199 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29199 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22882 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22882] = 30
                            mem[_22882 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23688 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23688 + 68] = mem[idx + _22882 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23688 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23688 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26735 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26735] = 30
                            mem[_26735 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _27959 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27959 + 68] = mem[idx + _26735 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27959 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27959 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _31567 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31567] = 30
                            mem[_31567 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                            _32744 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32744 + 68] = mem[idx + _31567 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32744 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32744 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _22881 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22881] = 30
                            mem[_22881 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23687 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23687 + 68] = mem[idx + _22881 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23687 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23687 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26733 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26733] = 30
                            mem[_26733 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _27958 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27958 + 68] = mem[idx + _26733 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27958 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27958 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31565 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31565] = 30
                            mem[_31565 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _32743 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32743 + 68] = mem[idx + _31565 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32743 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32743 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25673 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25673] = 30
                        mem[_25673 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _26732 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26732 + 68] = mem[idx + _25673 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26732 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26732 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _30342 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30342] = 30
                        mem[_30342 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _31564 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31564 + 68] = mem[idx + _30342 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31564 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31564 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _34571 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34571] = 30
                        mem[_34571 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _35438 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35438 + 68] = mem[idx + _34571 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35438 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35438 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _19310 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19310] = 30
                        mem[_19310 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _19390 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19390 + 68] = mem[idx + _19310 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19390 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19390 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _19743 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19743] = 30
                        mem[_19743 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _19791 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19791 + 68] = mem[idx + _19743 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19791 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19791 + -mem[64] + 100
                    _19311 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19311] = 26
                    mem[_19311 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19391 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19391 + 68] = mem[idx + _19311 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19391 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19391 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                return 0
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20678 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20678] = 30
                            mem[_20678 + 32] = 'SafeMath: subtraction overflow'
                            _22196 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22196] = 30
                            mem[_22196 + 32] = 'SafeMath: subtraction overflow'
                            _25686 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25686] = 30
                            mem[_25686 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply)
                            _26742 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26742 + 68] = mem[idx + _25686 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26742 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26742 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20677 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20677] = 30
                                mem[_20677 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20860 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20860 + 68] = mem[idx + _20677 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20860 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20860 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _22194 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22194] = 30
                                mem[_22194 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _22887 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22887 + 68] = mem[idx + _22194 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22887 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22887 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25684 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25684] = 30
                                mem[_25684 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                _26741 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26741 + 68] = mem[idx + _25684 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26741 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26741 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21673 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21673] = 30
                            mem[_21673 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _22193 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22193 + 68] = mem[idx + _21673 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22193 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22193 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24632 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24632] = 30
                            mem[_24632 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _25683 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25683 + 68] = mem[idx + _24632 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25683 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25683 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _29215 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29215] = 30
                            mem[_29215 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                            _30348 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30348 + 68] = mem[idx + _29215 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30348 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30348 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21672 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21672] = 30
                            mem[_21672 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _22192 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22192 + 68] = mem[idx + _21672 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22192 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22192 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24630 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24630] = 30
                            mem[_24630 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _25682 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25682 + 68] = mem[idx + _24630 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25682 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25682 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29213 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29213] = 30
                            mem[_29213 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _30347 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30347 + 68] = mem[idx + _29213 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30347 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30347 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23700 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23700] = 30
                        mem[_23700 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            _24629 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24629 + 68] = mem[idx + _23700 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24629 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24629 + -mem[64] + 100
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27975 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27975] = 30
                        mem[_27975 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            _29212 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29212 + 68] = mem[idx + _27975 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29212 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29212 + -mem[64] + 100
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32756 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32756] = 30
                        mem[_32756 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _33636 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33636 + 68] = mem[idx + _32756 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33636 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33636 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _20675 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20675] = 30
                            mem[_20675 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _20859 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20859 + 68] = mem[idx + _20675 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20859 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20859 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _22190 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22190] = 30
                            mem[_22190 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22885 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22885 + 68] = mem[idx + _22190 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22885 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22885 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25680 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25680] = 30
                            mem[_25680 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _26740 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26740 + 68] = mem[idx + _25680 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26740 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26740 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21671 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21671] = 30
                        mem[_21671 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _22189 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22189 + 68] = mem[idx + _21671 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22189 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22189 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _24627 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24627] = 30
                        mem[_24627 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _25679 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25679 + 68] = mem[idx + _24627 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25679 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25679 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _29210 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29210] = 30
                        mem[_29210 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                            if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _30345 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30345 + 68] = mem[idx + _29210 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30345 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30345 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21670 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21670] = 30
                            mem[_21670 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _22188 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22188 + 68] = mem[idx + _21670 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22188 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22188 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24625 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24625] = 30
                            mem[_24625 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _25678 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25678 + 68] = mem[idx + _24625 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25678 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25678 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _29208 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29208] = 30
                            mem[_29208 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _30344 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30344 + 68] = mem[idx + _29208 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30344 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30344 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23699 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23699] = 30
                        mem[_23699 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24624 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24624 + 68] = mem[idx + _23699 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24624 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24624 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27973 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27973] = 30
                        mem[_27973 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _29207 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29207 + 68] = mem[idx + _27973 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29207 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29207 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _32753 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32753] = 30
                        mem[_32753 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _33633 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33633 + 68] = mem[idx + _32753 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33633 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33633 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _23698 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23698] = 30
                        mem[_23698 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24623 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24623 + 68] = mem[idx + _23698 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24623 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24623 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27971 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27971] = 30
                        mem[_27971 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _29206 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29206 + 68] = mem[idx + _27971 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29206 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29206 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32751 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32751] = 30
                        mem[_32751 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _33632 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33632 + 68] = mem[idx + _32751 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33632 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33632 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26739 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26739] = 30
                    mem[_26739 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _27970 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27970 + 68] = mem[idx + _26739 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27970 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27970 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _31574 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31574] = 30
                    mem[_31574 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        _32750 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32750 + 68] = mem[idx + _31574 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32750 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32750 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _35442 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35442] = 30
                    mem[_35442 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _35936 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35936 + 68] = mem[idx + _35442 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35936 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35936 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor15 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                return 0
                            if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * t / s)
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * t / s < 0:
                                    revert with 0, 17
                                return (-1 * 0 / stor13 / 100 * t / s)
                            if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                        if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            return (arg1 * t / s)
                        if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((arg1 * t / s) - (0 / stor13 / 100 * t / s))
                        if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            return 0
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply)
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
            if arg1 and _BURN_FEE > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * _BURN_FEE / arg1 != _BURN_FEE:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not stor13:
                revert with 0, 'SafeMath: division by zero', 0
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor13:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0 / stor13 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor13 / 100 > arg1 - (0 / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor13 / 100) < arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1 - (0 / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100) < 0 / stor13 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor15
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _19232 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19232] = 26
                        mem[_19232 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19306 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19306 + 68] = mem[idx + _19232 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19306 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19306 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor13 / 100:
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    if not 0 / stor13 / 100:
                                        return 0
                                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20413 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20413] = 30
                                    mem[_20413 + 32] = 'SafeMath: subtraction overflow'
                                    _21646 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21646] = 30
                                    mem[_21646 + 32] = 'SafeMath: subtraction overflow'
                                    _24587 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24587] = 30
                                    mem[_24587 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply <= 0:
                                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                            revert with 0, 17
                                        return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                    _25652 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25652 + 68] = mem[idx + _24587 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25652 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25652 + -mem[64] + 100
                                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    _20412 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20412] = 30
                                    mem[_20412 + 32] = 'SafeMath: subtraction overflow'
                                    _21645 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21645] = 30
                                    mem[_21645 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                        _22166 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22166 + 68] = mem[idx + _21645 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22166 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22166 + -mem[64] + 100
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _24585 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24585] = 30
                                    mem[_24585 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        return (-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply)
                                    _25651 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25651 + 68] = mem[idx + _24585 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25651 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25651 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21165 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21165] = 30
                                mem[_21165 + 32] = 'SafeMath: subtraction overflow'
                                _23664 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23664] = 30
                                mem[_23664 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _24584 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24584 + 68] = mem[idx + _23664 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24584 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24584 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27926 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27926] = 30
                                mem[_27926 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _29171 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29171 + 68] = mem[idx + _27926 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29171 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29171 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    _20411 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20411] = 30
                                    mem[_20411 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                        _20664 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20664 + 68] = mem[idx + _20411 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20664 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20664 + -mem[64] + 100
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _21643 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21643] = 30
                                    mem[_21643 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        _22165 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22165 + 68] = mem[idx + _21643 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22165 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22165 + -mem[64] + 100
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24582 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24582] = 30
                                    mem[_24582 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                    _25650 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25650 + 68] = mem[idx + _24582 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25650 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25650 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21164 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21164] = 30
                                mem[_21164 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21642 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21642 + 68] = mem[idx + _21164 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21642 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21642 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23662 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23662] = 30
                                mem[_23662 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _24581 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24581 + 68] = mem[idx + _23662 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24581 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24581 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _27924 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27924] = 30
                                mem[_27924 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _29169 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29169 + 68] = mem[idx + _27924 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29169 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29169 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21163 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21163] = 30
                                mem[_21163 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21641 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21641 + 68] = mem[idx + _21163 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21641 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21641 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23660 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23660] = 30
                                mem[_23660 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _24580 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24580 + 68] = mem[idx + _23660 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24580 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24580 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27922 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27922] = 30
                                mem[_27922 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                                _29168 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29168 + 68] = mem[idx + _27922 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29168 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29168 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22863 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22863] = 30
                            mem[_22863 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _23659 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23659 + 68] = mem[idx + _22863 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23659 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23659 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26703 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26703] = 30
                            mem[_26703 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _27921 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27921 + 68] = mem[idx + _26703 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27921 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27921 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31533 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31533] = 30
                            mem[_31533 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _32712 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32712 + 68] = mem[idx + _31533 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32712 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32712 + -mem[64] + 100
                        if arg1 and stor15 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    _20409 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20409] = 30
                                    mem[_20409 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor15 / totalSupply:
                                        _20663 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20663 + 68] = mem[idx + _20409 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20663 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20663 + -mem[64] + 100
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _21639 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21639] = 30
                                    mem[_21639 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor15 / totalSupply:
                                        _22163 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22163 + 68] = mem[idx + _21639 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22163 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22163 + -mem[64] + 100
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24578 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24578] = 30
                                    mem[_24578 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor15 / totalSupply:
                                        if arg1 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor15 / totalSupply)
                                    _25649 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25649 + 68] = mem[idx + _24578 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25649 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25649 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21162 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21162] = 30
                                mem[_21162 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21638 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21638 + 68] = mem[idx + _21162 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21638 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21638 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23657 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23657] = 30
                                mem[_23657 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _24577 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24577 + 68] = mem[idx + _23657 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24577 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24577 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _27919 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27919] = 30
                                mem[_27919 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _29166 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29166 + 68] = mem[idx + _27919 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29166 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29166 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21161 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21161] = 30
                                mem[_21161 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21637 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21637 + 68] = mem[idx + _21161 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21637 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21637 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23655 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23655] = 30
                                mem[_23655 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _24576 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24576 + 68] = mem[idx + _23655 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24576 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24576 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27917 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27917] = 30
                                mem[_27917 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                                _29165 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29165 + 68] = mem[idx + _27917 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29165 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29165 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22862 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22862] = 30
                            mem[_22862 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _23654 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23654 + 68] = mem[idx + _22862 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23654 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23654 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _26701 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26701] = 30
                            mem[_26701 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _27916 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27916 + 68] = mem[idx + _26701 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27916 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27916 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31530 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31530] = 30
                            mem[_31530 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _32709 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32709 + 68] = mem[idx + _31530 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32709 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32709 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _21160 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21160] = 30
                                mem[_21160 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _21636 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21636 + 68] = mem[idx + _21160 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21636 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21636 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23652 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23652] = 30
                                mem[_23652 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    _24575 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24575 + 68] = mem[idx + _23652 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24575 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24575 + -mem[64] + 100
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                _27914 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27914] = 30
                                mem[_27914 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _29164 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29164 + 68] = mem[idx + _27914 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29164 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29164 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22861 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22861] = 30
                            mem[_22861 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23651 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23651 + 68] = mem[idx + _22861 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23651 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23651 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26699 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26699] = 30
                            mem[_26699 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _27913 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27913 + 68] = mem[idx + _26699 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27913 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27913 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _31528 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31528] = 30
                            mem[_31528 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _32707 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32707 + 68] = mem[idx + _31528 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32707 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32707 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _22860 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22860] = 30
                            mem[_22860 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23650 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23650 + 68] = mem[idx + _22860 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23650 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23650 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26697 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26697] = 30
                            mem[_26697 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _27912 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27912 + 68] = mem[idx + _26697 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27912 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27912 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31526 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31526] = 30
                            mem[_31526 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                            _32706 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32706 + 68] = mem[idx + _31526 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32706 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32706 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25648 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25648] = 30
                        mem[_25648 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _26696 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26696 + 68] = mem[idx + _25648 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26696 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26696 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _30316 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30316] = 30
                        mem[_30316 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _31525 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31525 + 68] = mem[idx + _30316 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31525 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31525 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _34543 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34543] = 30
                        mem[_34543 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _35411 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35411 + 68] = mem[idx + _34543 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35411 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35411 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _19307 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19307] = 30
                        mem[_19307 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _19387 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19387 + 68] = mem[idx + _19307 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19387 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19387 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _19740 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19740] = 30
                        mem[_19740 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _19788 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19788 + 68] = mem[idx + _19740 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19788 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19788 + -mem[64] + 100
                    _19308 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19308] = 26
                    mem[_19308 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19388 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19388 + 68] = mem[idx + _19308 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19388 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19388 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    return 0
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20671 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20671] = 30
                                mem[_20671 + 32] = 'SafeMath: subtraction overflow'
                                _22178 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22178] = 30
                                mem[_22178 + 32] = 'SafeMath: subtraction overflow'
                                _25666 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25666] = 30
                                mem[_25666 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= 0:
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                _26709 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26709 + 68] = mem[idx + _25666 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26709 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26709 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _20670 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20670] = 30
                                mem[_20670 + 32] = 'SafeMath: subtraction overflow'
                                _22177 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22177] = 30
                                mem[_22177 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _22869 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22869 + 68] = mem[idx + _22177 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22869 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22869 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _25664 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25664] = 30
                                mem[_25664 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply)
                                _26708 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26708 + 68] = mem[idx + _25664 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26708 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26708 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21653 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21653] = 30
                            mem[_21653 + 32] = 'SafeMath: subtraction overflow'
                            _24602 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24602] = 30
                            mem[_24602 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _25663 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25663 + 68] = mem[idx + _24602 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25663 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25663 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29188 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29188] = 30
                            mem[_29188 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _30325 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30325 + 68] = mem[idx + _29188 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30325 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30325 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _20669 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20669] = 30
                                mem[_20669 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20853 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20853 + 68] = mem[idx + _20669 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20853 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20853 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _22175 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22175] = 30
                                mem[_22175 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _22868 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22868 + 68] = mem[idx + _22175 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22868 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22868 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25661 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25661] = 30
                                mem[_25661 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                _26707 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26707 + 68] = mem[idx + _25661 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26707 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26707 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21652 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21652] = 30
                            mem[_21652 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _22174 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22174 + 68] = mem[idx + _21652 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22174 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22174 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24600 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24600] = 30
                            mem[_24600 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _25660 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25660 + 68] = mem[idx + _24600 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25660 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25660 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _29186 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29186] = 30
                            mem[_29186 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _30323 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30323 + 68] = mem[idx + _29186 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30323 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30323 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21651 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21651] = 30
                            mem[_21651 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _22173 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22173 + 68] = mem[idx + _21651 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22173 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22173 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24598 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24598] = 30
                            mem[_24598 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _25659 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25659 + 68] = mem[idx + _24598 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25659 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25659 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29184 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29184] = 30
                            mem[_29184 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                            _30322 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30322 + 68] = mem[idx + _29184 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30322 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30322 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23668 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23668] = 30
                        mem[_23668 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            _24597 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24597 + 68] = mem[idx + _23668 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24597 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24597 + -mem[64] + 100
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27936 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27936] = 30
                        mem[_27936 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            _29183 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29183 + 68] = mem[idx + _27936 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29183 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29183 + -mem[64] + 100
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32724 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32724] = 30
                        mem[_32724 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _33624 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33624 + 68] = mem[idx + _32724 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33624 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33624 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _20667 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20667] = 30
                                mem[_20667 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20852 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20852 + 68] = mem[idx + _20667 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20852 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20852 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _22171 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22171] = 30
                                mem[_22171 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _22866 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22866 + 68] = mem[idx + _22171 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22866 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22866 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25657 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25657] = 30
                                mem[_25657 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _26706 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26706 + 68] = mem[idx + _25657 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26706 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26706 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21650 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21650] = 30
                            mem[_21650 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22170 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22170 + 68] = mem[idx + _21650 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22170 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22170 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24595 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24595] = 30
                            mem[_24595 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _25656 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25656 + 68] = mem[idx + _24595 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25656 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25656 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _29181 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29181] = 30
                            mem[_29181 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _30320 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30320 + 68] = mem[idx + _29181 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30320 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30320 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21649 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21649] = 30
                            mem[_21649 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22169 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22169 + 68] = mem[idx + _21649 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22169 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22169 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24593 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24593] = 30
                            mem[_24593 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _25655 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25655 + 68] = mem[idx + _24593 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25655 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25655 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29179 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29179] = 30
                            mem[_29179 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                            _30319 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30319 + 68] = mem[idx + _29179 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30319 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30319 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23667 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23667] = 30
                        mem[_23667 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _24592 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24592 + 68] = mem[idx + _23667 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24592 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24592 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _27934 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27934] = 30
                        mem[_27934 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _29178 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29178 + 68] = mem[idx + _27934 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29178 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29178 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32721 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32721] = 30
                        mem[_32721 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _33621 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33621 + 68] = mem[idx + _32721 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33621 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33621 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            _21648 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21648] = 30
                            mem[_21648 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _22168 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22168 + 68] = mem[idx + _21648 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22168 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22168 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24590 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24590] = 30
                            mem[_24590 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _25654 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25654 + 68] = mem[idx + _24590 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25654 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25654 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _29176 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29176] = 30
                            mem[_29176 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _30318 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30318 + 68] = mem[idx + _29176 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30318 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30318 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23666 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23666] = 30
                        mem[_23666 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24589 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24589 + 68] = mem[idx + _23666 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24589 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24589 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27932 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27932] = 30
                        mem[_27932 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _29175 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29175 + 68] = mem[idx + _27932 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29175 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29175 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _32719 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32719] = 30
                        mem[_32719 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _33619 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33619 + 68] = mem[idx + _32719 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33619 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33619 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _23665 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23665] = 30
                        mem[_23665 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24588 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24588 + 68] = mem[idx + _23665 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24588 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24588 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27930 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27930] = 30
                        mem[_27930 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _29174 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29174 + 68] = mem[idx + _27930 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29174 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29174 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32717 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32717] = 30
                        mem[_32717 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                        _33618 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33618 + 68] = mem[idx + _32717 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33618 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33618 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26705 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26705] = 30
                    mem[_26705 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _27929 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27929 + 68] = mem[idx + _26705 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27929 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27929 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _31538 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31538] = 30
                    mem[_31538 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        _32716 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32716 + 68] = mem[idx + _31538 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32716 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32716 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _35416 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35416] = 30
                    mem[_35416 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    _35931 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35931 + 68] = mem[idx + _35416 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35931 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35931 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor15 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not 0 / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    return 0
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                return (-1 * 0 / stor13 / 100 * t / s)
                            if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _BURN_FEE / stor13 / 100 * t / s)
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor13 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * t / s < 0:
                                    revert with 0, 17
                                return (-1 * 0 / stor13 / 100 * t / s)
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            if 0 / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                        if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s))
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                return (arg1 * t / s)
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            return ((arg1 * t / s) - (0 / stor13 / 100 * t / s))
                        if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s))
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((arg1 * t / s) - (0 / stor13 / 100 * t / s))
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                    if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if 0 / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s))
                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not 0 / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                return 0
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply)
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not 0 / stor13 / 100:
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
            if arg1 and _CHARITY_FEE > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / arg1 != _CHARITY_FEE:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[352] = 26
            mem[384] = 'SafeMath: division by zero'
            if not stor13:
                revert with 0, 'SafeMath: division by zero', 0
            mem[416] = 26
            mem[448] = 'SafeMath: division by zero'
            mem[480] = 30
            mem[512] = 'SafeMath: subtraction overflow'
            if 0 / stor13 / 100 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < 0 / stor13 / 100:
                revert with 0, 17
            mem[544] = 30
            mem[576] = 'SafeMath: subtraction overflow'
            if arg1 * _BURN_FEE / stor13 / 100 > arg1 - (0 / stor13 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (0 / stor13 / 100) < arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 17
            mem[64] = 672
            mem[608] = 30
            mem[640] = 'SafeMath: subtraction overflow'
            if arg1 * _CHARITY_FEE / stor13 / 100 > arg1 - (0 / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (0 / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100) < arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 17
            idx = 0
            s = totalSupply
            t = stor15
            while idx < stor6.length:
                mem[0] = stor6[idx]
                mem[32] = 1
                if stor1[stor6[idx]] > t:
                    _19231 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19231] = 26
                    mem[_19231 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19303 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19303 + 68] = mem[idx + _19231 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19303 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19303 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    return 0
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20400 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20400] = 30
                                mem[_20400 + 32] = 'SafeMath: subtraction overflow'
                                _21622 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21622] = 30
                                mem[_21622 + 32] = 'SafeMath: subtraction overflow'
                                _24544 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24544] = 30
                                mem[_24544 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                    if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply)
                                _25625 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25625 + 68] = mem[idx + _24544 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25625 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25625 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20399 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20399] = 30
                                mem[_20399 + 32] = 'SafeMath: subtraction overflow'
                                _21621 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21621] = 30
                                mem[_21621 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _22142 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22142 + 68] = mem[idx + _21621 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22142 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22142 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _24542 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24542] = 30
                                mem[_24542 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply)
                                _25624 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25624 + 68] = mem[idx + _24542 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25624 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25624 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21143 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21143] = 30
                            mem[_21143 + 32] = 'SafeMath: subtraction overflow'
                            _23623 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23623] = 30
                            mem[_23623 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _24541 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24541 + 68] = mem[idx + _23623 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24541 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24541 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27872 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27872] = 30
                            mem[_27872 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                            _29134 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29134 + 68] = mem[idx + _27872 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29134 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29134 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20398 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20398] = 30
                                mem[_20398 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20655 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20655 + 68] = mem[idx + _20398 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20655 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20655 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _21619 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21619] = 30
                                mem[_21619 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _22141 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22141 + 68] = mem[idx + _21619 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22141 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22141 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24539 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24539] = 30
                                mem[_24539 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                _25623 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25623 + 68] = mem[idx + _24539 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25623 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25623 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21142 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21142] = 30
                            mem[_21142 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _21618 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21618 + 68] = mem[idx + _21142 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21618 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21618 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _23621 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23621] = 30
                            mem[_23621 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _24538 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24538 + 68] = mem[idx + _23621 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24538 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24538 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _27870 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27870] = 30
                            mem[_27870 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                            _29132 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29132 + 68] = mem[idx + _27870 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29132 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29132 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21141 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21141] = 30
                            mem[_21141 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _21617 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21617 + 68] = mem[idx + _21141 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21617 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21617 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _23619 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23619] = 30
                            mem[_23619 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _24537 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24537 + 68] = mem[idx + _23619 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24537 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24537 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27868 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27868] = 30
                            mem[_27868 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                            _29131 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29131 + 68] = mem[idx + _27868 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29131 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29131 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22838 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22838] = 30
                        mem[_22838 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            _23618 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23618 + 68] = mem[idx + _22838 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23618 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23618 + -mem[64] + 100
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _26659 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26659] = 30
                        mem[_26659 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            _27867 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27867 + 68] = mem[idx + _26659 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27867 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27867 + -mem[64] + 100
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _31484 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31484] = 30
                        mem[_31484 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _32669 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32669 + 68] = mem[idx + _31484 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32669 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32669 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20396 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20396] = 30
                                mem[_20396 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20654 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20654 + 68] = mem[idx + _20396 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20654 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20654 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _21615 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21615] = 30
                                mem[_21615 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _22139 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22139 + 68] = mem[idx + _21615 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22139 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22139 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24535 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24535] = 30
                                mem[_24535 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _25622 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25622 + 68] = mem[idx + _24535 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25622 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25622 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21140 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21140] = 30
                            mem[_21140 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _21614 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21614 + 68] = mem[idx + _21140 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21614 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21614 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _23616 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23616] = 30
                            mem[_23616 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _24534 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24534 + 68] = mem[idx + _23616 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24534 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24534 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _27865 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27865] = 30
                            mem[_27865 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                            _29129 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29129 + 68] = mem[idx + _27865 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29129 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29129 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21139 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21139] = 30
                            mem[_21139 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _21613 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21613 + 68] = mem[idx + _21139 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21613 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21613 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _23614 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23614] = 30
                            mem[_23614 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _24533 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24533 + 68] = mem[idx + _23614 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24533 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24533 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27863 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27863] = 30
                            mem[_27863 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                            _29128 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29128 + 68] = mem[idx + _27863 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29128 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29128 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22837 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22837] = 30
                        mem[_22837 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _23613 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23613 + 68] = mem[idx + _22837 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23613 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23613 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _26657 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26657] = 30
                        mem[_26657 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _27862 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27862 + 68] = mem[idx + _26657 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27862 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27862 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _31481 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31481] = 30
                        mem[_31481 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _32666 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32666 + 68] = mem[idx + _31481 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32666 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32666 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21138 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21138] = 30
                            mem[_21138 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _21612 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21612 + 68] = mem[idx + _21138 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21612 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21612 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _23611 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23611] = 30
                            mem[_23611 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _24532 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24532 + 68] = mem[idx + _23611 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24532 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24532 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _27860 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27860] = 30
                            mem[_27860 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _29127 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29127 + 68] = mem[idx + _27860 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29127 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29127 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22836 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22836] = 30
                        mem[_22836 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _23610 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23610 + 68] = mem[idx + _22836 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23610 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23610 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _26655 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26655] = 30
                        mem[_26655 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _27859 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27859 + 68] = mem[idx + _26655 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27859 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27859 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _31479 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31479] = 30
                        mem[_31479 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _32664 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32664 + 68] = mem[idx + _31479 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32664 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32664 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _22835 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22835] = 30
                        mem[_22835 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _23609 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23609 + 68] = mem[idx + _22835 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23609 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23609 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _26653 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26653] = 30
                        mem[_26653 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _27858 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27858 + 68] = mem[idx + _26653 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27858 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27858 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _31477 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31477] = 30
                        mem[_31477 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                        _32663 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32663 + 68] = mem[idx + _31477 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32663 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32663 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _25621 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25621] = 30
                    mem[_25621 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _26652 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26652 + 68] = mem[idx + _25621 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26652 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26652 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _30286 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30286] = 30
                    mem[_30286 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        _31476 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _31476 + 68] = mem[idx + _30286 + 32]
                            idx = idx + 32
                            continue 
                        mem[_31476 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _31476 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _34509 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_34509] = 30
                    mem[_34509 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _35378 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35378 + 68] = mem[idx + _34509 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35378 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35378 + -mem[64] + 100
                if idx >= stor6.length:
                    revert with 0, 50
                mem[0] = stor6[idx]
                mem[32] = 2
                if stor2[stor6[idx]] <= s:
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    _19304 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19304] = 30
                    mem[_19304 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[stor6[idx]] > t:
                        _19384 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19384 + 68] = mem[idx + _19304 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19384 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19384 + -mem[64] + 100
                    if t < stor1[stor6[idx]]:
                        revert with 0, 17
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    _19737 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19737] = 30
                    mem[_19737 + 32] = 'SafeMath: subtraction overflow'
                    if stor2[stor6[idx]] <= s:
                        if s < stor2[stor6[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor2[stor6[idx]]
                        t = t - stor1[stor6[idx]]
                        continue 
                    _19785 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _19785 + 68] = mem[idx + _19737 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19785 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _19785 + -mem[64] + 100
                _19305 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19305] = 26
                mem[_19305 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _19385 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _19385 + 68] = mem[idx + _19305 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19385 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _19385 + -mem[64] + 100
                if not arg1:
                    if not 0 / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                return 0
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20662 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20662] = 30
                            mem[_20662 + 32] = 'SafeMath: subtraction overflow'
                            _22154 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22154] = 30
                            mem[_22154 + 32] = 'SafeMath: subtraction overflow'
                            _25639 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25639] = 30
                            mem[_25639 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply)
                            _26665 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26665 + 68] = mem[idx + _25639 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26665 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26665 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _20661 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20661] = 30
                            mem[_20661 + 32] = 'SafeMath: subtraction overflow'
                            _22153 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22153] = 30
                            mem[_22153 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _22844 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22844 + 68] = mem[idx + _22153 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22844 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22844 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _25637 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25637] = 30
                            mem[_25637 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply)
                            _26664 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26664 + 68] = mem[idx + _25637 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26664 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26664 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21629 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21629] = 30
                        mem[_21629 + 32] = 'SafeMath: subtraction overflow'
                        _24559 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24559] = 30
                        mem[_24559 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _25636 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25636 + 68] = mem[idx + _24559 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25636 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25636 + -mem[64] + 100
                        if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _29151 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29151] = 30
                        mem[_29151 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _30295 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30295 + 68] = mem[idx + _29151 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30295 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30295 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _20660 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20660] = 30
                            mem[_20660 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _20845 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20845 + 68] = mem[idx + _20660 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20845 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20845 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _22151 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22151] = 30
                            mem[_22151 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _22843 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22843 + 68] = mem[idx + _22151 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22843 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22843 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25634 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25634] = 30
                            mem[_25634 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                            _26663 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26663 + 68] = mem[idx + _25634 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26663 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26663 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21628 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21628] = 30
                        mem[_21628 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            _22150 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22150 + 68] = mem[idx + _21628 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22150 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22150 + -mem[64] + 100
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _24557 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24557] = 30
                        mem[_24557 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            _25633 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25633 + 68] = mem[idx + _24557 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25633 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25633 + -mem[64] + 100
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _29149 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29149] = 30
                        mem[_29149 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _30293 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30293 + 68] = mem[idx + _29149 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30293 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30293 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _21627 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21627] = 30
                        mem[_21627 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            _22149 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22149 + 68] = mem[idx + _21627 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22149 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22149 + -mem[64] + 100
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _24555 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24555] = 30
                        mem[_24555 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            _25632 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25632 + 68] = mem[idx + _24555 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25632 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25632 + -mem[64] + 100
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _29147 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29147] = 30
                        mem[_29147 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                        _30292 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30292 + 68] = mem[idx + _29147 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30292 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30292 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23627 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23627] = 30
                    mem[_23627 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                        _24554 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24554 + 68] = mem[idx + _23627 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24554 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24554 + -mem[64] + 100
                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _27882 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27882] = 30
                    mem[_27882 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                        _29146 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29146 + 68] = mem[idx + _27882 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29146 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29146 + -mem[64] + 100
                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _32681 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32681] = 30
                    mem[_32681 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _33610 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33610 + 68] = mem[idx + _32681 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33610 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33610 + -mem[64] + 100
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _20658 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20658] = 30
                            mem[_20658 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _20844 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20844 + 68] = mem[idx + _20658 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20844 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20844 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _22147 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22147] = 30
                            mem[_22147 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22841 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22841 + 68] = mem[idx + _22147 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22841 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22841 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25630 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25630] = 30
                            mem[_25630 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _26662 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26662 + 68] = mem[idx + _25630 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26662 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26662 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21626 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21626] = 30
                        mem[_21626 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _22146 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22146 + 68] = mem[idx + _21626 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22146 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22146 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _24552 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24552] = 30
                        mem[_24552 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _25629 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25629 + 68] = mem[idx + _24552 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25629 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25629 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _29144 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29144] = 30
                        mem[_29144 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                            if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _30290 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30290 + 68] = mem[idx + _29144 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30290 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30290 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _21625 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21625] = 30
                        mem[_21625 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _22145 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22145 + 68] = mem[idx + _21625 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22145 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22145 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _24550 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24550] = 30
                        mem[_24550 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _25628 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25628 + 68] = mem[idx + _24550 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25628 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25628 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _29142 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29142] = 30
                        mem[_29142 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                        _30289 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30289 + 68] = mem[idx + _29142 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30289 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30289 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23626 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23626] = 30
                    mem[_23626 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        _24549 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24549 + 68] = mem[idx + _23626 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24549 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24549 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    _27880 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27880] = 30
                    mem[_27880 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _29141 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29141 + 68] = mem[idx + _27880 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29141 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29141 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _32678 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32678] = 30
                    mem[_32678 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _33607 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33607 + 68] = mem[idx + _32678 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33607 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33607 + -mem[64] + 100
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _21624 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21624] = 30
                        mem[_21624 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _22144 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22144 + 68] = mem[idx + _21624 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22144 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22144 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _24547 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24547] = 30
                        mem[_24547 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _25627 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25627 + 68] = mem[idx + _24547 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25627 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25627 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _29139 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29139] = 30
                        mem[_29139 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _30288 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30288 + 68] = mem[idx + _29139 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30288 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30288 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23625 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23625] = 30
                    mem[_23625 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _24546 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24546 + 68] = mem[idx + _23625 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24546 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24546 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _27878 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27878] = 30
                    mem[_27878 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        _29138 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29138 + 68] = mem[idx + _27878 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29138 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29138 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    _32676 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32676] = 30
                    mem[_32676 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _33605 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33605 + 68] = mem[idx + _32676 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33605 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33605 + -mem[64] + 100
                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    _23624 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23624] = 30
                    mem[_23624 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _24545 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24545 + 68] = mem[idx + _23624 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24545 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24545 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _27876 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27876] = 30
                    mem[_27876 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        _29137 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29137 + 68] = mem[idx + _27876 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29137 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29137 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _32674 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32674] = 30
                    mem[_32674 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                    _33604 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33604 + 68] = mem[idx + _32674 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33604 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33604 + -mem[64] + 100
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _26661 = mem[64]
                mem[64] = mem[64] + 64
                mem[_26661] = 30
                mem[_26661 + 32] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    _27875 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _27875 + 68] = mem[idx + _26661 + 32]
                        idx = idx + 32
                        continue 
                    mem[_27875 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _27875 + -mem[64] + 100
                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _31489 = mem[64]
                mem[64] = mem[64] + 64
                mem[_31489] = 30
                mem[_31489 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                    _32673 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32673 + 68] = mem[idx + _31489 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32673 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32673 + -mem[64] + 100
                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _35383 = mem[64]
                mem[64] = mem[64] + 64
                mem[_35383] = 30
                mem[_35383 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                _35926 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _35926 + 68] = mem[idx + _35383 + 32]
                    idx = idx + 32
                    continue 
                mem[_35926 + 98] = 0
                revert with memory
                  from mem[64]
                   len _35926 + -mem[64] + 100
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor15 / totalSupply:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not 0 / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                return 0
                            if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * t / s)
                        if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _BURN_FEE / stor13 / 100 * t / s)
                        if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * 0 / stor13 / 100 * t / s)
                        if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * 0 / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * 0 / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                    if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s))
                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor13 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            return (arg1 * t / s)
                        if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                    if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s))
                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor13 / 100 * t / s))
                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if 0 / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s))
                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not 0 / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            return 0
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply)
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply)
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
            if arg1 and stor15 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 0 / stor13 / 100:
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                revert with 0, 17
            if not 0 / stor13 / 100:
                revert with 0, 18
            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _BURN_FEE / stor13 / 100:
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
        if arg1 and _TAX_FEE > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * _TAX_FEE / arg1 != _TAX_FEE:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not stor13:
            revert with 0, 'SafeMath: division by zero', 0
        mem[160] = 26
        mem[192] = 'SafeMath: division by zero'
        if not arg1:
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not stor13:
                revert with 0, 'SafeMath: division by zero', 0
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor13:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor13 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor13 / 100) < 0 / stor13 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (0 / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (0 / stor13 / 100) < 0 / stor13 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor15
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _19230 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19230] = 26
                        mem[_19230 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19300 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19300 + 68] = mem[idx + _19230 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19300 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19300 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    return 0
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    _20388 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20388] = 30
                                    mem[_20388 + 32] = 'SafeMath: subtraction overflow'
                                    _21600 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21600] = 30
                                    mem[_21600 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                        _22121 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22121 + 68] = mem[idx + _21600 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22121 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22121 + -mem[64] + 100
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _24505 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24505] = 30
                                    mem[_24505 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                    _25601 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25601 + 68] = mem[idx + _24505 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25601 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25601 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21123 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21123] = 30
                                mem[_21123 + 32] = 'SafeMath: subtraction overflow'
                                _23583 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23583] = 30
                                mem[_23583 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _24504 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24504 + 68] = mem[idx + _23583 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24504 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24504 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27820 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27820] = 30
                                mem[_27820 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _29103 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29103 + 68] = mem[idx + _27820 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29103 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29103 + -mem[64] + 100
                            if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _20387 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20387] = 30
                                mem[_20387 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20647 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20647 + 68] = mem[idx + _20387 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20647 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20647 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _21598 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21598] = 30
                                mem[_21598 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _22120 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22120 + 68] = mem[idx + _21598 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22120 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22120 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24502 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24502] = 30
                                mem[_24502 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply)
                                _25600 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25600 + 68] = mem[idx + _24502 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25600 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25600 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21122 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21122] = 30
                                mem[_21122 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21597 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21597 + 68] = mem[idx + _21122 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21597 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21597 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23581 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23581] = 30
                                mem[_23581 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _24501 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24501 + 68] = mem[idx + _23581 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24501 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24501 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27818 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27818] = 30
                                mem[_27818 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _29101 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29101 + 68] = mem[idx + _27818 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29101 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29101 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22814 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22814] = 30
                            mem[_22814 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _23580 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23580 + 68] = mem[idx + _22814 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23580 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23580 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26616 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26616] = 30
                            mem[_26616 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _27817 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27817 + 68] = mem[idx + _26616 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27817 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27817 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31436 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31436] = 30
                            mem[_31436 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _32630 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32630 + 68] = mem[idx + _31436 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32630 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32630 + -mem[64] + 100
                        if arg1 and stor15 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _20385 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20385] = 30
                                mem[_20385 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20646 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20646 + 68] = mem[idx + _20385 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20646 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20646 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _21595 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21595] = 30
                                mem[_21595 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _22118 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22118 + 68] = mem[idx + _21595 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22118 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22118 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24499 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24499] = 30
                                mem[_24499 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _25599 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25599 + 68] = mem[idx + _24499 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25599 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25599 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21121 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21121] = 30
                                mem[_21121 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21594 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21594 + 68] = mem[idx + _21121 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21594 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21594 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23578 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23578] = 30
                                mem[_23578 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _24498 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24498 + 68] = mem[idx + _23578 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24498 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24498 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27815 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27815] = 30
                                mem[_27815 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _29099 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29099 + 68] = mem[idx + _27815 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29099 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29099 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22813 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22813] = 30
                            mem[_22813 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _23577 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23577 + 68] = mem[idx + _22813 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23577 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23577 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _26614 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26614] = 30
                            mem[_26614 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _27814 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27814 + 68] = mem[idx + _26614 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27814 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27814 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31433 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31433] = 30
                            mem[_31433 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _32628 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32628 + 68] = mem[idx + _31433 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32628 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32628 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21120 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21120] = 30
                            mem[_21120 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _21593 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21593 + 68] = mem[idx + _21120 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21593 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21593 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _23575 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23575] = 30
                            mem[_23575 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _24497 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24497 + 68] = mem[idx + _23575 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24497 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24497 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _27812 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27812] = 30
                            mem[_27812 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply))
                            _29098 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29098 + 68] = mem[idx + _27812 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29098 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29098 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _22812 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22812] = 30
                            mem[_22812 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23574 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23574 + 68] = mem[idx + _22812 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23574 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23574 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26612 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26612] = 30
                            mem[_26612 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _27811 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27811 + 68] = mem[idx + _26612 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27811 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27811 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31431 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31431] = 30
                            mem[_31431 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _32626 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32626 + 68] = mem[idx + _31431 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32626 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32626 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25598 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25598] = 30
                        mem[_25598 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _26611 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26611 + 68] = mem[idx + _25598 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26611 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26611 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _30259 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30259] = 30
                        mem[_30259 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _31430 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31430 + 68] = mem[idx + _30259 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31430 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31430 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _34477 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34477] = 30
                        mem[_34477 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _35348 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35348 + 68] = mem[idx + _34477 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35348 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35348 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _19301 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19301] = 30
                        mem[_19301 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _19381 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19381 + 68] = mem[idx + _19301 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19381 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19381 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _19734 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19734] = 30
                        mem[_19734 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _19782 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19782 + 68] = mem[idx + _19734 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19782 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19782 + -mem[64] + 100
                    _19302 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19302] = 26
                    mem[_19302 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19382 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19382 + 68] = mem[idx + _19302 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19382 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19382 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                return 0
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _20653 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20653] = 30
                                mem[_20653 + 32] = 'SafeMath: subtraction overflow'
                                _22130 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22130] = 30
                                mem[_22130 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _22819 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22819 + 68] = mem[idx + _22130 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22819 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22819 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _25611 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25611] = 30
                                mem[_25611 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                _26621 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26621 + 68] = mem[idx + _25611 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26621 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26621 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21605 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21605] = 30
                            mem[_21605 + 32] = 'SafeMath: subtraction overflow'
                            _24516 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24516] = 30
                            mem[_24516 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _25610 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25610 + 68] = mem[idx + _24516 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25610 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25610 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29114 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29114] = 30
                            mem[_29114 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _30266 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30266 + 68] = mem[idx + _29114 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30266 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30266 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _20652 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20652] = 30
                            mem[_20652 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _20837 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20837 + 68] = mem[idx + _20652 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20837 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20837 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _22128 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22128] = 30
                            mem[_22128 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _22818 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22818 + 68] = mem[idx + _22128 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22818 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22818 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25608 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25608] = 30
                            mem[_25608 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply)
                            _26620 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26620 + 68] = mem[idx + _25608 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26620 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26620 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21604 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21604] = 30
                            mem[_21604 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _22127 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22127 + 68] = mem[idx + _21604 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22127 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22127 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24514 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24514] = 30
                            mem[_24514 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _25607 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25607 + 68] = mem[idx + _24514 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25607 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25607 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29112 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29112] = 30
                            mem[_29112 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _30264 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30264 + 68] = mem[idx + _29112 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30264 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30264 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23586 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23586] = 30
                        mem[_23586 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _24513 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24513 + 68] = mem[idx + _23586 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24513 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24513 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27828 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27828] = 30
                        mem[_27828 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _29111 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29111 + 68] = mem[idx + _27828 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29111 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29111 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32639 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32639] = 30
                        mem[_32639 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _33597 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33597 + 68] = mem[idx + _32639 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33597 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33597 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            _20650 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20650] = 30
                            mem[_20650 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _20836 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20836 + 68] = mem[idx + _20650 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20836 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20836 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _22125 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22125] = 30
                            mem[_22125 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22816 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22816 + 68] = mem[idx + _22125 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22816 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22816 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25605 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25605] = 30
                            mem[_25605 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _26619 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26619 + 68] = mem[idx + _25605 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26619 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26619 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21603 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21603] = 30
                            mem[_21603 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22124 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22124 + 68] = mem[idx + _21603 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22124 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22124 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24511 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24511] = 30
                            mem[_24511 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _25604 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25604 + 68] = mem[idx + _24511 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25604 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25604 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29109 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29109] = 30
                            mem[_29109 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _30262 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30262 + 68] = mem[idx + _29109 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30262 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30262 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23585 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23585] = 30
                        mem[_23585 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _24510 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24510 + 68] = mem[idx + _23585 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24510 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24510 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _27826 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27826] = 30
                        mem[_27826 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _29108 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29108 + 68] = mem[idx + _27826 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29108 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29108 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32636 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32636] = 30
                        mem[_32636 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _33595 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33595 + 68] = mem[idx + _32636 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33595 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33595 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _21602 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21602] = 30
                        mem[_21602 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _22123 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22123 + 68] = mem[idx + _21602 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22123 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22123 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _24508 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24508] = 30
                        mem[_24508 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _25603 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25603 + 68] = mem[idx + _24508 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25603 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25603 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _29106 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29106] = 30
                        mem[_29106 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply))
                        _30261 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30261 + 68] = mem[idx + _29106 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30261 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30261 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _23584 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23584] = 30
                        mem[_23584 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24507 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24507 + 68] = mem[idx + _23584 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24507 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24507 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27824 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27824] = 30
                        mem[_27824 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _29105 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29105 + 68] = mem[idx + _27824 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29105 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29105 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32634 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32634] = 30
                        mem[_32634 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _33593 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33593 + 68] = mem[idx + _32634 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33593 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33593 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26618 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26618] = 30
                    mem[_26618 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _27823 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27823 + 68] = mem[idx + _26618 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27823 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27823 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _31440 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31440] = 30
                    mem[_31440 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _32633 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32633 + 68] = mem[idx + _31440 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32633 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32633 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _35352 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35352] = 30
                    mem[_35352 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    _35922 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35922 + 68] = mem[idx + _35352 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35922 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35922 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor15 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                return 0
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * t / s < 0:
                                    revert with 0, 17
                                return (-1 * 0 / stor13 / 100 * t / s)
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                        if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s)
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            return (arg1 * t / s)
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((arg1 * t / s) - (0 / stor13 / 100 * t / s))
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                    if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s))
                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            return 0
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply)
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not 0 / stor13 / 100:
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply))
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
            if arg1 and _CHARITY_FEE > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / arg1 != _CHARITY_FEE:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[352] = 26
            mem[384] = 'SafeMath: division by zero'
            if not stor13:
                revert with 0, 'SafeMath: division by zero', 0
            mem[416] = 26
            mem[448] = 'SafeMath: division by zero'
            mem[480] = 30
            mem[512] = 'SafeMath: subtraction overflow'
            if arg1 * _TAX_FEE / stor13 / 100 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * _TAX_FEE / stor13 / 100:
                revert with 0, 17
            mem[544] = 30
            mem[576] = 'SafeMath: subtraction overflow'
            if 0 / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _TAX_FEE / stor13 / 100) < 0 / stor13 / 100:
                revert with 0, 17
            mem[64] = 672
            mem[608] = 30
            mem[640] = 'SafeMath: subtraction overflow'
            if arg1 * _CHARITY_FEE / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (0 / stor13 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (0 / stor13 / 100) < arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 17
            idx = 0
            s = totalSupply
            t = stor15
            while idx < stor6.length:
                mem[0] = stor6[idx]
                mem[32] = 1
                if stor1[stor6[idx]] > t:
                    _19229 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19229] = 26
                    mem[_19229 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19297 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19297 + 68] = mem[idx + _19229 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19297 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19297 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    return 0
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20376 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20376] = 30
                                mem[_20376 + 32] = 'SafeMath: subtraction overflow'
                                _21579 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21579] = 30
                                mem[_21579 + 32] = 'SafeMath: subtraction overflow'
                                _24468 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24468] = 30
                                mem[_24468 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                    if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply)
                                _25577 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25577 + 68] = mem[idx + _24468 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25577 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25577 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20375 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20375] = 30
                                mem[_20375 + 32] = 'SafeMath: subtraction overflow'
                                _21578 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21578] = 30
                                mem[_21578 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _22102 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22102 + 68] = mem[idx + _21578 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22102 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22102 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _24466 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24466] = 30
                                mem[_24466 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                _25576 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25576 + 68] = mem[idx + _24466 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25576 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25576 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21105 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21105] = 30
                            mem[_21105 + 32] = 'SafeMath: subtraction overflow'
                            _23553 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23553] = 30
                            mem[_23553 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _24465 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24465 + 68] = mem[idx + _23553 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24465 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24465 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27777 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27777] = 30
                            mem[_27777 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                            _29070 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29070 + 68] = mem[idx + _27777 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29070 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29070 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20374 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20374] = 30
                                mem[_20374 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20638 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20638 + 68] = mem[idx + _20374 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20638 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20638 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _21576 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21576] = 30
                                mem[_21576 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _22101 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22101 + 68] = mem[idx + _21576 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22101 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22101 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24463 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24463] = 30
                                mem[_24463 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply)
                                _25575 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25575 + 68] = mem[idx + _24463 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25575 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25575 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21104 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21104] = 30
                            mem[_21104 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _21575 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21575 + 68] = mem[idx + _21104 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21575 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21575 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _23551 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23551] = 30
                            mem[_23551 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _24462 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24462 + 68] = mem[idx + _23551 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24462 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24462 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _27775 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27775] = 30
                            mem[_27775 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                            _29068 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29068 + 68] = mem[idx + _27775 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29068 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29068 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21103 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21103] = 30
                            mem[_21103 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _21574 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21574 + 68] = mem[idx + _21103 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21574 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21574 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _23549 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23549] = 30
                            mem[_23549 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _24461 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24461 + 68] = mem[idx + _23549 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24461 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24461 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27773 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27773] = 30
                            mem[_27773 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _29067 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29067 + 68] = mem[idx + _27773 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29067 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29067 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22794 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22794] = 30
                        mem[_22794 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _23548 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23548 + 68] = mem[idx + _22794 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23548 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23548 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _26584 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26584] = 30
                        mem[_26584 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _27772 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27772 + 68] = mem[idx + _26584 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27772 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27772 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _31399 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31399] = 30
                        mem[_31399 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _32595 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32595 + 68] = mem[idx + _31399 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32595 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32595 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20372 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20372] = 30
                                mem[_20372 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20637 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20637 + 68] = mem[idx + _20372 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20637 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20637 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _21572 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21572] = 30
                                mem[_21572 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _22099 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22099 + 68] = mem[idx + _21572 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22099 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22099 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24459 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24459] = 30
                                mem[_24459 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _25574 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25574 + 68] = mem[idx + _24459 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25574 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25574 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21102 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21102] = 30
                            mem[_21102 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _21571 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21571 + 68] = mem[idx + _21102 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21571 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21571 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _23546 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23546] = 30
                            mem[_23546 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _24458 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24458 + 68] = mem[idx + _23546 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24458 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24458 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _27770 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27770] = 30
                            mem[_27770 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                            _29065 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29065 + 68] = mem[idx + _27770 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29065 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29065 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21101 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21101] = 30
                            mem[_21101 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _21570 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21570 + 68] = mem[idx + _21101 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21570 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21570 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _23544 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23544] = 30
                            mem[_23544 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _24457 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24457 + 68] = mem[idx + _23544 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24457 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24457 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27768 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27768] = 30
                            mem[_27768 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _29064 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29064 + 68] = mem[idx + _27768 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29064 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29064 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22793 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22793] = 30
                        mem[_22793 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _23543 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23543 + 68] = mem[idx + _22793 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23543 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23543 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _26582 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26582] = 30
                        mem[_26582 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _27767 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27767 + 68] = mem[idx + _26582 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27767 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27767 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _31396 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31396] = 30
                        mem[_31396 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _32592 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32592 + 68] = mem[idx + _31396 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32592 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32592 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21100 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21100] = 30
                            mem[_21100 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _21569 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21569 + 68] = mem[idx + _21100 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21569 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21569 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _23541 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23541] = 30
                            mem[_23541 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _24456 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24456 + 68] = mem[idx + _23541 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24456 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24456 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _27765 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27765] = 30
                            mem[_27765 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply))
                            _29063 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29063 + 68] = mem[idx + _27765 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29063 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29063 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22792 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22792] = 30
                        mem[_22792 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _23540 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23540 + 68] = mem[idx + _22792 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23540 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23540 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _26580 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26580] = 30
                        mem[_26580 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _27764 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27764 + 68] = mem[idx + _26580 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27764 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27764 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _31394 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31394] = 30
                        mem[_31394 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _32590 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32590 + 68] = mem[idx + _31394 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32590 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32590 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _22791 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22791] = 30
                        mem[_22791 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _23539 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23539 + 68] = mem[idx + _22791 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23539 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23539 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _26578 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26578] = 30
                        mem[_26578 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _27763 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27763 + 68] = mem[idx + _26578 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27763 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27763 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _31392 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31392] = 30
                        mem[_31392 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _32589 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32589 + 68] = mem[idx + _31392 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32589 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32589 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _25573 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25573] = 30
                    mem[_25573 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _26577 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26577 + 68] = mem[idx + _25573 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26577 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26577 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _30233 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30233] = 30
                    mem[_30233 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _31391 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _31391 + 68] = mem[idx + _30233 + 32]
                            idx = idx + 32
                            continue 
                        mem[_31391 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _31391 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _34449 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_34449] = 30
                    mem[_34449 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _35321 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35321 + 68] = mem[idx + _34449 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35321 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35321 + -mem[64] + 100
                if idx >= stor6.length:
                    revert with 0, 50
                mem[0] = stor6[idx]
                mem[32] = 2
                if stor2[stor6[idx]] <= s:
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    _19298 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19298] = 30
                    mem[_19298 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[stor6[idx]] > t:
                        _19378 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19378 + 68] = mem[idx + _19298 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19378 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19378 + -mem[64] + 100
                    if t < stor1[stor6[idx]]:
                        revert with 0, 17
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    _19731 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19731] = 30
                    mem[_19731 + 32] = 'SafeMath: subtraction overflow'
                    if stor2[stor6[idx]] <= s:
                        if s < stor2[stor6[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor2[stor6[idx]]
                        t = t - stor1[stor6[idx]]
                        continue 
                    _19779 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _19779 + 68] = mem[idx + _19731 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19779 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _19779 + -mem[64] + 100
                _19299 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19299] = 26
                mem[_19299 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _19379 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _19379 + 68] = mem[idx + _19299 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19379 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _19379 + -mem[64] + 100
                if not arg1:
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                return 0
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20645 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20645] = 30
                            mem[_20645 + 32] = 'SafeMath: subtraction overflow'
                            _22114 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22114] = 30
                            mem[_22114 + 32] = 'SafeMath: subtraction overflow'
                            _25591 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25591] = 30
                            mem[_25591 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply)
                            _26590 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26590 + 68] = mem[idx + _25591 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26590 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26590 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _20644 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20644] = 30
                            mem[_20644 + 32] = 'SafeMath: subtraction overflow'
                            _22113 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22113] = 30
                            mem[_22113 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _22800 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22800 + 68] = mem[idx + _22113 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22800 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22800 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _25589 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25589] = 30
                            mem[_25589 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                            _26589 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26589 + 68] = mem[idx + _25589 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26589 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26589 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21586 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21586] = 30
                        mem[_21586 + 32] = 'SafeMath: subtraction overflow'
                        _24483 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24483] = 30
                        mem[_24483 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            _25588 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25588 + 68] = mem[idx + _24483 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25588 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25588 + -mem[64] + 100
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _29087 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29087] = 30
                        mem[_29087 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _30242 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30242 + 68] = mem[idx + _29087 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30242 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30242 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _20643 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20643] = 30
                            mem[_20643 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _20833 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20833 + 68] = mem[idx + _20643 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20833 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20833 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _22111 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22111] = 30
                            mem[_22111 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _22799 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22799 + 68] = mem[idx + _22111 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22799 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22799 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25586 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25586] = 30
                            mem[_25586 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply)
                            _26588 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26588 + 68] = mem[idx + _25586 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26588 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26588 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21585 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21585] = 30
                        mem[_21585 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _22110 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22110 + 68] = mem[idx + _21585 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22110 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22110 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _24481 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24481] = 30
                        mem[_24481 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _25585 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25585 + 68] = mem[idx + _24481 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25585 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25585 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _29085 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29085] = 30
                        mem[_29085 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _30240 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30240 + 68] = mem[idx + _29085 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30240 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30240 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _21584 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21584] = 30
                        mem[_21584 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _22109 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22109 + 68] = mem[idx + _21584 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22109 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22109 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _24479 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24479] = 30
                        mem[_24479 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _25584 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25584 + 68] = mem[idx + _24479 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25584 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25584 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _29083 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29083] = 30
                        mem[_29083 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _30239 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30239 + 68] = mem[idx + _29083 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30239 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30239 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23557 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23557] = 30
                    mem[_23557 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        _24478 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24478 + 68] = mem[idx + _23557 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24478 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24478 + -mem[64] + 100
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _27787 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27787] = 30
                    mem[_27787 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        _29082 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29082 + 68] = mem[idx + _27787 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29082 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29082 + -mem[64] + 100
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _32607 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32607] = 30
                    mem[_32607 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _33585 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33585 + 68] = mem[idx + _32607 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33585 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33585 + -mem[64] + 100
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _20641 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20641] = 30
                            mem[_20641 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _20832 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20832 + 68] = mem[idx + _20641 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20832 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20832 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _22107 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22107] = 30
                            mem[_22107 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22797 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22797 + 68] = mem[idx + _22107 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22797 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22797 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25582 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25582] = 30
                            mem[_25582 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _26587 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26587 + 68] = mem[idx + _25582 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26587 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26587 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21583 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21583] = 30
                        mem[_21583 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _22106 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22106 + 68] = mem[idx + _21583 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22106 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22106 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _24476 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24476] = 30
                        mem[_24476 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _25581 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25581 + 68] = mem[idx + _24476 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25581 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25581 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _29080 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29080] = 30
                        mem[_29080 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                            if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _30237 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30237 + 68] = mem[idx + _29080 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30237 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30237 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _21582 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21582] = 30
                        mem[_21582 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _22105 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22105 + 68] = mem[idx + _21582 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22105 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22105 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _24474 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24474] = 30
                        mem[_24474 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _25580 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25580 + 68] = mem[idx + _24474 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25580 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25580 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _29078 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29078] = 30
                        mem[_29078 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _30236 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30236 + 68] = mem[idx + _29078 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30236 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30236 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23556 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23556] = 30
                    mem[_23556 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        _24473 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24473 + 68] = mem[idx + _23556 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24473 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24473 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    _27785 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27785] = 30
                    mem[_27785 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _29077 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29077 + 68] = mem[idx + _27785 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29077 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29077 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _32604 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32604] = 30
                    mem[_32604 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _33582 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33582 + 68] = mem[idx + _32604 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33582 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33582 + -mem[64] + 100
                if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _21581 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21581] = 30
                        mem[_21581 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _22104 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22104 + 68] = mem[idx + _21581 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22104 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22104 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _24471 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24471] = 30
                        mem[_24471 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _25579 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25579 + 68] = mem[idx + _24471 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25579 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25579 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _29075 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29075] = 30
                        mem[_29075 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply))
                        _30235 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30235 + 68] = mem[idx + _29075 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30235 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30235 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23555 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23555] = 30
                    mem[_23555 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _24470 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24470 + 68] = mem[idx + _23555 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24470 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24470 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _27783 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27783] = 30
                    mem[_27783 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _29074 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29074 + 68] = mem[idx + _27783 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29074 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29074 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    _32602 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32602] = 30
                    mem[_32602 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _33580 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33580 + 68] = mem[idx + _32602 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33580 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33580 + -mem[64] + 100
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    _23554 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23554] = 30
                    mem[_23554 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _24469 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24469 + 68] = mem[idx + _23554 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24469 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24469 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _27781 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27781] = 30
                    mem[_27781 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _29073 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29073 + 68] = mem[idx + _27781 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29073 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29073 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _32600 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32600] = 30
                    mem[_32600 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    _33579 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33579 + 68] = mem[idx + _32600 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33579 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33579 + -mem[64] + 100
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _26586 = mem[64]
                mem[64] = mem[64] + 64
                mem[_26586] = 30
                mem[_26586 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    _27780 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _27780 + 68] = mem[idx + _26586 + 32]
                        idx = idx + 32
                        continue 
                    mem[_27780 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _27780 + -mem[64] + 100
                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _31404 = mem[64]
                mem[64] = mem[64] + 64
                mem[_31404] = 30
                mem[_31404 + 32] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    _32599 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32599 + 68] = mem[idx + _31404 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32599 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32599 + -mem[64] + 100
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _35326 = mem[64]
                mem[64] = mem[64] + 64
                mem[_35326] = 30
                mem[_35326 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                _35917 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _35917 + 68] = mem[idx + _35326 + 32]
                    idx = idx + 32
                    continue 
                mem[_35917 + 98] = 0
                revert with memory
                  from mem[64]
                   len _35917 + -mem[64] + 100
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor15 / totalSupply:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                return 0
                            if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * t / s)
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * 0 / stor13 / 100 * t / s)
                        if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * 0 / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                    if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s)
                        if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            return (arg1 * t / s)
                        if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor13 / 100 * t / s))
                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s))
                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            return 0
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply)
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply)
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
            if arg1 and stor15 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _TAX_FEE / stor13 / 100:
                if not 0 / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < 0:
                    revert with 0, 17
                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
            if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _TAX_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 0 / stor13 / 100:
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                revert with 0, 17
            if not 0 / stor13 / 100:
                revert with 0, 18
            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
        if arg1 and _BURN_FEE > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * _BURN_FEE / arg1 != _BURN_FEE:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[224] = 26
        mem[256] = 'SafeMath: division by zero'
        if not stor13:
            revert with 0, 'SafeMath: division by zero', 0
        mem[288] = 26
        mem[320] = 'SafeMath: division by zero'
        if not arg1:
            mem[352] = 26
            mem[384] = 'SafeMath: division by zero'
            if not stor13:
                revert with 0, 'SafeMath: division by zero', 0
            mem[416] = 26
            mem[448] = 'SafeMath: division by zero'
            mem[480] = 30
            mem[512] = 'SafeMath: subtraction overflow'
            if arg1 * _TAX_FEE / stor13 / 100 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * _TAX_FEE / stor13 / 100:
                revert with 0, 17
            mem[544] = 30
            mem[576] = 'SafeMath: subtraction overflow'
            if arg1 * _BURN_FEE / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _TAX_FEE / stor13 / 100) < arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 17
            mem[64] = 672
            mem[608] = 30
            mem[640] = 'SafeMath: subtraction overflow'
            if 0 / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100) < 0 / stor13 / 100:
                revert with 0, 17
            idx = 0
            s = totalSupply
            t = stor15
            while idx < stor6.length:
                mem[0] = stor6[idx]
                mem[32] = 1
                if stor1[stor6[idx]] > t:
                    _19228 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19228] = 26
                    mem[_19228 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19294 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19294 + 68] = mem[idx + _19228 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19294 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19294 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    return 0
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20363 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20363] = 30
                                mem[_20363 + 32] = 'SafeMath: subtraction overflow'
                                _21555 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21555] = 30
                                mem[_21555 + 32] = 'SafeMath: subtraction overflow'
                                _24425 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24425] = 30
                                mem[_24425 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= 0:
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                _25550 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25550 + 68] = mem[idx + _24425 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25550 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25550 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _20362 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20362] = 30
                                mem[_20362 + 32] = 'SafeMath: subtraction overflow'
                                _21554 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21554] = 30
                                mem[_21554 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _22078 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22078 + 68] = mem[idx + _21554 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22078 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22078 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _24423 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24423] = 30
                                mem[_24423 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply)
                                _25549 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25549 + 68] = mem[idx + _24423 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25549 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25549 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21083 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21083] = 30
                            mem[_21083 + 32] = 'SafeMath: subtraction overflow'
                            _23512 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23512] = 30
                            mem[_23512 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _24422 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24422 + 68] = mem[idx + _23512 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24422 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24422 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27723 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27723] = 30
                            mem[_27723 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _29033 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29033 + 68] = mem[idx + _27723 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29033 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29033 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _20361 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20361] = 30
                                mem[_20361 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20629 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20629 + 68] = mem[idx + _20361 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20629 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20629 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _21552 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21552] = 30
                                mem[_21552 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _22077 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22077 + 68] = mem[idx + _21552 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22077 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22077 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24420 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24420] = 30
                                mem[_24420 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply)
                                _25548 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25548 + 68] = mem[idx + _24420 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25548 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25548 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21082 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21082] = 30
                            mem[_21082 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _21551 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21551 + 68] = mem[idx + _21082 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21551 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21551 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _23510 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23510] = 30
                            mem[_23510 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _24419 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24419 + 68] = mem[idx + _23510 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24419 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24419 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _27721 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27721] = 30
                            mem[_27721 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _29031 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29031 + 68] = mem[idx + _27721 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29031 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29031 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21081 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21081] = 30
                            mem[_21081 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _21550 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21550 + 68] = mem[idx + _21081 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21550 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21550 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _23508 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23508] = 30
                            mem[_23508 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _24418 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24418 + 68] = mem[idx + _23508 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24418 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24418 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27719 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27719] = 30
                            mem[_27719 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                            _29030 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29030 + 68] = mem[idx + _27719 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29030 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29030 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22769 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22769] = 30
                        mem[_22769 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _23507 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23507 + 68] = mem[idx + _22769 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23507 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23507 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _26540 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26540] = 30
                        mem[_26540 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _27718 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27718 + 68] = mem[idx + _26540 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27718 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27718 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _31350 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31350] = 30
                        mem[_31350 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _32552 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32552 + 68] = mem[idx + _31350 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32552 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32552 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _20359 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20359] = 30
                                mem[_20359 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20628 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20628 + 68] = mem[idx + _20359 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20628 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20628 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _21548 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21548] = 30
                                mem[_21548 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _22075 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22075 + 68] = mem[idx + _21548 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22075 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22075 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24416 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24416] = 30
                                mem[_24416 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _25547 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25547 + 68] = mem[idx + _24416 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25547 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25547 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21080 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21080] = 30
                            mem[_21080 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _21547 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21547 + 68] = mem[idx + _21080 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21547 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21547 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _23505 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23505] = 30
                            mem[_23505 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _24415 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24415 + 68] = mem[idx + _23505 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24415 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24415 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _27716 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27716] = 30
                            mem[_27716 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _29028 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29028 + 68] = mem[idx + _27716 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29028 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29028 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21079 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21079] = 30
                            mem[_21079 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _21546 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21546 + 68] = mem[idx + _21079 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21546 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21546 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _23503 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23503] = 30
                            mem[_23503 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _24414 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24414 + 68] = mem[idx + _23503 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24414 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24414 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27714 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27714] = 30
                            mem[_27714 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                            _29027 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29027 + 68] = mem[idx + _27714 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29027 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29027 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22768 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22768] = 30
                        mem[_22768 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _23502 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23502 + 68] = mem[idx + _22768 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23502 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23502 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _26538 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26538] = 30
                        mem[_26538 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _27713 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27713 + 68] = mem[idx + _26538 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27713 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27713 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _31347 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31347] = 30
                        mem[_31347 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _32549 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32549 + 68] = mem[idx + _31347 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32549 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32549 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            _21078 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21078] = 30
                            mem[_21078 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _21545 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21545 + 68] = mem[idx + _21078 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21545 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21545 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _23500 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23500] = 30
                            mem[_23500 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _24413 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24413 + 68] = mem[idx + _23500 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24413 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24413 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _27711 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27711] = 30
                            mem[_27711 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply))
                            _29026 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29026 + 68] = mem[idx + _27711 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29026 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29026 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22767 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22767] = 30
                        mem[_22767 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _23499 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23499 + 68] = mem[idx + _22767 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23499 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23499 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _26536 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26536] = 30
                        mem[_26536 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _27710 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27710 + 68] = mem[idx + _26536 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27710 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27710 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _31345 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31345] = 30
                        mem[_31345 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _32547 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32547 + 68] = mem[idx + _31345 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32547 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32547 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _22766 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22766] = 30
                        mem[_22766 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _23498 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23498 + 68] = mem[idx + _22766 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23498 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23498 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _26534 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26534] = 30
                        mem[_26534 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _27709 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27709 + 68] = mem[idx + _26534 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27709 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27709 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _31343 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31343] = 30
                        mem[_31343 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                        _32546 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32546 + 68] = mem[idx + _31343 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32546 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32546 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _25546 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25546] = 30
                    mem[_25546 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _26533 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26533 + 68] = mem[idx + _25546 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26533 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26533 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _30203 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30203] = 30
                    mem[_30203 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _31342 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _31342 + 68] = mem[idx + _30203 + 32]
                            idx = idx + 32
                            continue 
                        mem[_31342 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _31342 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _34415 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_34415] = 30
                    mem[_34415 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    _35288 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35288 + 68] = mem[idx + _34415 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35288 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35288 + -mem[64] + 100
                if idx >= stor6.length:
                    revert with 0, 50
                mem[0] = stor6[idx]
                mem[32] = 2
                if stor2[stor6[idx]] <= s:
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    _19295 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19295] = 30
                    mem[_19295 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[stor6[idx]] > t:
                        _19375 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19375 + 68] = mem[idx + _19295 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19375 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19375 + -mem[64] + 100
                    if t < stor1[stor6[idx]]:
                        revert with 0, 17
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    _19728 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19728] = 30
                    mem[_19728 + 32] = 'SafeMath: subtraction overflow'
                    if stor2[stor6[idx]] <= s:
                        if s < stor2[stor6[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor2[stor6[idx]]
                        t = t - stor1[stor6[idx]]
                        continue 
                    _19776 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _19776 + 68] = mem[idx + _19728 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19776 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _19776 + -mem[64] + 100
                _19296 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19296] = 26
                mem[_19296 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _19376 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _19376 + 68] = mem[idx + _19296 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19376 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _19376 + -mem[64] + 100
                if not arg1:
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                return 0
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20636 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20636] = 30
                            mem[_20636 + 32] = 'SafeMath: subtraction overflow'
                            _22090 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22090] = 30
                            mem[_22090 + 32] = 'SafeMath: subtraction overflow'
                            _25564 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25564] = 30
                            mem[_25564 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= 0:
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                            _26546 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26546 + 68] = mem[idx + _25564 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26546 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26546 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _20635 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20635] = 30
                            mem[_20635 + 32] = 'SafeMath: subtraction overflow'
                            _22089 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22089] = 30
                            mem[_22089 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _22775 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22775 + 68] = mem[idx + _22089 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22775 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22775 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _25562 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25562] = 30
                            mem[_25562 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply)
                            _26545 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26545 + 68] = mem[idx + _25562 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26545 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26545 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21562 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21562] = 30
                        mem[_21562 + 32] = 'SafeMath: subtraction overflow'
                        _24440 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24440] = 30
                        mem[_24440 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _25561 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25561 + 68] = mem[idx + _24440 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25561 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25561 + -mem[64] + 100
                        if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _29050 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29050] = 30
                        mem[_29050 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _30212 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30212 + 68] = mem[idx + _29050 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30212 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30212 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            _20634 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20634] = 30
                            mem[_20634 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _20825 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20825 + 68] = mem[idx + _20634 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20825 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20825 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _22087 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22087] = 30
                            mem[_22087 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _22774 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22774 + 68] = mem[idx + _22087 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22774 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22774 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25559 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25559] = 30
                            mem[_25559 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply)
                            _26544 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26544 + 68] = mem[idx + _25559 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26544 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26544 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21561 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21561] = 30
                        mem[_21561 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _22086 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22086 + 68] = mem[idx + _21561 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22086 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22086 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _24438 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24438] = 30
                        mem[_24438 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _25558 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25558 + 68] = mem[idx + _24438 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25558 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25558 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _29048 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29048] = 30
                        mem[_29048 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _30210 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30210 + 68] = mem[idx + _29048 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30210 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30210 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _21560 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21560] = 30
                        mem[_21560 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _22085 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22085 + 68] = mem[idx + _21560 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22085 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22085 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _24436 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24436] = 30
                        mem[_24436 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _25557 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25557 + 68] = mem[idx + _24436 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25557 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25557 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _29046 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29046] = 30
                        mem[_29046 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                        _30209 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30209 + 68] = mem[idx + _29046 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30209 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30209 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23516 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23516] = 30
                    mem[_23516 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        _24435 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24435 + 68] = mem[idx + _23516 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24435 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24435 + -mem[64] + 100
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _27733 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27733] = 30
                    mem[_27733 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        _29045 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29045 + 68] = mem[idx + _27733 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29045 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29045 + -mem[64] + 100
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _32564 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32564] = 30
                    mem[_32564 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    _33571 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33571 + 68] = mem[idx + _32564 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33571 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33571 + -mem[64] + 100
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            _20632 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20632] = 30
                            mem[_20632 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _20824 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20824 + 68] = mem[idx + _20632 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20824 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20824 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _22083 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22083] = 30
                            mem[_22083 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22772 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22772 + 68] = mem[idx + _22083 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22772 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22772 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25555 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25555] = 30
                            mem[_25555 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _26543 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26543 + 68] = mem[idx + _25555 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26543 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26543 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21559 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21559] = 30
                        mem[_21559 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _22082 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22082 + 68] = mem[idx + _21559 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22082 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22082 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _24433 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24433] = 30
                        mem[_24433 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _25554 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25554 + 68] = mem[idx + _24433 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25554 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25554 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _29043 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29043] = 30
                        mem[_29043 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _30207 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30207 + 68] = mem[idx + _29043 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30207 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30207 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _21558 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21558] = 30
                        mem[_21558 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _22081 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22081 + 68] = mem[idx + _21558 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22081 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22081 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _24431 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24431] = 30
                        mem[_24431 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _25553 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25553 + 68] = mem[idx + _24431 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25553 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25553 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _29041 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29041] = 30
                        mem[_29041 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                        _30206 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30206 + 68] = mem[idx + _29041 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30206 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30206 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23515 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23515] = 30
                    mem[_23515 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        _24430 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24430 + 68] = mem[idx + _23515 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24430 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24430 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    _27731 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27731] = 30
                    mem[_27731 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _29040 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29040 + 68] = mem[idx + _27731 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29040 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29040 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _32561 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32561] = 30
                    mem[_32561 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    _33568 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33568 + 68] = mem[idx + _32561 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33568 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33568 + -mem[64] + 100
                if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not 0 / stor13 / 100:
                        _21557 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21557] = 30
                        mem[_21557 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _22080 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22080 + 68] = mem[idx + _21557 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22080 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22080 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _24428 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24428] = 30
                        mem[_24428 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _25552 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25552 + 68] = mem[idx + _24428 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25552 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25552 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _29038 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29038] = 30
                        mem[_29038 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply))
                        _30205 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30205 + 68] = mem[idx + _29038 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30205 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30205 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23514 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23514] = 30
                    mem[_23514 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _24427 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24427 + 68] = mem[idx + _23514 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24427 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24427 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _27729 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27729] = 30
                    mem[_27729 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _29037 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29037 + 68] = mem[idx + _27729 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29037 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29037 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    _32559 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32559] = 30
                    mem[_32559 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    _33566 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33566 + 68] = mem[idx + _32559 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33566 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33566 + -mem[64] + 100
                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    _23513 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23513] = 30
                    mem[_23513 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _24426 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24426 + 68] = mem[idx + _23513 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24426 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24426 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _27727 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27727] = 30
                    mem[_27727 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _29036 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29036 + 68] = mem[idx + _27727 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29036 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29036 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _32557 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32557] = 30
                    mem[_32557 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                    _33565 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33565 + 68] = mem[idx + _32557 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33565 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33565 + -mem[64] + 100
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _26542 = mem[64]
                mem[64] = mem[64] + 64
                mem[_26542] = 30
                mem[_26542 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    _27726 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _27726 + 68] = mem[idx + _26542 + 32]
                        idx = idx + 32
                        continue 
                    mem[_27726 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _27726 + -mem[64] + 100
                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _31355 = mem[64]
                mem[64] = mem[64] + 64
                mem[_31355] = 30
                mem[_31355 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    _32556 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32556 + 68] = mem[idx + _31355 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32556 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32556 + -mem[64] + 100
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _35293 = mem[64]
                mem[64] = mem[64] + 64
                mem[_35293] = 30
                mem[_35293 + 32] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                _35912 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _35912 + 68] = mem[idx + _35293 + 32]
                    idx = idx + 32
                    continue 
                mem[_35912 + 98] = 0
                revert with memory
                  from mem[64]
                   len _35912 + -mem[64] + 100
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor15 / totalSupply:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                return 0
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            return (-1 * 0 / stor13 / 100 * t / s)
                        if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _BURN_FEE / stor13 / 100 * t / s)
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                    if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s)
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                    if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s))
                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor13 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            return (arg1 * t / s)
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor13 / 100 * t / s))
                    if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s))
                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not 0 / stor13 / 100:
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s))
                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                        revert with 0, 17
                    if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s))
                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            return 0
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply)
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not 0 / stor13 / 100:
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply)
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 / stor13 / 100 * stor15 / totalSupply > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
            if arg1 and stor15 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _TAX_FEE / stor13 / 100:
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not 0 / stor13 / 100:
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
            if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _TAX_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _BURN_FEE / stor13 / 100:
                if not 0 / stor13 / 100:
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply))
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                    revert with 0, 17
                if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 0 / stor13 / 100:
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                revert with 0, 17
            if not 0 / stor13 / 100:
                revert with 0, 18
            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
        if arg1 and _CHARITY_FEE > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * _CHARITY_FEE / arg1 != _CHARITY_FEE:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[352] = 26
        mem[384] = 'SafeMath: division by zero'
        if not stor13:
            revert with 0, 'SafeMath: division by zero', 0
        mem[416] = 26
        mem[448] = 'SafeMath: division by zero'
        mem[480] = 30
        mem[512] = 'SafeMath: subtraction overflow'
        if arg1 * _TAX_FEE / stor13 / 100 > arg1:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 < arg1 * _TAX_FEE / stor13 / 100:
            revert with 0, 17
        mem[544] = 30
        mem[576] = 'SafeMath: subtraction overflow'
        if arg1 * _BURN_FEE / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 - (arg1 * _TAX_FEE / stor13 / 100) < arg1 * _BURN_FEE / stor13 / 100:
            revert with 0, 17
        mem[64] = 672
        mem[608] = 30
        mem[640] = 'SafeMath: subtraction overflow'
        if arg1 * _CHARITY_FEE / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100) < arg1 * _CHARITY_FEE / stor13 / 100:
            revert with 0, 17
        idx = 0
        s = totalSupply
        t = stor15
        while idx < stor6.length:
            mem[0] = stor6[idx]
            mem[32] = 1
            if stor1[stor6[idx]] > t:
                _19227 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19227] = 26
                mem[_19227 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _19291 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _19291 + 68] = mem[idx + _19227 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19291 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _19291 + -mem[64] + 100
                if not arg1:
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                return 0
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20350 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20350] = 30
                            mem[_20350 + 32] = 'SafeMath: subtraction overflow'
                            _21531 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21531] = 30
                            mem[_21531 + 32] = 'SafeMath: subtraction overflow'
                            _24382 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24382] = 30
                            mem[_24382 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply)
                            _25523 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25523 + 68] = mem[idx + _24382 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25523 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25523 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _20349 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20349] = 30
                            mem[_20349 + 32] = 'SafeMath: subtraction overflow'
                            _21530 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21530] = 30
                            mem[_21530 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _22054 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22054 + 68] = mem[idx + _21530 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22054 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22054 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24380 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24380] = 30
                            mem[_24380 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply)
                            _25522 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25522 + 68] = mem[idx + _24380 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25522 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25522 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21061 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21061] = 30
                        mem[_21061 + 32] = 'SafeMath: subtraction overflow'
                        _23471 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23471] = 30
                        mem[_23471 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _24379 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24379 + 68] = mem[idx + _23471 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24379 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24379 + -mem[64] + 100
                        if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27669 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27669] = 30
                        mem[_27669 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _28996 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28996 + 68] = mem[idx + _27669 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28996 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28996 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _20348 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20348] = 30
                            mem[_20348 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _20620 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20620 + 68] = mem[idx + _20348 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20620 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20620 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _21528 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21528] = 30
                            mem[_21528 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _22053 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22053 + 68] = mem[idx + _21528 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22053 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22053 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24377 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24377] = 30
                            mem[_24377 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply)
                            _25521 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25521 + 68] = mem[idx + _24377 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25521 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25521 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21060 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21060] = 30
                        mem[_21060 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _21527 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21527 + 68] = mem[idx + _21060 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21527 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21527 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _23469 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23469] = 30
                        mem[_23469 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _24376 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24376 + 68] = mem[idx + _23469 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24376 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24376 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _27667 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27667] = 30
                        mem[_27667 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _28994 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28994 + 68] = mem[idx + _27667 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28994 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28994 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _21059 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21059] = 30
                        mem[_21059 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _21526 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21526 + 68] = mem[idx + _21059 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21526 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21526 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _23467 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23467] = 30
                        mem[_23467 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _24375 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24375 + 68] = mem[idx + _23467 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24375 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24375 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27665 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27665] = 30
                        mem[_27665 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                        _28993 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28993 + 68] = mem[idx + _27665 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28993 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28993 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _22744 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_22744] = 30
                    mem[_22744 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        _23466 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _23466 + 68] = mem[idx + _22744 + 32]
                            idx = idx + 32
                            continue 
                        mem[_23466 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _23466 + -mem[64] + 100
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _26496 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26496] = 30
                    mem[_26496 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        _27664 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27664 + 68] = mem[idx + _26496 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27664 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27664 + -mem[64] + 100
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _31301 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31301] = 30
                    mem[_31301 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _32509 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32509 + 68] = mem[idx + _31301 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32509 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32509 + -mem[64] + 100
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _20346 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20346] = 30
                            mem[_20346 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _20619 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20619 + 68] = mem[idx + _20346 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20619 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20619 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _21524 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21524] = 30
                            mem[_21524 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22051 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22051 + 68] = mem[idx + _21524 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22051 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22051 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24373 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24373] = 30
                            mem[_24373 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _25520 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25520 + 68] = mem[idx + _24373 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25520 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25520 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21058 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21058] = 30
                        mem[_21058 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _21523 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21523 + 68] = mem[idx + _21058 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21523 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21523 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _23464 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23464] = 30
                        mem[_23464 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _24372 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24372 + 68] = mem[idx + _23464 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24372 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24372 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _27662 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27662] = 30
                        mem[_27662 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                            if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _28991 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28991 + 68] = mem[idx + _27662 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28991 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28991 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _21057 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21057] = 30
                        mem[_21057 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _21522 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21522 + 68] = mem[idx + _21057 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21522 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21522 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _23462 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23462] = 30
                        mem[_23462 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24371 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24371 + 68] = mem[idx + _23462 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24371 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24371 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27660 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27660] = 30
                        mem[_27660 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                        _28990 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28990 + 68] = mem[idx + _27660 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28990 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28990 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _22743 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_22743] = 30
                    mem[_22743 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        _23461 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _23461 + 68] = mem[idx + _22743 + 32]
                            idx = idx + 32
                            continue 
                        mem[_23461 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _23461 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    _26494 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26494] = 30
                    mem[_26494 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _27659 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27659 + 68] = mem[idx + _26494 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27659 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27659 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _31298 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31298] = 30
                    mem[_31298 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _32506 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32506 + 68] = mem[idx + _31298 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32506 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32506 + -mem[64] + 100
                if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _21056 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21056] = 30
                        mem[_21056 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _21521 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21521 + 68] = mem[idx + _21056 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21521 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21521 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _23459 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23459] = 30
                        mem[_23459 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _24370 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24370 + 68] = mem[idx + _23459 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24370 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24370 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _27657 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27657] = 30
                        mem[_27657 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply))
                        _28989 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28989 + 68] = mem[idx + _27657 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28989 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28989 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _22742 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_22742] = 30
                    mem[_22742 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _23458 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _23458 + 68] = mem[idx + _22742 + 32]
                            idx = idx + 32
                            continue 
                        mem[_23458 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _23458 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _26492 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26492] = 30
                    mem[_26492 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _27656 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27656 + 68] = mem[idx + _26492 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27656 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27656 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    _31296 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31296] = 30
                    mem[_31296 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _32504 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32504 + 68] = mem[idx + _31296 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32504 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32504 + -mem[64] + 100
                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    _22741 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_22741] = 30
                    mem[_22741 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _23457 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _23457 + 68] = mem[idx + _22741 + 32]
                            idx = idx + 32
                            continue 
                        mem[_23457 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _23457 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _26490 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26490] = 30
                    mem[_26490 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _27655 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27655 + 68] = mem[idx + _26490 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27655 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27655 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _31294 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31294] = 30
                    mem[_31294 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                    _32503 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32503 + 68] = mem[idx + _31294 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32503 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32503 + -mem[64] + 100
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _25519 = mem[64]
                mem[64] = mem[64] + 64
                mem[_25519] = 30
                mem[_25519 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    _26489 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _26489 + 68] = mem[idx + _25519 + 32]
                        idx = idx + 32
                        continue 
                    mem[_26489 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _26489 + -mem[64] + 100
                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _30173 = mem[64]
                mem[64] = mem[64] + 64
                mem[_30173] = 30
                mem[_30173 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    _31293 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _31293 + 68] = mem[idx + _30173 + 32]
                        idx = idx + 32
                        continue 
                    mem[_31293 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _31293 + -mem[64] + 100
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _34381 = mem[64]
                mem[64] = mem[64] + 64
                mem[_34381] = 30
                mem[_34381 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                _35255 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _35255 + 68] = mem[idx + _34381 + 32]
                    idx = idx + 32
                    continue 
                mem[_35255 + 98] = 0
                revert with memory
                  from mem[64]
                   len _35255 + -mem[64] + 100
            if idx >= stor6.length:
                revert with 0, 50
            mem[0] = stor6[idx]
            mem[32] = 2
            if stor2[stor6[idx]] <= s:
                if idx >= stor6.length:
                    revert with 0, 50
                mem[0] = stor6[idx]
                mem[32] = 1
                _19292 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19292] = 30
                mem[_19292 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor6[idx]] > t:
                    _19372 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _19372 + 68] = mem[idx + _19292 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19372 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _19372 + -mem[64] + 100
                if t < stor1[stor6[idx]]:
                    revert with 0, 17
                if idx >= stor6.length:
                    revert with 0, 50
                mem[0] = stor6[idx]
                mem[32] = 2
                _19725 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19725] = 30
                mem[_19725 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor6[idx]] <= s:
                    if s < stor2[stor6[idx]]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s - stor2[stor6[idx]]
                    t = t - stor1[stor6[idx]]
                    continue 
                _19773 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _19773 + 68] = mem[idx + _19725 + 32]
                    idx = idx + 32
                    continue 
                mem[_19773 + 98] = 0
                revert with memory
                  from mem[64]
                   len _19773 + -mem[64] + 100
            _19293 = mem[64]
            mem[64] = mem[64] + 64
            mem[_19293] = 26
            mem[_19293 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _19373 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _19373 + 68] = mem[idx + _19293 + 32]
                    idx = idx + 32
                    continue 
                mem[_19373 + 94] = 0
                revert with memory
                  from mem[64]
                   len _19373 + -mem[64] + 100
            if not arg1:
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            return 0
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _20627 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20627] = 30
                        mem[_20627 + 32] = 'SafeMath: subtraction overflow'
                        _22066 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22066] = 30
                        mem[_22066 + 32] = 'SafeMath: subtraction overflow'
                        _25537 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25537] = 30
                        mem[_25537 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                            if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply)
                        _26502 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26502 + 68] = mem[idx + _25537 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26502 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26502 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _20626 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20626] = 30
                        mem[_20626 + 32] = 'SafeMath: subtraction overflow'
                        _22065 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22065] = 30
                        mem[_22065 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _22750 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22750 + 68] = mem[idx + _22065 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22750 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22750 + -mem[64] + 100
                        if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _25535 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25535] = 30
                        mem[_25535 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply)
                        _26501 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26501 + 68] = mem[idx + _25535 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26501 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26501 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _21538 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21538] = 30
                    mem[_21538 + 32] = 'SafeMath: subtraction overflow'
                    _24397 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_24397] = 30
                    mem[_24397 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        _25534 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25534 + 68] = mem[idx + _24397 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25534 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _25534 + -mem[64] + 100
                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _29013 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29013] = 30
                    mem[_29013 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _30182 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _30182 + 68] = mem[idx + _29013 + 32]
                        idx = idx + 32
                        continue 
                    mem[_30182 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _30182 + -mem[64] + 100
                if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _20625 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20625] = 30
                        mem[_20625 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _20817 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20817 + 68] = mem[idx + _20625 + 32]
                                idx = idx + 32
                                continue 
                            mem[_20817 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20817 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _22063 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22063] = 30
                        mem[_22063 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _22749 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22749 + 68] = mem[idx + _22063 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22749 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22749 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _25532 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25532] = 30
                        mem[_25532 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply)
                        _26500 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26500 + 68] = mem[idx + _25532 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26500 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26500 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _21537 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21537] = 30
                    mem[_21537 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        _22062 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _22062 + 68] = mem[idx + _21537 + 32]
                            idx = idx + 32
                            continue 
                        mem[_22062 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _22062 + -mem[64] + 100
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _24395 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_24395] = 30
                    mem[_24395 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        _25531 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25531 + 68] = mem[idx + _24395 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25531 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _25531 + -mem[64] + 100
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    _29011 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29011] = 30
                    mem[_29011 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _30180 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _30180 + 68] = mem[idx + _29011 + 32]
                        idx = idx + 32
                        continue 
                    mem[_30180 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _30180 + -mem[64] + 100
                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    _21536 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21536] = 30
                    mem[_21536 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        _22061 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _22061 + 68] = mem[idx + _21536 + 32]
                            idx = idx + 32
                            continue 
                        mem[_22061 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _22061 + -mem[64] + 100
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _24393 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_24393] = 30
                    mem[_24393 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        _25530 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25530 + 68] = mem[idx + _24393 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25530 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _25530 + -mem[64] + 100
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _29009 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29009] = 30
                    mem[_29009 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                    _30179 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _30179 + 68] = mem[idx + _29009 + 32]
                        idx = idx + 32
                        continue 
                    mem[_30179 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _30179 + -mem[64] + 100
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _23475 = mem[64]
                mem[64] = mem[64] + 64
                mem[_23475] = 30
                mem[_23475 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                    _24392 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _24392 + 68] = mem[idx + _23475 + 32]
                        idx = idx + 32
                        continue 
                    mem[_24392 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _24392 + -mem[64] + 100
                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _27679 = mem[64]
                mem[64] = mem[64] + 64
                mem[_27679] = 30
                mem[_27679 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    _29008 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _29008 + 68] = mem[idx + _27679 + 32]
                        idx = idx + 32
                        continue 
                    mem[_29008 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _29008 + -mem[64] + 100
                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _32521 = mem[64]
                mem[64] = mem[64] + 64
                mem[_32521] = 30
                mem[_32521 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                _33557 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _33557 + 68] = mem[idx + _32521 + 32]
                    idx = idx + 32
                    continue 
                mem[_33557 + 98] = 0
                revert with memory
                  from mem[64]
                   len _33557 + -mem[64] + 100
            if arg1 and stor15 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _TAX_FEE / stor13 / 100:
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _20623 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20623] = 30
                        mem[_20623 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _20816 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20816 + 68] = mem[idx + _20623 + 32]
                                idx = idx + 32
                                continue 
                            mem[_20816 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20816 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _22059 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22059] = 30
                        mem[_22059 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _22747 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22747 + 68] = mem[idx + _22059 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22747 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22747 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _25528 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25528] = 30
                        mem[_25528 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor15 / totalSupply:
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _26499 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26499 + 68] = mem[idx + _25528 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26499 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26499 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _21535 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21535] = 30
                    mem[_21535 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        _22058 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _22058 + 68] = mem[idx + _21535 + 32]
                            idx = idx + 32
                            continue 
                        mem[_22058 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _22058 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    _24390 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_24390] = 30
                    mem[_24390 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        _25527 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25527 + 68] = mem[idx + _24390 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25527 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _25527 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    _29006 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29006] = 30
                    mem[_29006 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                        if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _30177 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _30177 + 68] = mem[idx + _29006 + 32]
                        idx = idx + 32
                        continue 
                    mem[_30177 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _30177 + -mem[64] + 100
                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    _21534 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21534] = 30
                    mem[_21534 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        _22057 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _22057 + 68] = mem[idx + _21534 + 32]
                            idx = idx + 32
                            continue 
                        mem[_22057 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _22057 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    _24388 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_24388] = 30
                    mem[_24388 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _25526 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25526 + 68] = mem[idx + _24388 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25526 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _25526 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _29004 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29004] = 30
                    mem[_29004 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                    _30176 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _30176 + 68] = mem[idx + _29004 + 32]
                        idx = idx + 32
                        continue 
                    mem[_30176 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _30176 + -mem[64] + 100
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _23474 = mem[64]
                mem[64] = mem[64] + 64
                mem[_23474] = 30
                mem[_23474 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor15 / totalSupply:
                    _24387 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _24387 + 68] = mem[idx + _23474 + 32]
                        idx = idx + 32
                        continue 
                    mem[_24387 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _24387 + -mem[64] + 100
                if arg1 * stor15 / totalSupply < 0:
                    revert with 0, 17
                _27677 = mem[64]
                mem[64] = mem[64] + 64
                mem[_27677] = 30
                mem[_27677 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    _29003 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _29003 + 68] = mem[idx + _27677 + 32]
                        idx = idx + 32
                        continue 
                    mem[_29003 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _29003 + -mem[64] + 100
                if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _32518 = mem[64]
                mem[64] = mem[64] + 64
                mem[_32518] = 30
                mem[_32518 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                _33554 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _33554 + 68] = mem[idx + _32518 + 32]
                    idx = idx + 32
                    continue 
                mem[_33554 + 98] = 0
                revert with memory
                  from mem[64]
                   len _33554 + -mem[64] + 100
            if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _TAX_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _BURN_FEE / stor13 / 100:
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    _21533 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21533] = 30
                    mem[_21533 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _22056 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _22056 + 68] = mem[idx + _21533 + 32]
                            idx = idx + 32
                            continue 
                        mem[_22056 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _22056 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _24385 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_24385] = 30
                    mem[_24385 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _25525 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25525 + 68] = mem[idx + _24385 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25525 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _25525 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    _29001 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29001] = 30
                    mem[_29001 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply))
                    _30175 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _30175 + 68] = mem[idx + _29001 + 32]
                        idx = idx + 32
                        continue 
                    mem[_30175 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _30175 + -mem[64] + 100
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _23473 = mem[64]
                mem[64] = mem[64] + 64
                mem[_23473] = 30
                mem[_23473 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    _24384 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _24384 + 68] = mem[idx + _23473 + 32]
                        idx = idx + 32
                        continue 
                    mem[_24384 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _24384 + -mem[64] + 100
                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _27675 = mem[64]
                mem[64] = mem[64] + 64
                mem[_27675] = 30
                mem[_27675 + 32] = 'SafeMath: subtraction overflow'
                if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    _29000 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _29000 + 68] = mem[idx + _27675 + 32]
                        idx = idx + 32
                        continue 
                    mem[_29000 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _29000 + -mem[64] + 100
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                    revert with 0, 17
                _32516 = mem[64]
                mem[64] = mem[64] + 64
                mem[_32516] = 30
                mem[_32516 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                _33552 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _33552 + 68] = mem[idx + _32516 + 32]
                    idx = idx + 32
                    continue 
                mem[_33552 + 98] = 0
                revert with memory
                  from mem[64]
                   len _33552 + -mem[64] + 100
            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                _23472 = mem[64]
                mem[64] = mem[64] + 64
                mem[_23472] = 30
                mem[_23472 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    _24383 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _24383 + 68] = mem[idx + _23472 + 32]
                        idx = idx + 32
                        continue 
                    mem[_24383 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _24383 + -mem[64] + 100
                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _27673 = mem[64]
                mem[64] = mem[64] + 64
                mem[_27673] = 30
                mem[_27673 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    _28999 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _28999 + 68] = mem[idx + _27673 + 32]
                        idx = idx + 32
                        continue 
                    mem[_28999 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _28999 + -mem[64] + 100
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _32514 = mem[64]
                mem[64] = mem[64] + 64
                mem[_32514] = 30
                mem[_32514 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                _33551 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _33551 + 68] = mem[idx + _32514 + 32]
                    idx = idx + 32
                    continue 
                mem[_33551 + 98] = 0
                revert with memory
                  from mem[64]
                   len _33551 + -mem[64] + 100
            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            _26498 = mem[64]
            mem[64] = mem[64] + 64
            mem[_26498] = 30
            mem[_26498 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                _27672 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _27672 + 68] = mem[idx + _26498 + 32]
                    idx = idx + 32
                    continue 
                mem[_27672 + 98] = 0
                revert with memory
                  from mem[64]
                   len _27672 + -mem[64] + 100
            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            _31306 = mem[64]
            mem[64] = mem[64] + 64
            mem[_31306] = 30
            mem[_31306 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                _32513 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _32513 + 68] = mem[idx + _31306 + 32]
                    idx = idx + 32
                    continue 
                mem[_32513 + 98] = 0
                revert with memory
                  from mem[64]
                   len _32513 + -mem[64] + 100
            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            _35260 = mem[64]
            mem[64] = mem[64] + 64
            mem[_35260] = 30
            mem[_35260 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
            _35907 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _35907 + 68] = mem[idx + _35260 + 32]
                idx = idx + 32
                continue 
            mem[_35907 + 98] = 0
            revert with memory
              from mem[64]
               len _35907 + -mem[64] + 100
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if t >= stor15 / totalSupply:
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            return 0
                        if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * t / s)
                    if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _BURN_FEE / stor13 / 100 * t / s)
                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s)
                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s))
                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
            if arg1 and t / s > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * t / s / arg1 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _TAX_FEE / stor13 / 100:
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s))
                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
            if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _TAX_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _BURN_FEE / stor13 / 100:
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s))
                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
            if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s))
            if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                revert with 0, 17
            if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                revert with 0, 17
            if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                revert with 0, 17
            return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if not arg1:
            if not arg1 * _TAX_FEE / stor13 / 100:
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        return 0
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply)
                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply)
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
            if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _TAX_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _BURN_FEE / stor13 / 100:
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply)
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                    revert with 0, 17
                return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
        if arg1 and stor15 / totalSupply > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * _TAX_FEE / stor13 / 100:
            if not arg1 * _BURN_FEE / stor13 / 100:
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor15 / totalSupply)
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < 0:
                    revert with 0, 17
                if 0 > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                if 0 > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 > arg1 * stor15 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor15 / totalSupply < 0:
                revert with 0, 17
            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
            revert with 0, 17
        if not arg1 * _TAX_FEE / stor13 / 100:
            revert with 0, 18
        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * _BURN_FEE / stor13 / 100:
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                    revert with 0, 17
                if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply))
            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                revert with 0, 17
            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
            revert with 0, 17
        if not arg1 * _BURN_FEE / stor13 / 100:
            revert with 0, 18
        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * _CHARITY_FEE / stor13 / 100:
            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                revert with 0, 17
            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
            revert with 0, 17
        if not arg1 * _CHARITY_FEE / stor13 / 100:
            revert with 0, 18
        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
            revert with 0, 17
        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
            revert with 0, 17
        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
            revert with 0, 17
        return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
    if not arg1:
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not stor13:
            revert with 0, 'SafeMath: division by zero', 0
        mem[160] = 26
        mem[192] = 'SafeMath: division by zero'
        if not arg1:
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not stor13:
                revert with 0, 'SafeMath: division by zero', 0
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor13:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0 / stor13 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1 - (0 / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor13 / 100) < 0 / stor13 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1 - (2 * 0 / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (2 * 0 / stor13 / 100) < 0 / stor13 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor15
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _19242 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19242] = 26
                        mem[_19242 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19336 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19336 + 68] = mem[idx + _19242 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19336 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19336 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor13 / 100:
                                return 0
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _20522 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20522] = 30
                                mem[_20522 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20746 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20746 + 68] = mem[idx + _20522 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20746 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20746 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _21858 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21858] = 30
                                mem[_21858 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _22363 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22363 + 68] = mem[idx + _21858 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22363 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22363 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24947 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24947] = 30
                                mem[_24947 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _25883 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25883 + 68] = mem[idx + _24947 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25883 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25883 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21342 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21342] = 30
                                mem[_21342 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21857 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21857 + 68] = mem[idx + _21342 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21857 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21857 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _24003 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24003] = 30
                                mem[_24003 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _24946 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24946 + 68] = mem[idx + _24003 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24946 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24946 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _28371 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28371] = 30
                                mem[_28371 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29482 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29482 + 68] = mem[idx + _28371 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29482 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29482 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _23070 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23070] = 30
                            mem[_23070 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _24002 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24002 + 68] = mem[idx + _23070 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24002 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24002 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27062 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27062] = 30
                            mem[_27062 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _28370 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28370 + 68] = mem[idx + _27062 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28370 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28370 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31934 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31934] = 30
                            mem[_31934 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _33066 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _33066 + 68] = mem[idx + _31934 + 32]
                                idx = idx + 32
                                continue 
                            mem[_33066 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _33066 + -mem[64] + 100
                        if arg1 and stor15 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _20520 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20520] = 30
                            mem[_20520 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _20745 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20745 + 68] = mem[idx + _20520 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20745 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20745 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _21855 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21855] = 30
                            mem[_21855 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22361 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22361 + 68] = mem[idx + _21855 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22361 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22361 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24944 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24944] = 30
                            mem[_24944 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _25882 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25882 + 68] = mem[idx + _24944 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25882 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25882 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21341 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21341] = 30
                            mem[_21341 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _21854 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21854 + 68] = mem[idx + _21341 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21854 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21854 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24000 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24000] = 30
                            mem[_24000 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _24943 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24943 + 68] = mem[idx + _24000 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24943 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24943 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _28368 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28368] = 30
                            mem[_28368 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _29480 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29480 + 68] = mem[idx + _28368 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29480 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29480 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _23069 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23069] = 30
                            mem[_23069 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23999 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23999 + 68] = mem[idx + _23069 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23999 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23999 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27060 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27060] = 30
                            mem[_27060 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _28367 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28367 + 68] = mem[idx + _27060 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28367 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28367 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31931 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31931] = 30
                            mem[_31931 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _33064 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _33064 + 68] = mem[idx + _31931 + 32]
                                idx = idx + 32
                                continue 
                            mem[_33064 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _33064 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25881 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25881] = 30
                        mem[_25881 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _27059 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27059 + 68] = mem[idx + _25881 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27059 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27059 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _30573 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30573] = 30
                        mem[_30573 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _31930 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31930 + 68] = mem[idx + _30573 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31930 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31930 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _34831 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34831] = 30
                        mem[_34831 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _35684 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35684 + 68] = mem[idx + _34831 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35684 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35684 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _19337 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19337] = 30
                        mem[_19337 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _19417 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19417 + 68] = mem[idx + _19337 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19417 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19417 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _19770 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19770] = 30
                        mem[_19770 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _19818 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19818 + 68] = mem[idx + _19770 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19818 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19818 + -mem[64] + 100
                    _19338 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19338] = 26
                    mem[_19338 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19418 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19418 + 68] = mem[idx + _19338 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19418 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19418 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor13 / 100:
                            return 0
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _20750 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20750] = 30
                            mem[_20750 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _20917 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20917 + 68] = mem[idx + _20750 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20917 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20917 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _22369 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22369] = 30
                            mem[_22369 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _23073 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23073 + 68] = mem[idx + _22369 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23073 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23073 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25889 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25889] = 30
                            mem[_25889 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _27066 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27066 + 68] = mem[idx + _25889 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27066 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27066 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21862 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21862] = 30
                            mem[_21862 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _22368 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22368 + 68] = mem[idx + _21862 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22368 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22368 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24953 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24953] = 30
                            mem[_24953 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _25888 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25888 + 68] = mem[idx + _24953 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25888 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25888 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29488 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29488] = 30
                            mem[_29488 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30577 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30577 + 68] = mem[idx + _29488 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30577 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30577 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _24006 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24006] = 30
                        mem[_24006 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            _24952 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24952 + 68] = mem[idx + _24006 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24952 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24952 + -mem[64] + 100
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28377 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28377] = 30
                        mem[_28377 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            _29487 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29487 + 68] = mem[idx + _28377 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29487 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29487 + -mem[64] + 100
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _33072 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33072] = 30
                        mem[_33072 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33745 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33745 + 68] = mem[idx + _33072 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33745 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33745 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _20748 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20748] = 30
                        mem[_20748 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _20916 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20916 + 68] = mem[idx + _20748 + 32]
                                idx = idx + 32
                                continue 
                            mem[_20916 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20916 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _22366 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22366] = 30
                        mem[_22366 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _23071 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23071 + 68] = mem[idx + _22366 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23071 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23071 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _25886 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25886] = 30
                        mem[_25886 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor15 / totalSupply:
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _27065 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27065 + 68] = mem[idx + _25886 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27065 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27065 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _21861 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21861] = 30
                        mem[_21861 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _22365 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22365 + 68] = mem[idx + _21861 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22365 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22365 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _24950 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24950] = 30
                        mem[_24950 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _25885 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25885 + 68] = mem[idx + _24950 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25885 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25885 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _29485 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29485] = 30
                        mem[_29485 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _30575 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30575 + 68] = mem[idx + _29485 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30575 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30575 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _24005 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24005] = 30
                        mem[_24005 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24949 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24949 + 68] = mem[idx + _24005 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24949 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24949 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28375 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28375] = 30
                        mem[_28375 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _29484 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29484 + 68] = mem[idx + _28375 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29484 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29484 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _33069 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33069] = 30
                        mem[_33069 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33743 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33743 + 68] = mem[idx + _33069 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33743 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33743 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _27064 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27064] = 30
                    mem[_27064 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _28374 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28374 + 68] = mem[idx + _27064 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28374 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28374 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _31937 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31937] = 30
                    mem[_31937 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        _33068 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33068 + 68] = mem[idx + _31937 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33068 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33068 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _35687 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35687] = 30
                    mem[_35687 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    _35976 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35976 + 68] = mem[idx + _35687 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35976 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35976 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor15 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if 0 / stor13 / 100:
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                            return 0
                        else:
                            return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if 0 / stor13 / 100:
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                        return 0
                    else:
                        return 0
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                else:
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
            else:
                if arg1 and _CHARITY_FEE > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / arg1 != _CHARITY_FEE:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor13:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0 / stor13 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1 - (0 / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor13 / 100) < 0 / stor13 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor13 / 100 > arg1 - (2 * 0 / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (2 * 0 / stor13 / 100) < arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor15
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _19241 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19241] = 26
                        mem[_19241 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19333 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19333 + 68] = mem[idx + _19241 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19333 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19333 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    return 0
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20514 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20514] = 30
                                mem[_20514 + 32] = 'SafeMath: subtraction overflow'
                                _21842 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21842] = 30
                                mem[_21842 + 32] = 'SafeMath: subtraction overflow'
                                _24922 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24922] = 30
                                mem[_24922 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                    if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _25866 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25866 + 68] = mem[idx + _24922 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25866 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25866 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    _20513 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20513] = 30
                                    mem[_20513 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                        _20739 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20739 + 68] = mem[idx + _20513 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20739 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20739 + -mem[64] + 100
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _21840 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21840] = 30
                                    mem[_21840 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        _22350 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22350 + 68] = mem[idx + _21840 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22350 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22350 + -mem[64] + 100
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24920 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24920] = 30
                                    mem[_24920 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25865 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25865 + 68] = mem[idx + _24920 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25865 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25865 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21331 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21331] = 30
                                mem[_21331 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21839 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21839 + 68] = mem[idx + _21331 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21839 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21839 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23982 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23982] = 30
                                mem[_23982 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _24919 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24919 + 68] = mem[idx + _23982 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24919 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24919 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _28343 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28343] = 30
                                mem[_28343 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29459 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29459 + 68] = mem[idx + _28343 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29459 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29459 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21330 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21330] = 30
                                mem[_21330 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21838 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21838 + 68] = mem[idx + _21330 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21838 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21838 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23980 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23980] = 30
                                mem[_23980 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _24918 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24918 + 68] = mem[idx + _23980 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24918 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24918 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _28341 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28341] = 30
                                mem[_28341 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29458 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29458 + 68] = mem[idx + _28341 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29458 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29458 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _23057 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23057] = 30
                            mem[_23057 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _23979 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23979 + 68] = mem[idx + _23057 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23979 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23979 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27041 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27041] = 30
                            mem[_27041 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _28340 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28340 + 68] = mem[idx + _27041 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28340 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28340 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31910 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31910] = 30
                            mem[_31910 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _33043 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _33043 + 68] = mem[idx + _31910 + 32]
                                idx = idx + 32
                                continue 
                            mem[_33043 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _33043 + -mem[64] + 100
                        if arg1 and stor15 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20511 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20511] = 30
                                mem[_20511 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20738 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20738 + 68] = mem[idx + _20511 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20738 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20738 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _21836 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21836] = 30
                                mem[_21836 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _22348 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22348 + 68] = mem[idx + _21836 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22348 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22348 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24916 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24916] = 30
                                mem[_24916 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _25864 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25864 + 68] = mem[idx + _24916 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25864 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25864 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21329 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21329] = 30
                            mem[_21329 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _21835 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21835 + 68] = mem[idx + _21329 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21835 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21835 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _23977 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23977] = 30
                            mem[_23977 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _24915 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24915 + 68] = mem[idx + _23977 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24915 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24915 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _28338 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28338] = 30
                            mem[_28338 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _29456 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29456 + 68] = mem[idx + _28338 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29456 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29456 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21328 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21328] = 30
                                mem[_21328 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _21834 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21834 + 68] = mem[idx + _21328 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21834 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21834 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23975 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23975] = 30
                                mem[_23975 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    _24914 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24914 + 68] = mem[idx + _23975 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24914 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24914 + -mem[64] + 100
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                _28336 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28336] = 30
                                mem[_28336 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _29455 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29455 + 68] = mem[idx + _28336 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29455 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29455 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _23056 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23056] = 30
                            mem[_23056 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23974 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23974 + 68] = mem[idx + _23056 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23974 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23974 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27039 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27039] = 30
                            mem[_27039 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _28335 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28335 + 68] = mem[idx + _27039 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28335 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28335 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _31907 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31907] = 30
                            mem[_31907 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _33040 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _33040 + 68] = mem[idx + _31907 + 32]
                                idx = idx + 32
                                continue 
                            mem[_33040 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _33040 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _23055 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23055] = 30
                            mem[_23055 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23973 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23973 + 68] = mem[idx + _23055 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23973 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23973 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27037 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27037] = 30
                            mem[_27037 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _28334 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28334 + 68] = mem[idx + _27037 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28334 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28334 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31905 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31905] = 30
                            mem[_31905 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _33039 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _33039 + 68] = mem[idx + _31905 + 32]
                                idx = idx + 32
                                continue 
                            mem[_33039 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _33039 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25863 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25863] = 30
                        mem[_25863 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _27036 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27036 + 68] = mem[idx + _25863 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27036 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27036 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _30554 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30554] = 30
                        mem[_30554 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _31904 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31904 + 68] = mem[idx + _30554 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31904 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31904 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _34811 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34811] = 30
                        mem[_34811 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _35666 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35666 + 68] = mem[idx + _34811 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35666 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35666 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _19334 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19334] = 30
                        mem[_19334 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _19414 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19414 + 68] = mem[idx + _19334 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19414 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19414 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _19767 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19767] = 30
                        mem[_19767 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _19815 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19815 + 68] = mem[idx + _19767 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19815 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19815 + -mem[64] + 100
                    _19335 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19335] = 26
                    mem[_19335 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19415 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19415 + 68] = mem[idx + _19335 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19415 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19415 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                return 0
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20744 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20744] = 30
                            mem[_20744 + 32] = 'SafeMath: subtraction overflow'
                            _22360 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22360] = 30
                            mem[_22360 + 32] = 'SafeMath: subtraction overflow'
                            _25876 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25876] = 30
                            mem[_25876 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _27046 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27046 + 68] = mem[idx + _25876 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27046 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27046 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20743 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20743] = 30
                                mem[_20743 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20914 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20914 + 68] = mem[idx + _20743 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20914 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20914 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _22358 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22358] = 30
                                mem[_22358 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _23061 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23061 + 68] = mem[idx + _22358 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23061 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23061 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25874 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25874] = 30
                                mem[_25874 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _27045 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27045 + 68] = mem[idx + _25874 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27045 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27045 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21847 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21847] = 30
                            mem[_21847 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _22357 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22357 + 68] = mem[idx + _21847 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22357 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22357 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24932 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24932] = 30
                            mem[_24932 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _25873 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25873 + 68] = mem[idx + _24932 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25873 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25873 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _29471 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29471] = 30
                            mem[_29471 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30560 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30560 + 68] = mem[idx + _29471 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30560 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30560 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21846 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21846] = 30
                            mem[_21846 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _22356 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22356 + 68] = mem[idx + _21846 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22356 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22356 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24930 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24930] = 30
                            mem[_24930 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _25872 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25872 + 68] = mem[idx + _24930 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25872 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25872 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29469 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29469] = 30
                            mem[_29469 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30559 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30559 + 68] = mem[idx + _29469 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30559 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30559 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23986 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23986] = 30
                        mem[_23986 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            _24929 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24929 + 68] = mem[idx + _23986 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24929 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24929 + -mem[64] + 100
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28351 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28351] = 30
                        mem[_28351 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            _29468 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29468 + 68] = mem[idx + _28351 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29468 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29468 + -mem[64] + 100
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _33052 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33052] = 30
                        mem[_33052 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33736 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33736 + 68] = mem[idx + _33052 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33736 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33736 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _20741 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20741] = 30
                            mem[_20741 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _20913 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20913 + 68] = mem[idx + _20741 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20913 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20913 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _22354 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22354] = 30
                            mem[_22354 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _23059 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23059 + 68] = mem[idx + _22354 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23059 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23059 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25870 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25870] = 30
                            mem[_25870 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _27044 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27044 + 68] = mem[idx + _25870 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27044 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27044 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21845 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21845] = 30
                        mem[_21845 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _22353 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22353 + 68] = mem[idx + _21845 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22353 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22353 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _24927 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24927] = 30
                        mem[_24927 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _25869 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25869 + 68] = mem[idx + _24927 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25869 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25869 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _29466 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29466] = 30
                        mem[_29466 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                            if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _30557 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30557 + 68] = mem[idx + _29466 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30557 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30557 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21844 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21844] = 30
                            mem[_21844 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _22352 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22352 + 68] = mem[idx + _21844 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22352 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22352 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24925 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24925] = 30
                            mem[_24925 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _25868 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25868 + 68] = mem[idx + _24925 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25868 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25868 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _29464 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29464] = 30
                            mem[_29464 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _30556 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30556 + 68] = mem[idx + _29464 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30556 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30556 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23985 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23985] = 30
                        mem[_23985 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24924 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24924 + 68] = mem[idx + _23985 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24924 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24924 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28349 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28349] = 30
                        mem[_28349 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _29463 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29463 + 68] = mem[idx + _28349 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29463 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29463 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _33049 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33049] = 30
                        mem[_33049 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33733 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33733 + 68] = mem[idx + _33049 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33733 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33733 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _23984 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23984] = 30
                        mem[_23984 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24923 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24923 + 68] = mem[idx + _23984 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24923 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24923 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28347 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28347] = 30
                        mem[_28347 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _29462 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29462 + 68] = mem[idx + _28347 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29462 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29462 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _33047 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33047] = 30
                        mem[_33047 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33732 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33732 + 68] = mem[idx + _33047 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33732 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33732 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _27043 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27043] = 30
                    mem[_27043 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _28346 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28346 + 68] = mem[idx + _27043 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28346 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28346 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _31914 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31914] = 30
                    mem[_31914 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        _33046 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33046 + 68] = mem[idx + _31914 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33046 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33046 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _35670 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35670] = 30
                    mem[_35670 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    _35972 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35972 + 68] = mem[idx + _35670 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35972 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35972 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor15 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not 0 / stor13 / 100:
                            if arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not 0 / stor13 / 100:
                        if arg1 * _CHARITY_FEE / stor13 / 100:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                    else:
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                else:
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
        else:
            if arg1 and _BURN_FEE > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * _BURN_FEE / arg1 != _BURN_FEE:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not stor13:
                revert with 0, 'SafeMath: division by zero', 0
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor13:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0 / stor13 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor13 / 100 > arg1 - (0 / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor13 / 100) < arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1 - (0 / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100) < 0 / stor13 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor15
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _19240 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19240] = 26
                        mem[_19240 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19330 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19330 + 68] = mem[idx + _19240 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19330 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19330 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor13 / 100:
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    if not 0 / stor13 / 100:
                                        return 0
                                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20505 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20505] = 30
                                    mem[_20505 + 32] = 'SafeMath: subtraction overflow'
                                    _21820 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21820] = 30
                                    mem[_21820 + 32] = 'SafeMath: subtraction overflow'
                                    _24887 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24887] = 30
                                    mem[_24887 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply <= 0:
                                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25842 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25842 + 68] = mem[idx + _24887 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25842 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25842 + -mem[64] + 100
                                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    _20504 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20504] = 30
                                    mem[_20504 + 32] = 'SafeMath: subtraction overflow'
                                    _21819 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21819] = 30
                                    mem[_21819 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                        _22330 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22330 + 68] = mem[idx + _21819 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22330 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22330 + -mem[64] + 100
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _24885 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24885] = 30
                                    mem[_24885 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25841 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25841 + 68] = mem[idx + _24885 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25841 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25841 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21315 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21315] = 30
                                mem[_21315 + 32] = 'SafeMath: subtraction overflow'
                                _23950 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23950] = 30
                                mem[_23950 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _24884 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24884 + 68] = mem[idx + _23950 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24884 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24884 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _28302 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28302] = 30
                                mem[_28302 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29427 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29427 + 68] = mem[idx + _28302 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29427 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29427 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    _20503 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20503] = 30
                                    mem[_20503 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                        _20730 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20730 + 68] = mem[idx + _20503 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20730 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20730 + -mem[64] + 100
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _21817 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21817] = 30
                                    mem[_21817 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        _22329 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22329 + 68] = mem[idx + _21817 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22329 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22329 + -mem[64] + 100
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24882 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24882] = 30
                                    mem[_24882 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25840 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25840 + 68] = mem[idx + _24882 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25840 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25840 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21314 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21314] = 30
                                mem[_21314 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21816 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21816 + 68] = mem[idx + _21314 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21816 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21816 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23948 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23948] = 30
                                mem[_23948 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _24881 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24881 + 68] = mem[idx + _23948 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24881 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24881 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _28300 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28300] = 30
                                mem[_28300 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29425 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29425 + 68] = mem[idx + _28300 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29425 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29425 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21313 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21313] = 30
                                mem[_21313 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21815 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21815 + 68] = mem[idx + _21313 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21815 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21815 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23946 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23946] = 30
                                mem[_23946 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _24880 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24880 + 68] = mem[idx + _23946 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24880 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24880 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _28298 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28298] = 30
                                mem[_28298 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29424 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29424 + 68] = mem[idx + _28298 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29424 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29424 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _23037 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23037] = 30
                            mem[_23037 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _23945 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23945 + 68] = mem[idx + _23037 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23945 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23945 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27007 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27007] = 30
                            mem[_27007 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _28297 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28297 + 68] = mem[idx + _27007 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28297 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28297 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31873 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31873] = 30
                            mem[_31873 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _33008 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _33008 + 68] = mem[idx + _31873 + 32]
                                idx = idx + 32
                                continue 
                            mem[_33008 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _33008 + -mem[64] + 100
                        if arg1 and stor15 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    _20501 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20501] = 30
                                    mem[_20501 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor15 / totalSupply:
                                        _20729 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20729 + 68] = mem[idx + _20501 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20729 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20729 + -mem[64] + 100
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _21813 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21813] = 30
                                    mem[_21813 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor15 / totalSupply:
                                        _22327 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22327 + 68] = mem[idx + _21813 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22327 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22327 + -mem[64] + 100
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24878 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24878] = 30
                                    mem[_24878 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor15 / totalSupply:
                                        if arg1 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor15 / totalSupply)
                                    _25839 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25839 + 68] = mem[idx + _24878 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25839 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25839 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21312 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21312] = 30
                                mem[_21312 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21812 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21812 + 68] = mem[idx + _21312 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21812 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21812 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23943 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23943] = 30
                                mem[_23943 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _24877 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24877 + 68] = mem[idx + _23943 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24877 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24877 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _28295 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28295] = 30
                                mem[_28295 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _29422 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29422 + 68] = mem[idx + _28295 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29422 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29422 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21311 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21311] = 30
                                mem[_21311 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21811 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21811 + 68] = mem[idx + _21311 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21811 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21811 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23941 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23941] = 30
                                mem[_23941 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _24876 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24876 + 68] = mem[idx + _23941 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24876 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24876 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _28293 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28293] = 30
                                mem[_28293 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _29421 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29421 + 68] = mem[idx + _28293 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29421 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29421 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _23036 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23036] = 30
                            mem[_23036 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _23940 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23940 + 68] = mem[idx + _23036 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23940 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23940 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _27005 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27005] = 30
                            mem[_27005 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _28292 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28292 + 68] = mem[idx + _27005 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28292 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28292 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31870 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31870] = 30
                            mem[_31870 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _33005 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _33005 + 68] = mem[idx + _31870 + 32]
                                idx = idx + 32
                                continue 
                            mem[_33005 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _33005 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _21310 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21310] = 30
                                mem[_21310 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _21810 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21810 + 68] = mem[idx + _21310 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21810 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21810 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23938 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23938] = 30
                                mem[_23938 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    _24875 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24875 + 68] = mem[idx + _23938 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24875 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24875 + -mem[64] + 100
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                _28290 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28290] = 30
                                mem[_28290 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _29420 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29420 + 68] = mem[idx + _28290 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29420 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29420 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _23035 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23035] = 30
                            mem[_23035 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23937 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23937 + 68] = mem[idx + _23035 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23937 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23937 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27003 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27003] = 30
                            mem[_27003 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _28289 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28289 + 68] = mem[idx + _27003 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28289 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28289 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _31868 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31868] = 30
                            mem[_31868 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _33003 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _33003 + 68] = mem[idx + _31868 + 32]
                                idx = idx + 32
                                continue 
                            mem[_33003 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _33003 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _23034 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23034] = 30
                            mem[_23034 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23936 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23936 + 68] = mem[idx + _23034 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23936 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23936 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27001 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27001] = 30
                            mem[_27001 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _28288 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28288 + 68] = mem[idx + _27001 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28288 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28288 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31866 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31866] = 30
                            mem[_31866 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _33002 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _33002 + 68] = mem[idx + _31866 + 32]
                                idx = idx + 32
                                continue 
                            mem[_33002 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _33002 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25838 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25838] = 30
                        mem[_25838 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _27000 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27000 + 68] = mem[idx + _25838 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27000 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27000 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _30528 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30528] = 30
                        mem[_30528 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _31865 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31865 + 68] = mem[idx + _30528 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31865 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31865 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _34783 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34783] = 30
                        mem[_34783 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _35639 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35639 + 68] = mem[idx + _34783 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35639 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35639 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _19331 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19331] = 30
                        mem[_19331 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _19411 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19411 + 68] = mem[idx + _19331 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19411 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19411 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _19764 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19764] = 30
                        mem[_19764 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _19812 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19812 + 68] = mem[idx + _19764 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19812 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19812 + -mem[64] + 100
                    _19332 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19332] = 26
                    mem[_19332 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19412 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19412 + 68] = mem[idx + _19332 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19412 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19412 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    return 0
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20737 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20737] = 30
                                mem[_20737 + 32] = 'SafeMath: subtraction overflow'
                                _22342 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22342] = 30
                                mem[_22342 + 32] = 'SafeMath: subtraction overflow'
                                _25856 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25856] = 30
                                mem[_25856 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= 0:
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _27013 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27013 + 68] = mem[idx + _25856 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27013 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27013 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _20736 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20736] = 30
                                mem[_20736 + 32] = 'SafeMath: subtraction overflow'
                                _22341 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22341] = 30
                                mem[_22341 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _23043 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23043 + 68] = mem[idx + _22341 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23043 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23043 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _25854 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25854] = 30
                                mem[_25854 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _27012 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27012 + 68] = mem[idx + _25854 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27012 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27012 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21827 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21827] = 30
                            mem[_21827 + 32] = 'SafeMath: subtraction overflow'
                            _24902 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24902] = 30
                            mem[_24902 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _25853 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25853 + 68] = mem[idx + _24902 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25853 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25853 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29444 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29444] = 30
                            mem[_29444 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30537 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30537 + 68] = mem[idx + _29444 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30537 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30537 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _20735 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20735] = 30
                                mem[_20735 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20907 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20907 + 68] = mem[idx + _20735 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20907 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20907 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _22339 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22339] = 30
                                mem[_22339 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _23042 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23042 + 68] = mem[idx + _22339 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23042 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23042 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25851 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25851] = 30
                                mem[_25851 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _27011 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27011 + 68] = mem[idx + _25851 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27011 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27011 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21826 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21826] = 30
                            mem[_21826 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _22338 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22338 + 68] = mem[idx + _21826 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22338 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22338 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24900 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24900] = 30
                            mem[_24900 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _25850 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25850 + 68] = mem[idx + _24900 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25850 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25850 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _29442 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29442] = 30
                            mem[_29442 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30535 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30535 + 68] = mem[idx + _29442 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30535 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30535 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21825 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21825] = 30
                            mem[_21825 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _22337 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22337 + 68] = mem[idx + _21825 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22337 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22337 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24898 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24898] = 30
                            mem[_24898 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _25849 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25849 + 68] = mem[idx + _24898 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25849 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25849 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29440 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29440] = 30
                            mem[_29440 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30534 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30534 + 68] = mem[idx + _29440 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30534 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30534 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23954 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23954] = 30
                        mem[_23954 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            _24897 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24897 + 68] = mem[idx + _23954 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24897 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24897 + -mem[64] + 100
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28312 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28312] = 30
                        mem[_28312 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            _29439 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29439 + 68] = mem[idx + _28312 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29439 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29439 + -mem[64] + 100
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _33020 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33020] = 30
                        mem[_33020 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33724 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33724 + 68] = mem[idx + _33020 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33724 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33724 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _20733 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20733] = 30
                                mem[_20733 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20906 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20906 + 68] = mem[idx + _20733 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20906 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20906 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _22335 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22335] = 30
                                mem[_22335 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _23040 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23040 + 68] = mem[idx + _22335 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23040 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23040 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25847 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25847] = 30
                                mem[_25847 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _27010 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27010 + 68] = mem[idx + _25847 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27010 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27010 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21824 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21824] = 30
                            mem[_21824 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22334 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22334 + 68] = mem[idx + _21824 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22334 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22334 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24895 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24895] = 30
                            mem[_24895 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _25846 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25846 + 68] = mem[idx + _24895 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25846 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25846 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _29437 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29437] = 30
                            mem[_29437 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _30532 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30532 + 68] = mem[idx + _29437 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30532 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30532 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21823 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21823] = 30
                            mem[_21823 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22333 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22333 + 68] = mem[idx + _21823 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22333 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22333 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24893 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24893] = 30
                            mem[_24893 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _25845 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25845 + 68] = mem[idx + _24893 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25845 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25845 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29435 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29435] = 30
                            mem[_29435 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _30531 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30531 + 68] = mem[idx + _29435 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30531 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30531 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23953 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23953] = 30
                        mem[_23953 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _24892 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24892 + 68] = mem[idx + _23953 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24892 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24892 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _28310 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28310] = 30
                        mem[_28310 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _29434 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29434 + 68] = mem[idx + _28310 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29434 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29434 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _33017 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33017] = 30
                        mem[_33017 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33721 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33721 + 68] = mem[idx + _33017 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33721 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33721 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            _21822 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21822] = 30
                            mem[_21822 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _22332 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22332 + 68] = mem[idx + _21822 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22332 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22332 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24890 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24890] = 30
                            mem[_24890 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _25844 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25844 + 68] = mem[idx + _24890 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25844 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25844 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _29432 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29432] = 30
                            mem[_29432 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _30530 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30530 + 68] = mem[idx + _29432 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30530 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30530 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23952 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23952] = 30
                        mem[_23952 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24889 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24889 + 68] = mem[idx + _23952 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24889 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24889 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28308 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28308] = 30
                        mem[_28308 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _29431 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29431 + 68] = mem[idx + _28308 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29431 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29431 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _33015 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33015] = 30
                        mem[_33015 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33719 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33719 + 68] = mem[idx + _33015 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33719 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33719 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _23951 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23951] = 30
                        mem[_23951 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24888 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24888 + 68] = mem[idx + _23951 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24888 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24888 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28306 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28306] = 30
                        mem[_28306 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _29430 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29430 + 68] = mem[idx + _28306 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29430 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29430 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _33013 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33013] = 30
                        mem[_33013 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33718 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33718 + 68] = mem[idx + _33013 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33718 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33718 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _27009 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27009] = 30
                    mem[_27009 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _28305 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28305 + 68] = mem[idx + _27009 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28305 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28305 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _31878 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31878] = 30
                    mem[_31878 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        _33012 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33012 + 68] = mem[idx + _31878 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33012 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33012 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _35644 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35644] = 30
                    mem[_35644 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    _35967 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35967 + 68] = mem[idx + _35644 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35967 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35967 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor15 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not 0 / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if 0 / stor13 / 100:
                                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not 0 / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if 0 / stor13 / 100:
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                else:
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
            else:
                if arg1 and _CHARITY_FEE > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / arg1 != _CHARITY_FEE:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor13:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0 / stor13 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor13 / 100 > arg1 - (0 / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor13 / 100) < arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor13 / 100 > arg1 - (0 / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100) < arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor15
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _19239 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19239] = 26
                        mem[_19239 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19327 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19327 + 68] = mem[idx + _19239 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19327 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19327 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor13 / 100:
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        return 0
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20492 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20492] = 30
                                    mem[_20492 + 32] = 'SafeMath: subtraction overflow'
                                    _21796 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21796] = 30
                                    mem[_21796 + 32] = 'SafeMath: subtraction overflow'
                                    _24844 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24844] = 30
                                    mem[_24844 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                        if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25815 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25815 + 68] = mem[idx + _24844 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25815 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25815 + -mem[64] + 100
                                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    _20491 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20491] = 30
                                    mem[_20491 + 32] = 'SafeMath: subtraction overflow'
                                    _21795 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21795] = 30
                                    mem[_21795 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                        _22306 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22306 + 68] = mem[idx + _21795 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22306 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22306 + -mem[64] + 100
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _24842 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24842] = 30
                                    mem[_24842 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25814 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25814 + 68] = mem[idx + _24842 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25814 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25814 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21293 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21293] = 30
                                mem[_21293 + 32] = 'SafeMath: subtraction overflow'
                                _23909 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23909] = 30
                                mem[_23909 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _24841 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24841 + 68] = mem[idx + _23909 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24841 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24841 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _28248 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28248] = 30
                                mem[_28248 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29390 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29390 + 68] = mem[idx + _28248 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29390 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29390 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    _20490 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20490] = 30
                                    mem[_20490 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                        _20721 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20721 + 68] = mem[idx + _20490 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20721 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20721 + -mem[64] + 100
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _21793 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21793] = 30
                                    mem[_21793 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        _22305 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22305 + 68] = mem[idx + _21793 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22305 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22305 + -mem[64] + 100
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24839 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24839] = 30
                                    mem[_24839 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25813 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25813 + 68] = mem[idx + _24839 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25813 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25813 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21292 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21292] = 30
                                mem[_21292 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21792 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21792 + 68] = mem[idx + _21292 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21792 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21792 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23907 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23907] = 30
                                mem[_23907 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _24838 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24838 + 68] = mem[idx + _23907 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24838 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24838 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _28246 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28246] = 30
                                mem[_28246 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29388 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29388 + 68] = mem[idx + _28246 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29388 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29388 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21291 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21291] = 30
                                mem[_21291 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21791 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21791 + 68] = mem[idx + _21291 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21791 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21791 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23905 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23905] = 30
                                mem[_23905 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _24837 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24837 + 68] = mem[idx + _23905 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24837 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24837 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _28244 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28244] = 30
                                mem[_28244 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29387 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29387 + 68] = mem[idx + _28244 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29387 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29387 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _23012 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23012] = 30
                            mem[_23012 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _23904 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23904 + 68] = mem[idx + _23012 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23904 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23904 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26963 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26963] = 30
                            mem[_26963 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _28243 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28243 + 68] = mem[idx + _26963 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28243 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28243 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31824 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31824] = 30
                            mem[_31824 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32965 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32965 + 68] = mem[idx + _31824 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32965 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32965 + -mem[64] + 100
                        if arg1 and stor15 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    _20488 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20488] = 30
                                    mem[_20488 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor15 / totalSupply:
                                        _20720 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20720 + 68] = mem[idx + _20488 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20720 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20720 + -mem[64] + 100
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _21789 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21789] = 30
                                    mem[_21789 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor15 / totalSupply:
                                        _22303 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22303 + 68] = mem[idx + _21789 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22303 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22303 + -mem[64] + 100
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24835 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24835] = 30
                                    mem[_24835 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor15 / totalSupply:
                                        if arg1 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor15 / totalSupply)
                                    _25812 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25812 + 68] = mem[idx + _24835 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25812 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25812 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21290 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21290] = 30
                                mem[_21290 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21788 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21788 + 68] = mem[idx + _21290 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21788 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21788 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23902 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23902] = 30
                                mem[_23902 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _24834 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24834 + 68] = mem[idx + _23902 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24834 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24834 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _28241 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28241] = 30
                                mem[_28241 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _29385 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29385 + 68] = mem[idx + _28241 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29385 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29385 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21289 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21289] = 30
                                mem[_21289 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21787 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21787 + 68] = mem[idx + _21289 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21787 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21787 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23900 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23900] = 30
                                mem[_23900 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _24833 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24833 + 68] = mem[idx + _23900 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24833 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24833 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _28239 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28239] = 30
                                mem[_28239 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _29384 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29384 + 68] = mem[idx + _28239 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29384 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29384 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _23011 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23011] = 30
                            mem[_23011 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _23899 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23899 + 68] = mem[idx + _23011 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23899 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23899 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _26961 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26961] = 30
                            mem[_26961 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _28238 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28238 + 68] = mem[idx + _26961 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28238 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28238 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31821 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31821] = 30
                            mem[_31821 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32962 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32962 + 68] = mem[idx + _31821 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32962 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32962 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21288 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21288] = 30
                                mem[_21288 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _21786 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21786 + 68] = mem[idx + _21288 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21786 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21786 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23897 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23897] = 30
                                mem[_23897 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    _24832 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24832 + 68] = mem[idx + _23897 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24832 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24832 + -mem[64] + 100
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                _28236 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28236] = 30
                                mem[_28236 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _29383 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29383 + 68] = mem[idx + _28236 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29383 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29383 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _23010 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23010] = 30
                            mem[_23010 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23896 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23896 + 68] = mem[idx + _23010 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23896 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23896 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26959 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26959] = 30
                            mem[_26959 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _28235 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28235 + 68] = mem[idx + _26959 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28235 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28235 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _31819 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31819] = 30
                            mem[_31819 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32960 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32960 + 68] = mem[idx + _31819 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32960 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32960 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _23009 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23009] = 30
                            mem[_23009 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23895 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23895 + 68] = mem[idx + _23009 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23895 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23895 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26957 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26957] = 30
                            mem[_26957 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _28234 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28234 + 68] = mem[idx + _26957 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28234 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28234 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31817 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31817] = 30
                            mem[_31817 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32959 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32959 + 68] = mem[idx + _31817 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32959 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32959 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25811 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25811] = 30
                        mem[_25811 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _26956 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26956 + 68] = mem[idx + _25811 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26956 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26956 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _30498 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30498] = 30
                        mem[_30498 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _31816 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31816 + 68] = mem[idx + _30498 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31816 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31816 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _34749 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34749] = 30
                        mem[_34749 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _35606 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35606 + 68] = mem[idx + _34749 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35606 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35606 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _19328 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19328] = 30
                        mem[_19328 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _19408 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19408 + 68] = mem[idx + _19328 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19408 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19408 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _19761 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19761] = 30
                        mem[_19761 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _19809 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19809 + 68] = mem[idx + _19761 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19809 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19809 + -mem[64] + 100
                    _19329 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19329] = 26
                    mem[_19329 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19409 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19409 + 68] = mem[idx + _19329 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19409 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19409 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    return 0
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20728 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20728] = 30
                                mem[_20728 + 32] = 'SafeMath: subtraction overflow'
                                _22318 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22318] = 30
                                mem[_22318 + 32] = 'SafeMath: subtraction overflow'
                                _25829 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25829] = 30
                                mem[_25829 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                    if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26969 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26969 + 68] = mem[idx + _25829 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26969 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26969 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20727 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20727] = 30
                                mem[_20727 + 32] = 'SafeMath: subtraction overflow'
                                _22317 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22317] = 30
                                mem[_22317 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _23018 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23018 + 68] = mem[idx + _22317 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23018 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23018 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _25827 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25827] = 30
                                mem[_25827 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26968 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26968 + 68] = mem[idx + _25827 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26968 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26968 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21803 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21803] = 30
                            mem[_21803 + 32] = 'SafeMath: subtraction overflow'
                            _24859 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24859] = 30
                            mem[_24859 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _25826 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25826 + 68] = mem[idx + _24859 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25826 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25826 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29407 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29407] = 30
                            mem[_29407 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30507 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30507 + 68] = mem[idx + _29407 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30507 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30507 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20726 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20726] = 30
                                mem[_20726 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20899 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20899 + 68] = mem[idx + _20726 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20899 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20899 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _22315 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22315] = 30
                                mem[_22315 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _23017 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23017 + 68] = mem[idx + _22315 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23017 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23017 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25824 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25824] = 30
                                mem[_25824 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26967 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26967 + 68] = mem[idx + _25824 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26967 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26967 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21802 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21802] = 30
                            mem[_21802 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _22314 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22314 + 68] = mem[idx + _21802 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22314 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22314 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24857 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24857] = 30
                            mem[_24857 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _25823 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25823 + 68] = mem[idx + _24857 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25823 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25823 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _29405 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29405] = 30
                            mem[_29405 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30505 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30505 + 68] = mem[idx + _29405 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30505 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30505 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21801 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21801] = 30
                            mem[_21801 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _22313 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22313 + 68] = mem[idx + _21801 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22313 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22313 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24855 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24855] = 30
                            mem[_24855 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _25822 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25822 + 68] = mem[idx + _24855 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25822 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25822 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29403 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29403] = 30
                            mem[_29403 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30504 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30504 + 68] = mem[idx + _29403 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30504 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30504 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23913 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23913] = 30
                        mem[_23913 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            _24854 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24854 + 68] = mem[idx + _23913 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24854 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24854 + -mem[64] + 100
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28258 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28258] = 30
                        mem[_28258 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            _29402 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29402 + 68] = mem[idx + _28258 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29402 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29402 + -mem[64] + 100
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32977 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32977] = 30
                        mem[_32977 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33710 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33710 + 68] = mem[idx + _32977 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33710 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33710 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20724 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20724] = 30
                                mem[_20724 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20898 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20898 + 68] = mem[idx + _20724 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20898 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20898 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _22311 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22311] = 30
                                mem[_22311 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _23015 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23015 + 68] = mem[idx + _22311 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23015 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23015 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25820 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25820] = 30
                                mem[_25820 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _26966 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26966 + 68] = mem[idx + _25820 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26966 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26966 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21800 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21800] = 30
                            mem[_21800 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22310 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22310 + 68] = mem[idx + _21800 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22310 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22310 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24852 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24852] = 30
                            mem[_24852 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _25819 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25819 + 68] = mem[idx + _24852 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25819 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25819 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _29400 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29400] = 30
                            mem[_29400 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _30502 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30502 + 68] = mem[idx + _29400 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30502 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30502 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21799 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21799] = 30
                            mem[_21799 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22309 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22309 + 68] = mem[idx + _21799 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22309 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22309 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24850 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24850] = 30
                            mem[_24850 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _25818 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25818 + 68] = mem[idx + _24850 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25818 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25818 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29398 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29398] = 30
                            mem[_29398 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _30501 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30501 + 68] = mem[idx + _29398 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30501 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30501 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23912 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23912] = 30
                        mem[_23912 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _24849 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24849 + 68] = mem[idx + _23912 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24849 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24849 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _28256 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28256] = 30
                        mem[_28256 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _29397 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29397 + 68] = mem[idx + _28256 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29397 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29397 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32974 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32974] = 30
                        mem[_32974 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33707 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33707 + 68] = mem[idx + _32974 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33707 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33707 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21798 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21798] = 30
                            mem[_21798 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _22308 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22308 + 68] = mem[idx + _21798 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22308 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22308 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24847 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24847] = 30
                            mem[_24847 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _25817 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25817 + 68] = mem[idx + _24847 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25817 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25817 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _29395 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29395] = 30
                            mem[_29395 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _30500 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30500 + 68] = mem[idx + _29395 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30500 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30500 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23911 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23911] = 30
                        mem[_23911 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24846 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24846 + 68] = mem[idx + _23911 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24846 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24846 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28254 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28254] = 30
                        mem[_28254 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _29394 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29394 + 68] = mem[idx + _28254 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29394 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29394 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _32972 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32972] = 30
                        mem[_32972 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33705 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33705 + 68] = mem[idx + _32972 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33705 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33705 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _23910 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23910] = 30
                        mem[_23910 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24845 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24845 + 68] = mem[idx + _23910 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24845 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24845 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28252 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28252] = 30
                        mem[_28252 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _29393 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29393 + 68] = mem[idx + _28252 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29393 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29393 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32970 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32970] = 30
                        mem[_32970 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33704 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33704 + 68] = mem[idx + _32970 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33704 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33704 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26965 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26965] = 30
                    mem[_26965 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _28251 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28251 + 68] = mem[idx + _26965 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28251 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28251 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _31829 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31829] = 30
                    mem[_31829 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        _32969 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32969 + 68] = mem[idx + _31829 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32969 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32969 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _35611 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35611] = 30
                    mem[_35611 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    _35962 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35962 + 68] = mem[idx + _35611 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35962 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35962 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor15 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not 0 / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if arg1 * _CHARITY_FEE / stor13 / 100:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not 0 / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                else:
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
    else:
        if arg1 and _TAX_FEE > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * _TAX_FEE / arg1 != _TAX_FEE:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not stor13:
            revert with 0, 'SafeMath: division by zero', 0
        mem[160] = 26
        mem[192] = 'SafeMath: division by zero'
        if not arg1:
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not stor13:
                revert with 0, 'SafeMath: division by zero', 0
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor13:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor13 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor13 / 100) < 0 / stor13 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (0 / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (0 / stor13 / 100) < 0 / stor13 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor15
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _19238 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19238] = 26
                        mem[_19238 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19324 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19324 + 68] = mem[idx + _19238 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19324 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19324 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    return 0
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    _20480 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20480] = 30
                                    mem[_20480 + 32] = 'SafeMath: subtraction overflow'
                                    _21774 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21774] = 30
                                    mem[_21774 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                        _22285 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22285 + 68] = mem[idx + _21774 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22285 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22285 + -mem[64] + 100
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _24805 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24805] = 30
                                    mem[_24805 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25791 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25791 + 68] = mem[idx + _24805 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25791 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25791 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21273 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21273] = 30
                                mem[_21273 + 32] = 'SafeMath: subtraction overflow'
                                _23869 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23869] = 30
                                mem[_23869 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _24804 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24804 + 68] = mem[idx + _23869 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24804 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24804 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _28196 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28196] = 30
                                mem[_28196 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29359 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29359 + 68] = mem[idx + _28196 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29359 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29359 + -mem[64] + 100
                            if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _20479 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20479] = 30
                                mem[_20479 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20713 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20713 + 68] = mem[idx + _20479 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20713 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20713 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _21772 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21772] = 30
                                mem[_21772 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _22284 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22284 + 68] = mem[idx + _21772 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22284 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22284 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24802 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24802] = 30
                                mem[_24802 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _25790 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25790 + 68] = mem[idx + _24802 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25790 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25790 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21272 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21272] = 30
                                mem[_21272 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21771 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21771 + 68] = mem[idx + _21272 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21771 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21771 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23867 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23867] = 30
                                mem[_23867 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _24801 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24801 + 68] = mem[idx + _23867 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24801 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24801 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _28194 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28194] = 30
                                mem[_28194 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29357 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29357 + 68] = mem[idx + _28194 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29357 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29357 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22988 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22988] = 30
                            mem[_22988 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _23866 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23866 + 68] = mem[idx + _22988 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23866 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23866 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26920 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26920] = 30
                            mem[_26920 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _28193 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28193 + 68] = mem[idx + _26920 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28193 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28193 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31776 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31776] = 30
                            mem[_31776 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32926 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32926 + 68] = mem[idx + _31776 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32926 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32926 + -mem[64] + 100
                        if arg1 and stor15 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _20477 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20477] = 30
                                mem[_20477 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20712 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20712 + 68] = mem[idx + _20477 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20712 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20712 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _21769 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21769] = 30
                                mem[_21769 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _22282 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22282 + 68] = mem[idx + _21769 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22282 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22282 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24799 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24799] = 30
                                mem[_24799 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _25789 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25789 + 68] = mem[idx + _24799 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25789 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25789 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21271 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21271] = 30
                                mem[_21271 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21768 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21768 + 68] = mem[idx + _21271 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21768 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21768 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23864 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23864] = 30
                                mem[_23864 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _24798 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24798 + 68] = mem[idx + _23864 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24798 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24798 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _28191 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28191] = 30
                                mem[_28191 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _29355 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29355 + 68] = mem[idx + _28191 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29355 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29355 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22987 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22987] = 30
                            mem[_22987 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _23863 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23863 + 68] = mem[idx + _22987 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23863 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23863 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _26918 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26918] = 30
                            mem[_26918 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _28190 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28190 + 68] = mem[idx + _26918 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28190 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28190 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31773 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31773] = 30
                            mem[_31773 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32924 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32924 + 68] = mem[idx + _31773 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32924 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32924 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21270 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21270] = 30
                            mem[_21270 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _21767 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21767 + 68] = mem[idx + _21270 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21767 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21767 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _23861 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23861] = 30
                            mem[_23861 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _24797 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24797 + 68] = mem[idx + _23861 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24797 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24797 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _28188 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28188] = 30
                            mem[_28188 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _29354 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29354 + 68] = mem[idx + _28188 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29354 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29354 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _22986 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22986] = 30
                            mem[_22986 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23860 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23860 + 68] = mem[idx + _22986 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23860 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23860 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26916 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26916] = 30
                            mem[_26916 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _28187 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28187 + 68] = mem[idx + _26916 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28187 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28187 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31771 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31771] = 30
                            mem[_31771 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32922 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32922 + 68] = mem[idx + _31771 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32922 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32922 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25788 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25788] = 30
                        mem[_25788 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _26915 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26915 + 68] = mem[idx + _25788 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26915 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26915 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _30471 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30471] = 30
                        mem[_30471 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _31770 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31770 + 68] = mem[idx + _30471 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31770 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31770 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _34717 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34717] = 30
                        mem[_34717 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _35576 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35576 + 68] = mem[idx + _34717 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35576 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35576 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _19325 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19325] = 30
                        mem[_19325 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _19405 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19405 + 68] = mem[idx + _19325 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19405 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19405 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _19758 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19758] = 30
                        mem[_19758 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _19806 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19806 + 68] = mem[idx + _19758 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19806 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19806 + -mem[64] + 100
                    _19326 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19326] = 26
                    mem[_19326 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19406 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19406 + 68] = mem[idx + _19326 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19406 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19406 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                return 0
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _20719 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20719] = 30
                                mem[_20719 + 32] = 'SafeMath: subtraction overflow'
                                _22294 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22294] = 30
                                mem[_22294 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _22993 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22993 + 68] = mem[idx + _22294 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22993 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22993 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _25801 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25801] = 30
                                mem[_25801 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26925 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26925 + 68] = mem[idx + _25801 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26925 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26925 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21779 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21779] = 30
                            mem[_21779 + 32] = 'SafeMath: subtraction overflow'
                            _24816 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24816] = 30
                            mem[_24816 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _25800 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25800 + 68] = mem[idx + _24816 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25800 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25800 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29370 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29370] = 30
                            mem[_29370 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30478 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30478 + 68] = mem[idx + _29370 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30478 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30478 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _20718 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20718] = 30
                            mem[_20718 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _20891 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20891 + 68] = mem[idx + _20718 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20891 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20891 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _22292 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22292] = 30
                            mem[_22292 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _22992 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22992 + 68] = mem[idx + _22292 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22992 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22992 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25798 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25798] = 30
                            mem[_25798 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _26924 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26924 + 68] = mem[idx + _25798 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26924 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26924 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21778 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21778] = 30
                            mem[_21778 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _22291 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22291 + 68] = mem[idx + _21778 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22291 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22291 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24814 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24814] = 30
                            mem[_24814 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _25797 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25797 + 68] = mem[idx + _24814 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25797 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25797 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29368 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29368] = 30
                            mem[_29368 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30476 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30476 + 68] = mem[idx + _29368 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30476 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30476 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23872 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23872] = 30
                        mem[_23872 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _24813 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24813 + 68] = mem[idx + _23872 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24813 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24813 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28204 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28204] = 30
                        mem[_28204 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _29367 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29367 + 68] = mem[idx + _28204 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29367 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29367 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32935 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32935] = 30
                        mem[_32935 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33697 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33697 + 68] = mem[idx + _32935 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33697 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33697 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            _20716 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20716] = 30
                            mem[_20716 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _20890 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20890 + 68] = mem[idx + _20716 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20890 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20890 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _22289 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22289] = 30
                            mem[_22289 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22990 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22990 + 68] = mem[idx + _22289 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22990 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22990 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25795 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25795] = 30
                            mem[_25795 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _26923 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26923 + 68] = mem[idx + _25795 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26923 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26923 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21777 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21777] = 30
                            mem[_21777 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22288 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22288 + 68] = mem[idx + _21777 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22288 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22288 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24811 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24811] = 30
                            mem[_24811 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _25794 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25794 + 68] = mem[idx + _24811 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25794 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25794 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29365 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29365] = 30
                            mem[_29365 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _30474 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30474 + 68] = mem[idx + _29365 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30474 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30474 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23871 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23871] = 30
                        mem[_23871 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _24810 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24810 + 68] = mem[idx + _23871 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24810 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24810 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _28202 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28202] = 30
                        mem[_28202 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _29364 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29364 + 68] = mem[idx + _28202 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29364 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29364 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32932 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32932] = 30
                        mem[_32932 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33695 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33695 + 68] = mem[idx + _32932 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33695 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33695 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _21776 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21776] = 30
                        mem[_21776 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _22287 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22287 + 68] = mem[idx + _21776 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22287 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22287 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _24808 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24808] = 30
                        mem[_24808 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _25793 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25793 + 68] = mem[idx + _24808 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25793 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25793 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _29362 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29362] = 30
                        mem[_29362 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _30473 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30473 + 68] = mem[idx + _29362 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30473 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30473 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _23870 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23870] = 30
                        mem[_23870 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24807 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24807 + 68] = mem[idx + _23870 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24807 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24807 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28200 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28200] = 30
                        mem[_28200 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _29361 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29361 + 68] = mem[idx + _28200 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29361 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29361 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32930 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32930] = 30
                        mem[_32930 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33693 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33693 + 68] = mem[idx + _32930 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33693 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33693 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26922 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26922] = 30
                    mem[_26922 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _28199 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28199 + 68] = mem[idx + _26922 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28199 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28199 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _31780 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31780] = 30
                    mem[_31780 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _32929 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32929 + 68] = mem[idx + _31780 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32929 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32929 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _35580 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35580] = 30
                    mem[_35580 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    _35958 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35958 + 68] = mem[idx + _35580 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35958 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35958 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor15 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if 0 / stor13 / 100:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if 0 / stor13 / 100:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not 0 / stor13 / 100:
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                else:
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
            else:
                if arg1 and _CHARITY_FEE > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / arg1 != _CHARITY_FEE:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor13:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor13 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor13 / 100) < 0 / stor13 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (0 / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (0 / stor13 / 100) < arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor15
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _19237 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19237] = 26
                        mem[_19237 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19321 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19321 + 68] = mem[idx + _19237 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19321 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19321 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        return 0
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20468 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20468] = 30
                                    mem[_20468 + 32] = 'SafeMath: subtraction overflow'
                                    _21753 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21753] = 30
                                    mem[_21753 + 32] = 'SafeMath: subtraction overflow'
                                    _24768 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24768] = 30
                                    mem[_24768 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                        if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25767 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25767 + 68] = mem[idx + _24768 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25767 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25767 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    _20467 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20467] = 30
                                    mem[_20467 + 32] = 'SafeMath: subtraction overflow'
                                    _21752 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21752] = 30
                                    mem[_21752 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                        _22266 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22266 + 68] = mem[idx + _21752 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22266 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22266 + -mem[64] + 100
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _24766 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24766] = 30
                                    mem[_24766 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25766 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25766 + 68] = mem[idx + _24766 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25766 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25766 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21255 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21255] = 30
                                mem[_21255 + 32] = 'SafeMath: subtraction overflow'
                                _23839 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23839] = 30
                                mem[_23839 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _24765 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24765 + 68] = mem[idx + _23839 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24765 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24765 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _28153 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28153] = 30
                                mem[_28153 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29326 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29326 + 68] = mem[idx + _28153 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29326 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29326 + -mem[64] + 100
                            if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    _20466 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20466] = 30
                                    mem[_20466 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                        _20704 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20704 + 68] = mem[idx + _20466 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20704 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20704 + -mem[64] + 100
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _21750 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21750] = 30
                                    mem[_21750 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                        _22265 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22265 + 68] = mem[idx + _21750 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22265 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22265 + -mem[64] + 100
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24763 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24763] = 30
                                    mem[_24763 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25765 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25765 + 68] = mem[idx + _24763 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25765 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25765 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21254 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21254] = 30
                                mem[_21254 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21749 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21749 + 68] = mem[idx + _21254 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21749 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21749 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23837 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23837] = 30
                                mem[_23837 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _24762 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24762 + 68] = mem[idx + _23837 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24762 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24762 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _28151 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28151] = 30
                                mem[_28151 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29324 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29324 + 68] = mem[idx + _28151 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29324 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29324 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21253 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21253] = 30
                                mem[_21253 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21748 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21748 + 68] = mem[idx + _21253 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21748 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21748 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23835 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23835] = 30
                                mem[_23835 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _24761 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24761 + 68] = mem[idx + _23835 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24761 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24761 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _28149 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28149] = 30
                                mem[_28149 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29323 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29323 + 68] = mem[idx + _28149 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29323 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29323 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22968 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22968] = 30
                            mem[_22968 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _23834 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23834 + 68] = mem[idx + _22968 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23834 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23834 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26888 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26888] = 30
                            mem[_26888 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _28148 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28148 + 68] = mem[idx + _26888 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28148 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28148 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31739 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31739] = 30
                            mem[_31739 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32891 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32891 + 68] = mem[idx + _31739 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32891 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32891 + -mem[64] + 100
                        if arg1 and stor15 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    _20464 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20464] = 30
                                    mem[_20464 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor15 / totalSupply:
                                        _20703 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20703 + 68] = mem[idx + _20464 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20703 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20703 + -mem[64] + 100
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _21746 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21746] = 30
                                    mem[_21746 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor15 / totalSupply:
                                        _22263 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22263 + 68] = mem[idx + _21746 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22263 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22263 + -mem[64] + 100
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24759 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24759] = 30
                                    mem[_24759 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor15 / totalSupply:
                                        if arg1 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor15 / totalSupply)
                                    _25764 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25764 + 68] = mem[idx + _24759 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25764 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25764 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21252 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21252] = 30
                                mem[_21252 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21745 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21745 + 68] = mem[idx + _21252 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21745 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21745 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23832 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23832] = 30
                                mem[_23832 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _24758 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24758 + 68] = mem[idx + _23832 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24758 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24758 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _28146 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28146] = 30
                                mem[_28146 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _29321 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29321 + 68] = mem[idx + _28146 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29321 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29321 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21251 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21251] = 30
                                mem[_21251 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21744 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21744 + 68] = mem[idx + _21251 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21744 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21744 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23830 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23830] = 30
                                mem[_23830 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _24757 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24757 + 68] = mem[idx + _23830 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24757 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24757 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _28144 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28144] = 30
                                mem[_28144 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _29320 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29320 + 68] = mem[idx + _28144 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29320 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29320 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22967 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22967] = 30
                            mem[_22967 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _23829 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23829 + 68] = mem[idx + _22967 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23829 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23829 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _26886 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26886] = 30
                            mem[_26886 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _28143 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28143 + 68] = mem[idx + _26886 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28143 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28143 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31736 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31736] = 30
                            mem[_31736 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32888 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32888 + 68] = mem[idx + _31736 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32888 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32888 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21250 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21250] = 30
                                mem[_21250 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _21743 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21743 + 68] = mem[idx + _21250 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21743 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21743 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23827 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23827] = 30
                                mem[_23827 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                    _24756 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24756 + 68] = mem[idx + _23827 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24756 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24756 + -mem[64] + 100
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                _28141 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28141] = 30
                                mem[_28141 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _29319 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29319 + 68] = mem[idx + _28141 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29319 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29319 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22966 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22966] = 30
                            mem[_22966 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23826 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23826 + 68] = mem[idx + _22966 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23826 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23826 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26884 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26884] = 30
                            mem[_26884 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _28140 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28140 + 68] = mem[idx + _26884 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28140 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28140 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _31734 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31734] = 30
                            mem[_31734 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32886 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32886 + 68] = mem[idx + _31734 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32886 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32886 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _22965 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22965] = 30
                            mem[_22965 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23825 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23825 + 68] = mem[idx + _22965 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23825 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23825 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26882 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26882] = 30
                            mem[_26882 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _28139 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28139 + 68] = mem[idx + _26882 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28139 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28139 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31732 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31732] = 30
                            mem[_31732 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32885 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32885 + 68] = mem[idx + _31732 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32885 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32885 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25763 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25763] = 30
                        mem[_25763 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _26881 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26881 + 68] = mem[idx + _25763 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26881 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26881 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _30445 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30445] = 30
                        mem[_30445 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _31731 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31731 + 68] = mem[idx + _30445 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31731 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31731 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _34689 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34689] = 30
                        mem[_34689 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _35549 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35549 + 68] = mem[idx + _34689 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35549 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35549 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _19322 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19322] = 30
                        mem[_19322 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _19402 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19402 + 68] = mem[idx + _19322 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19402 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19402 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _19755 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19755] = 30
                        mem[_19755 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _19803 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19803 + 68] = mem[idx + _19755 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19803 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19803 + -mem[64] + 100
                    _19323 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19323] = 26
                    mem[_19323 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19403 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19403 + 68] = mem[idx + _19323 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19403 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19403 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    return 0
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20711 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20711] = 30
                                mem[_20711 + 32] = 'SafeMath: subtraction overflow'
                                _22278 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22278] = 30
                                mem[_22278 + 32] = 'SafeMath: subtraction overflow'
                                _25781 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25781] = 30
                                mem[_25781 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                    if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26894 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26894 + 68] = mem[idx + _25781 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26894 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26894 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20710 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20710] = 30
                                mem[_20710 + 32] = 'SafeMath: subtraction overflow'
                                _22277 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22277] = 30
                                mem[_22277 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _22974 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22974 + 68] = mem[idx + _22277 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22974 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22974 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _25779 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25779] = 30
                                mem[_25779 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26893 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26893 + 68] = mem[idx + _25779 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26893 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26893 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21760 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21760] = 30
                            mem[_21760 + 32] = 'SafeMath: subtraction overflow'
                            _24783 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24783] = 30
                            mem[_24783 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _25778 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25778 + 68] = mem[idx + _24783 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25778 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25778 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29343 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29343] = 30
                            mem[_29343 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30454 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30454 + 68] = mem[idx + _29343 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30454 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30454 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20709 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20709] = 30
                                mem[_20709 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20887 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20887 + 68] = mem[idx + _20709 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20887 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20887 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _22275 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22275] = 30
                                mem[_22275 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _22973 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22973 + 68] = mem[idx + _22275 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22973 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22973 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25776 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25776] = 30
                                mem[_25776 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26892 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26892 + 68] = mem[idx + _25776 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26892 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26892 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21759 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21759] = 30
                            mem[_21759 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _22274 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22274 + 68] = mem[idx + _21759 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22274 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22274 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24781 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24781] = 30
                            mem[_24781 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _25775 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25775 + 68] = mem[idx + _24781 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25775 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25775 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _29341 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29341] = 30
                            mem[_29341 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30452 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30452 + 68] = mem[idx + _29341 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30452 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30452 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21758 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21758] = 30
                            mem[_21758 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _22273 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22273 + 68] = mem[idx + _21758 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22273 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22273 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24779 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24779] = 30
                            mem[_24779 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _25774 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25774 + 68] = mem[idx + _24779 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25774 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25774 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29339 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29339] = 30
                            mem[_29339 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30451 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30451 + 68] = mem[idx + _29339 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30451 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30451 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23843 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23843] = 30
                        mem[_23843 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _24778 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24778 + 68] = mem[idx + _23843 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24778 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24778 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28163 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28163] = 30
                        mem[_28163 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _29338 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29338 + 68] = mem[idx + _28163 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29338 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29338 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32903 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32903] = 30
                        mem[_32903 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33685 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33685 + 68] = mem[idx + _32903 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33685 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33685 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20707 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20707] = 30
                                mem[_20707 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20886 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20886 + 68] = mem[idx + _20707 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20886 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20886 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _22271 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22271] = 30
                                mem[_22271 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _22971 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22971 + 68] = mem[idx + _22271 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22971 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22971 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25772 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25772] = 30
                                mem[_25772 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _26891 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26891 + 68] = mem[idx + _25772 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26891 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26891 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21757 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21757] = 30
                            mem[_21757 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22270 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22270 + 68] = mem[idx + _21757 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22270 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22270 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24776 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24776] = 30
                            mem[_24776 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _25771 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25771 + 68] = mem[idx + _24776 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25771 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25771 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _29336 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29336] = 30
                            mem[_29336 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _30449 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30449 + 68] = mem[idx + _29336 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30449 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30449 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21756 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21756] = 30
                            mem[_21756 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22269 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22269 + 68] = mem[idx + _21756 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22269 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22269 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24774 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24774] = 30
                            mem[_24774 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _25770 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25770 + 68] = mem[idx + _24774 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25770 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25770 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29334 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29334] = 30
                            mem[_29334 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _30448 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30448 + 68] = mem[idx + _29334 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30448 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30448 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23842 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23842] = 30
                        mem[_23842 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _24773 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24773 + 68] = mem[idx + _23842 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24773 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24773 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _28161 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28161] = 30
                        mem[_28161 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _29333 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29333 + 68] = mem[idx + _28161 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29333 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29333 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32900 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32900] = 30
                        mem[_32900 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33682 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33682 + 68] = mem[idx + _32900 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33682 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33682 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21755 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21755] = 30
                            mem[_21755 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _22268 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22268 + 68] = mem[idx + _21755 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22268 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22268 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24771 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24771] = 30
                            mem[_24771 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _25769 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25769 + 68] = mem[idx + _24771 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25769 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25769 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _29331 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29331] = 30
                            mem[_29331 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _30447 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30447 + 68] = mem[idx + _29331 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30447 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30447 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23841 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23841] = 30
                        mem[_23841 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24770 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24770 + 68] = mem[idx + _23841 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24770 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24770 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28159 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28159] = 30
                        mem[_28159 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _29330 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29330 + 68] = mem[idx + _28159 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29330 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29330 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _32898 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32898] = 30
                        mem[_32898 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33680 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33680 + 68] = mem[idx + _32898 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33680 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33680 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _23840 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23840] = 30
                        mem[_23840 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24769 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24769 + 68] = mem[idx + _23840 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24769 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24769 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28157 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28157] = 30
                        mem[_28157 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _29329 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29329 + 68] = mem[idx + _28157 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29329 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29329 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32896 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32896] = 30
                        mem[_32896 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33679 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33679 + 68] = mem[idx + _32896 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33679 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33679 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26890 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26890] = 30
                    mem[_26890 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _28156 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28156 + 68] = mem[idx + _26890 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28156 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28156 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _31744 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31744] = 30
                    mem[_31744 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _32895 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32895 + 68] = mem[idx + _31744 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32895 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32895 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _35554 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35554] = 30
                    mem[_35554 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    _35953 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35953 + 68] = mem[idx + _35554 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35953 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35953 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor15 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                if arg1 * _CHARITY_FEE / stor13 / 100:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                else:
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
        else:
            if arg1 and _BURN_FEE > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * _BURN_FEE / arg1 != _BURN_FEE:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not stor13:
                revert with 0, 'SafeMath: division by zero', 0
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor13:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor13 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor13 / 100) < arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100) < 0 / stor13 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor15
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _19236 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19236] = 26
                        mem[_19236 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19318 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19318 + 68] = mem[idx + _19236 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19318 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19318 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    if not 0 / stor13 / 100:
                                        return 0
                                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20455 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20455] = 30
                                    mem[_20455 + 32] = 'SafeMath: subtraction overflow'
                                    _21729 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21729] = 30
                                    mem[_21729 + 32] = 'SafeMath: subtraction overflow'
                                    _24725 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24725] = 30
                                    mem[_24725 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply <= 0:
                                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25740 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25740 + 68] = mem[idx + _24725 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25740 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25740 + -mem[64] + 100
                                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    _20454 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20454] = 30
                                    mem[_20454 + 32] = 'SafeMath: subtraction overflow'
                                    _21728 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21728] = 30
                                    mem[_21728 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                        _22242 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22242 + 68] = mem[idx + _21728 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22242 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22242 + -mem[64] + 100
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _24723 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24723] = 30
                                    mem[_24723 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25739 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25739 + 68] = mem[idx + _24723 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25739 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25739 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21233 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21233] = 30
                                mem[_21233 + 32] = 'SafeMath: subtraction overflow'
                                _23798 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23798] = 30
                                mem[_23798 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _24722 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24722 + 68] = mem[idx + _23798 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24722 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24722 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _28099 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28099] = 30
                                mem[_28099 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29289 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29289 + 68] = mem[idx + _28099 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29289 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29289 + -mem[64] + 100
                            if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    _20453 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20453] = 30
                                    mem[_20453 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                        _20695 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20695 + 68] = mem[idx + _20453 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20695 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20695 + -mem[64] + 100
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _21726 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21726] = 30
                                    mem[_21726 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                        _22241 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22241 + 68] = mem[idx + _21726 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22241 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22241 + -mem[64] + 100
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24720 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24720] = 30
                                    mem[_24720 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25738 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25738 + 68] = mem[idx + _24720 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25738 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25738 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21232 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21232] = 30
                                mem[_21232 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21725 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21725 + 68] = mem[idx + _21232 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21725 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21725 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23796 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23796] = 30
                                mem[_23796 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _24719 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24719 + 68] = mem[idx + _23796 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24719 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24719 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _28097 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28097] = 30
                                mem[_28097 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29287 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29287 + 68] = mem[idx + _28097 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29287 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29287 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21231 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21231] = 30
                                mem[_21231 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21724 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21724 + 68] = mem[idx + _21231 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21724 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21724 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23794 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23794] = 30
                                mem[_23794 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _24718 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24718 + 68] = mem[idx + _23794 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24718 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24718 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _28095 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28095] = 30
                                mem[_28095 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29286 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29286 + 68] = mem[idx + _28095 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29286 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29286 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22943 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22943] = 30
                            mem[_22943 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _23793 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23793 + 68] = mem[idx + _22943 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23793 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23793 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26844 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26844] = 30
                            mem[_26844 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _28094 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28094 + 68] = mem[idx + _26844 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28094 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28094 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31690 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31690] = 30
                            mem[_31690 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32848 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32848 + 68] = mem[idx + _31690 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32848 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32848 + -mem[64] + 100
                        if arg1 and stor15 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    _20451 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20451] = 30
                                    mem[_20451 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor15 / totalSupply:
                                        _20694 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20694 + 68] = mem[idx + _20451 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20694 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20694 + -mem[64] + 100
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _21722 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21722] = 30
                                    mem[_21722 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor15 / totalSupply:
                                        _22239 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22239 + 68] = mem[idx + _21722 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22239 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22239 + -mem[64] + 100
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24716 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24716] = 30
                                    mem[_24716 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor15 / totalSupply:
                                        if arg1 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor15 / totalSupply)
                                    _25737 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25737 + 68] = mem[idx + _24716 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25737 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25737 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21230 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21230] = 30
                                mem[_21230 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21721 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21721 + 68] = mem[idx + _21230 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21721 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21721 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23791 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23791] = 30
                                mem[_23791 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _24715 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24715 + 68] = mem[idx + _23791 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24715 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24715 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _28092 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28092] = 30
                                mem[_28092 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _29284 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29284 + 68] = mem[idx + _28092 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29284 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29284 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21229 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21229] = 30
                                mem[_21229 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21720 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21720 + 68] = mem[idx + _21229 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21720 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21720 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23789 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23789] = 30
                                mem[_23789 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _24714 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24714 + 68] = mem[idx + _23789 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24714 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24714 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _28090 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28090] = 30
                                mem[_28090 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _29283 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29283 + 68] = mem[idx + _28090 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29283 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29283 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22942 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22942] = 30
                            mem[_22942 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _23788 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23788 + 68] = mem[idx + _22942 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23788 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23788 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _26842 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26842] = 30
                            mem[_26842 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _28089 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28089 + 68] = mem[idx + _26842 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28089 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28089 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31687 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31687] = 30
                            mem[_31687 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32845 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32845 + 68] = mem[idx + _31687 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32845 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32845 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _21228 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21228] = 30
                                mem[_21228 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _21719 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21719 + 68] = mem[idx + _21228 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21719 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21719 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23786 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23786] = 30
                                mem[_23786 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                    _24713 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24713 + 68] = mem[idx + _23786 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24713 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24713 + -mem[64] + 100
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                _28087 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28087] = 30
                                mem[_28087 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _29282 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29282 + 68] = mem[idx + _28087 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29282 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29282 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22941 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22941] = 30
                            mem[_22941 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23785 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23785 + 68] = mem[idx + _22941 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23785 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23785 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26840 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26840] = 30
                            mem[_26840 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _28086 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28086 + 68] = mem[idx + _26840 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28086 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28086 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _31685 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31685] = 30
                            mem[_31685 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32843 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32843 + 68] = mem[idx + _31685 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32843 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32843 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _22940 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22940] = 30
                            mem[_22940 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23784 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23784 + 68] = mem[idx + _22940 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23784 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23784 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26838 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26838] = 30
                            mem[_26838 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _28085 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28085 + 68] = mem[idx + _26838 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28085 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28085 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31683 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31683] = 30
                            mem[_31683 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32842 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32842 + 68] = mem[idx + _31683 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32842 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32842 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25736 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25736] = 30
                        mem[_25736 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _26837 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26837 + 68] = mem[idx + _25736 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26837 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26837 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _30415 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30415] = 30
                        mem[_30415 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _31682 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31682 + 68] = mem[idx + _30415 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31682 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31682 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _34655 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34655] = 30
                        mem[_34655 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _35516 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35516 + 68] = mem[idx + _34655 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35516 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35516 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _19319 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19319] = 30
                        mem[_19319 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _19399 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19399 + 68] = mem[idx + _19319 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19399 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19399 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _19752 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19752] = 30
                        mem[_19752 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _19800 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19800 + 68] = mem[idx + _19752 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19800 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19800 + -mem[64] + 100
                    _19320 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19320] = 26
                    mem[_19320 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19400 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19400 + 68] = mem[idx + _19320 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19400 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19400 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    return 0
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20702 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20702] = 30
                                mem[_20702 + 32] = 'SafeMath: subtraction overflow'
                                _22254 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22254] = 30
                                mem[_22254 + 32] = 'SafeMath: subtraction overflow'
                                _25754 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25754] = 30
                                mem[_25754 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= 0:
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26850 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26850 + 68] = mem[idx + _25754 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26850 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26850 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _20701 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20701] = 30
                                mem[_20701 + 32] = 'SafeMath: subtraction overflow'
                                _22253 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22253] = 30
                                mem[_22253 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _22949 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22949 + 68] = mem[idx + _22253 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22949 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22949 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _25752 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25752] = 30
                                mem[_25752 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26849 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26849 + 68] = mem[idx + _25752 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26849 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26849 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21736 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21736] = 30
                            mem[_21736 + 32] = 'SafeMath: subtraction overflow'
                            _24740 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24740] = 30
                            mem[_24740 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _25751 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25751 + 68] = mem[idx + _24740 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25751 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25751 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29306 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29306] = 30
                            mem[_29306 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30424 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30424 + 68] = mem[idx + _29306 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30424 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30424 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _20700 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20700] = 30
                                mem[_20700 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20879 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20879 + 68] = mem[idx + _20700 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20879 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20879 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _22251 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22251] = 30
                                mem[_22251 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _22948 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22948 + 68] = mem[idx + _22251 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22948 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22948 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25749 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25749] = 30
                                mem[_25749 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26848 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26848 + 68] = mem[idx + _25749 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26848 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26848 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21735 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21735] = 30
                            mem[_21735 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _22250 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22250 + 68] = mem[idx + _21735 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22250 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22250 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24738 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24738] = 30
                            mem[_24738 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _25748 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25748 + 68] = mem[idx + _24738 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25748 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25748 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _29304 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29304] = 30
                            mem[_29304 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30422 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30422 + 68] = mem[idx + _29304 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30422 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30422 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21734 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21734] = 30
                            mem[_21734 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _22249 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22249 + 68] = mem[idx + _21734 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22249 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22249 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24736 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24736] = 30
                            mem[_24736 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _25747 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25747 + 68] = mem[idx + _24736 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25747 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25747 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29302 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29302] = 30
                            mem[_29302 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30421 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30421 + 68] = mem[idx + _29302 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30421 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30421 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23802 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23802] = 30
                        mem[_23802 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _24735 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24735 + 68] = mem[idx + _23802 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24735 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24735 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28109 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28109] = 30
                        mem[_28109 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _29301 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29301 + 68] = mem[idx + _28109 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29301 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29301 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32860 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32860] = 30
                        mem[_32860 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33671 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33671 + 68] = mem[idx + _32860 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33671 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33671 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _20698 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20698] = 30
                                mem[_20698 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20878 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20878 + 68] = mem[idx + _20698 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20878 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20878 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _22247 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22247] = 30
                                mem[_22247 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _22946 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22946 + 68] = mem[idx + _22247 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22946 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22946 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25745 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25745] = 30
                                mem[_25745 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _26847 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26847 + 68] = mem[idx + _25745 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26847 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26847 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21733 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21733] = 30
                            mem[_21733 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22246 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22246 + 68] = mem[idx + _21733 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22246 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22246 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24733 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24733] = 30
                            mem[_24733 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _25744 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25744 + 68] = mem[idx + _24733 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25744 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25744 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _29299 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29299] = 30
                            mem[_29299 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _30419 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30419 + 68] = mem[idx + _29299 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30419 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30419 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21732 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21732] = 30
                            mem[_21732 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22245 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22245 + 68] = mem[idx + _21732 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22245 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22245 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24731 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24731] = 30
                            mem[_24731 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _25743 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25743 + 68] = mem[idx + _24731 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25743 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25743 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29297 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29297] = 30
                            mem[_29297 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _30418 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30418 + 68] = mem[idx + _29297 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30418 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30418 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23801 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23801] = 30
                        mem[_23801 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _24730 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24730 + 68] = mem[idx + _23801 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24730 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24730 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _28107 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28107] = 30
                        mem[_28107 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _29296 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29296 + 68] = mem[idx + _28107 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29296 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29296 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32857 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32857] = 30
                        mem[_32857 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33668 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33668 + 68] = mem[idx + _32857 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33668 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33668 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            _21731 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21731] = 30
                            mem[_21731 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _22244 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22244 + 68] = mem[idx + _21731 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22244 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22244 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24728 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24728] = 30
                            mem[_24728 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _25742 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25742 + 68] = mem[idx + _24728 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25742 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25742 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _29294 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29294] = 30
                            mem[_29294 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _30417 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30417 + 68] = mem[idx + _29294 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30417 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30417 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23800 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23800] = 30
                        mem[_23800 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24727 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24727 + 68] = mem[idx + _23800 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24727 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24727 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28105 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28105] = 30
                        mem[_28105 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _29293 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29293 + 68] = mem[idx + _28105 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29293 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29293 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _32855 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32855] = 30
                        mem[_32855 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33666 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33666 + 68] = mem[idx + _32855 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33666 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33666 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _23799 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23799] = 30
                        mem[_23799 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24726 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24726 + 68] = mem[idx + _23799 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24726 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24726 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28103 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28103] = 30
                        mem[_28103 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _29292 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29292 + 68] = mem[idx + _28103 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29292 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29292 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32853 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32853] = 30
                        mem[_32853 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33665 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33665 + 68] = mem[idx + _32853 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33665 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33665 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26846 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26846] = 30
                    mem[_26846 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _28102 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28102 + 68] = mem[idx + _26846 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28102 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28102 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _31695 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31695] = 30
                    mem[_31695 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _32852 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32852 + 68] = mem[idx + _31695 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32852 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32852 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _35521 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35521] = 30
                    mem[_35521 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    _35948 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35948 + 68] = mem[idx + _35521 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35948 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35948 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor15 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if 0 / stor13 / 100:
                                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if 0 / stor13 / 100:
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                else:
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
            else:
                if arg1 and _CHARITY_FEE > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / arg1 != _CHARITY_FEE:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor13:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor13 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor13 / 100) < arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100) < arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor15
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _19235 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19235] = 26
                        mem[_19235 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19315 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19315 + 68] = mem[idx + _19235 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19315 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19315 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        return 0
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20442 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20442] = 30
                                    mem[_20442 + 32] = 'SafeMath: subtraction overflow'
                                    _21705 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21705] = 30
                                    mem[_21705 + 32] = 'SafeMath: subtraction overflow'
                                    _24682 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24682] = 30
                                    mem[_24682 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                        if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25713 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25713 + 68] = mem[idx + _24682 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25713 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25713 + -mem[64] + 100
                                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    _20441 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20441] = 30
                                    mem[_20441 + 32] = 'SafeMath: subtraction overflow'
                                    _21704 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21704] = 30
                                    mem[_21704 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                        _22218 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22218 + 68] = mem[idx + _21704 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22218 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22218 + -mem[64] + 100
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _24680 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24680] = 30
                                    mem[_24680 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25712 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25712 + 68] = mem[idx + _24680 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25712 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25712 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21211 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21211] = 30
                                mem[_21211 + 32] = 'SafeMath: subtraction overflow'
                                _23757 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23757] = 30
                                mem[_23757 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _24679 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24679 + 68] = mem[idx + _23757 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24679 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24679 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _28045 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28045] = 30
                                mem[_28045 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29252 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29252 + 68] = mem[idx + _28045 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29252 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29252 + -mem[64] + 100
                            if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    _20440 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20440] = 30
                                    mem[_20440 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                        _20686 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20686 + 68] = mem[idx + _20440 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20686 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20686 + -mem[64] + 100
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _21702 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21702] = 30
                                    mem[_21702 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                        _22217 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22217 + 68] = mem[idx + _21702 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22217 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22217 + -mem[64] + 100
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24677 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24677] = 30
                                    mem[_24677 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25711 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25711 + 68] = mem[idx + _24677 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25711 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25711 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21210 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21210] = 30
                                mem[_21210 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21701 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21701 + 68] = mem[idx + _21210 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21701 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21701 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23755 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23755] = 30
                                mem[_23755 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _24676 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24676 + 68] = mem[idx + _23755 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24676 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24676 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _28043 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28043] = 30
                                mem[_28043 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29250 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29250 + 68] = mem[idx + _28043 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29250 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29250 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21209 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21209] = 30
                                mem[_21209 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21700 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21700 + 68] = mem[idx + _21209 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21700 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21700 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23753 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23753] = 30
                                mem[_23753 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _24675 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24675 + 68] = mem[idx + _23753 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24675 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24675 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _28041 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28041] = 30
                                mem[_28041 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29249 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29249 + 68] = mem[idx + _28041 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29249 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29249 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22918 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22918] = 30
                            mem[_22918 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _23752 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23752 + 68] = mem[idx + _22918 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23752 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23752 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26800 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26800] = 30
                            mem[_26800 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _28040 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28040 + 68] = mem[idx + _26800 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28040 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28040 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31641 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31641] = 30
                            mem[_31641 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32805 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32805 + 68] = mem[idx + _31641 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32805 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32805 + -mem[64] + 100
                        if arg1 and stor15 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    _20438 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20438] = 30
                                    mem[_20438 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor15 / totalSupply:
                                        _20685 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20685 + 68] = mem[idx + _20438 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20685 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20685 + -mem[64] + 100
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _21698 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21698] = 30
                                    mem[_21698 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor15 / totalSupply:
                                        _22215 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22215 + 68] = mem[idx + _21698 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22215 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22215 + -mem[64] + 100
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24673 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24673] = 30
                                    mem[_24673 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor15 / totalSupply:
                                        if arg1 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor15 / totalSupply)
                                    _25710 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25710 + 68] = mem[idx + _24673 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25710 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25710 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21208 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21208] = 30
                                mem[_21208 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21697 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21697 + 68] = mem[idx + _21208 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21697 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21697 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23750 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23750] = 30
                                mem[_23750 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _24672 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24672 + 68] = mem[idx + _23750 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24672 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24672 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _28038 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28038] = 30
                                mem[_28038 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _29247 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29247 + 68] = mem[idx + _28038 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29247 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29247 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21207 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21207] = 30
                                mem[_21207 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21696 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21696 + 68] = mem[idx + _21207 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21696 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21696 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23748 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23748] = 30
                                mem[_23748 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _24671 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24671 + 68] = mem[idx + _23748 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24671 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24671 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _28036 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28036] = 30
                                mem[_28036 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _29246 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29246 + 68] = mem[idx + _28036 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29246 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29246 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22917 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22917] = 30
                            mem[_22917 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _23747 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23747 + 68] = mem[idx + _22917 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23747 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23747 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _26798 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26798] = 30
                            mem[_26798 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _28035 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28035 + 68] = mem[idx + _26798 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28035 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28035 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31638 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31638] = 30
                            mem[_31638 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32802 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32802 + 68] = mem[idx + _31638 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32802 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32802 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21206 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21206] = 30
                                mem[_21206 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _21695 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21695 + 68] = mem[idx + _21206 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21695 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21695 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23745 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23745] = 30
                                mem[_23745 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                    _24670 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24670 + 68] = mem[idx + _23745 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24670 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24670 + -mem[64] + 100
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                _28033 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28033] = 30
                                mem[_28033 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _29245 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29245 + 68] = mem[idx + _28033 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29245 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29245 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22916 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22916] = 30
                            mem[_22916 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23744 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23744 + 68] = mem[idx + _22916 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23744 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23744 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26796 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26796] = 30
                            mem[_26796 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _28032 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28032 + 68] = mem[idx + _26796 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28032 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28032 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _31636 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31636] = 30
                            mem[_31636 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32800 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32800 + 68] = mem[idx + _31636 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32800 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32800 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _22915 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22915] = 30
                            mem[_22915 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23743 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23743 + 68] = mem[idx + _22915 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23743 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23743 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26794 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26794] = 30
                            mem[_26794 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _28031 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28031 + 68] = mem[idx + _26794 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28031 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28031 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31634 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31634] = 30
                            mem[_31634 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32799 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32799 + 68] = mem[idx + _31634 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32799 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32799 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25709 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25709] = 30
                        mem[_25709 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _26793 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26793 + 68] = mem[idx + _25709 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26793 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26793 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _30385 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30385] = 30
                        mem[_30385 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _31633 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31633 + 68] = mem[idx + _30385 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31633 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31633 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _34621 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34621] = 30
                        mem[_34621 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _35483 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35483 + 68] = mem[idx + _34621 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35483 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35483 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _19316 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19316] = 30
                        mem[_19316 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _19396 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19396 + 68] = mem[idx + _19316 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19396 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19396 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _19749 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19749] = 30
                        mem[_19749 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _19797 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19797 + 68] = mem[idx + _19749 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19797 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19797 + -mem[64] + 100
                    _19317 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19317] = 26
                    mem[_19317 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19397 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19397 + 68] = mem[idx + _19317 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19397 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19397 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    return 0
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20693 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20693] = 30
                                mem[_20693 + 32] = 'SafeMath: subtraction overflow'
                                _22230 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22230] = 30
                                mem[_22230 + 32] = 'SafeMath: subtraction overflow'
                                _25727 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25727] = 30
                                mem[_25727 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                    if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26806 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26806 + 68] = mem[idx + _25727 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26806 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26806 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20692 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20692] = 30
                                mem[_20692 + 32] = 'SafeMath: subtraction overflow'
                                _22229 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22229] = 30
                                mem[_22229 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _22924 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22924 + 68] = mem[idx + _22229 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22924 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22924 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _25725 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25725] = 30
                                mem[_25725 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26805 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26805 + 68] = mem[idx + _25725 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26805 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26805 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21712 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21712] = 30
                            mem[_21712 + 32] = 'SafeMath: subtraction overflow'
                            _24697 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24697] = 30
                            mem[_24697 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _25724 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25724 + 68] = mem[idx + _24697 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25724 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25724 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29269 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29269] = 30
                            mem[_29269 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30394 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30394 + 68] = mem[idx + _29269 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30394 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30394 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20691 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20691] = 30
                                mem[_20691 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20871 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20871 + 68] = mem[idx + _20691 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20871 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20871 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _22227 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22227] = 30
                                mem[_22227 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _22923 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22923 + 68] = mem[idx + _22227 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22923 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22923 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25722 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25722] = 30
                                mem[_25722 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26804 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26804 + 68] = mem[idx + _25722 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26804 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26804 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21711 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21711] = 30
                            mem[_21711 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _22226 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22226 + 68] = mem[idx + _21711 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22226 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22226 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24695 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24695] = 30
                            mem[_24695 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _25721 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25721 + 68] = mem[idx + _24695 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25721 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25721 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _29267 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29267] = 30
                            mem[_29267 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30392 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30392 + 68] = mem[idx + _29267 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30392 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30392 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21710 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21710] = 30
                            mem[_21710 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _22225 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22225 + 68] = mem[idx + _21710 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22225 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22225 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24693 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24693] = 30
                            mem[_24693 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _25720 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25720 + 68] = mem[idx + _24693 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25720 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25720 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29265 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29265] = 30
                            mem[_29265 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30391 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30391 + 68] = mem[idx + _29265 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30391 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30391 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23761 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23761] = 30
                        mem[_23761 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _24692 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24692 + 68] = mem[idx + _23761 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24692 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24692 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28055 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28055] = 30
                        mem[_28055 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _29264 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29264 + 68] = mem[idx + _28055 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29264 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29264 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32817 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32817] = 30
                        mem[_32817 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33657 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33657 + 68] = mem[idx + _32817 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33657 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33657 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20689 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20689] = 30
                                mem[_20689 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20870 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20870 + 68] = mem[idx + _20689 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20870 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20870 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _22223 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22223] = 30
                                mem[_22223 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _22921 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22921 + 68] = mem[idx + _22223 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22921 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22921 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25718 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25718] = 30
                                mem[_25718 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _26803 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26803 + 68] = mem[idx + _25718 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26803 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26803 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21709 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21709] = 30
                            mem[_21709 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22222 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22222 + 68] = mem[idx + _21709 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22222 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22222 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24690 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24690] = 30
                            mem[_24690 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _25717 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25717 + 68] = mem[idx + _24690 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25717 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25717 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _29262 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29262] = 30
                            mem[_29262 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _30389 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30389 + 68] = mem[idx + _29262 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30389 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30389 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21708 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21708] = 30
                            mem[_21708 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22221 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22221 + 68] = mem[idx + _21708 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22221 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22221 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24688 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24688] = 30
                            mem[_24688 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _25716 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25716 + 68] = mem[idx + _24688 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25716 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25716 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29260 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29260] = 30
                            mem[_29260 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _30388 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30388 + 68] = mem[idx + _29260 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30388 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30388 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23760 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23760] = 30
                        mem[_23760 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _24687 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24687 + 68] = mem[idx + _23760 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24687 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24687 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _28053 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28053] = 30
                        mem[_28053 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _29259 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29259 + 68] = mem[idx + _28053 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29259 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29259 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32814 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32814] = 30
                        mem[_32814 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33654 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33654 + 68] = mem[idx + _32814 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33654 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33654 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21707 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21707] = 30
                            mem[_21707 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _22220 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22220 + 68] = mem[idx + _21707 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22220 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22220 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24685 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24685] = 30
                            mem[_24685 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _25715 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25715 + 68] = mem[idx + _24685 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25715 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25715 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _29257 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29257] = 30
                            mem[_29257 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _30387 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30387 + 68] = mem[idx + _29257 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30387 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30387 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23759 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23759] = 30
                        mem[_23759 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24684 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24684 + 68] = mem[idx + _23759 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24684 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24684 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28051 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28051] = 30
                        mem[_28051 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _29256 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29256 + 68] = mem[idx + _28051 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29256 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29256 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _32812 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32812] = 30
                        mem[_32812 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33652 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33652 + 68] = mem[idx + _32812 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33652 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33652 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _23758 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23758] = 30
                        mem[_23758 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24683 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24683 + 68] = mem[idx + _23758 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24683 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24683 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28049 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28049] = 30
                        mem[_28049 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _29255 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29255 + 68] = mem[idx + _28049 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29255 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29255 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32810 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32810] = 30
                        mem[_32810 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33651 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33651 + 68] = mem[idx + _32810 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33651 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33651 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26802 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26802] = 30
                    mem[_26802 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _28048 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28048 + 68] = mem[idx + _26802 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28048 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28048 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _31646 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31646] = 30
                    mem[_31646 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _32809 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32809 + 68] = mem[idx + _31646 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32809 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32809 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _35488 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35488] = 30
                    mem[_35488 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    _35943 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35943 + 68] = mem[idx + _35488 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35943 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35943 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor15 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if arg1 * _CHARITY_FEE / stor13 / 100:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                else:
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
    return (arg1 * stor15 / totalSupply)
}



}
